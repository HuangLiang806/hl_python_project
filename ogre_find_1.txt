[('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses CMake as its build system. It is recommended that you use it in your project as well. Then all you need is to add the following three lines to your project </p><div class="fragment"><div class="line"><span class="comment"># specify which version you need</span></div><div class="line">find_package(OGRE 1.10 REQUIRED)</div><div class="line"></div><div class="line"><span class="comment"># the search paths</span></div><div class="line">include_directories(${OGRE_INCLUDE_DIRS})</div><div class="line">link_directories(${OGRE_LIBRARY_DIRS})</div><div class="line"></div><div class="line"><span class="comment"># copy essential config files next to our binary where OGRE autodiscovers them</span></div><div class="line">file(COPY ${OGRE_CONFIG_DIR}/plugins.cfg ${OGRE_CONFIG_DIR}/resources.cfg</div><div class="line">     DESTINATION ${CMAKE_BINARY_DIR})</div></div><!-- fragment --><p>These settings include all available components and third party libraries OGRE depends on (e.g. boost) - nothing more to do.', '</p>'), ('<p>', 'If you installed OGRE in a non-standard path, you will have to set <code>OGRE_DIR</code> to the location of <code>OGREConfig.cmake</code> so <code>find_package</code> can figure out the rest.', '</p>'), ('<p>', 'For inspecting the detected OGRE installation, the following CMake variables are available', '</p>'), ('<p>', 'The easiest way to get started is the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Component. It handles <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> startup/ tear down (including <a class="el" href="class_ogre_1_1_overlay.html" title="Represents a layer which is rendered on top of the &#39;normal&#39; scene contents. ">Ogre::Overlay</a>, <a class="el" href="rtss.html">RTSS</a>), input using SDL2 and even includes a <a class="el" href="trays.html">Simple GUI System</a>.', '</p>'), ('<p>', 'This is useful if all you want is to get a Scene with a FPS counter up and running (rapid prototyping). If available it also uses SDL2 for input - you now just have to implement the callbacks.', '</p>'), ('<p>', 'To use it, simply derive from <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> and if you want to get input events from <a class="el" href="struct_ogre_bites_1_1_input_listener.html" title="the return values of the callbacks are ignored by ApplicationContext however they can be used to cont...">OgreBites::InputListener</a>', '</p>'), ('<p>', ' in the constructor we set our application name. The ogre configuration files will be stored in a system dependant location specific to our app. </p><div class="fragment"><div class="line">MyTestApp::MyTestApp() : <a class="code" href="namespace_ogre_bites.html">OgreBites</a>::ApplicationContext(<span class="stringliteral">&quot;OgreTutorialApp&quot;</span>)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><p> to handle input events, we then override the according method </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyTestApp::keyPressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_keyboard_event.html">OgreBites::KeyboardEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (evt.<a class="code" href="struct_ogre_bites_1_1_keyboard_event.html#a0d402ed4c6025e4a0a83fdac5eef219c">keysym</a>.<a class="code" href="struct_ogre_bites_1_1_keyboard_event.html#a747c886f46684fab3e14a9b8d751333b">sym</a> == <a class="code" href="_ogre_input_8h.html#abc5c98fcc1211af2b80116dd6e0a035dab050f8c23b43c76246a93e599b7b411f">SDLK_ESCAPE</a>)</div><div class="line">    {</div><div class="line">        getRoot()-&gt;queueEndRendering();</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> the interesting part however is the setup method ', '</p>'), ('<p>', 'finally we start everything as ', '</p>'), ('<p>', '<a class="el" href="namespace_ogre_bites.html">OgreBites</a> itself is also a good starting point if you need more control over the Camera or the Window creation. For instance to render into an existing Qt Window.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses CMake as its build system. It is recommended that you use it in your project as well. Then all you need is to add the following three lines to your project </p><div class="fragment"><div class="line"><span class="comment"># specify which version you need</span></div><div class="line">find_package(OGRE 1.10 REQUIRED)</div><div class="line"></div><div class="line"><span class="comment"># the search paths</span></div><div class="line">include_directories(${OGRE_INCLUDE_DIRS})</div><div class="line">link_directories(${OGRE_LIBRARY_DIRS})</div><div class="line"></div><div class="line"><span class="comment"># copy essential config files next to our binary where OGRE autodiscovers them</span></div><div class="line">file(COPY ${OGRE_CONFIG_DIR}/plugins.cfg ${OGRE_CONFIG_DIR}/resources.cfg</div><div class="line">     DESTINATION ${CMAKE_BINARY_DIR})</div></div><!-- fragment --><p>These settings include all available components and third party libraries OGRE depends on (e.g. boost) - nothing more to do.', '</p>'), ('<p>', 'If you installed OGRE in a non-standard path, you will have to set <code>OGRE_DIR</code> to the location of <code>OGREConfig.cmake</code> so <code>find_package</code> can figure out the rest.', '</p>'), ('<p>', 'For inspecting the detected OGRE installation, the following CMake variables are available', '</p>'), ('<p>', 'The easiest way to get started is the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Component. It handles <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> startup/ tear down (including <a class="el" href="class_ogre_1_1_overlay.html" title="Represents a layer which is rendered on top of the &#39;normal&#39; scene contents. ">Ogre::Overlay</a>, <a class="el" href="rtss.html">RTSS</a>), input using SDL2 and even includes a <a class="el" href="trays.html">Simple GUI System</a>.', '</p>'), ('<p>', 'This is useful if all you want is to get a Scene with a FPS counter up and running (rapid prototyping). If available it also uses SDL2 for input - you now just have to implement the callbacks.', '</p>'), ('<p>', 'To use it, simply derive from <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> and if you want to get input events from <a class="el" href="struct_ogre_bites_1_1_input_listener.html" title="the return values of the callbacks are ignored by ApplicationContext however they can be used to cont...">OgreBites::InputListener</a>', '</p>'), ('<p>', ' in the constructor we set our application name. The ogre configuration files will be stored in a system dependant location specific to our app. </p><div class="fragment"><div class="line">MyTestApp::MyTestApp() : <a class="code" href="namespace_ogre_bites.html">OgreBites</a>::ApplicationContext(<span class="stringliteral">&quot;OgreTutorialApp&quot;</span>)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><p> to handle input events, we then override the according method </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyTestApp::keyPressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_keyboard_event.html">OgreBites::KeyboardEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (evt.<a class="code" href="struct_ogre_bites_1_1_keyboard_event.html#a0d402ed4c6025e4a0a83fdac5eef219c">keysym</a>.<a class="code" href="struct_ogre_bites_1_1_keyboard_event.html#a747c886f46684fab3e14a9b8d751333b">sym</a> == <a class="code" href="_ogre_input_8h.html#abc5c98fcc1211af2b80116dd6e0a035dab050f8c23b43c76246a93e599b7b411f">SDLK_ESCAPE</a>)</div><div class="line">    {</div><div class="line">        getRoot()-&gt;queueEndRendering();</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> the interesting part however is the setup method ', '</p>'), ('<p>', 'finally we start everything as ', '</p>'), ('<p>', '<a class="el" href="namespace_ogre_bites.html">OgreBites</a> itself is also a good starting point if you need more control over the Camera or the Window creation. For instance to render into an existing Qt Window.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses CMake as its build system. It is recommended that you use it in your project as well. Then all you need is to add the following three lines to your project </p><div class="fragment"><div class="line"><span class="comment"># specify which version you need</span></div><div class="line">find_package(OGRE 1.10 REQUIRED)</div><div class="line"></div><div class="line"><span class="comment"># the search paths</span></div><div class="line">include_directories(${OGRE_INCLUDE_DIRS})</div><div class="line">link_directories(${OGRE_LIBRARY_DIRS})</div><div class="line"></div><div class="line"><span class="comment"># copy essential config files next to our binary where OGRE autodiscovers them</span></div><div class="line">file(COPY ${OGRE_CONFIG_DIR}/plugins.cfg ${OGRE_CONFIG_DIR}/resources.cfg</div><div class="line">     DESTINATION ${CMAKE_BINARY_DIR})</div></div><!-- fragment --><p>These settings include all available components and third party libraries OGRE depends on (e.g. boost) - nothing more to do.', '</p>'), ('<p>', 'If you installed OGRE in a non-standard path, you will have to set <code>OGRE_DIR</code> to the location of <code>OGREConfig.cmake</code> so <code>find_package</code> can figure out the rest.', '</p>'), ('<p>', 'For inspecting the detected OGRE installation, the following CMake variables are available', '</p>'), ('<p>', 'The easiest way to get started is the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Component. It handles <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> startup/ tear down (including <a class="el" href="class_ogre_1_1_overlay.html" title="Represents a layer which is rendered on top of the &#39;normal&#39; scene contents. ">Ogre::Overlay</a>, <a class="el" href="rtss.html">RTSS</a>), input using SDL2 and even includes a <a class="el" href="trays.html">Simple GUI System</a>.', '</p>'), ('<p>', 'This is useful if all you want is to get a Scene with a FPS counter up and running (rapid prototyping). If available it also uses SDL2 for input - you now just have to implement the callbacks.', '</p>'), ('<p>', 'To use it, simply derive from <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> and if you want to get input events from <a class="el" href="struct_ogre_bites_1_1_input_listener.html" title="the return values of the callbacks are ignored by ApplicationContext however they can be used to cont...">OgreBites::InputListener</a>', '</p>'), ('<p>', ' in the constructor we set our application name. The ogre configuration files will be stored in a system dependant location specific to our app. </p><div class="fragment"><div class="line">MyTestApp::MyTestApp() : <a class="code" href="namespace_ogre_bites.html">OgreBites</a>::ApplicationContext(<span class="stringliteral">&quot;OgreTutorialApp&quot;</span>)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><p> to handle input events, we then override the according method </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyTestApp::keyPressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_keyboard_event.html">OgreBites::KeyboardEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (evt.<a class="code" href="struct_ogre_bites_1_1_keyboard_event.html#a0d402ed4c6025e4a0a83fdac5eef219c">keysym</a>.<a class="code" href="struct_ogre_bites_1_1_keyboard_event.html#a747c886f46684fab3e14a9b8d751333b">sym</a> == <a class="code" href="_ogre_input_8h.html#abc5c98fcc1211af2b80116dd6e0a035dab050f8c23b43c76246a93e599b7b411f">SDLK_ESCAPE</a>)</div><div class="line">    {</div><div class="line">        getRoot()-&gt;queueEndRendering();</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> the interesting part however is the setup method ', '</p>'), ('<p>', 'finally we start everything as ', '</p>'), ('<p>', '<a class="el" href="namespace_ogre_bites.html">OgreBites</a> itself is also a good starting point if you need more control over the Camera or the Window creation. For instance to render into an existing Qt Window.', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.', '</p>'), ('<p>', 'We\'ll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don\'t worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.', '</p>'), ('<p>', 'Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.', '</p>'), ('<p>', 'SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.', '</p>'), ('<p>', 'SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn\'t want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character\'s main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.', '</p>'), ('<p>', 'One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.', '</p>'), ('<p>', 'An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don\'t directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.', '</p>'), ('<p>', 'It\'s finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.', '</p>'), ('<p>', 'The first thing we want to do is turn on the lights.', '</p>'), ('<p>', ' The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.', '</p>'), ('<p>', 'scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.', '</p>'), ('<p>', 'Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.', '</p>'), ('<p>', ' Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.', '</p>'), ('<p>', 'Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.', '</p>'), ('<p>', ' Next step is to create a camera.', '</p>'), ('<p>', ' Details about camera will be covered in the following tutorial.', '</p>'), ('<p>', 'The next thing we do is ask the SceneManager to create an Entity.', '</p>'), ('<p>', ' The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.', '</p>'), ('<p>', 'Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.', '</p>'), ('<p>', ' We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.', '</p>'), ('<p>', ' We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s head on your screen. This is only the beginning...', '</p>'), ('<p>', 'Before we go on, let\'s cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a>', '</p>'), ('<p>', 'The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don\'t take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.', '</p>'), ('<p>', 'When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren\'t really covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.', '</p>'), ('<p>', 'It\'s time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We\'ve already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.', '</p>'), ('<p>', "First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:", '</p>'), ('<p>', " Now, let's create another Entity and SceneNode, but this time we'll give it a new position.", '</p>'), ('<p>', " This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.", '</p>'), ('<p>', 'Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.', '</p>'), ('<p>', 'The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.', '</p>'), ('<p>', 'You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.', '</p>'), ('<p>', 'SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object\'s orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.', '</p>'), ('<p>', 'We\'ve already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode\'s children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.', '</p>'), ('<p>', 'Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:', '</p>'), ('<p>', 'To this:', '</p>'), ('<p>', 'Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.', '</p>'), ('<p>', "If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.", '</p>'), ('<p>', 'So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:', '</p>'), ('<p>', "Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.", '</p>'), ('<p>', 'Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don\'t have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.', '</p>'), ('<p>', 'We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let\'s add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.', '</p>'), ('<p>', ' Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.', '</p>'), ('<p>', "An Entity's rotation can be changed using the yaw, pitch, and roll methods.", '</p>'), ('<p>', 'These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.', '</p>'), ('<p>', 'There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They\'re trying to remember which direction the magnetic field is headed.', '</p>'), ('<p>', "Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.", '</p>'), ('<p>', ' Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.', '</p>'), ('<p>', 'The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the \'bin\' folder of your OgreSDK. You should use the debug files when building your application in debug mod', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.', '</p>'), ('<p>', 'The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.', '</p>'), ('<p>', 'The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won\'t try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.', '</p>'), ('<p>', 'The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.', '</p>'), ('<p>', 'The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.', '</p>'), ('<p>', "When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You\'ll slowly read more about them as you progress through the tutorials as well.', '</p>'), ('<p>', '<b>plugins.cfg</b>', '</p>'), ('<p>', 'This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:', '</p>'), ('<p>', 'We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.', '</p>'), ('<p>', 'You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the \'PluginFolder\' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:', '</p>'), ('<p>', 'By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in \'/usr/lib/OGRE\'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.', '</p>'), ('<p>', '<b>resources.cfg</b>', '</p>'), ('<p>', 'This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:', '</p>'), ('<p>', 'Here is an example of a relative path being used and the need to list subdirectories. Including the \'../media\' directory did not automatically include the \'../media/models\' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn\'t get greedy and waste time loading up unneeded resources.', '</p>'), ('<p>', '<b>media.cfg</b>', '</p>'), ('<p>', 'This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.', '</p>'), ('<p>', '<b>ogre.cfg</b>', '</p>'), ('<p>', 'This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.', '</p>'), ('<p>', '<b>quake3settings.cfg</b>', '</p>'), ('<p>', 'This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.', '</p>'), ('<p>', 'That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find \'plugins.cfg\', \'resources.cfg\', and \'media.cfg\' to function properly. Later tutorials will cover more of their use.', '</p>'), ('<p>', 'You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.', '</p>'), ('<p>', 'An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. ', '</p>'), ('<p>', 'This tutorial will expand on the use of Lights in a scene and using them to cast shadows.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera\'s position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.', '</p>'), ('<p>', 'We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:', '</p>'), ('<p>', "You can retrieve the Camera by name using the SceneManager's getCamera method.", '</p>'), ('<p>', 'Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.', '</p>'), ('<p>', "The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.", '</p>'), ('<p>', 'When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.', '</p>'), ('<p>', 'There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera\'s view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.', '</p>'), ('<p>', 'Let\'s create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.', '</p>'), ('<p>', 'Now let\'s set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We\'ve set it to black because we are going to add colored lighting later, and we don\'t want the background color affecting how we see the lighting.', '</p>'), ('<p>', 'The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.', '</p>'), ('<p>', " We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.", '</p>'), ('<p>', 'Compile and run your application. You should still only see a black screen, just make sure it runs.', '</p>'), ('<p>', 'Before we get to shadows and lighting, let\'s add some elements to our scene. Let\'s put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.', '</p>'), ('<p>', 'We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.', '</p>'), ('<p>', 'The first thing we\'ll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here\'s a picture:', '</p>'), ('<p>', 'There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.', '</p>'), ('<p>', "Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.", '</p>'), ('<p>', 'This is a complicated method, and we\'re not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we\'ve created a new mesh called "ground" with a size of 1500x1500.', '</p>'), ('<p>', 'Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don\'t confuse the parameter given to createEntity for the Entity\'s name. It is actually the name of the mesh we just created. We\'re used to seeing mesh names end with \'.mesh\'.', '</p>'), ('<p>', 'We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don\'t get confused, this means the ground won\'t cast a shadow, it doesn\'t mean we can\'t cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called \'rockwall.tga\'. You can find the name yourself by reading the entry in the material script.', '</p>'), ('<p>', 'Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.', '</p>'), ('<p>', "Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:", '</p>'), ('<p>', " Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.', '</p>'), ('<p>', 'Let\'s add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We\'ll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.', '</p>'), ('<p>', " The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.", '</p>'), ('<p>', 'Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.', '</p>'), ('<p>', 'Compile and run the application. You should see the shadowy blue figure of a ninja.', '</p>'), ('<p>', "Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.", '</p>'), ('<p>', ' Now we\'ll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light\'s direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.', '</p>'), ('<p>', 'The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.', '</p>'), ('<p>', 'Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.', '</p>'), ('<p>', 'To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We\'ll set the the specular and diffuse colors to a dark gray.', '</p>'), ('<p>', ' A point light has no direction. It only has a position. We will place our last light above and behind the ninja.', '</p>'), ('<p>', ' Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.', '</p>'), ('<p>', 'Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.', '</p>'), ('<p>', 'This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.', '</p>'), ('<p>', 'There are a lot of different settings we\'ve covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you\'ve finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. ', '</p>'), ('<p>', 'This tutorial will expand on the use of Lights in a scene and using them to cast shadows.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera\'s position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.', '</p>'), ('<p>', 'We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:', '</p>'), ('<p>', "You can retrieve the Camera by name using the SceneManager's getCamera method.", '</p>'), ('<p>', 'Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.', '</p>'), ('<p>', "The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.", '</p>'), ('<p>', 'When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.', '</p>'), ('<p>', 'There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera\'s view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.', '</p>'), ('<p>', 'Let\'s create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.', '</p>'), ('<p>', 'Now let\'s set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We\'ve set it to black because we are going to add colored lighting later, and we don\'t want the background color affecting how we see the lighting.', '</p>'), ('<p>', 'The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.', '</p>'), ('<p>', " We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.", '</p>'), ('<p>', 'Compile and run your application. You should still only see a black screen, just make sure it runs.', '</p>'), ('<p>', 'Before we get to shadows and lighting, let\'s add some elements to our scene. Let\'s put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.', '</p>'), ('<p>', 'We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.', '</p>'), ('<p>', 'The first thing we\'ll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here\'s a picture:', '</p>'), ('<p>', 'There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.', '</p>'), ('<p>', "Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.", '</p>'), ('<p>', 'This is a complicated method, and we\'re not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we\'ve created a new mesh called "ground" with a size of 1500x1500.', '</p>'), ('<p>', 'Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don\'t confuse the parameter given to createEntity for the Entity\'s name. It is actually the name of the mesh we just created. We\'re used to seeing mesh names end with \'.mesh\'.', '</p>'), ('<p>', 'We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don\'t get confused, this means the ground won\'t cast a shadow, it doesn\'t mean we can\'t cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called \'rockwall.tga\'. You can find the name yourself by reading the entry in the material script.', '</p>'), ('<p>', 'Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.', '</p>'), ('<p>', "Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:", '</p>'), ('<p>', " Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.', '</p>'), ('<p>', 'Let\'s add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We\'ll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.', '</p>'), ('<p>', " The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.", '</p>'), ('<p>', 'Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.', '</p>'), ('<p>', 'Compile and run the application. You should see the shadowy blue figure of a ninja.', '</p>'), ('<p>', "Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.", '</p>'), ('<p>', ' Now we\'ll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light\'s direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.', '</p>'), ('<p>', 'The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.', '</p>'), ('<p>', 'Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.', '</p>'), ('<p>', 'To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We\'ll set the the specular and diffuse colors to a dark gray.', '</p>'), ('<p>', ' A point light has no direction. It only has a position. We will place our last light above and behind the ninja.', '</p>'), ('<p>', ' Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.', '</p>'), ('<p>', 'Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.', '</p>'), ('<p>', 'This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.', '</p>'), ('<p>', 'There are a lot of different settings we\'ve covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you\'ve finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. ', '</p>'), ('<p>', 'This tutorial will expand on the use of Lights in a scene and using them to cast shadows.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera\'s position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.', '</p>'), ('<p>', 'We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:', '</p>'), ('<p>', "You can retrieve the Camera by name using the SceneManager's getCamera method.", '</p>'), ('<p>', 'Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.', '</p>'), ('<p>', "The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.", '</p>'), ('<p>', 'When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.', '</p>'), ('<p>', 'There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera\'s view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.', '</p>'), ('<p>', 'Let\'s create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.', '</p>'), ('<p>', 'Now let\'s set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We\'ve set it to black because we are going to add colored lighting later, and we don\'t want the background color affecting how we see the lighting.', '</p>'), ('<p>', 'The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.', '</p>'), ('<p>', " We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.", '</p>'), ('<p>', 'Compile and run your application. You should still only see a black screen, just make sure it runs.', '</p>'), ('<p>', 'Before we get to shadows and lighting, let\'s add some elements to our scene. Let\'s put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.', '</p>'), ('<p>', 'We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.', '</p>'), ('<p>', 'The first thing we\'ll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here\'s a picture:', '</p>'), ('<p>', 'There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.', '</p>'), ('<p>', "Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.", '</p>'), ('<p>', 'This is a complicated method, and we\'re not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we\'ve created a new mesh called "ground" with a size of 1500x1500.', '</p>'), ('<p>', 'Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don\'t confuse the parameter given to createEntity for the Entity\'s name. It is actually the name of the mesh we just created. We\'re used to seeing mesh names end with \'.mesh\'.', '</p>'), ('<p>', 'We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don\'t get confused, this means the ground won\'t cast a shadow, it doesn\'t mean we can\'t cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called \'rockwall.tga\'. You can find the name yourself by reading the entry in the material script.', '</p>'), ('<p>', 'Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.', '</p>'), ('<p>', "Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:", '</p>'), ('<p>', " Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.', '</p>'), ('<p>', 'Let\'s add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We\'ll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.', '</p>'), ('<p>', " The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.", '</p>'), ('<p>', 'Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.', '</p>'), ('<p>', 'Compile and run the application. You should see the shadowy blue figure of a ninja.', '</p>'), ('<p>', "Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.", '</p>'), ('<p>', ' Now we\'ll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light\'s direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.', '</p>'), ('<p>', 'The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.', '</p>'), ('<p>', 'Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.', '</p>'), ('<p>', 'To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We\'ll set the the specular and diffuse colors to a dark gray.', '</p>'), ('<p>', ' A point light has no direction. It only has a position. We will place our last light above and behind the ninja.', '</p>'), ('<p>', ' Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.', '</p>'), ('<p>', 'Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.', '</p>'), ('<p>', 'This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.', '</p>'), ('<p>', 'There are a lot of different settings we\'ve covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you\'ve finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. ', '</p>'), ('<p>', 'This tutorial will expand on the use of Lights in a scene and using them to cast shadows.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera\'s position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.', '</p>'), ('<p>', 'We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:', '</p>'), ('<p>', "You can retrieve the Camera by name using the SceneManager's getCamera method.", '</p>'), ('<p>', 'Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.', '</p>'), ('<p>', "The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.", '</p>'), ('<p>', 'When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.', '</p>'), ('<p>', 'There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera\'s view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.', '</p>'), ('<p>', 'Let\'s create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.', '</p>'), ('<p>', 'Now let\'s set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We\'ve set it to black because we are going to add colored lighting later, and we don\'t want the background color affecting how we see the lighting.', '</p>'), ('<p>', 'The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.', '</p>'), ('<p>', " We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.", '</p>'), ('<p>', 'Compile and run your application. You should still only see a black screen, just make sure it runs.', '</p>'), ('<p>', 'Before we get to shadows and lighting, let\'s add some elements to our scene. Let\'s put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.', '</p>'), ('<p>', 'We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.', '</p>'), ('<p>', 'The first thing we\'ll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here\'s a picture:', '</p>'), ('<p>', 'There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.', '</p>'), ('<p>', "Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.", '</p>'), ('<p>', 'This is a complicated method, and we\'re not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we\'ve created a new mesh called "ground" with a size of 1500x1500.', '</p>'), ('<p>', 'Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don\'t confuse the parameter given to createEntity for the Entity\'s name. It is actually the name of the mesh we just created. We\'re used to seeing mesh names end with \'.mesh\'.', '</p>'), ('<p>', 'We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don\'t get confused, this means the ground won\'t cast a shadow, it doesn\'t mean we can\'t cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called \'rockwall.tga\'. You can find the name yourself by reading the entry in the material script.', '</p>'), ('<p>', 'Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.', '</p>'), ('<p>', "Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:", '</p>'), ('<p>', " Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.', '</p>'), ('<p>', 'Let\'s add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We\'ll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.', '</p>'), ('<p>', " The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.", '</p>'), ('<p>', 'Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.', '</p>'), ('<p>', 'Compile and run the application. You should see the shadowy blue figure of a ninja.', '</p>'), ('<p>', "Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.", '</p>'), ('<p>', ' Now we\'ll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light\'s direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.', '</p>'), ('<p>', 'The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.', '</p>'), ('<p>', 'Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.', '</p>'), ('<p>', 'To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We\'ll set the the specular and diffuse colors to a dark gray.', '</p>'), ('<p>', ' A point light has no direction. It only has a position. We will place our last light above and behind the ninja.', '</p>'), ('<p>', ' Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.', '</p>'), ('<p>', 'Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.', '</p>'), ('<p>', 'This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.', '</p>'), ('<p>', 'There are a lot of different settings we\'ve covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you\'ve finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. ', '</p>'), ('<p>', 'This tutorial will expand on the use of Lights in a scene and using them to cast shadows.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera\'s position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.', '</p>'), ('<p>', 'We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:', '</p>'), ('<p>', "You can retrieve the Camera by name using the SceneManager's getCamera method.", '</p>'), ('<p>', 'Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.', '</p>'), ('<p>', "The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.", '</p>'), ('<p>', 'When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.', '</p>'), ('<p>', 'There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera\'s view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.', '</p>'), ('<p>', 'Let\'s create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.', '</p>'), ('<p>', 'Now let\'s set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We\'ve set it to black because we are going to add colored lighting later, and we don\'t want the background color affecting how we see the lighting.', '</p>'), ('<p>', 'The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.', '</p>'), ('<p>', " We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.", '</p>'), ('<p>', 'Compile and run your application. You should still only see a black screen, just make sure it runs.', '</p>'), ('<p>', 'Before we get to shadows and lighting, let\'s add some elements to our scene. Let\'s put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.', '</p>'), ('<p>', 'We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.', '</p>'), ('<p>', 'The first thing we\'ll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here\'s a picture:', '</p>'), ('<p>', 'There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.', '</p>'), ('<p>', "Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.", '</p>'), ('<p>', 'This is a complicated method, and we\'re not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we\'ve created a new mesh called "ground" with a size of 1500x1500.', '</p>'), ('<p>', 'Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don\'t confuse the parameter given to createEntity for the Entity\'s name. It is actually the name of the mesh we just created. We\'re used to seeing mesh names end with \'.mesh\'.', '</p>'), ('<p>', 'We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don\'t get confused, this means the ground won\'t cast a shadow, it doesn\'t mean we can\'t cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called \'rockwall.tga\'. You can find the name yourself by reading the entry in the material script.', '</p>'), ('<p>', 'Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.', '</p>'), ('<p>', "Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:", '</p>'), ('<p>', " Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.', '</p>'), ('<p>', 'Let\'s add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We\'ll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.', '</p>'), ('<p>', " The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.", '</p>'), ('<p>', 'Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.', '</p>'), ('<p>', 'Compile and run the application. You should see the shadowy blue figure of a ninja.', '</p>'), ('<p>', "Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.", '</p>'), ('<p>', ' Now we\'ll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light\'s direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.', '</p>'), ('<p>', 'The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.', '</p>'), ('<p>', 'Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.', '</p>'), ('<p>', 'To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We\'ll set the the specular and diffuse colors to a dark gray.', '</p>'), ('<p>', ' A point light has no direction. It only has a position. We will place our last light above and behind the ninja.', '</p>'), ('<p>', ' Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.', '</p>'), ('<p>', 'Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.', '</p>'), ('<p>', 'This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.', '</p>'), ('<p>', 'There are a lot of different settings we\'ve covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you\'ve finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. ', '</p>'), ('<p>', 'This tutorial will expand on the use of Lights in a scene and using them to cast shadows.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera\'s position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.', '</p>'), ('<p>', 'We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:', '</p>'), ('<p>', "You can retrieve the Camera by name using the SceneManager's getCamera method.", '</p>'), ('<p>', 'Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.', '</p>'), ('<p>', "The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.", '</p>'), ('<p>', 'When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.', '</p>'), ('<p>', 'There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera\'s view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.', '</p>'), ('<p>', 'Let\'s create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.', '</p>'), ('<p>', 'Now let\'s set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We\'ve set it to black because we are going to add colored lighting later, and we don\'t want the background color affecting how we see the lighting.', '</p>'), ('<p>', 'The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.', '</p>'), ('<p>', " We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.", '</p>'), ('<p>', 'Compile and run your application. You should still only see a black screen, just make sure it runs.', '</p>'), ('<p>', 'Before we get to shadows and lighting, let\'s add some elements to our scene. Let\'s put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.', '</p>'), ('<p>', 'We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.', '</p>'), ('<p>', 'The first thing we\'ll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here\'s a picture:', '</p>'), ('<p>', 'There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.', '</p>'), ('<p>', "Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.", '</p>'), ('<p>', 'This is a complicated method, and we\'re not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we\'ve created a new mesh called "ground" with a size of 1500x1500.', '</p>'), ('<p>', 'Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don\'t confuse the parameter given to createEntity for the Entity\'s name. It is actually the name of the mesh we just created. We\'re used to seeing mesh names end with \'.mesh\'.', '</p>'), ('<p>', 'We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don\'t get confused, this means the ground won\'t cast a shadow, it doesn\'t mean we can\'t cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called \'rockwall.tga\'. You can find the name yourself by reading the entry in the material script.', '</p>'), ('<p>', 'Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.', '</p>'), ('<p>', "Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:", '</p>'), ('<p>', " Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.', '</p>'), ('<p>', 'Let\'s add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We\'ll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.', '</p>'), ('<p>', " The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.", '</p>'), ('<p>', 'Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.', '</p>'), ('<p>', 'Compile and run the application. You should see the shadowy blue figure of a ninja.', '</p>'), ('<p>', "Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.", '</p>'), ('<p>', ' Now we\'ll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light\'s direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.', '</p>'), ('<p>', 'The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.', '</p>'), ('<p>', 'Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.', '</p>'), ('<p>', 'To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We\'ll set the the specular and diffuse colors to a dark gray.', '</p>'), ('<p>', ' A point light has no direction. It only has a position. We will place our last light above and behind the ninja.', '</p>'), ('<p>', ' Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.', '</p>'), ('<p>', 'Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.', '</p>'), ('<p>', 'This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.', '</p>'), ('<p>', 'There are a lot of different settings we\'ve covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you\'ve finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. ', '</p>'), ('<p>', 'This tutorial will expand on the use of Lights in a scene and using them to cast shadows.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera\'s position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.', '</p>'), ('<p>', 'We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:', '</p>'), ('<p>', "You can retrieve the Camera by name using the SceneManager's getCamera method.", '</p>'), ('<p>', 'Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.', '</p>'), ('<p>', "The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.", '</p>'), ('<p>', 'When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.', '</p>'), ('<p>', 'There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera\'s view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.', '</p>'), ('<p>', 'Let\'s create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.', '</p>'), ('<p>', 'Now let\'s set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We\'ve set it to black because we are going to add colored lighting later, and we don\'t want the background color affecting how we see the lighting.', '</p>'), ('<p>', 'The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.', '</p>'), ('<p>', " We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.", '</p>'), ('<p>', 'Compile and run your application. You should still only see a black screen, just make sure it runs.', '</p>'), ('<p>', 'Before we get to shadows and lighting, let\'s add some elements to our scene. Let\'s put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.', '</p>'), ('<p>', 'We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.', '</p>'), ('<p>', 'The first thing we\'ll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here\'s a picture:', '</p>'), ('<p>', 'There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.', '</p>'), ('<p>', "Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.", '</p>'), ('<p>', 'This is a complicated method, and we\'re not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we\'ve created a new mesh called "ground" with a size of 1500x1500.', '</p>'), ('<p>', 'Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don\'t confuse the parameter given to createEntity for the Entity\'s name. It is actually the name of the mesh we just created. We\'re used to seeing mesh names end with \'.mesh\'.', '</p>'), ('<p>', 'We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don\'t get confused, this means the ground won\'t cast a shadow, it doesn\'t mean we can\'t cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called \'rockwall.tga\'. You can find the name yourself by reading the entry in the material script.', '</p>'), ('<p>', 'Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.', '</p>'), ('<p>', "Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:", '</p>'), ('<p>', " Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.', '</p>'), ('<p>', 'Let\'s add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We\'ll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.', '</p>'), ('<p>', " The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.", '</p>'), ('<p>', 'Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.', '</p>'), ('<p>', 'Compile and run the application. You should see the shadowy blue figure of a ninja.', '</p>'), ('<p>', "Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.", '</p>'), ('<p>', ' Now we\'ll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light\'s direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.', '</p>'), ('<p>', 'The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.', '</p>'), ('<p>', 'Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.', '</p>'), ('<p>', 'To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We\'ll set the the specular and diffuse colors to a dark gray.', '</p>'), ('<p>', ' A point light has no direction. It only has a position. We will place our last light above and behind the ninja.', '</p>'), ('<p>', ' Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.', '</p>'), ('<p>', 'Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.', '</p>'), ('<p>', 'This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.', '</p>'), ('<p>', 'There are a lot of different settings we\'ve covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you\'ve finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. ', '</p>'), ('<p>', 'This tutorial will expand on the use of Lights in a scene and using them to cast shadows.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera\'s position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.', '</p>'), ('<p>', 'We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:', '</p>'), ('<p>', "You can retrieve the Camera by name using the SceneManager's getCamera method.", '</p>'), ('<p>', 'Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.', '</p>'), ('<p>', "The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.", '</p>'), ('<p>', 'When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.', '</p>'), ('<p>', 'There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera\'s view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.', '</p>'), ('<p>', 'Let\'s create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.', '</p>'), ('<p>', 'Now let\'s set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We\'ve set it to black because we are going to add colored lighting later, and we don\'t want the background color affecting how we see the lighting.', '</p>'), ('<p>', 'The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.', '</p>'), ('<p>', " We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.", '</p>'), ('<p>', 'Compile and run your application. You should still only see a black screen, just make sure it runs.', '</p>'), ('<p>', 'Before we get to shadows and lighting, let\'s add some elements to our scene. Let\'s put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.', '</p>'), ('<p>', 'We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.', '</p>'), ('<p>', 'The first thing we\'ll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here\'s a picture:', '</p>'), ('<p>', 'There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.', '</p>'), ('<p>', "Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.", '</p>'), ('<p>', 'This is a complicated method, and we\'re not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we\'ve created a new mesh called "ground" with a size of 1500x1500.', '</p>'), ('<p>', 'Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don\'t confuse the parameter given to createEntity for the Entity\'s name. It is actually the name of the mesh we just created. We\'re used to seeing mesh names end with \'.mesh\'.', '</p>'), ('<p>', 'We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don\'t get confused, this means the ground won\'t cast a shadow, it doesn\'t mean we can\'t cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called \'rockwall.tga\'. You can find the name yourself by reading the entry in the material script.', '</p>'), ('<p>', 'Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.', '</p>'), ('<p>', "Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:", '</p>'), ('<p>', " Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.', '</p>'), ('<p>', 'Let\'s add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We\'ll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.', '</p>'), ('<p>', " The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.", '</p>'), ('<p>', 'Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.', '</p>'), ('<p>', 'Compile and run the application. You should see the shadowy blue figure of a ninja.', '</p>'), ('<p>', "Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.", '</p>'), ('<p>', ' Now we\'ll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light\'s direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.', '</p>'), ('<p>', 'The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.', '</p>'), ('<p>', 'Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.', '</p>'), ('<p>', 'To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We\'ll set the the specular and diffuse colors to a dark gray.', '</p>'), ('<p>', ' A point light has no direction. It only has a position. We will place our last light above and behind the ninja.', '</p>'), ('<p>', ' Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.', '</p>'), ('<p>', 'Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.', '</p>'), ('<p>', 'This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.', '</p>'), ('<p>', 'There are a lot of different settings we\'ve covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you\'ve finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. ', '</p>'), ('<p>', 'This tutorial will expand on the use of Lights in a scene and using them to cast shadows.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera\'s position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.', '</p>'), ('<p>', 'We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:', '</p>'), ('<p>', "You can retrieve the Camera by name using the SceneManager's getCamera method.", '</p>'), ('<p>', 'Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.', '</p>'), ('<p>', "The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.", '</p>'), ('<p>', 'When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.', '</p>'), ('<p>', 'There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera\'s view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.', '</p>'), ('<p>', 'Let\'s create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.', '</p>'), ('<p>', 'Now let\'s set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We\'ve set it to black because we are going to add colored lighting later, and we don\'t want the background color affecting how we see the lighting.', '</p>'), ('<p>', 'The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.', '</p>'), ('<p>', " We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.", '</p>'), ('<p>', 'Compile and run your application. You should still only see a black screen, just make sure it runs.', '</p>'), ('<p>', 'Before we get to shadows and lighting, let\'s add some elements to our scene. Let\'s put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.', '</p>'), ('<p>', 'We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.', '</p>'), ('<p>', 'The first thing we\'ll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here\'s a picture:', '</p>'), ('<p>', 'There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.', '</p>'), ('<p>', "Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.", '</p>'), ('<p>', 'This is a complicated method, and we\'re not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we\'ve created a new mesh called "ground" with a size of 1500x1500.', '</p>'), ('<p>', 'Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don\'t confuse the parameter given to createEntity for the Entity\'s name. It is actually the name of the mesh we just created. We\'re used to seeing mesh names end with \'.mesh\'.', '</p>'), ('<p>', 'We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don\'t get confused, this means the ground won\'t cast a shadow, it doesn\'t mean we can\'t cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called \'rockwall.tga\'. You can find the name yourself by reading the entry in the material script.', '</p>'), ('<p>', 'Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.', '</p>'), ('<p>', "Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:", '</p>'), ('<p>', " Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.', '</p>'), ('<p>', 'Let\'s add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We\'ll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.', '</p>'), ('<p>', " The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.", '</p>'), ('<p>', 'Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.', '</p>'), ('<p>', 'Compile and run the application. You should see the shadowy blue figure of a ninja.', '</p>'), ('<p>', "Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.", '</p>'), ('<p>', ' Now we\'ll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light\'s direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.', '</p>'), ('<p>', 'The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.', '</p>'), ('<p>', 'Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.', '</p>'), ('<p>', 'To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We\'ll set the the specular and diffuse colors to a dark gray.', '</p>'), ('<p>', ' A point light has no direction. It only has a position. We will place our last light above and behind the ninja.', '</p>'), ('<p>', ' Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.', '</p>'), ('<p>', 'Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.', '</p>'), ('<p>', 'This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.', '</p>'), ('<p>', 'There are a lot of different settings we\'ve covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you\'ve finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. ', '</p>'), ('<p>', 'This tutorial will expand on the use of Lights in a scene and using them to cast shadows.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera\'s position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.', '</p>'), ('<p>', 'We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:', '</p>'), ('<p>', "You can retrieve the Camera by name using the SceneManager's getCamera method.", '</p>'), ('<p>', 'Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.', '</p>'), ('<p>', "The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.", '</p>'), ('<p>', 'When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.', '</p>'), ('<p>', 'There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera\'s view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.', '</p>'), ('<p>', 'Let\'s create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.', '</p>'), ('<p>', 'Now let\'s set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We\'ve set it to black because we are going to add colored lighting later, and we don\'t want the background color affecting how we see the lighting.', '</p>'), ('<p>', 'The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.', '</p>'), ('<p>', " We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.", '</p>'), ('<p>', 'Compile and run your application. You should still only see a black screen, just make sure it runs.', '</p>'), ('<p>', 'Before we get to shadows and lighting, let\'s add some elements to our scene. Let\'s put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.', '</p>'), ('<p>', 'We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.', '</p>'), ('<p>', 'The first thing we\'ll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here\'s a picture:', '</p>'), ('<p>', 'There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.', '</p>'), ('<p>', "Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.", '</p>'), ('<p>', 'This is a complicated method, and we\'re not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we\'ve created a new mesh called "ground" with a size of 1500x1500.', '</p>'), ('<p>', 'Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don\'t confuse the parameter given to createEntity for the Entity\'s name. It is actually the name of the mesh we just created. We\'re used to seeing mesh names end with \'.mesh\'.', '</p>'), ('<p>', 'We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don\'t get confused, this means the ground won\'t cast a shadow, it doesn\'t mean we can\'t cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called \'rockwall.tga\'. You can find the name yourself by reading the entry in the material script.', '</p>'), ('<p>', 'Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.', '</p>'), ('<p>', "Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:", '</p>'), ('<p>', " Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.', '</p>'), ('<p>', 'Let\'s add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We\'ll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.', '</p>'), ('<p>', " The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.", '</p>'), ('<p>', 'Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.', '</p>'), ('<p>', 'Compile and run the application. You should see the shadowy blue figure of a ninja.', '</p>'), ('<p>', "Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.", '</p>'), ('<p>', ' Now we\'ll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light\'s direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.', '</p>'), ('<p>', 'The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.', '</p>'), ('<p>', 'Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.', '</p>'), ('<p>', 'To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We\'ll set the the specular and diffuse colors to a dark gray.', '</p>'), ('<p>', ' A point light has no direction. It only has a position. We will place our last light above and behind the ninja.', '</p>'), ('<p>', ' Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.', '</p>'), ('<p>', 'Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.', '</p>'), ('<p>', 'This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.', '</p>'), ('<p>', 'There are a lot of different settings we\'ve covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you\'ve finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. ', '</p>'), ('<p>', 'This tutorial will expand on the use of Lights in a scene and using them to cast shadows.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera\'s position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.', '</p>'), ('<p>', 'We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:', '</p>'), ('<p>', "You can retrieve the Camera by name using the SceneManager's getCamera method.", '</p>'), ('<p>', 'Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.', '</p>'), ('<p>', "The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.", '</p>'), ('<p>', 'When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.', '</p>'), ('<p>', 'There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera\'s view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.', '</p>'), ('<p>', 'Let\'s create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.', '</p>'), ('<p>', 'Now let\'s set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We\'ve set it to black because we are going to add colored lighting later, and we don\'t want the background color affecting how we see the lighting.', '</p>'), ('<p>', 'The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.', '</p>'), ('<p>', " We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.", '</p>'), ('<p>', 'Compile and run your application. You should still only see a black screen, just make sure it runs.', '</p>'), ('<p>', 'Before we get to shadows and lighting, let\'s add some elements to our scene. Let\'s put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.', '</p>'), ('<p>', 'We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.', '</p>'), ('<p>', 'The first thing we\'ll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here\'s a picture:', '</p>'), ('<p>', 'There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.', '</p>'), ('<p>', "Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.", '</p>'), ('<p>', 'This is a complicated method, and we\'re not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we\'ve created a new mesh called "ground" with a size of 1500x1500.', '</p>'), ('<p>', 'Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don\'t confuse the parameter given to createEntity for the Entity\'s name. It is actually the name of the mesh we just created. We\'re used to seeing mesh names end with \'.mesh\'.', '</p>'), ('<p>', 'We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don\'t get confused, this means the ground won\'t cast a shadow, it doesn\'t mean we can\'t cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called \'rockwall.tga\'. You can find the name yourself by reading the entry in the material script.', '</p>'), ('<p>', 'Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.', '</p>'), ('<p>', "Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:", '</p>'), ('<p>', " Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.', '</p>'), ('<p>', 'Let\'s add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We\'ll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.', '</p>'), ('<p>', " The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.", '</p>'), ('<p>', 'Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.', '</p>'), ('<p>', 'Compile and run the application. You should see the shadowy blue figure of a ninja.', '</p>'), ('<p>', "Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.", '</p>'), ('<p>', ' Now we\'ll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light\'s direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.', '</p>'), ('<p>', 'The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.', '</p>'), ('<p>', 'Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.', '</p>'), ('<p>', 'To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We\'ll set the the specular and diffuse colors to a dark gray.', '</p>'), ('<p>', ' A point light has no direction. It only has a position. We will place our last light above and behind the ninja.', '</p>'), ('<p>', ' Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.', '</p>'), ('<p>', 'Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.', '</p>'), ('<p>', 'This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.', '</p>'), ('<p>', 'There are a lot of different settings we\'ve covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you\'ve finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. ', '</p>'), ('<p>', 'This tutorial will expand on the use of Lights in a scene and using them to cast shadows.', '</p>'), ('<p>', 'The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.', '</p>'), ('<p>', 'A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera\'s position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.', '</p>'), ('<p>', 'We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:', '</p>'), ('<p>', "You can retrieve the Camera by name using the SceneManager's getCamera method.", '</p>'), ('<p>', 'Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.', '</p>'), ('<p>', "The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.", '</p>'), ('<p>', 'When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.', '</p>'), ('<p>', 'There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera\'s view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.', '</p>'), ('<p>', 'Let\'s create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.', '</p>'), ('<p>', 'Now let\'s set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We\'ve set it to black because we are going to add colored lighting later, and we don\'t want the background color affecting how we see the lighting.', '</p>'), ('<p>', 'The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.', '</p>'), ('<p>', " We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.", '</p>'), ('<p>', 'Compile and run your application. You should still only see a black screen, just make sure it runs.', '</p>'), ('<p>', 'Before we get to shadows and lighting, let\'s add some elements to our scene. Let\'s put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.', '</p>'), ('<p>', 'We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.', '</p>'), ('<p>', 'The first thing we\'ll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here\'s a picture:', '</p>'), ('<p>', 'There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.', '</p>'), ('<p>', "Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.", '</p>'), ('<p>', 'This is a complicated method, and we\'re not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we\'ve created a new mesh called "ground" with a size of 1500x1500.', '</p>'), ('<p>', 'Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don\'t confuse the parameter given to createEntity for the Entity\'s name. It is actually the name of the mesh we just created. We\'re used to seeing mesh names end with \'.mesh\'.', '</p>'), ('<p>', 'We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don\'t get confused, this means the ground won\'t cast a shadow, it doesn\'t mean we can\'t cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called \'rockwall.tga\'. You can find the name yourself by reading the entry in the material script.', '</p>'), ('<p>', 'Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.', '</p>'), ('<p>', "Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:", '</p>'), ('<p>', " Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.", '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.', '</p>'), ('<p>', 'The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.', '</p>'), ('<p>', 'Let\'s add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We\'ll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.', '</p>'), ('<p>', " The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.", '</p>'), ('<p>', 'Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.', '</p>'), ('<p>', 'Compile and run the application. You should see the shadowy blue figure of a ninja.', '</p>'), ('<p>', "Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.", '</p>'), ('<p>', ' Now we\'ll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light\'s direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.', '</p>'), ('<p>', 'The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.', '</p>'), ('<p>', 'Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.', '</p>'), ('<p>', 'To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We\'ll set the the specular and diffuse colors to a dark gray.', '</p>'), ('<p>', ' A point light has no direction. It only has a position. We will place our last light above and behind the ninja.', '</p>'), ('<p>', ' Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.', '</p>'), ('<p>', 'Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.', '</p>'), ('<p>', 'This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.', '</p>'), ('<p>', 'There are a lot of different settings we\'ve covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you\'ve finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. ', '</p>'), ('<p>', 'This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.', '</p>'), ('<p>', 'The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.', '</p>'), ('<p>', 'Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.', '</p>'), ('<p>', 'To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.', '</p>'), ('<p>', 'After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.', '</p>'), ('<p>', 'Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates', '</p>'), ('<p>', 'It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)', '</p>'), ('<p>', 'Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.', '</p>'), ('<p>', 'The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.', '</p>'), ('<p>', 'The first option is to globally enforce per-pixel lighting, you can do the following', '</p>'), ('<p>', ' any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.', '</p>'), ('<p>', 'Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following', '</p>'), ('<p>', ' for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.', '</p>'), ('<p>', 'Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:', '</p>'), ('<p>', '<a class="anchor" id="lighting_stage"></a>', '</p>'), ('<p>', 'Force a specific lighting model.', '</p>'), ('<p>', 'Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code>', '</p>'), ('<p>', 'Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code>', '</p>'), ('<p>', 'Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code>', '</p>'), ('<p>', '<a class="anchor" id="light_count"></a>', '</p>'), ('<p>', 'Override dynamic light count. Allows to customize which lights the RTSS will consider.', '</p>'), ('<p>', 'Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="triplanarTexturing"></a>', '</p>'), ('<p>', 'Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a>', '</p>'), ('<p>', 'Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code>', '</p>'), ('<p>', 'Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code>', '</p>'), ('<p>', '<a class="anchor" id="integrated_pssm4"></a>', '</p>'), ('<p>', 'Integrated PSSM shadow receiver with 3 splits. Custom split points.', '</p>'), ('<p>', 'Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="layered_blend"></a>', '</p>'), ('<p>', 'Apply photoshop-like blend effects to texture layers', '</p>'), ('<p>', 'Format: <code>layered_blend &lt;effect&gt;</code>', '</p>'), ('<p>', 'Example: layered_blend luminosity', '</p>'), ('<p>', '<a class="anchor" id="source_modifier"></a>', '</p>'), ('<p>', 'Apply custom modulate effect to texture layer', '</p>'), ('<p>', 'Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code>', '</p>'), ('<p>', 'Example: <code>source_modifier src1_inverse_modulate custom 2</code>', '</p>'), ('<p>', 'When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.', '</p>'), ('<p>', 'The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).', '</p>'), ('<p>', 'Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.', '</p>'), ('<p>', 'The following steps are executed in order to generate shaders for a given technique:', '</p>'), ('<p>', 'Initializing the system is composed of the following steps:', '</p>'), ('<p>', 'This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.', '</p>'), ('<p>', 'To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.', '</p>'), ('<p>', 'Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.', '</p>'), ('<p>', 'During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.', '</p>'), ('<p>', 'The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.', '</p>'), ('<p>', 'The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.', '</p>'), ('<p>', 'A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.', '</p>'), ('<p>', 'RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.', '</p>'), ('<p>', "Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.", '</p>'), ('<p>', 'There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:', '</p>'), ('<p>', 'There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...', '</p>'), ('<p>', 'As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.', '</p>'), ('<p>', 'These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.', '</p>'), ('<p>', 'Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.', '</p>'), ('<p>', "In order to extend the system with your own shader effects you'll have to follow these steps:", '</p>'), ('<p>', 'Implementing the SubRenderState requires overriding the pure methods of the base class.', '</p>'), ('<p>', 'The SubRenderState supply default implementation for this method which break down this method into three stages:', '</p>'), ('<p>', ' Note:', '</p>'), ('<p>', ' This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.', '</p>'), ('<p>', 'Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods', '</p>'), ('<p>', 'A couple of notes on debugging shaders coming from the RTSS:', '</p>'), ('<p>', 'When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).', '</p>'), ('<p>', 'As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.', '</p>'), ('<p>', 'Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.', '</p>'), ('<p>', 'The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.', '</p>'), ('<p>', 'With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.', '</p>'), ('<p>', 'Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders', '</p>'), ('<p>', 'Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.', '</p>'), ('<p>', 'So why use a runtime shader system anyway?', '</p>'), ('<p>', 'This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.', '</p>'), ('<p>', 'The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.', '</p>'), ('<p>', 'Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.', '</p>'), ('<p>', 'To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.', '</p>'), ('<p>', 'After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.', '</p>'), ('<p>', 'Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates', '</p>'), ('<p>', 'It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)', '</p>'), ('<p>', 'Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.', '</p>'), ('<p>', 'The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.', '</p>'), ('<p>', 'The first option is to globally enforce per-pixel lighting, you can do the following', '</p>'), ('<p>', ' any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.', '</p>'), ('<p>', 'Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following', '</p>'), ('<p>', ' for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.', '</p>'), ('<p>', 'Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:', '</p>'), ('<p>', '<a class="anchor" id="lighting_stage"></a>', '</p>'), ('<p>', 'Force a specific lighting model.', '</p>'), ('<p>', 'Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code>', '</p>'), ('<p>', 'Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code>', '</p>'), ('<p>', 'Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code>', '</p>'), ('<p>', '<a class="anchor" id="light_count"></a>', '</p>'), ('<p>', 'Override dynamic light count. Allows to customize which lights the RTSS will consider.', '</p>'), ('<p>', 'Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="triplanarTexturing"></a>', '</p>'), ('<p>', 'Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a>', '</p>'), ('<p>', 'Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code>', '</p>'), ('<p>', 'Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code>', '</p>'), ('<p>', '<a class="anchor" id="integrated_pssm4"></a>', '</p>'), ('<p>', 'Integrated PSSM shadow receiver with 3 splits. Custom split points.', '</p>'), ('<p>', 'Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="layered_blend"></a>', '</p>'), ('<p>', 'Apply photoshop-like blend effects to texture layers', '</p>'), ('<p>', 'Format: <code>layered_blend &lt;effect&gt;</code>', '</p>'), ('<p>', 'Example: layered_blend luminosity', '</p>'), ('<p>', '<a class="anchor" id="source_modifier"></a>', '</p>'), ('<p>', 'Apply custom modulate effect to texture layer', '</p>'), ('<p>', 'Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code>', '</p>'), ('<p>', 'Example: <code>source_modifier src1_inverse_modulate custom 2</code>', '</p>'), ('<p>', 'When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.', '</p>'), ('<p>', 'The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).', '</p>'), ('<p>', 'Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.', '</p>'), ('<p>', 'The following steps are executed in order to generate shaders for a given technique:', '</p>'), ('<p>', 'Initializing the system is composed of the following steps:', '</p>'), ('<p>', 'This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.', '</p>'), ('<p>', 'To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.', '</p>'), ('<p>', 'Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.', '</p>'), ('<p>', 'During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.', '</p>'), ('<p>', 'The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.', '</p>'), ('<p>', 'The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.', '</p>'), ('<p>', 'A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.', '</p>'), ('<p>', 'RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.', '</p>'), ('<p>', "Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.", '</p>'), ('<p>', 'There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:', '</p>'), ('<p>', 'There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...', '</p>'), ('<p>', 'As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.', '</p>'), ('<p>', 'These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.', '</p>'), ('<p>', 'Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.', '</p>'), ('<p>', "In order to extend the system with your own shader effects you'll have to follow these steps:", '</p>'), ('<p>', 'Implementing the SubRenderState requires overriding the pure methods of the base class.', '</p>'), ('<p>', 'The SubRenderState supply default implementation for this method which break down this method into three stages:', '</p>'), ('<p>', ' Note:', '</p>'), ('<p>', ' This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.', '</p>'), ('<p>', 'Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods', '</p>'), ('<p>', 'A couple of notes on debugging shaders coming from the RTSS:', '</p>'), ('<p>', 'When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).', '</p>'), ('<p>', 'As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.', '</p>'), ('<p>', 'Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.', '</p>'), ('<p>', 'The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.', '</p>'), ('<p>', 'With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.', '</p>'), ('<p>', 'Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders', '</p>'), ('<p>', 'Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.', '</p>'), ('<p>', 'So why use a runtime shader system anyway?', '</p>'), ('<p>', 'This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.', '</p>'), ('<p>', 'The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.', '</p>'), ('<p>', 'Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.', '</p>'), ('<p>', 'To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.', '</p>'), ('<p>', 'After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.', '</p>'), ('<p>', 'Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates', '</p>'), ('<p>', 'It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)', '</p>'), ('<p>', 'Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.', '</p>'), ('<p>', 'The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.', '</p>'), ('<p>', 'The first option is to globally enforce per-pixel lighting, you can do the following', '</p>'), ('<p>', ' any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.', '</p>'), ('<p>', 'Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following', '</p>'), ('<p>', ' for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.', '</p>'), ('<p>', 'Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:', '</p>'), ('<p>', '<a class="anchor" id="lighting_stage"></a>', '</p>'), ('<p>', 'Force a specific lighting model.', '</p>'), ('<p>', 'Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code>', '</p>'), ('<p>', 'Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code>', '</p>'), ('<p>', 'Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code>', '</p>'), ('<p>', '<a class="anchor" id="light_count"></a>', '</p>'), ('<p>', 'Override dynamic light count. Allows to customize which lights the RTSS will consider.', '</p>'), ('<p>', 'Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="triplanarTexturing"></a>', '</p>'), ('<p>', 'Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a>', '</p>'), ('<p>', 'Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code>', '</p>'), ('<p>', 'Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code>', '</p>'), ('<p>', '<a class="anchor" id="integrated_pssm4"></a>', '</p>'), ('<p>', 'Integrated PSSM shadow receiver with 3 splits. Custom split points.', '</p>'), ('<p>', 'Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="layered_blend"></a>', '</p>'), ('<p>', 'Apply photoshop-like blend effects to texture layers', '</p>'), ('<p>', 'Format: <code>layered_blend &lt;effect&gt;</code>', '</p>'), ('<p>', 'Example: layered_blend luminosity', '</p>'), ('<p>', '<a class="anchor" id="source_modifier"></a>', '</p>'), ('<p>', 'Apply custom modulate effect to texture layer', '</p>'), ('<p>', 'Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code>', '</p>'), ('<p>', 'Example: <code>source_modifier src1_inverse_modulate custom 2</code>', '</p>'), ('<p>', 'When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.', '</p>'), ('<p>', 'The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).', '</p>'), ('<p>', 'Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.', '</p>'), ('<p>', 'The following steps are executed in order to generate shaders for a given technique:', '</p>'), ('<p>', 'Initializing the system is composed of the following steps:', '</p>'), ('<p>', 'This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.', '</p>'), ('<p>', 'To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.', '</p>'), ('<p>', 'Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.', '</p>'), ('<p>', 'During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.', '</p>'), ('<p>', 'The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.', '</p>'), ('<p>', 'The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.', '</p>'), ('<p>', 'A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.', '</p>'), ('<p>', 'RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.', '</p>'), ('<p>', "Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.", '</p>'), ('<p>', 'There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:', '</p>'), ('<p>', 'There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...', '</p>'), ('<p>', 'As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.', '</p>'), ('<p>', 'These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.', '</p>'), ('<p>', 'Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.', '</p>'), ('<p>', "In order to extend the system with your own shader effects you'll have to follow these steps:", '</p>'), ('<p>', 'Implementing the SubRenderState requires overriding the pure methods of the base class.', '</p>'), ('<p>', 'The SubRenderState supply default implementation for this method which break down this method into three stages:', '</p>'), ('<p>', ' Note:', '</p>'), ('<p>', ' This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.', '</p>'), ('<p>', 'Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods', '</p>'), ('<p>', 'A couple of notes on debugging shaders coming from the RTSS:', '</p>'), ('<p>', 'When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).', '</p>'), ('<p>', 'As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.', '</p>'), ('<p>', 'Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.', '</p>'), ('<p>', 'The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.', '</p>'), ('<p>', 'With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.', '</p>'), ('<p>', 'Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders', '</p>'), ('<p>', 'Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.', '</p>'), ('<p>', 'So why use a runtime shader system anyway?', '</p>'), ('<p>', 'This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.', '</p>'), ('<p>', 'The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.', '</p>'), ('<p>', 'Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.', '</p>'), ('<p>', 'To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.', '</p>'), ('<p>', 'After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.', '</p>'), ('<p>', 'Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates', '</p>'), ('<p>', 'It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)', '</p>'), ('<p>', 'Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.', '</p>'), ('<p>', 'The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.', '</p>'), ('<p>', 'The first option is to globally enforce per-pixel lighting, you can do the following', '</p>'), ('<p>', ' any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.', '</p>'), ('<p>', 'Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following', '</p>'), ('<p>', ' for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.', '</p>'), ('<p>', 'Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:', '</p>'), ('<p>', '<a class="anchor" id="lighting_stage"></a>', '</p>'), ('<p>', 'Force a specific lighting model.', '</p>'), ('<p>', 'Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code>', '</p>'), ('<p>', 'Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code>', '</p>'), ('<p>', 'Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code>', '</p>'), ('<p>', '<a class="anchor" id="light_count"></a>', '</p>'), ('<p>', 'Override dynamic light count. Allows to customize which lights the RTSS will consider.', '</p>'), ('<p>', 'Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="triplanarTexturing"></a>', '</p>'), ('<p>', 'Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a>', '</p>'), ('<p>', 'Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code>', '</p>'), ('<p>', 'Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code>', '</p>'), ('<p>', '<a class="anchor" id="integrated_pssm4"></a>', '</p>'), ('<p>', 'Integrated PSSM shadow receiver with 3 splits. Custom split points.', '</p>'), ('<p>', 'Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="layered_blend"></a>', '</p>'), ('<p>', 'Apply photoshop-like blend effects to texture layers', '</p>'), ('<p>', 'Format: <code>layered_blend &lt;effect&gt;</code>', '</p>'), ('<p>', 'Example: layered_blend luminosity', '</p>'), ('<p>', '<a class="anchor" id="source_modifier"></a>', '</p>'), ('<p>', 'Apply custom modulate effect to texture layer', '</p>'), ('<p>', 'Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code>', '</p>'), ('<p>', 'Example: <code>source_modifier src1_inverse_modulate custom 2</code>', '</p>'), ('<p>', 'When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.', '</p>'), ('<p>', 'The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).', '</p>'), ('<p>', 'Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.', '</p>'), ('<p>', 'The following steps are executed in order to generate shaders for a given technique:', '</p>'), ('<p>', 'Initializing the system is composed of the following steps:', '</p>'), ('<p>', 'This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.', '</p>'), ('<p>', 'To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.', '</p>'), ('<p>', 'Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.', '</p>'), ('<p>', 'During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.', '</p>'), ('<p>', 'The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.', '</p>'), ('<p>', 'The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.', '</p>'), ('<p>', 'A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.', '</p>'), ('<p>', 'RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.', '</p>'), ('<p>', "Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.", '</p>'), ('<p>', 'There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:', '</p>'), ('<p>', 'There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...', '</p>'), ('<p>', 'As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.', '</p>'), ('<p>', 'These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.', '</p>'), ('<p>', 'Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.', '</p>'), ('<p>', "In order to extend the system with your own shader effects you'll have to follow these steps:", '</p>'), ('<p>', 'Implementing the SubRenderState requires overriding the pure methods of the base class.', '</p>'), ('<p>', 'The SubRenderState supply default implementation for this method which break down this method into three stages:', '</p>'), ('<p>', ' Note:', '</p>'), ('<p>', ' This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.', '</p>'), ('<p>', 'Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods', '</p>'), ('<p>', 'A couple of notes on debugging shaders coming from the RTSS:', '</p>'), ('<p>', 'When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).', '</p>'), ('<p>', 'As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.', '</p>'), ('<p>', 'Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.', '</p>'), ('<p>', 'The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.', '</p>'), ('<p>', 'With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.', '</p>'), ('<p>', 'Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders', '</p>'), ('<p>', 'Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.', '</p>'), ('<p>', 'So why use a runtime shader system anyway?', '</p>'), ('<p>', 'This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.', '</p>'), ('<p>', 'The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.', '</p>'), ('<p>', 'Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.', '</p>'), ('<p>', 'To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.', '</p>'), ('<p>', 'After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.', '</p>'), ('<p>', 'Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates', '</p>'), ('<p>', 'It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)', '</p>'), ('<p>', 'Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.', '</p>'), ('<p>', 'The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.', '</p>'), ('<p>', 'The first option is to globally enforce per-pixel lighting, you can do the following', '</p>'), ('<p>', ' any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.', '</p>'), ('<p>', 'Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following', '</p>'), ('<p>', ' for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.', '</p>'), ('<p>', 'Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:', '</p>'), ('<p>', '<a class="anchor" id="lighting_stage"></a>', '</p>'), ('<p>', 'Force a specific lighting model.', '</p>'), ('<p>', 'Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code>', '</p>'), ('<p>', 'Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code>', '</p>'), ('<p>', 'Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code>', '</p>'), ('<p>', '<a class="anchor" id="light_count"></a>', '</p>'), ('<p>', 'Override dynamic light count. Allows to customize which lights the RTSS will consider.', '</p>'), ('<p>', 'Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="triplanarTexturing"></a>', '</p>'), ('<p>', 'Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a>', '</p>'), ('<p>', 'Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code>', '</p>'), ('<p>', 'Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code>', '</p>'), ('<p>', '<a class="anchor" id="integrated_pssm4"></a>', '</p>'), ('<p>', 'Integrated PSSM shadow receiver with 3 splits. Custom split points.', '</p>'), ('<p>', 'Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="layered_blend"></a>', '</p>'), ('<p>', 'Apply photoshop-like blend effects to texture layers', '</p>'), ('<p>', 'Format: <code>layered_blend &lt;effect&gt;</code>', '</p>'), ('<p>', 'Example: layered_blend luminosity', '</p>'), ('<p>', '<a class="anchor" id="source_modifier"></a>', '</p>'), ('<p>', 'Apply custom modulate effect to texture layer', '</p>'), ('<p>', 'Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code>', '</p>'), ('<p>', 'Example: <code>source_modifier src1_inverse_modulate custom 2</code>', '</p>'), ('<p>', 'When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.', '</p>'), ('<p>', 'The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).', '</p>'), ('<p>', 'Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.', '</p>'), ('<p>', 'The following steps are executed in order to generate shaders for a given technique:', '</p>'), ('<p>', 'Initializing the system is composed of the following steps:', '</p>'), ('<p>', 'This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.', '</p>'), ('<p>', 'To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.', '</p>'), ('<p>', 'Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.', '</p>'), ('<p>', 'During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.', '</p>'), ('<p>', 'The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.', '</p>'), ('<p>', 'The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.', '</p>'), ('<p>', 'A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.', '</p>'), ('<p>', 'RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.', '</p>'), ('<p>', "Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.", '</p>'), ('<p>', 'There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:', '</p>'), ('<p>', 'There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...', '</p>'), ('<p>', 'As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.', '</p>'), ('<p>', 'These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.', '</p>'), ('<p>', 'Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.', '</p>'), ('<p>', "In order to extend the system with your own shader effects you'll have to follow these steps:", '</p>'), ('<p>', 'Implementing the SubRenderState requires overriding the pure methods of the base class.', '</p>'), ('<p>', 'The SubRenderState supply default implementation for this method which break down this method into three stages:', '</p>'), ('<p>', ' Note:', '</p>'), ('<p>', ' This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.', '</p>'), ('<p>', 'Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods', '</p>'), ('<p>', 'A couple of notes on debugging shaders coming from the RTSS:', '</p>'), ('<p>', 'When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).', '</p>'), ('<p>', 'As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.', '</p>'), ('<p>', 'Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.', '</p>'), ('<p>', 'The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.', '</p>'), ('<p>', 'With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.', '</p>'), ('<p>', 'Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders', '</p>'), ('<p>', 'Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.', '</p>'), ('<p>', 'So why use a runtime shader system anyway?', '</p>'), ('<p>', 'This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.', '</p>'), ('<p>', 'Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.', '</p>'), ('<p>', 'Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.', '</p>'), ('<p>', 'But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.', '</p>'), ('<p>', 'Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.', '</p>'), ('<p>', 'Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.', '</p>'), ('<p>', 'For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.', '</p>'), ('<p>', 'It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.', '</p>'), ('<p>', 'Materials are still useful for:', '</p>'), ('<p>', 'You could be thinking the reason I came up with these two is to fit with D3D11s grand scheme of things while being compatible with OpenGL. But thats a half truth and an awesome side effect. Ive been developing the Hlms using OpenGL this whole time.', '</p>'), ('<p>', 'An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and theyre right about that.', '</p>'), ('<p>', 'However, there are big advantages for using blocks:', '</p>'), ('<p>', 'Of course its not perfect, it cant fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); youll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. Were aiming the general use case.', '</p>'), ('<p>', 'These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since Im not used to driver development. However from an engine perspective, blocks make sense.', '</p>'), ('<p>', 'Were introducing the concept of Datablocks. A Datablock is a material from the users perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.', '</p>'), ('<p>', 'The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.', '</p>'), ('<p>', 'The Hlms will parse the template files from the template folder according to the following rules:', '</p>'), ('<p>', "The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.", '</p>'), ('<p>', 'The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.', '</p>'), ('<p>', 'For example </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can\'t evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can\'t check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable IncludeLightingEquals2 and check whether it\'s non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms\'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can\'t see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you\'ll depend on the driver implementation having a good macro preprocessor.', '</p>'), ('<p>', 'The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:', '</p>'), ('<p>', "Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.", '</p>'), ('<p>', 'The logical operands &amp;&amp; || ! are valid.', '</p>'), ('<p>', 'Examples: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \\<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \\@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: ', '</p>'), ('<p>', 'Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.', '</p>'), ('<p>', 'Newlines are very important, as they will be printed with the loop.', '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', '<b>Attention #1!</b>', '</p>'), ('<p>', "Don't use the common letter i for the loop counter. It will conflict with other keywords.", '</p>'), ('<p>', 'i.e. @foreach( 1, i )@insertpiece( pieceName )@end will print 0nsertpiece( pieceName ) which is probably not what you intended.', '</p>'), ('<p>', '<b>Attention #2!</b>', '</p>'), ('<p>', 'foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.', '</p>'), ('<p>', 'i.e. The following code will not work:', '</p>'), ('<p>', 'Because psub will be evaluated before expanding the foreach. ', '</p>'), ('<p>', "Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.", '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', "Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. ", '</p>'), ('<p>', "Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.", '</p>'), ('<p>', 'Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c', '</p>'), ('<p>', 'Useful in combination with @counter and @value', '</p>'), ('<p>', 'Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won\'t be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Analogous to <a href="#toc304"><em>the family of math functions without the \'p\' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.', '</p>'), ('<p>', 'i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )', '</p>'), ('<p>', "One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.", '</p>'), ('<p>', 'If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.', '</p>'), ('<p>', 'There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:', '</p>'), ('<p>', 'When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.', '</p>'), ('<p>', "If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).", '</p>'), ('<p>', 'The following graph summarizes the process:', '</p>'), ('<p>', 'Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a <a href="#toc567"><em>pass hash</em></a> instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).', '</p>'), ('<p>', "While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:", '</p>'), ('<p>', 'Note: This section is relevant to those seeking to write their own Hlms implementation.', '</p>'), ('<p>', 'C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set key to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod', '</p>'), ('<p>', 'To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.', '</p>'), ('<p>', 'The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.', '</p>'), ('<p>', 'In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.', '</p>'), ('<p>', "Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.", '</p>'), ('<p>', 'For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.', '</p>'), ('<p>', 'The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.', '</p>'), ('<p>', "Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.", '</p>'), ('<p>', "Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.", '</p>'), ('<p>', 'For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.', '</p>'), ('<p>', 'Properties in underscore_case are set from C++; propierties in camelCase are set from the template.', '</p>'), ('<p>', "Propierties and pieces starting with 'custom_' are for user customizations of the template", '</p>'), ('<p>', 'TBD', '</p>'), ('<p>', "By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.", '</p>'), ('<p>', 'Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.', '</p>'), ('<p>', 'In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.', '</p>'), ('<p>', "Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.", '</p>'), ('<p>', 'Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.', '</p>'), ('<p>', 'There are different levels in which an Hlms implementation can be customized:', '</p>'), ('<p>', 'This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.', '</p>'), ('<p>', 'Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.', '</p>'), ('<p>', 'Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.', '</p>'), ('<p>', 'But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.', '</p>'), ('<p>', 'Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.', '</p>'), ('<p>', 'Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.', '</p>'), ('<p>', 'For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.', '</p>'), ('<p>', 'It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.', '</p>'), ('<p>', 'Materials are still useful for:', '</p>'), ('<p>', 'You could be thinking the reason I came up with these two is to fit with D3D11s grand scheme of things while being compatible with OpenGL. But thats a half truth and an awesome side effect. Ive been developing the Hlms using OpenGL this whole time.', '</p>'), ('<p>', 'An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and theyre right about that.', '</p>'), ('<p>', 'However, there are big advantages for using blocks:', '</p>'), ('<p>', 'Of course its not perfect, it cant fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); youll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. Were aiming the general use case.', '</p>'), ('<p>', 'These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since Im not used to driver development. However from an engine perspective, blocks make sense.', '</p>'), ('<p>', 'Were introducing the concept of Datablocks. A Datablock is a material from the users perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.', '</p>'), ('<p>', 'The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.', '</p>'), ('<p>', 'The Hlms will parse the template files from the template folder according to the following rules:', '</p>'), ('<p>', "The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.", '</p>'), ('<p>', 'The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.', '</p>'), ('<p>', 'For example </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can\'t evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can\'t check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable IncludeLightingEquals2 and check whether it\'s non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms\'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can\'t see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you\'ll depend on the driver implementation having a good macro preprocessor.', '</p>'), ('<p>', 'The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:', '</p>'), ('<p>', "Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.", '</p>'), ('<p>', 'The logical operands &amp;&amp; || ! are valid.', '</p>'), ('<p>', 'Examples: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \\<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \\@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: ', '</p>'), ('<p>', 'Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.', '</p>'), ('<p>', 'Newlines are very important, as they will be printed with the loop.', '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', '<b>Attention #1!</b>', '</p>'), ('<p>', "Don't use the common letter i for the loop counter. It will conflict with other keywords.", '</p>'), ('<p>', 'i.e. @foreach( 1, i )@insertpiece( pieceName )@end will print 0nsertpiece( pieceName ) which is probably not what you intended.', '</p>'), ('<p>', '<b>Attention #2!</b>', '</p>'), ('<p>', 'foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.', '</p>'), ('<p>', 'i.e. The following code will not work:', '</p>'), ('<p>', 'Because psub will be evaluated before expanding the foreach. ', '</p>'), ('<p>', "Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.", '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', "Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. ", '</p>'), ('<p>', "Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.", '</p>'), ('<p>', 'Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c', '</p>'), ('<p>', 'Useful in combination with @counter and @value', '</p>'), ('<p>', 'Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won\'t be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Analogous to <a href="#toc304"><em>the family of math functions without the \'p\' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.', '</p>'), ('<p>', 'i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )', '</p>'), ('<p>', "One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.", '</p>'), ('<p>', 'If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.', '</p>'), ('<p>', 'There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:', '</p>'), ('<p>', 'When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.', '</p>'), ('<p>', "If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).", '</p>'), ('<p>', 'The following graph summarizes the process:', '</p>'), ('<p>', 'Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a <a href="#toc567"><em>pass hash</em></a> instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).', '</p>'), ('<p>', "While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:", '</p>'), ('<p>', 'Note: This section is relevant to those seeking to write their own Hlms implementation.', '</p>'), ('<p>', 'C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set key to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod', '</p>'), ('<p>', 'To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.', '</p>'), ('<p>', 'The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.', '</p>'), ('<p>', 'In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.', '</p>'), ('<p>', "Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.", '</p>'), ('<p>', 'For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.', '</p>'), ('<p>', 'The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.', '</p>'), ('<p>', "Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.", '</p>'), ('<p>', "Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.", '</p>'), ('<p>', 'For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.', '</p>'), ('<p>', 'Properties in underscore_case are set from C++; propierties in camelCase are set from the template.', '</p>'), ('<p>', "Propierties and pieces starting with 'custom_' are for user customizations of the template", '</p>'), ('<p>', 'TBD', '</p>'), ('<p>', "By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.", '</p>'), ('<p>', 'Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.', '</p>'), ('<p>', 'In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.', '</p>'), ('<p>', "Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.", '</p>'), ('<p>', 'Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.', '</p>'), ('<p>', 'There are different levels in which an Hlms implementation can be customized:', '</p>'), ('<p>', 'This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.', '</p>'), ('<p>', 'The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.', '</p>'), ('<p>', 'Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.', '</p>'), ('<p>', 'To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.', '</p>'), ('<p>', 'After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.', '</p>'), ('<p>', 'Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates', '</p>'), ('<p>', 'It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)', '</p>'), ('<p>', 'Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.', '</p>'), ('<p>', 'The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.', '</p>'), ('<p>', 'The first option is to globally enforce per-pixel lighting, you can do the following', '</p>'), ('<p>', ' any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.', '</p>'), ('<p>', 'Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following', '</p>'), ('<p>', ' for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.', '</p>'), ('<p>', 'Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:', '</p>'), ('<p>', '<a class="anchor" id="lighting_stage"></a>', '</p>'), ('<p>', 'Force a specific lighting model.', '</p>'), ('<p>', 'Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code>', '</p>'), ('<p>', 'Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code>', '</p>'), ('<p>', 'Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code>', '</p>'), ('<p>', '<a class="anchor" id="light_count"></a>', '</p>'), ('<p>', 'Override dynamic light count. Allows to customize which lights the RTSS will consider.', '</p>'), ('<p>', 'Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="triplanarTexturing"></a>', '</p>'), ('<p>', 'Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a>', '</p>'), ('<p>', 'Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code>', '</p>'), ('<p>', 'Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code>', '</p>'), ('<p>', '<a class="anchor" id="integrated_pssm4"></a>', '</p>'), ('<p>', 'Integrated PSSM shadow receiver with 3 splits. Custom split points.', '</p>'), ('<p>', 'Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="layered_blend"></a>', '</p>'), ('<p>', 'Apply photoshop-like blend effects to texture layers', '</p>'), ('<p>', 'Format: <code>layered_blend &lt;effect&gt;</code>', '</p>'), ('<p>', 'Example: layered_blend luminosity', '</p>'), ('<p>', '<a class="anchor" id="source_modifier"></a>', '</p>'), ('<p>', 'Apply custom modulate effect to texture layer', '</p>'), ('<p>', 'Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code>', '</p>'), ('<p>', 'Example: <code>source_modifier src1_inverse_modulate custom 2</code>', '</p>'), ('<p>', 'When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.', '</p>'), ('<p>', 'The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).', '</p>'), ('<p>', 'Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.', '</p>'), ('<p>', 'The following steps are executed in order to generate shaders for a given technique:', '</p>'), ('<p>', 'Initializing the system is composed of the following steps:', '</p>'), ('<p>', 'This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.', '</p>'), ('<p>', 'To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.', '</p>'), ('<p>', 'Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.', '</p>'), ('<p>', 'During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.', '</p>'), ('<p>', 'The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.', '</p>'), ('<p>', 'The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.', '</p>'), ('<p>', 'A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.', '</p>'), ('<p>', 'RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.', '</p>'), ('<p>', "Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.", '</p>'), ('<p>', 'There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:', '</p>'), ('<p>', 'There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...', '</p>'), ('<p>', 'As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.', '</p>'), ('<p>', 'These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.', '</p>'), ('<p>', 'Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.', '</p>'), ('<p>', "In order to extend the system with your own shader effects you'll have to follow these steps:", '</p>'), ('<p>', 'Implementing the SubRenderState requires overriding the pure methods of the base class.', '</p>'), ('<p>', 'The SubRenderState supply default implementation for this method which break down this method into three stages:', '</p>'), ('<p>', ' Note:', '</p>'), ('<p>', ' This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.', '</p>'), ('<p>', 'Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods', '</p>'), ('<p>', 'A couple of notes on debugging shaders coming from the RTSS:', '</p>'), ('<p>', 'When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).', '</p>'), ('<p>', 'As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.', '</p>'), ('<p>', 'Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.', '</p>'), ('<p>', 'The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.', '</p>'), ('<p>', 'With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.', '</p>'), ('<p>', 'Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders', '</p>'), ('<p>', 'Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.', '</p>'), ('<p>', 'So why use a runtime shader system anyway?', '</p>'), ('<p>', 'This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.', '</p>'), ('<p>', 'Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.', '</p>'), ('<p>', 'Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.', '</p>'), ('<p>', 'But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.', '</p>'), ('<p>', 'Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.', '</p>'), ('<p>', 'Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.', '</p>'), ('<p>', 'For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.', '</p>'), ('<p>', 'It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.', '</p>'), ('<p>', 'Materials are still useful for:', '</p>'), ('<p>', 'You could be thinking the reason I came up with these two is to fit with D3D11s grand scheme of things while being compatible with OpenGL. But thats a half truth and an awesome side effect. Ive been developing the Hlms using OpenGL this whole time.', '</p>'), ('<p>', 'An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and theyre right about that.', '</p>'), ('<p>', 'However, there are big advantages for using blocks:', '</p>'), ('<p>', 'Of course its not perfect, it cant fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); youll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. Were aiming the general use case.', '</p>'), ('<p>', 'These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since Im not used to driver development. However from an engine perspective, blocks make sense.', '</p>'), ('<p>', 'Were introducing the concept of Datablocks. A Datablock is a material from the users perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.', '</p>'), ('<p>', 'The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.', '</p>'), ('<p>', 'The Hlms will parse the template files from the template folder according to the following rules:', '</p>'), ('<p>', "The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.", '</p>'), ('<p>', 'The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.', '</p>'), ('<p>', 'For example </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can\'t evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can\'t check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable IncludeLightingEquals2 and check whether it\'s non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms\'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can\'t see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you\'ll depend on the driver implementation having a good macro preprocessor.', '</p>'), ('<p>', 'The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:', '</p>'), ('<p>', "Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.", '</p>'), ('<p>', 'The logical operands &amp;&amp; || ! are valid.', '</p>'), ('<p>', 'Examples: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \\<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \\@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: ', '</p>'), ('<p>', 'Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.', '</p>'), ('<p>', 'Newlines are very important, as they will be printed with the loop.', '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', '<b>Attention #1!</b>', '</p>'), ('<p>', "Don't use the common letter i for the loop counter. It will conflict with other keywords.", '</p>'), ('<p>', 'i.e. @foreach( 1, i )@insertpiece( pieceName )@end will print 0nsertpiece( pieceName ) which is probably not what you intended.', '</p>'), ('<p>', '<b>Attention #2!</b>', '</p>'), ('<p>', 'foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.', '</p>'), ('<p>', 'i.e. The following code will not work:', '</p>'), ('<p>', 'Because psub will be evaluated before expanding the foreach. ', '</p>'), ('<p>', "Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.", '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', "Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. ", '</p>'), ('<p>', "Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.", '</p>'), ('<p>', 'Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c', '</p>'), ('<p>', 'Useful in combination with @counter and @value', '</p>'), ('<p>', 'Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won\'t be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Analogous to <a href="#toc304"><em>the family of math functions without the \'p\' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.', '</p>'), ('<p>', 'i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )', '</p>'), ('<p>', "One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.", '</p>'), ('<p>', 'If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.', '</p>'), ('<p>', 'There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:', '</p>'), ('<p>', 'When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.', '</p>'), ('<p>', "If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).", '</p>'), ('<p>', 'The following graph summarizes the process:', '</p>'), ('<p>', 'Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a <a href="#toc567"><em>pass hash</em></a> instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).', '</p>'), ('<p>', "While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:", '</p>'), ('<p>', 'Note: This section is relevant to those seeking to write their own Hlms implementation.', '</p>'), ('<p>', 'C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set key to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod', '</p>'), ('<p>', 'To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.', '</p>'), ('<p>', 'The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.', '</p>'), ('<p>', 'In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.', '</p>'), ('<p>', "Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.", '</p>'), ('<p>', 'For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.', '</p>'), ('<p>', 'The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.', '</p>'), ('<p>', "Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.", '</p>'), ('<p>', "Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.", '</p>'), ('<p>', 'For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.', '</p>'), ('<p>', 'Properties in underscore_case are set from C++; propierties in camelCase are set from the template.', '</p>'), ('<p>', "Propierties and pieces starting with 'custom_' are for user customizations of the template", '</p>'), ('<p>', 'TBD', '</p>'), ('<p>', "By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.", '</p>'), ('<p>', 'Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.', '</p>'), ('<p>', 'In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.', '</p>'), ('<p>', "Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.", '</p>'), ('<p>', 'Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.', '</p>'), ('<p>', 'There are different levels in which an Hlms implementation can be customized:', '</p>'), ('<p>', 'This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.', '</p>'), ('<p>', 'The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.', '</p>'), ('<p>', 'Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.', '</p>'), ('<p>', 'To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.', '</p>'), ('<p>', 'After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.', '</p>'), ('<p>', 'Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates', '</p>'), ('<p>', 'It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)', '</p>'), ('<p>', 'Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.', '</p>'), ('<p>', 'The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.', '</p>'), ('<p>', 'The first option is to globally enforce per-pixel lighting, you can do the following', '</p>'), ('<p>', ' any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.', '</p>'), ('<p>', 'Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following', '</p>'), ('<p>', ' for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.', '</p>'), ('<p>', 'Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:', '</p>'), ('<p>', '<a class="anchor" id="lighting_stage"></a>', '</p>'), ('<p>', 'Force a specific lighting model.', '</p>'), ('<p>', 'Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code>', '</p>'), ('<p>', 'Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code>', '</p>'), ('<p>', 'Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code>', '</p>'), ('<p>', '<a class="anchor" id="light_count"></a>', '</p>'), ('<p>', 'Override dynamic light count. Allows to customize which lights the RTSS will consider.', '</p>'), ('<p>', 'Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="triplanarTexturing"></a>', '</p>'), ('<p>', 'Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a>', '</p>'), ('<p>', 'Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code>', '</p>'), ('<p>', 'Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code>', '</p>'), ('<p>', '<a class="anchor" id="integrated_pssm4"></a>', '</p>'), ('<p>', 'Integrated PSSM shadow receiver with 3 splits. Custom split points.', '</p>'), ('<p>', 'Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="layered_blend"></a>', '</p>'), ('<p>', 'Apply photoshop-like blend effects to texture layers', '</p>'), ('<p>', 'Format: <code>layered_blend &lt;effect&gt;</code>', '</p>'), ('<p>', 'Example: layered_blend luminosity', '</p>'), ('<p>', '<a class="anchor" id="source_modifier"></a>', '</p>'), ('<p>', 'Apply custom modulate effect to texture layer', '</p>'), ('<p>', 'Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code>', '</p>'), ('<p>', 'Example: <code>source_modifier src1_inverse_modulate custom 2</code>', '</p>'), ('<p>', 'When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.', '</p>'), ('<p>', 'The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).', '</p>'), ('<p>', 'Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.', '</p>'), ('<p>', 'The following steps are executed in order to generate shaders for a given technique:', '</p>'), ('<p>', 'Initializing the system is composed of the following steps:', '</p>'), ('<p>', 'This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.', '</p>'), ('<p>', 'To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.', '</p>'), ('<p>', 'Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.', '</p>'), ('<p>', 'During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.', '</p>'), ('<p>', 'The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.', '</p>'), ('<p>', 'The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.', '</p>'), ('<p>', 'A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.', '</p>'), ('<p>', 'RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.', '</p>'), ('<p>', "Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.", '</p>'), ('<p>', 'There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:', '</p>'), ('<p>', 'There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...', '</p>'), ('<p>', 'As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.', '</p>'), ('<p>', 'These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.', '</p>'), ('<p>', 'Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.', '</p>'), ('<p>', "In order to extend the system with your own shader effects you'll have to follow these steps:", '</p>'), ('<p>', 'Implementing the SubRenderState requires overriding the pure methods of the base class.', '</p>'), ('<p>', 'The SubRenderState supply default implementation for this method which break down this method into three stages:', '</p>'), ('<p>', ' Note:', '</p>'), ('<p>', ' This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.', '</p>'), ('<p>', 'Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods', '</p>'), ('<p>', 'A couple of notes on debugging shaders coming from the RTSS:', '</p>'), ('<p>', 'When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).', '</p>'), ('<p>', 'As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.', '</p>'), ('<p>', 'Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.', '</p>'), ('<p>', 'The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.', '</p>'), ('<p>', 'With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.', '</p>'), ('<p>', 'Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders', '</p>'), ('<p>', 'Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.', '</p>'), ('<p>', 'So why use a runtime shader system anyway?', '</p>'), ('<p>', 'This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.', '</p>'), ('<p>', 'Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.', '</p>'), ('<p>', 'Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.', '</p>'), ('<p>', 'But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.', '</p>'), ('<p>', 'Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.', '</p>'), ('<p>', 'Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.', '</p>'), ('<p>', 'For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.', '</p>'), ('<p>', 'It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.', '</p>'), ('<p>', 'Materials are still useful for:', '</p>'), ('<p>', 'You could be thinking the reason I came up with these two is to fit with D3D11s grand scheme of things while being compatible with OpenGL. But thats a half truth and an awesome side effect. Ive been developing the Hlms using OpenGL this whole time.', '</p>'), ('<p>', 'An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and theyre right about that.', '</p>'), ('<p>', 'However, there are big advantages for using blocks:', '</p>'), ('<p>', 'Of course its not perfect, it cant fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); youll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. Were aiming the general use case.', '</p>'), ('<p>', 'These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since Im not used to driver development. However from an engine perspective, blocks make sense.', '</p>'), ('<p>', 'Were introducing the concept of Datablocks. A Datablock is a material from the users perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.', '</p>'), ('<p>', 'The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.', '</p>'), ('<p>', 'The Hlms will parse the template files from the template folder according to the following rules:', '</p>'), ('<p>', "The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.", '</p>'), ('<p>', 'The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.', '</p>'), ('<p>', 'For example </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can\'t evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can\'t check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable IncludeLightingEquals2 and check whether it\'s non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms\'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can\'t see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you\'ll depend on the driver implementation having a good macro preprocessor.', '</p>'), ('<p>', 'The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:', '</p>'), ('<p>', "Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.", '</p>'), ('<p>', 'The logical operands &amp;&amp; || ! are valid.', '</p>'), ('<p>', 'Examples: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \\<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \\@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: ', '</p>'), ('<p>', 'Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.', '</p>'), ('<p>', 'Newlines are very important, as they will be printed with the loop.', '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', '<b>Attention #1!</b>', '</p>'), ('<p>', "Don't use the common letter i for the loop counter. It will conflict with other keywords.", '</p>'), ('<p>', 'i.e. @foreach( 1, i )@insertpiece( pieceName )@end will print 0nsertpiece( pieceName ) which is probably not what you intended.', '</p>'), ('<p>', '<b>Attention #2!</b>', '</p>'), ('<p>', 'foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.', '</p>'), ('<p>', 'i.e. The following code will not work:', '</p>'), ('<p>', 'Because psub will be evaluated before expanding the foreach. ', '</p>'), ('<p>', "Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.", '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', "Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. ", '</p>'), ('<p>', "Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.", '</p>'), ('<p>', 'Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c', '</p>'), ('<p>', 'Useful in combination with @counter and @value', '</p>'), ('<p>', 'Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won\'t be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Analogous to <a href="#toc304"><em>the family of math functions without the \'p\' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.', '</p>'), ('<p>', 'i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )', '</p>'), ('<p>', "One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.", '</p>'), ('<p>', 'If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.', '</p>'), ('<p>', 'There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:', '</p>'), ('<p>', 'When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.', '</p>'), ('<p>', "If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).", '</p>'), ('<p>', 'The following graph summarizes the process:', '</p>'), ('<p>', 'Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a <a href="#toc567"><em>pass hash</em></a> instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).', '</p>'), ('<p>', "While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:", '</p>'), ('<p>', 'Note: This section is relevant to those seeking to write their own Hlms implementation.', '</p>'), ('<p>', 'C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set key to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod', '</p>'), ('<p>', 'To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.', '</p>'), ('<p>', 'The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.', '</p>'), ('<p>', 'In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.', '</p>'), ('<p>', "Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.", '</p>'), ('<p>', 'For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.', '</p>'), ('<p>', 'The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.', '</p>'), ('<p>', "Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.", '</p>'), ('<p>', "Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.", '</p>'), ('<p>', 'For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.', '</p>'), ('<p>', 'Properties in underscore_case are set from C++; propierties in camelCase are set from the template.', '</p>'), ('<p>', "Propierties and pieces starting with 'custom_' are for user customizations of the template", '</p>'), ('<p>', 'TBD', '</p>'), ('<p>', "By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.", '</p>'), ('<p>', 'Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.', '</p>'), ('<p>', 'In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.', '</p>'), ('<p>', "Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.", '</p>'), ('<p>', 'Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.', '</p>'), ('<p>', 'There are different levels in which an Hlms implementation can be customized:', '</p>'), ('<p>', 'This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.', '</p>'), ('<p>', 'The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.', '</p>'), ('<p>', 'Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.', '</p>'), ('<p>', 'To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.', '</p>'), ('<p>', 'After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.', '</p>'), ('<p>', 'Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates', '</p>'), ('<p>', 'It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)', '</p>'), ('<p>', 'Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.', '</p>'), ('<p>', 'The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.', '</p>'), ('<p>', 'The first option is to globally enforce per-pixel lighting, you can do the following', '</p>'), ('<p>', ' any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.', '</p>'), ('<p>', 'Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following', '</p>'), ('<p>', ' for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.', '</p>'), ('<p>', 'Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:', '</p>'), ('<p>', '<a class="anchor" id="lighting_stage"></a>', '</p>'), ('<p>', 'Force a specific lighting model.', '</p>'), ('<p>', 'Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code>', '</p>'), ('<p>', 'Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code>', '</p>'), ('<p>', 'Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code>', '</p>'), ('<p>', '<a class="anchor" id="light_count"></a>', '</p>'), ('<p>', 'Override dynamic light count. Allows to customize which lights the RTSS will consider.', '</p>'), ('<p>', 'Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="triplanarTexturing"></a>', '</p>'), ('<p>', 'Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a>', '</p>'), ('<p>', 'Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code>', '</p>'), ('<p>', 'Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code>', '</p>'), ('<p>', '<a class="anchor" id="integrated_pssm4"></a>', '</p>'), ('<p>', 'Integrated PSSM shadow receiver with 3 splits. Custom split points.', '</p>'), ('<p>', 'Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="layered_blend"></a>', '</p>'), ('<p>', 'Apply photoshop-like blend effects to texture layers', '</p>'), ('<p>', 'Format: <code>layered_blend &lt;effect&gt;</code>', '</p>'), ('<p>', 'Example: layered_blend luminosity', '</p>'), ('<p>', '<a class="anchor" id="source_modifier"></a>', '</p>'), ('<p>', 'Apply custom modulate effect to texture layer', '</p>'), ('<p>', 'Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code>', '</p>'), ('<p>', 'Example: <code>source_modifier src1_inverse_modulate custom 2</code>', '</p>'), ('<p>', 'When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.', '</p>'), ('<p>', 'The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).', '</p>'), ('<p>', 'Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.', '</p>'), ('<p>', 'The following steps are executed in order to generate shaders for a given technique:', '</p>'), ('<p>', 'Initializing the system is composed of the following steps:', '</p>'), ('<p>', 'This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.', '</p>'), ('<p>', 'To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.', '</p>'), ('<p>', 'Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.', '</p>'), ('<p>', 'During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.', '</p>'), ('<p>', 'The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.', '</p>'), ('<p>', 'The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.', '</p>'), ('<p>', 'A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.', '</p>'), ('<p>', 'RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.', '</p>'), ('<p>', "Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.", '</p>'), ('<p>', 'There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:', '</p>'), ('<p>', 'There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...', '</p>'), ('<p>', 'As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.', '</p>'), ('<p>', 'These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.', '</p>'), ('<p>', 'Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.', '</p>'), ('<p>', "In order to extend the system with your own shader effects you'll have to follow these steps:", '</p>'), ('<p>', 'Implementing the SubRenderState requires overriding the pure methods of the base class.', '</p>'), ('<p>', 'The SubRenderState supply default implementation for this method which break down this method into three stages:', '</p>'), ('<p>', ' Note:', '</p>'), ('<p>', ' This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.', '</p>'), ('<p>', 'Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods', '</p>'), ('<p>', 'A couple of notes on debugging shaders coming from the RTSS:', '</p>'), ('<p>', 'When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).', '</p>'), ('<p>', 'As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.', '</p>'), ('<p>', 'Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.', '</p>'), ('<p>', 'The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.', '</p>'), ('<p>', 'With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.', '</p>'), ('<p>', 'Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders', '</p>'), ('<p>', 'Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.', '</p>'), ('<p>', 'So why use a runtime shader system anyway?', '</p>'), ('<p>', 'This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.', '</p>'), ('<p>', 'Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.', '</p>'), ('<p>', 'Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.', '</p>'), ('<p>', 'But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.', '</p>'), ('<p>', 'Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.', '</p>'), ('<p>', 'Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.', '</p>'), ('<p>', 'For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.', '</p>'), ('<p>', 'It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.', '</p>'), ('<p>', 'Materials are still useful for:', '</p>'), ('<p>', 'You could be thinking the reason I came up with these two is to fit with D3D11s grand scheme of things while being compatible with OpenGL. But thats a half truth and an awesome side effect. Ive been developing the Hlms using OpenGL this whole time.', '</p>'), ('<p>', 'An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and theyre right about that.', '</p>'), ('<p>', 'However, there are big advantages for using blocks:', '</p>'), ('<p>', 'Of course its not perfect, it cant fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); youll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. Were aiming the general use case.', '</p>'), ('<p>', 'These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since Im not used to driver development. However from an engine perspective, blocks make sense.', '</p>'), ('<p>', 'Were introducing the concept of Datablocks. A Datablock is a material from the users perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.', '</p>'), ('<p>', 'The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.', '</p>'), ('<p>', 'The Hlms will parse the template files from the template folder according to the following rules:', '</p>'), ('<p>', "The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.", '</p>'), ('<p>', 'The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.', '</p>'), ('<p>', 'For example </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can\'t evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can\'t check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable IncludeLightingEquals2 and check whether it\'s non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms\'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can\'t see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you\'ll depend on the driver implementation having a good macro preprocessor.', '</p>'), ('<p>', 'The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:', '</p>'), ('<p>', "Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.", '</p>'), ('<p>', 'The logical operands &amp;&amp; || ! are valid.', '</p>'), ('<p>', 'Examples: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \\<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \\@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: ', '</p>'), ('<p>', 'Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.', '</p>'), ('<p>', 'Newlines are very important, as they will be printed with the loop.', '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', '<b>Attention #1!</b>', '</p>'), ('<p>', "Don't use the common letter i for the loop counter. It will conflict with other keywords.", '</p>'), ('<p>', 'i.e. @foreach( 1, i )@insertpiece( pieceName )@end will print 0nsertpiece( pieceName ) which is probably not what you intended.', '</p>'), ('<p>', '<b>Attention #2!</b>', '</p>'), ('<p>', 'foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.', '</p>'), ('<p>', 'i.e. The following code will not work:', '</p>'), ('<p>', 'Because psub will be evaluated before expanding the foreach. ', '</p>'), ('<p>', "Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.", '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', "Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. ", '</p>'), ('<p>', "Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.", '</p>'), ('<p>', 'Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c', '</p>'), ('<p>', 'Useful in combination with @counter and @value', '</p>'), ('<p>', 'Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won\'t be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Analogous to <a href="#toc304"><em>the family of math functions without the \'p\' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.', '</p>'), ('<p>', 'i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )', '</p>'), ('<p>', "One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.", '</p>'), ('<p>', 'If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.', '</p>'), ('<p>', 'There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:', '</p>'), ('<p>', 'When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.', '</p>'), ('<p>', "If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).", '</p>'), ('<p>', 'The following graph summarizes the process:', '</p>'), ('<p>', 'Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a <a href="#toc567"><em>pass hash</em></a> instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).', '</p>'), ('<p>', "While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:", '</p>'), ('<p>', 'Note: This section is relevant to those seeking to write their own Hlms implementation.', '</p>'), ('<p>', 'C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set key to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod', '</p>'), ('<p>', 'To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.', '</p>'), ('<p>', 'The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.', '</p>'), ('<p>', 'In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.', '</p>'), ('<p>', "Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.", '</p>'), ('<p>', 'For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.', '</p>'), ('<p>', 'The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.', '</p>'), ('<p>', "Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.", '</p>'), ('<p>', "Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.", '</p>'), ('<p>', 'For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.', '</p>'), ('<p>', 'Properties in underscore_case are set from C++; propierties in camelCase are set from the template.', '</p>'), ('<p>', "Propierties and pieces starting with 'custom_' are for user customizations of the template", '</p>'), ('<p>', 'TBD', '</p>'), ('<p>', "By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.", '</p>'), ('<p>', 'Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.', '</p>'), ('<p>', 'In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.', '</p>'), ('<p>', "Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.", '</p>'), ('<p>', 'Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.', '</p>'), ('<p>', 'There are different levels in which an Hlms implementation can be customized:', '</p>'), ('<p>', 'This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.', '</p>'), ('<p>', 'The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.', '</p>'), ('<p>', 'Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.', '</p>'), ('<p>', 'To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.', '</p>'), ('<p>', 'After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.', '</p>'), ('<p>', 'Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates', '</p>'), ('<p>', 'It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)', '</p>'), ('<p>', 'Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.', '</p>'), ('<p>', 'The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.', '</p>'), ('<p>', 'The first option is to globally enforce per-pixel lighting, you can do the following', '</p>'), ('<p>', ' any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.', '</p>'), ('<p>', 'Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following', '</p>'), ('<p>', ' for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.', '</p>'), ('<p>', 'Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:', '</p>'), ('<p>', '<a class="anchor" id="lighting_stage"></a>', '</p>'), ('<p>', 'Force a specific lighting model.', '</p>'), ('<p>', 'Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code>', '</p>'), ('<p>', 'Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code>', '</p>'), ('<p>', 'Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code>', '</p>'), ('<p>', '<a class="anchor" id="light_count"></a>', '</p>'), ('<p>', 'Override dynamic light count. Allows to customize which lights the RTSS will consider.', '</p>'), ('<p>', 'Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="triplanarTexturing"></a>', '</p>'), ('<p>', 'Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a>', '</p>'), ('<p>', 'Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code>', '</p>'), ('<p>', 'Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code>', '</p>'), ('<p>', '<a class="anchor" id="integrated_pssm4"></a>', '</p>'), ('<p>', 'Integrated PSSM shadow receiver with 3 splits. Custom split points.', '</p>'), ('<p>', 'Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="layered_blend"></a>', '</p>'), ('<p>', 'Apply photoshop-like blend effects to texture layers', '</p>'), ('<p>', 'Format: <code>layered_blend &lt;effect&gt;</code>', '</p>'), ('<p>', 'Example: layered_blend luminosity', '</p>'), ('<p>', '<a class="anchor" id="source_modifier"></a>', '</p>'), ('<p>', 'Apply custom modulate effect to texture layer', '</p>'), ('<p>', 'Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code>', '</p>'), ('<p>', 'Example: <code>source_modifier src1_inverse_modulate custom 2</code>', '</p>'), ('<p>', 'When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.', '</p>'), ('<p>', 'The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).', '</p>'), ('<p>', 'Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.', '</p>'), ('<p>', 'The following steps are executed in order to generate shaders for a given technique:', '</p>'), ('<p>', 'Initializing the system is composed of the following steps:', '</p>'), ('<p>', 'This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.', '</p>'), ('<p>', 'To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.', '</p>'), ('<p>', 'Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.', '</p>'), ('<p>', 'During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.', '</p>'), ('<p>', 'The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.', '</p>'), ('<p>', 'The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.', '</p>'), ('<p>', 'A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.', '</p>'), ('<p>', 'RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.', '</p>'), ('<p>', "Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.", '</p>'), ('<p>', 'There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:', '</p>'), ('<p>', 'There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...', '</p>'), ('<p>', 'As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.', '</p>'), ('<p>', 'These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.', '</p>'), ('<p>', 'Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.', '</p>'), ('<p>', "In order to extend the system with your own shader effects you'll have to follow these steps:", '</p>'), ('<p>', 'Implementing the SubRenderState requires overriding the pure methods of the base class.', '</p>'), ('<p>', 'The SubRenderState supply default implementation for this method which break down this method into three stages:', '</p>'), ('<p>', ' Note:', '</p>'), ('<p>', ' This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.', '</p>'), ('<p>', 'Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods', '</p>'), ('<p>', 'A couple of notes on debugging shaders coming from the RTSS:', '</p>'), ('<p>', 'When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).', '</p>'), ('<p>', 'As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.', '</p>'), ('<p>', 'Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.', '</p>'), ('<p>', 'The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.', '</p>'), ('<p>', 'With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.', '</p>'), ('<p>', 'Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders', '</p>'), ('<p>', 'Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.', '</p>'), ('<p>', 'So why use a runtime shader system anyway?', '</p>'), ('<p>', 'This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.', '</p>'), ('<p>', 'The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.', '</p>'), ('<p>', 'Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.', '</p>'), ('<p>', 'To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.', '</p>'), ('<p>', 'After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.', '</p>'), ('<p>', 'Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates', '</p>'), ('<p>', 'It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)', '</p>'), ('<p>', 'Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.', '</p>'), ('<p>', 'The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.', '</p>'), ('<p>', 'The first option is to globally enforce per-pixel lighting, you can do the following', '</p>'), ('<p>', ' any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.', '</p>'), ('<p>', 'Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following', '</p>'), ('<p>', ' for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.', '</p>'), ('<p>', 'Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:', '</p>'), ('<p>', '<a class="anchor" id="lighting_stage"></a>', '</p>'), ('<p>', 'Force a specific lighting model.', '</p>'), ('<p>', 'Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code>', '</p>'), ('<p>', 'Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code>', '</p>'), ('<p>', 'Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code>', '</p>'), ('<p>', '<a class="anchor" id="light_count"></a>', '</p>'), ('<p>', 'Override dynamic light count. Allows to customize which lights the RTSS will consider.', '</p>'), ('<p>', 'Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="triplanarTexturing"></a>', '</p>'), ('<p>', 'Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a>', '</p>'), ('<p>', 'Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code>', '</p>'), ('<p>', 'Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code>', '</p>'), ('<p>', '<a class="anchor" id="integrated_pssm4"></a>', '</p>'), ('<p>', 'Integrated PSSM shadow receiver with 3 splits. Custom split points.', '</p>'), ('<p>', 'Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code>', '</p>'), ('<p>', '<a class="anchor" id="layered_blend"></a>', '</p>'), ('<p>', 'Apply photoshop-like blend effects to texture layers', '</p>'), ('<p>', 'Format: <code>layered_blend &lt;effect&gt;</code>', '</p>'), ('<p>', 'Example: layered_blend luminosity', '</p>'), ('<p>', '<a class="anchor" id="source_modifier"></a>', '</p>'), ('<p>', 'Apply custom modulate effect to texture layer', '</p>'), ('<p>', 'Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code>', '</p>'), ('<p>', 'Example: <code>source_modifier src1_inverse_modulate custom 2</code>', '</p>'), ('<p>', 'When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.', '</p>'), ('<p>', 'The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>\'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).', '</p>'), ('<p>', 'Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.', '</p>'), ('<p>', 'The following steps are executed in order to generate shaders for a given technique:', '</p>'), ('<p>', 'Initializing the system is composed of the following steps:', '</p>'), ('<p>', 'This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.', '</p>'), ('<p>', 'To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.', '</p>'), ('<p>', 'Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.', '</p>'), ('<p>', 'During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.', '</p>'), ('<p>', 'The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.', '</p>'), ('<p>', 'The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.', '</p>'), ('<p>', 'A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.', '</p>'), ('<p>', 'RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.', '</p>'), ('<p>', "Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.", '</p>'), ('<p>', 'There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:', '</p>'), ('<p>', 'There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...', '</p>'), ('<p>', 'As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.', '</p>'), ('<p>', 'These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.', '</p>'), ('<p>', 'Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.', '</p>'), ('<p>', "In order to extend the system with your own shader effects you'll have to follow these steps:", '</p>'), ('<p>', 'Implementing the SubRenderState requires overriding the pure methods of the base class.', '</p>'), ('<p>', 'The SubRenderState supply default implementation for this method which break down this method into three stages:', '</p>'), ('<p>', ' Note:', '</p>'), ('<p>', ' This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.', '</p>'), ('<p>', 'Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods', '</p>'), ('<p>', 'A couple of notes on debugging shaders coming from the RTSS:', '</p>'), ('<p>', 'When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).', '</p>'), ('<p>', 'As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.', '</p>'), ('<p>', 'Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.', '</p>'), ('<p>', 'The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.', '</p>'), ('<p>', 'With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.', '</p>'), ('<p>', 'Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders', '</p>'), ('<p>', 'Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.', '</p>'), ('<p>', 'So why use a runtime shader system anyway?', '</p>'), ('<p>', 'This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.', '</p>'), ('<p>', 'Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.', '</p>'), ('<p>', 'Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.', '</p>'), ('<p>', 'But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.', '</p>'), ('<p>', 'Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.', '</p>'), ('<p>', 'Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.', '</p>'), ('<p>', 'For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.', '</p>'), ('<p>', 'It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.', '</p>'), ('<p>', 'Materials are still useful for:', '</p>'), ('<p>', 'You could be thinking the reason I came up with these two is to fit with D3D11s grand scheme of things while being compatible with OpenGL. But thats a half truth and an awesome side effect. Ive been developing the Hlms using OpenGL this whole time.', '</p>'), ('<p>', 'An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and theyre right about that.', '</p>'), ('<p>', 'However, there are big advantages for using blocks:', '</p>'), ('<p>', 'Of course its not perfect, it cant fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); youll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. Were aiming the general use case.', '</p>'), ('<p>', 'These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since Im not used to driver development. However from an engine perspective, blocks make sense.', '</p>'), ('<p>', 'Were introducing the concept of Datablocks. A Datablock is a material from the users perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.', '</p>'), ('<p>', 'The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.', '</p>'), ('<p>', 'The Hlms will parse the template files from the template folder according to the following rules:', '</p>'), ('<p>', "The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.", '</p>'), ('<p>', 'The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.', '</p>'), ('<p>', 'For example </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can\'t evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can\'t check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable IncludeLightingEquals2 and check whether it\'s non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms\'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can\'t see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you\'ll depend on the driver implementation having a good macro preprocessor.', '</p>'), ('<p>', 'The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:', '</p>'), ('<p>', "Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.", '</p>'), ('<p>', 'The logical operands &amp;&amp; || ! are valid.', '</p>'), ('<p>', 'Examples: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \\<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \\@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: ', '</p>'), ('<p>', 'Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.', '</p>'), ('<p>', 'Newlines are very important, as they will be printed with the loop.', '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', '<b>Attention #1!</b>', '</p>'), ('<p>', "Don't use the common letter i for the loop counter. It will conflict with other keywords.", '</p>'), ('<p>', 'i.e. @foreach( 1, i )@insertpiece( pieceName )@end will print 0nsertpiece( pieceName ) which is probably not what you intended.', '</p>'), ('<p>', '<b>Attention #2!</b>', '</p>'), ('<p>', 'foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.', '</p>'), ('<p>', 'i.e. The following code will not work:', '</p>'), ('<p>', 'Because psub will be evaluated before expanding the foreach. ', '</p>'), ('<p>', "Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.", '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', "Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. ", '</p>'), ('<p>', "Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.", '</p>'), ('<p>', 'Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c', '</p>'), ('<p>', 'Useful in combination with @counter and @value', '</p>'), ('<p>', 'Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won\'t be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Analogous to <a href="#toc304"><em>the family of math functions without the \'p\' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.', '</p>'), ('<p>', 'i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )', '</p>'), ('<p>', "One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.", '</p>'), ('<p>', 'If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.', '</p>'), ('<p>', 'There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:', '</p>'), ('<p>', 'When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.', '</p>'), ('<p>', "If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).", '</p>'), ('<p>', 'The following graph summarizes the process:', '</p>'), ('<p>', 'Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a <a href="#toc567"><em>pass hash</em></a> instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).', '</p>'), ('<p>', "While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:", '</p>'), ('<p>', 'Note: This section is relevant to those seeking to write their own Hlms implementation.', '</p>'), ('<p>', 'C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set key to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod', '</p>'), ('<p>', 'To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.', '</p>'), ('<p>', 'The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.', '</p>'), ('<p>', 'In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.', '</p>'), ('<p>', "Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.", '</p>'), ('<p>', 'For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.', '</p>'), ('<p>', 'The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.', '</p>'), ('<p>', "Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.", '</p>'), ('<p>', "Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.", '</p>'), ('<p>', 'For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.', '</p>'), ('<p>', 'Properties in underscore_case are set from C++; propierties in camelCase are set from the template.', '</p>'), ('<p>', "Propierties and pieces starting with 'custom_' are for user customizations of the template", '</p>'), ('<p>', 'TBD', '</p>'), ('<p>', "By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.", '</p>'), ('<p>', 'Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.', '</p>'), ('<p>', 'In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.', '</p>'), ('<p>', "Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.", '</p>'), ('<p>', 'Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.', '</p>'), ('<p>', 'There are different levels in which an Hlms implementation can be customized:', '</p>'), ('<p>', 'This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.', '</p>'), ('<p>', 'Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.', '</p>'), ('<p>', 'Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.', '</p>'), ('<p>', 'But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.', '</p>'), ('<p>', 'Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.', '</p>'), ('<p>', 'Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.', '</p>'), ('<p>', 'For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.', '</p>'), ('<p>', 'It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.', '</p>'), ('<p>', 'Materials are still useful for:', '</p>'), ('<p>', 'You could be thinking the reason I came up with these two is to fit with D3D11s grand scheme of things while being compatible with OpenGL. But thats a half truth and an awesome side effect. Ive been developing the Hlms using OpenGL this whole time.', '</p>'), ('<p>', 'An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and theyre right about that.', '</p>'), ('<p>', 'However, there are big advantages for using blocks:', '</p>'), ('<p>', 'Of course its not perfect, it cant fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); youll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. Were aiming the general use case.', '</p>'), ('<p>', 'These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since Im not used to driver development. However from an engine perspective, blocks make sense.', '</p>'), ('<p>', 'Were introducing the concept of Datablocks. A Datablock is a material from the users perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.', '</p>'), ('<p>', 'The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.', '</p>'), ('<p>', 'The Hlms will parse the template files from the template folder according to the following rules:', '</p>'), ('<p>', "The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.", '</p>'), ('<p>', 'The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.', '</p>'), ('<p>', 'For example </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can\'t evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can\'t check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable IncludeLightingEquals2 and check whether it\'s non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms\'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can\'t see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you\'ll depend on the driver implementation having a good macro preprocessor.', '</p>'), ('<p>', 'The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:', '</p>'), ('<p>', "Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.", '</p>'), ('<p>', 'The logical operands &amp;&amp; || ! are valid.', '</p>'), ('<p>', 'Examples: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \\<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \\@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: ', '</p>'), ('<p>', 'Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.', '</p>'), ('<p>', 'Newlines are very important, as they will be printed with the loop.', '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', '<b>Attention #1!</b>', '</p>'), ('<p>', "Don't use the common letter i for the loop counter. It will conflict with other keywords.", '</p>'), ('<p>', 'i.e. @foreach( 1, i )@insertpiece( pieceName )@end will print 0nsertpiece( pieceName ) which is probably not what you intended.', '</p>'), ('<p>', '<b>Attention #2!</b>', '</p>'), ('<p>', 'foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.', '</p>'), ('<p>', 'i.e. The following code will not work:', '</p>'), ('<p>', 'Because psub will be evaluated before expanding the foreach. ', '</p>'), ('<p>', "Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.", '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', "Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. ", '</p>'), ('<p>', "Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.", '</p>'), ('<p>', 'Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c', '</p>'), ('<p>', 'Useful in combination with @counter and @value', '</p>'), ('<p>', 'Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won\'t be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Analogous to <a href="#toc304"><em>the family of math functions without the \'p\' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.', '</p>'), ('<p>', 'i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )', '</p>'), ('<p>', "One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.", '</p>'), ('<p>', 'If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.', '</p>'), ('<p>', 'There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:', '</p>'), ('<p>', 'When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.', '</p>'), ('<p>', "If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).", '</p>'), ('<p>', 'The following graph summarizes the process:', '</p>'), ('<p>', 'Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a <a href="#toc567"><em>pass hash</em></a> instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).', '</p>'), ('<p>', "While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:", '</p>'), ('<p>', 'Note: This section is relevant to those seeking to write their own Hlms implementation.', '</p>'), ('<p>', 'C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set key to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod', '</p>'), ('<p>', 'To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.', '</p>'), ('<p>', 'The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.', '</p>'), ('<p>', 'In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.', '</p>'), ('<p>', "Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.", '</p>'), ('<p>', 'For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.', '</p>'), ('<p>', 'The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.', '</p>'), ('<p>', "Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.", '</p>'), ('<p>', "Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.", '</p>'), ('<p>', 'For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.', '</p>'), ('<p>', 'Properties in underscore_case are set from C++; propierties in camelCase are set from the template.', '</p>'), ('<p>', "Propierties and pieces starting with 'custom_' are for user customizations of the template", '</p>'), ('<p>', 'TBD', '</p>'), ('<p>', "By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.", '</p>'), ('<p>', 'Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.', '</p>'), ('<p>', 'In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.', '</p>'), ('<p>', "Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.", '</p>'), ('<p>', 'Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.', '</p>'), ('<p>', 'There are different levels in which an Hlms implementation can be customized:', '</p>'), ('<p>', "Ever wanted really simple GUI controls for your sample? Don't want to write one from scratch, but CEGUI's just a little too much? The Trays system was created to address this issue. It's a simple GUI system based on the OGRE Overlay system and designed just for samples. Because it's simple, you're not going to be able to skin it or build very unique interfaces, but you'll also find it much easier to use. The entire system is based on the OGRE Overlay system.", '</p>'), ('<p>', 'Why trays? The concept of trays is central to the system in that it removes the need for the GUI designer (you) to calculate or specify positional coordinates of any kind. Think about the widget locations in a typical GUI. They are almost always in any of the four corners, along any of the four edges or, on the rare occasion, in the center of the screen. In Trays, there are nine "trays", one in each of the locations previously mentioned. When you create a widget, you specify one of these nine locations, and the widget will be added to the tray at that location. Your widget will be added directly beneath the last widget in that tray. When you add a widget to a tray, the tray grows in size. Trays along the top of the screen grow downward, Trays along the bottom grow upward, and the trays in the middle row grow vertically in both directions. Visually, the trays are semi-transparent panels that fit the widgets they contain. Only non-empty trays are visible. If this is hard to visualise, don\'t worry, here\'s a picture to help you out. ', '</p>'), ('<p>', 'To use Trays, you have to create an TrayManager. This is the class through which you will create and manage all your widgets, manipulate the cursor, change the backdrop image, adjust tray properties, pop up dialogs, show/hide the loading bar, etc. You can have multiple tray managers in one application. For example, the OGRE Sample Browser uses its own tray manager and hides it when a sample is running, and the SDK samples also have their own tray managers, which are hidden when the samples are paused by the browser. The TrayManager requires "Trays.zip", so you can only create it after loading that resource. Also, make sure you\'re using the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> namespace (Trays is part of the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Samples Framework). Create your tray manager like so: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>* mTrayMgr = <span class="keyword">new</span> <a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>(<span class="stringliteral">&quot;InterfaceName&quot;</span>, mWindow, <span class="keyword">this</span>);</div></div><!-- fragment --><p> You must pass in a name for your interface, an <code><a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a></code> and an <code><a class="el" href="class_ogre_bites_1_1_tray_listener.html" title="Listener class for responding to tray events. ">OgreBites::TrayListener</a></code>. You can extend your sample or sample context to be a tray listener. Destroy your tray manager like so: </p><div class="fragment"><div class="line"><span class="keyword">delete</span> mTrayMgr;</div><div class="line">mTrayMgr = 0;</div></div><!-- fragment --><p> Once you have your tray manager, make sure you relay your OIS events to it. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> mousePressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseDown(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseReleased(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseUp(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseMoved(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_motion_event.html">OgreBites::MouseMotionEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseMove(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> The injection methods return true if the event was relevant to the tray manager, and should not be processed again by you. For example, if you click a button that is over an interactive part of your scene, you want the button to be pressed, but you don\'t want the scene interaction to take place. So the injection methods double as filters for your mouse events.', '</p>'), ('<p>', 'You\'re now free to create widgets! Try adding a button to the top-left tray: </p><div class="fragment"><div class="line">Button* b = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">createButton</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530afe04de8736168ab0dd6e7938e679c292">TL_TOPLEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <span class="stringliteral">&quot;Click Me!&quot;</span>);</div></div><!-- fragment --><p> TrayManager is a huge class, and you can do tons of things with it. For some examples, see the Things to Try section below.', '</p>'), ('<p>', 'The cursor has three parts in the Trays system: The layer it moves around in Overlay, the container which positions the cursor (OverlayContainer), and the cursor image, which is a child of the container (OverlayElement). When hiding/showing the cursor, the entire cursor layer is hidden/shown. The top left corner of the cursor container is used as the hotspot of the cursor. By positioning the cursor image relative to the cursor container, you can basically decide which part of the cursor image is the "clicking part". For the default arrow cursor, the image is simply lined up with the container, meaning the top left is the hotspot. However, for something like a crosshair cursor, you could move the cursor image so that its center is over the top left corner of the cursor container. To show the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1cc48ac157278b5845d425abbe9acefd" title="Displays specified material on cursor, or the last material used if none specified. ">OgreBites::TrayManager::showCursor</a></code>, which takes an optional material name for the cursor image. If unspecified, the cursor image is not changed. To hide the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a979ff2ad2d729223259b3bebb237cafb">OgreBites::TrayManager::hideCursor</a></code>. You can get the cursor\'s different parts using getCursorLayer, getCursorContainer, and getCursorImage. Note that if the cursor is hidden, all interactions with widgets are disabled.', '</p>'), ('<p>', 'If you want to show a backdrop, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ad554418c27edb907f0e3bead8659b83c" title="Displays specified material on backdrop, or the last material used if none specified. ">OgreBites::TrayManager::showBackdrop</a></code>, which takes an optional material name for the backdrop. If unspecified, the backdrop image is not changed. To hide it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a6129a1e92ac22789a4602cf36f9c5394">OgreBites::TrayManager::hideBackdrop</a></code>.', '</p>'), ('<p>', 'There are 10 basic widgets. Each widget is just an instance of an OverlayElement template, and all widgets use {LEX()}pixel{LEX} metrics. You can get access to any widget\'s underlying OverlayElement through <code><a class="el" href="class_ogre_bites_1_1_widget.html#a379d3f1a2ca6eaf13fc5c52afaafd0d2">OgreBites::Widget::getOverlayElement</a></code>. Do not instantiate and delete widgets manually. Create and destroy them using the TrayManager. The first argument to any one of TrayManager\'s widget creation methods is the location of the tray you want the widget to be in. This is of the enumerated type TrayLocation. The second argument is the name of your widget (this is not your widget\'s caption, but a unique string identifier for your widget). The rest of the arguments are specific to the type of widget.', '</p>'), ('<p>', 'This is the most basic widget of all. To create a button, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">OgreBites::TrayManager::createButton</a></code>. In addition to a tray location and a name, you must specify a caption for your button, and an optional width. If width is not specified, the button will automatically resize to fit its caption. There are no button states. You only get notified when a button is pushed. To see how to respond to button push events, see the TrayListener section below.', '</p>'), ('<p>', 'This widget consists of a bold caption bar and a text area that can be scrolled vertically. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a07a8d212939266339e877ff2118250a6">OgreBites::TrayManager::createTextBox</a></code> takes a caption, width, and height. You can set/get the caption, the text area contents, text padding, text alignment, manually change the scroll bar position, among other things.', '</p>'), ('<p>', 'A basic drop-down menu. To create it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a60864ca00d65b2bf1b97bb8545fab737">OgreBites::TrayManager::createLongSelectMenu</a></code> or <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a98f478c8daa5084b53146de03adbc216">OgreBites::TrayManager::createThickSelectMenu</a></code>. Both these methods return a SelectMenu object, but they give one of two different visual styles to the widget. One is thicker, but shorter, because it places the caption over the item box. This style of menu is good for putting in the side trays. The other is longer, but thinner, because it places the item box next to the caption. This style of menu is good for putting in the top or bottom trays. createThickSelectMenu takes a tray location, a name, a caption, the width of the whole widget, the maximum number of visible items when expanded, and an optional string vector of items. The medthod <code>createLongSelectMenu</code> takes nearly the same arguments, except that it needs the width of the text box that shows the currently selected item. Also, for long menus, it is optional to specify the total width because it will automatically resize to fit the item box and the caption. You can set/get the caption, and set/get the items in many different ways. You can also manually change the selection, with the option of not firing an event. To see how to respond to menu item selection events, see the TrayListener section below.', '</p>'), ('<p>', 'A big, semi-transparent, tabby-looking label. This widget uses a different font from the rest of the widgets, and is good for section headings and such. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a15375d59b5c57059c9c6549fc5a1bfcd">OgreBites::TrayManager::createLabel</a></code> takes a caption, and an optional width. If the width is not specified, the label automatically adjusts its width to fill the tray it\'s currently in, so it matches the other contents of the tray. Labels can also be clicked. To see how to respond to label click events, see the TrayListener section below.', '</p>'), ('<p>', "A horizontal line which looks like it was etched into the tray. Good for dividing up other widgets into sections without taking up as much space as a label. <code>TrayManager::createSeparator</code> takes a tray location, name, and an optional width. If the width is not specified, the behaviour is the same as a Label's.", '</p>'), ('<p>', 'A slider bar consists of a container box, a small text box to display the value, and a track + handle. Sliders are type-agnostic. Using three parameters - a minimum value, a maximum value, and the number of "snapping points", you can give your slider track of any kind of discrete scale - integer, floating point, or even nominal. Snapping points are basically the "steps" on your slider track. By specifying how many of them there are, you are in effect specifying an entire range of values all the way from your minimum value to your maximum value. Let\'s say you have minimum value 0, maximum value 1, and 6 snapping points. Underneath the surface, each slider stores a floating point value, so in this case you would be able to display 6 floating point values: {0, 0.2, 0.4, 0.6, 0.8, 1}. The slider will display your value in the cleanest way possible (using <code><a class="el" href="class_ogre_1_1_string_converter.html#a45fb498a2f798c82bbf88116a5a34c53" title="Converts a float to a String. ">Ogre::StringConverter::toString</a></code>). This means that if all your values happen to land on integers, then they will be displayed as integers without decimals. You can also exploit this by using your slider\'s integer values as indices into an array of string values, and manually set your slider\'s value to the new string value. Basically, you can make your slider display things like Low, Medium, High, 1/4, 3/4, $4.00, N/A, etc. This requires you to respond to slider move events. More on this in the TrayListener section below. Then your Like select menus, sliders also come in two flavours - thick and long. The thick style places the caption and the value box above the track, while the long style places the caption, track, and value box side by side in that order. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a597ec173c1b424980e18fd92e0c56905">OgreBites::TrayManager::createThickSlider</a></code> takes a tray location, name, caption, total width, value box width, minimum value, maximum value, and the number of snapping points. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a321429ade975d3a63dfc1125b4375e78">OgreBites::TrayManager::createLongSlider</a></code> takes a an optional total width, track width, value box width, minimum value, maximum value, and the number of snapping points. If the total width is not specified, the slider will automatically scale to fit the track, the value box, and the caption text. You can get/set the slider\'s caption, displayed value, actual value, and range of values. When you change the range, the value is reset to be the minimum value. When you change the value, you also have the option of not firing an event. To respond to slider move events, see the TrayListener section below.', '</p>'), ('<p>', 'This panel displays an arbitrary number of parameters and their values. This could be anything you want. For example, the stats panel in the SDK samples shows the average framerate, best framerate, batch count, etc. The details panel in the SDK samples shows the texture filtering technique, the polygon mode, and the camera position and orientation. To create a ParamsPanel, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a5ae6b66603e05193b3077f30900209eb">OgreBites::TrayManager::createParamsPanel</a></code>, which takes a tray location, a name, a width, and then either a string vector of parameter names or the number of parameters (lines) to leave room for. The parameter names will be left justified, and their values will be right justified on the same line. At any time, you can set/get the parameter names and values either one at a time, or all at once using a string vector.', '</p>'), ('<p>', 'Self-explanatory. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7433f3e89c5b3a1b1b0012dfcb121f1d">OgreBites::TrayManager::createCheckBox</a></code> takes a tray location, name, caption, and an optional width. Unspecified width means auto-fit to caption. You can set/get the state of the check box, with the option of not triggering an event. To respond to check box state change events, see the TrayListener section below. ', '</p>'), ('<p>', 'This widget takes any OverlayElement template, and creates a widget out of it. If you want to put your own picture, icons, or other static objects into the trays, make an OverlayElement template out of it, and then turn it into a DecorWidget. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a24d1b3a3b95ddcf274bf899b7600deba">OgreBites::TrayManager::createDecorWidget</a></code> takes a tray location, a name, and an OverlayElement template name. These are basically the same things you would normally use to create an OverlayElement from a template. The OGRE logo in the SDK samples is a DecorWidget. ', '</p>'), ('<p>', 'A progress bar with a caption, a comment/details box, and a meter that fills up. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a431a347db6465bbf66af82ef363c875f">OgreBites::TrayManager::createProgressBar</a></code> takes a tray location, a name, a caption, a total width, and comment box width. You can use progress bars to show any kind of progress you want, but for the most common kind (loading resources), there\'s a special instance of ProgressBar already created by TrayManager which you can use. See Loading Bar below.', '</p>'), ('<p>', 'In addition to the nine trays you can place your widgets in, there is also a "null tray". This is an imaginary tray, whose location is specified by <code>TL_NONE</code>. This tray is virtual, invisible, and does not arrange widgets within it. Basically, if you place a widget in this tray, it becomes "free-floating", and you\'re allowed to manually position it anywhere on the screen. Widgets must always reside in a tray for as long as they exist, so when a widget is removed from a tray, it is automatically placed in the null tray.', '</p>'), ('<p>', 'Some widgets are so common they deserve special treatment.', '</p>'), ('<p>', 'This is not exactly one widget, but a combination of Label that displays the current FPS, and a ParamsPanel that displays advanced frame statistics (such as average FPS and batch count). Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a49e2f792fee94e75b1b472826bcc8019" title="Shows frame statistics widget set in the specified location. ">OgreBites::TrayManager::showFrameStats</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1c2e9618a3e6b061a9cfeac4f2cb55e9" title="Hides frame statistics widget set. ">OgreBites::TrayManager::hideFrameStats</a></code> to show/hide this special widget. You can choose where to put it. When the user clicks the FPS label, it toggles the visibility of the advanced frame stats, so they can be out of the way when they\'re unwanted. You can also manually toggle the visibility of the advanced frame stats using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aed00f8a1009f2ebf6806774cb894d0d7" title="Toggles visibility of advanced statistics. ">OgreBites::TrayManager::toggleAdvancedFrameStats</a></code>.', '</p>'), ('<p>', 'This is just a decor widget of the OGRE logo. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#affee57f47066e25437649d64daaa7dd9" title="Shows logo in the specified location. ">OgreBites::TrayManager::showLogo</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ac1ee637b7ef5e887170c8a9aca1c4c7b">OgreBites::TrayManager::hideLogo</a></code> to show/hide the logo. You can choose where to put it.', '</p>'), ('<p>', 'This is a progress bar that shows you the progress of your current resource loading job. The comment box will show the current resource being loaded. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a0d51005a4b148a4df2c1c6b55e34f085" title="Shows loading bar. ">OgreBites::TrayManager::showLoadingBar</a></code> before you begin your loading job. Specify the number of resource groups you will initialise, the number of groups you will load, and, if you want to, the proportion of time you think will go to initialisation (default estimate is 70%). You cannot decide where to place this loading bar. The screen will be darkened, and the loading bar will appear in the center. Any other dialog or loading bar will be closed. When you finish your loading job, call <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aab014a2c48c8f91556182e42684d44ad">OgreBites::TrayManager::hideLoadingBar</a></code>.', '</p>'), ('<p>', 'This is a dialog which tells the user something and displays an OK button. It\'s a combination of a TextBox and a Button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#abf3bd8e4ef9a6d0d76f27535a6010623" title="Pops up a message dialog with an OK button. ">OgreBites::TrayManager::showOkDialog</a></code> to display an information dialog. Specify the caption of the TextBox, and the message you want to display in it. Any other dialog or loading bar will be closed. The screen will be darkened, and the dialog will appear in the center. All other widget interactions are disabled until the dialog is closed. You can manually close a dialog using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#af5d95dcaa7c74d3345308e4f4e3035e8" title="Hides whatever dialog is currently showing. ">OgreBites::TrayManager::closeDialog</a></code>. To respond to information dialog closing events, see the TrayListenersection below.', '</p>'), ('<p>', 'Same as the Information Dialog except it asks the user something and displays a Yes button and a No button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a85d47aa11d761742884dc6457ec11cdf" title="Pops up a question dialog with Yes and No buttons. ">OgreBites::TrayManager::showYesNoDialog</a></code> to display a question dialog. Specify the caption of the TextBox, and the question you want to display in it. To respond to question dialog closing events, see the TrayListener section below.', '</p>'), ('<p>', "This class contains handlers for all the different events that your widgets can fire. The TrayManager class itself is an TrayListener, because it responds to events from its special widgets. You should extend your sample class from TrayListener as well as Sample if you want to handle widget events. If you're using SdkSample, you're all set because it's already an TrayListener. Some widgets give you an option of not firing an event when you change their state. This is helpful for initialising or resetting a widget, in which case there shouldn't be a response of any sort. For example, if you're initialising your slider bar before the scene is set up, and your slider bar is used to control some part of your scene, firing an event would cause an error. Below is a list of the different handlers. All handlers have return type void.", '</p>'), ('<p>', 'Getting access to widgets: </p><div class="fragment"><div class="line">Button* b;</div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);  <span class="comment">// by tray and position</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by tray and name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#af968c01a627ee654409f558e4ef55537">getWidgetIterator</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>).<a class="code" href="class_ogre_1_1_vector_iterator_wrapper.html#a2460c8adb6819235849de954db6a0f64">getNext</a>();  <span class="comment">// by iterator</span></div></div><!-- fragment --><p> Counting widgets: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>();  <span class="comment">// total</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);  <span class="comment">// by tray</span></div></div><!-- fragment --><p> Moving widgets to other trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div></div><!-- fragment --><p> Removing widgets from trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a04a1085bdee61d7234849663cce08664">TL_NONE</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a77ba6e4d641c146e262b6cdd2c8b04a0">clearTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9787ec5e8989bf6cfa89d03c6ddd27b6">clearAllTrays</a>();</div></div><!-- fragment --><p> Destroying widgets: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4a89cd6f7d87e0e538aa842f1a42a7bc">destroyAllWidgetsInTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aadb1f5a3b7e3b5397b10bdd3449e1603">destroyAllWidgets</a>();</div></div><!-- fragment --><p> Finding the position of a widget in a tray: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa993d2b60cfbcb903aecbff1c4896b67">locateWidgetInTray</a>(b);</div></div><!-- fragment --><p> Finding the tray a widget is in: </p><div class="fragment"><div class="line"><a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530">TrayLocation</a> trayLoc = b-&gt;getTrayLocation();</div></div><!-- fragment --><p> Changing the tray listener object: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a3235fea714a0c61e463dee69ae308be8">setListener</a>(newListener);</div></div><!-- fragment --><p> Toggling system visibility: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a075805136b2241cbb03eeb2c3d27b40d">showAll</a>();</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a188f1d5f5ca16af3b28d11ecd553105a">hideAll</a>();</div></div><!-- fragment --><p> Changing horizontal widget alignment in one tray: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#adfbbc97615fd5f1a939be6e7a1f00c07">setTrayWidgetAlignment</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <a class="code" href="group___overlays.html#gga3396780cdb2d731aa5e4389148bdc5f3a270f18cf07dbe4e75e1b790d02924205">GHA_RIGHT</a>);</div></div><!-- fragment --><p> Changing spacing and padding: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a33a3e3f66a3989dd3de48b4c4577422f">setWidgetSpacing</a>(5);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a52d3fc8638533540232232c37b257de6">setWidgetPadding</a>(3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a866229b6d88dc9d3a609115eaab46e67">setTrayPadding</a>(12);</div></div><!-- fragment --><p> Casting 3D ray from under cursor into the scene: </p><div class="fragment"><div class="line">Ray r = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9dd5d303968329462e9bf4225f59722e">getCursorRay</a>(mCamera);</div></div><!-- fragment --><p> Casting 3D ray from any 2D screen coordinate into the scene: </p><div class="fragment"><div class="line">Ray r = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#a6833f46b0303b559a050f310fa0204fc">OgreBites::TrayManager::screenToScene</a>(mCamera, Vector2(320, 240));</div></div><!-- fragment --><p> Converting a 3D scene coordinate to a 2D screen coordinate: ', '</p>'), ('<p>', 'This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.', '</p>'), ('<p>', 'Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.', '</p>'), ('<p>', 'Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.', '</p>'), ('<p>', 'But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.', '</p>'), ('<p>', 'Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.', '</p>'), ('<p>', 'Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.', '</p>'), ('<p>', 'For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.', '</p>'), ('<p>', 'It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.', '</p>'), ('<p>', 'Materials are still useful for:', '</p>'), ('<p>', 'You could be thinking the reason I came up with these two is to fit with D3D11s grand scheme of things while being compatible with OpenGL. But thats a half truth and an awesome side effect. Ive been developing the Hlms using OpenGL this whole time.', '</p>'), ('<p>', 'An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and theyre right about that.', '</p>'), ('<p>', 'However, there are big advantages for using blocks:', '</p>'), ('<p>', 'Of course its not perfect, it cant fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); youll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. Were aiming the general use case.', '</p>'), ('<p>', 'These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since Im not used to driver development. However from an engine perspective, blocks make sense.', '</p>'), ('<p>', 'Were introducing the concept of Datablocks. A Datablock is a material from the users perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.', '</p>'), ('<p>', 'The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.', '</p>'), ('<p>', 'The Hlms will parse the template files from the template folder according to the following rules:', '</p>'), ('<p>', "The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.", '</p>'), ('<p>', 'The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.', '</p>'), ('<p>', 'For example </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can\'t evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can\'t check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable IncludeLightingEquals2 and check whether it\'s non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms\'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can\'t see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you\'ll depend on the driver implementation having a good macro preprocessor.', '</p>'), ('<p>', 'The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:', '</p>'), ('<p>', "Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.", '</p>'), ('<p>', 'The logical operands &amp;&amp; || ! are valid.', '</p>'), ('<p>', 'Examples: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \\<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \\@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: ', '</p>'), ('<p>', 'Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.', '</p>'), ('<p>', 'Newlines are very important, as they will be printed with the loop.', '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', '<b>Attention #1!</b>', '</p>'), ('<p>', "Don't use the common letter i for the loop counter. It will conflict with other keywords.", '</p>'), ('<p>', 'i.e. @foreach( 1, i )@insertpiece( pieceName )@end will print 0nsertpiece( pieceName ) which is probably not what you intended.', '</p>'), ('<p>', '<b>Attention #2!</b>', '</p>'), ('<p>', 'foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.', '</p>'), ('<p>', 'i.e. The following code will not work:', '</p>'), ('<p>', 'Because psub will be evaluated before expanding the foreach. ', '</p>'), ('<p>', "Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.", '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', "Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. ", '</p>'), ('<p>', "Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.", '</p>'), ('<p>', 'Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c', '</p>'), ('<p>', 'Useful in combination with @counter and @value', '</p>'), ('<p>', 'Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won\'t be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Analogous to <a href="#toc304"><em>the family of math functions without the \'p\' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.', '</p>'), ('<p>', 'i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )', '</p>'), ('<p>', "One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.", '</p>'), ('<p>', 'If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.', '</p>'), ('<p>', 'There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:', '</p>'), ('<p>', 'When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.', '</p>'), ('<p>', "If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).", '</p>'), ('<p>', 'The following graph summarizes the process:', '</p>'), ('<p>', 'Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a <a href="#toc567"><em>pass hash</em></a> instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).', '</p>'), ('<p>', "While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:", '</p>'), ('<p>', 'Note: This section is relevant to those seeking to write their own Hlms implementation.', '</p>'), ('<p>', 'C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set key to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod', '</p>'), ('<p>', 'To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.', '</p>'), ('<p>', 'The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.', '</p>'), ('<p>', 'In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.', '</p>'), ('<p>', "Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.", '</p>'), ('<p>', 'For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.', '</p>'), ('<p>', 'The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.', '</p>'), ('<p>', "Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.", '</p>'), ('<p>', "Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.", '</p>'), ('<p>', 'For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.', '</p>'), ('<p>', 'Properties in underscore_case are set from C++; propierties in camelCase are set from the template.', '</p>'), ('<p>', "Propierties and pieces starting with 'custom_' are for user customizations of the template", '</p>'), ('<p>', 'TBD', '</p>'), ('<p>', "By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.", '</p>'), ('<p>', 'Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.', '</p>'), ('<p>', 'In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.', '</p>'), ('<p>', "Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.", '</p>'), ('<p>', 'Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.', '</p>'), ('<p>', 'There are different levels in which an Hlms implementation can be customized:', '</p>'), ('<p>', 'This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.', '</p>'), ('<p>', 'Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.', '</p>'), ('<p>', 'Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.', '</p>'), ('<p>', 'But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.', '</p>'), ('<p>', 'Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.', '</p>'), ('<p>', 'Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.', '</p>'), ('<p>', 'For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.', '</p>'), ('<p>', 'It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.', '</p>'), ('<p>', 'Materials are still useful for:', '</p>'), ('<p>', 'You could be thinking the reason I came up with these two is to fit with D3D11s grand scheme of things while being compatible with OpenGL. But thats a half truth and an awesome side effect. Ive been developing the Hlms using OpenGL this whole time.', '</p>'), ('<p>', 'An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and theyre right about that.', '</p>'), ('<p>', 'However, there are big advantages for using blocks:', '</p>'), ('<p>', 'Of course its not perfect, it cant fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); youll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. Were aiming the general use case.', '</p>'), ('<p>', 'These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since Im not used to driver development. However from an engine perspective, blocks make sense.', '</p>'), ('<p>', 'Were introducing the concept of Datablocks. A Datablock is a material from the users perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.', '</p>'), ('<p>', 'The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.', '</p>'), ('<p>', 'The Hlms will parse the template files from the template folder according to the following rules:', '</p>'), ('<p>', "The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.", '</p>'), ('<p>', 'The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.', '</p>'), ('<p>', 'For example </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can\'t evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can\'t check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable IncludeLightingEquals2 and check whether it\'s non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms\'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can\'t see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you\'ll depend on the driver implementation having a good macro preprocessor.', '</p>'), ('<p>', 'The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:', '</p>'), ('<p>', "Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.", '</p>'), ('<p>', 'The logical operands &amp;&amp; || ! are valid.', '</p>'), ('<p>', 'Examples: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \\<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \\@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: ', '</p>'), ('<p>', 'Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.', '</p>'), ('<p>', 'Newlines are very important, as they will be printed with the loop.', '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', '<b>Attention #1!</b>', '</p>'), ('<p>', "Don't use the common letter i for the loop counter. It will conflict with other keywords.", '</p>'), ('<p>', 'i.e. @foreach( 1, i )@insertpiece( pieceName )@end will print 0nsertpiece( pieceName ) which is probably not what you intended.', '</p>'), ('<p>', '<b>Attention #2!</b>', '</p>'), ('<p>', 'foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.', '</p>'), ('<p>', 'i.e. The following code will not work:', '</p>'), ('<p>', 'Because psub will be evaluated before expanding the foreach. ', '</p>'), ('<p>', "Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.", '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', "Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. ", '</p>'), ('<p>', "Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.", '</p>'), ('<p>', 'Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c', '</p>'), ('<p>', 'Useful in combination with @counter and @value', '</p>'), ('<p>', 'Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won\'t be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Analogous to <a href="#toc304"><em>the family of math functions without the \'p\' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.', '</p>'), ('<p>', 'i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )', '</p>'), ('<p>', "One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.", '</p>'), ('<p>', 'If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.', '</p>'), ('<p>', 'There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:', '</p>'), ('<p>', 'When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.', '</p>'), ('<p>', "If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).", '</p>'), ('<p>', 'The following graph summarizes the process:', '</p>'), ('<p>', 'Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a <a href="#toc567"><em>pass hash</em></a> instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).', '</p>'), ('<p>', "While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:", '</p>'), ('<p>', 'Note: This section is relevant to those seeking to write their own Hlms implementation.', '</p>'), ('<p>', 'C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set key to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod', '</p>'), ('<p>', 'To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.', '</p>'), ('<p>', 'The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.', '</p>'), ('<p>', 'In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.', '</p>'), ('<p>', "Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.", '</p>'), ('<p>', 'For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.', '</p>'), ('<p>', 'The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.', '</p>'), ('<p>', "Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.", '</p>'), ('<p>', "Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.", '</p>'), ('<p>', 'For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.', '</p>'), ('<p>', 'Properties in underscore_case are set from C++; propierties in camelCase are set from the template.', '</p>'), ('<p>', "Propierties and pieces starting with 'custom_' are for user customizations of the template", '</p>'), ('<p>', 'TBD', '</p>'), ('<p>', "By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.", '</p>'), ('<p>', 'Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.', '</p>'), ('<p>', 'In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.', '</p>'), ('<p>', "Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.", '</p>'), ('<p>', 'Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.', '</p>'), ('<p>', 'There are different levels in which an Hlms implementation can be customized:', '</p>'), ('<p>', "Ever wanted really simple GUI controls for your sample? Don't want to write one from scratch, but CEGUI's just a little too much? The Trays system was created to address this issue. It's a simple GUI system based on the OGRE Overlay system and designed just for samples. Because it's simple, you're not going to be able to skin it or build very unique interfaces, but you'll also find it much easier to use. The entire system is based on the OGRE Overlay system.", '</p>'), ('<p>', 'Why trays? The concept of trays is central to the system in that it removes the need for the GUI designer (you) to calculate or specify positional coordinates of any kind. Think about the widget locations in a typical GUI. They are almost always in any of the four corners, along any of the four edges or, on the rare occasion, in the center of the screen. In Trays, there are nine "trays", one in each of the locations previously mentioned. When you create a widget, you specify one of these nine locations, and the widget will be added to the tray at that location. Your widget will be added directly beneath the last widget in that tray. When you add a widget to a tray, the tray grows in size. Trays along the top of the screen grow downward, Trays along the bottom grow upward, and the trays in the middle row grow vertically in both directions. Visually, the trays are semi-transparent panels that fit the widgets they contain. Only non-empty trays are visible. If this is hard to visualise, don\'t worry, here\'s a picture to help you out. ', '</p>'), ('<p>', 'To use Trays, you have to create an TrayManager. This is the class through which you will create and manage all your widgets, manipulate the cursor, change the backdrop image, adjust tray properties, pop up dialogs, show/hide the loading bar, etc. You can have multiple tray managers in one application. For example, the OGRE Sample Browser uses its own tray manager and hides it when a sample is running, and the SDK samples also have their own tray managers, which are hidden when the samples are paused by the browser. The TrayManager requires "Trays.zip", so you can only create it after loading that resource. Also, make sure you\'re using the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> namespace (Trays is part of the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Samples Framework). Create your tray manager like so: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>* mTrayMgr = <span class="keyword">new</span> <a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>(<span class="stringliteral">&quot;InterfaceName&quot;</span>, mWindow, <span class="keyword">this</span>);</div></div><!-- fragment --><p> You must pass in a name for your interface, an <code><a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a></code> and an <code><a class="el" href="class_ogre_bites_1_1_tray_listener.html" title="Listener class for responding to tray events. ">OgreBites::TrayListener</a></code>. You can extend your sample or sample context to be a tray listener. Destroy your tray manager like so: </p><div class="fragment"><div class="line"><span class="keyword">delete</span> mTrayMgr;</div><div class="line">mTrayMgr = 0;</div></div><!-- fragment --><p> Once you have your tray manager, make sure you relay your OIS events to it. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> mousePressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseDown(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseReleased(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseUp(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseMoved(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_motion_event.html">OgreBites::MouseMotionEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseMove(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> The injection methods return true if the event was relevant to the tray manager, and should not be processed again by you. For example, if you click a button that is over an interactive part of your scene, you want the button to be pressed, but you don\'t want the scene interaction to take place. So the injection methods double as filters for your mouse events.', '</p>'), ('<p>', 'You\'re now free to create widgets! Try adding a button to the top-left tray: </p><div class="fragment"><div class="line">Button* b = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">createButton</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530afe04de8736168ab0dd6e7938e679c292">TL_TOPLEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <span class="stringliteral">&quot;Click Me!&quot;</span>);</div></div><!-- fragment --><p> TrayManager is a huge class, and you can do tons of things with it. For some examples, see the Things to Try section below.', '</p>'), ('<p>', 'The cursor has three parts in the Trays system: The layer it moves around in Overlay, the container which positions the cursor (OverlayContainer), and the cursor image, which is a child of the container (OverlayElement). When hiding/showing the cursor, the entire cursor layer is hidden/shown. The top left corner of the cursor container is used as the hotspot of the cursor. By positioning the cursor image relative to the cursor container, you can basically decide which part of the cursor image is the "clicking part". For the default arrow cursor, the image is simply lined up with the container, meaning the top left is the hotspot. However, for something like a crosshair cursor, you could move the cursor image so that its center is over the top left corner of the cursor container. To show the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1cc48ac157278b5845d425abbe9acefd" title="Displays specified material on cursor, or the last material used if none specified. ">OgreBites::TrayManager::showCursor</a></code>, which takes an optional material name for the cursor image. If unspecified, the cursor image is not changed. To hide the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a979ff2ad2d729223259b3bebb237cafb">OgreBites::TrayManager::hideCursor</a></code>. You can get the cursor\'s different parts using getCursorLayer, getCursorContainer, and getCursorImage. Note that if the cursor is hidden, all interactions with widgets are disabled.', '</p>'), ('<p>', 'If you want to show a backdrop, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ad554418c27edb907f0e3bead8659b83c" title="Displays specified material on backdrop, or the last material used if none specified. ">OgreBites::TrayManager::showBackdrop</a></code>, which takes an optional material name for the backdrop. If unspecified, the backdrop image is not changed. To hide it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a6129a1e92ac22789a4602cf36f9c5394">OgreBites::TrayManager::hideBackdrop</a></code>.', '</p>'), ('<p>', 'There are 10 basic widgets. Each widget is just an instance of an OverlayElement template, and all widgets use {LEX()}pixel{LEX} metrics. You can get access to any widget\'s underlying OverlayElement through <code><a class="el" href="class_ogre_bites_1_1_widget.html#a379d3f1a2ca6eaf13fc5c52afaafd0d2">OgreBites::Widget::getOverlayElement</a></code>. Do not instantiate and delete widgets manually. Create and destroy them using the TrayManager. The first argument to any one of TrayManager\'s widget creation methods is the location of the tray you want the widget to be in. This is of the enumerated type TrayLocation. The second argument is the name of your widget (this is not your widget\'s caption, but a unique string identifier for your widget). The rest of the arguments are specific to the type of widget.', '</p>'), ('<p>', 'This is the most basic widget of all. To create a button, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">OgreBites::TrayManager::createButton</a></code>. In addition to a tray location and a name, you must specify a caption for your button, and an optional width. If width is not specified, the button will automatically resize to fit its caption. There are no button states. You only get notified when a button is pushed. To see how to respond to button push events, see the TrayListener section below.', '</p>'), ('<p>', 'This widget consists of a bold caption bar and a text area that can be scrolled vertically. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a07a8d212939266339e877ff2118250a6">OgreBites::TrayManager::createTextBox</a></code> takes a caption, width, and height. You can set/get the caption, the text area contents, text padding, text alignment, manually change the scroll bar position, among other things.', '</p>'), ('<p>', 'A basic drop-down menu. To create it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a60864ca00d65b2bf1b97bb8545fab737">OgreBites::TrayManager::createLongSelectMenu</a></code> or <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a98f478c8daa5084b53146de03adbc216">OgreBites::TrayManager::createThickSelectMenu</a></code>. Both these methods return a SelectMenu object, but they give one of two different visual styles to the widget. One is thicker, but shorter, because it places the caption over the item box. This style of menu is good for putting in the side trays. The other is longer, but thinner, because it places the item box next to the caption. This style of menu is good for putting in the top or bottom trays. createThickSelectMenu takes a tray location, a name, a caption, the width of the whole widget, the maximum number of visible items when expanded, and an optional string vector of items. The medthod <code>createLongSelectMenu</code> takes nearly the same arguments, except that it needs the width of the text box that shows the currently selected item. Also, for long menus, it is optional to specify the total width because it will automatically resize to fit the item box and the caption. You can set/get the caption, and set/get the items in many different ways. You can also manually change the selection, with the option of not firing an event. To see how to respond to menu item selection events, see the TrayListener section below.', '</p>'), ('<p>', 'A big, semi-transparent, tabby-looking label. This widget uses a different font from the rest of the widgets, and is good for section headings and such. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a15375d59b5c57059c9c6549fc5a1bfcd">OgreBites::TrayManager::createLabel</a></code> takes a caption, and an optional width. If the width is not specified, the label automatically adjusts its width to fill the tray it\'s currently in, so it matches the other contents of the tray. Labels can also be clicked. To see how to respond to label click events, see the TrayListener section below.', '</p>'), ('<p>', "A horizontal line which looks like it was etched into the tray. Good for dividing up other widgets into sections without taking up as much space as a label. <code>TrayManager::createSeparator</code> takes a tray location, name, and an optional width. If the width is not specified, the behaviour is the same as a Label's.", '</p>'), ('<p>', 'A slider bar consists of a container box, a small text box to display the value, and a track + handle. Sliders are type-agnostic. Using three parameters - a minimum value, a maximum value, and the number of "snapping points", you can give your slider track of any kind of discrete scale - integer, floating point, or even nominal. Snapping points are basically the "steps" on your slider track. By specifying how many of them there are, you are in effect specifying an entire range of values all the way from your minimum value to your maximum value. Let\'s say you have minimum value 0, maximum value 1, and 6 snapping points. Underneath the surface, each slider stores a floating point value, so in this case you would be able to display 6 floating point values: {0, 0.2, 0.4, 0.6, 0.8, 1}. The slider will display your value in the cleanest way possible (using <code><a class="el" href="class_ogre_1_1_string_converter.html#a45fb498a2f798c82bbf88116a5a34c53" title="Converts a float to a String. ">Ogre::StringConverter::toString</a></code>). This means that if all your values happen to land on integers, then they will be displayed as integers without decimals. You can also exploit this by using your slider\'s integer values as indices into an array of string values, and manually set your slider\'s value to the new string value. Basically, you can make your slider display things like Low, Medium, High, 1/4, 3/4, $4.00, N/A, etc. This requires you to respond to slider move events. More on this in the TrayListener section below. Then your Like select menus, sliders also come in two flavours - thick and long. The thick style places the caption and the value box above the track, while the long style places the caption, track, and value box side by side in that order. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a597ec173c1b424980e18fd92e0c56905">OgreBites::TrayManager::createThickSlider</a></code> takes a tray location, name, caption, total width, value box width, minimum value, maximum value, and the number of snapping points. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a321429ade975d3a63dfc1125b4375e78">OgreBites::TrayManager::createLongSlider</a></code> takes a an optional total width, track width, value box width, minimum value, maximum value, and the number of snapping points. If the total width is not specified, the slider will automatically scale to fit the track, the value box, and the caption text. You can get/set the slider\'s caption, displayed value, actual value, and range of values. When you change the range, the value is reset to be the minimum value. When you change the value, you also have the option of not firing an event. To respond to slider move events, see the TrayListener section below.', '</p>'), ('<p>', 'This panel displays an arbitrary number of parameters and their values. This could be anything you want. For example, the stats panel in the SDK samples shows the average framerate, best framerate, batch count, etc. The details panel in the SDK samples shows the texture filtering technique, the polygon mode, and the camera position and orientation. To create a ParamsPanel, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a5ae6b66603e05193b3077f30900209eb">OgreBites::TrayManager::createParamsPanel</a></code>, which takes a tray location, a name, a width, and then either a string vector of parameter names or the number of parameters (lines) to leave room for. The parameter names will be left justified, and their values will be right justified on the same line. At any time, you can set/get the parameter names and values either one at a time, or all at once using a string vector.', '</p>'), ('<p>', 'Self-explanatory. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7433f3e89c5b3a1b1b0012dfcb121f1d">OgreBites::TrayManager::createCheckBox</a></code> takes a tray location, name, caption, and an optional width. Unspecified width means auto-fit to caption. You can set/get the state of the check box, with the option of not triggering an event. To respond to check box state change events, see the TrayListener section below. ', '</p>'), ('<p>', 'This widget takes any OverlayElement template, and creates a widget out of it. If you want to put your own picture, icons, or other static objects into the trays, make an OverlayElement template out of it, and then turn it into a DecorWidget. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a24d1b3a3b95ddcf274bf899b7600deba">OgreBites::TrayManager::createDecorWidget</a></code> takes a tray location, a name, and an OverlayElement template name. These are basically the same things you would normally use to create an OverlayElement from a template. The OGRE logo in the SDK samples is a DecorWidget. ', '</p>'), ('<p>', 'A progress bar with a caption, a comment/details box, and a meter that fills up. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a431a347db6465bbf66af82ef363c875f">OgreBites::TrayManager::createProgressBar</a></code> takes a tray location, a name, a caption, a total width, and comment box width. You can use progress bars to show any kind of progress you want, but for the most common kind (loading resources), there\'s a special instance of ProgressBar already created by TrayManager which you can use. See Loading Bar below.', '</p>'), ('<p>', 'In addition to the nine trays you can place your widgets in, there is also a "null tray". This is an imaginary tray, whose location is specified by <code>TL_NONE</code>. This tray is virtual, invisible, and does not arrange widgets within it. Basically, if you place a widget in this tray, it becomes "free-floating", and you\'re allowed to manually position it anywhere on the screen. Widgets must always reside in a tray for as long as they exist, so when a widget is removed from a tray, it is automatically placed in the null tray.', '</p>'), ('<p>', 'Some widgets are so common they deserve special treatment.', '</p>'), ('<p>', 'This is not exactly one widget, but a combination of Label that displays the current FPS, and a ParamsPanel that displays advanced frame statistics (such as average FPS and batch count). Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a49e2f792fee94e75b1b472826bcc8019" title="Shows frame statistics widget set in the specified location. ">OgreBites::TrayManager::showFrameStats</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1c2e9618a3e6b061a9cfeac4f2cb55e9" title="Hides frame statistics widget set. ">OgreBites::TrayManager::hideFrameStats</a></code> to show/hide this special widget. You can choose where to put it. When the user clicks the FPS label, it toggles the visibility of the advanced frame stats, so they can be out of the way when they\'re unwanted. You can also manually toggle the visibility of the advanced frame stats using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aed00f8a1009f2ebf6806774cb894d0d7" title="Toggles visibility of advanced statistics. ">OgreBites::TrayManager::toggleAdvancedFrameStats</a></code>.', '</p>'), ('<p>', 'This is just a decor widget of the OGRE logo. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#affee57f47066e25437649d64daaa7dd9" title="Shows logo in the specified location. ">OgreBites::TrayManager::showLogo</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ac1ee637b7ef5e887170c8a9aca1c4c7b">OgreBites::TrayManager::hideLogo</a></code> to show/hide the logo. You can choose where to put it.', '</p>'), ('<p>', 'This is a progress bar that shows you the progress of your current resource loading job. The comment box will show the current resource being loaded. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a0d51005a4b148a4df2c1c6b55e34f085" title="Shows loading bar. ">OgreBites::TrayManager::showLoadingBar</a></code> before you begin your loading job. Specify the number of resource groups you will initialise, the number of groups you will load, and, if you want to, the proportion of time you think will go to initialisation (default estimate is 70%). You cannot decide where to place this loading bar. The screen will be darkened, and the loading bar will appear in the center. Any other dialog or loading bar will be closed. When you finish your loading job, call <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aab014a2c48c8f91556182e42684d44ad">OgreBites::TrayManager::hideLoadingBar</a></code>.', '</p>'), ('<p>', 'This is a dialog which tells the user something and displays an OK button. It\'s a combination of a TextBox and a Button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#abf3bd8e4ef9a6d0d76f27535a6010623" title="Pops up a message dialog with an OK button. ">OgreBites::TrayManager::showOkDialog</a></code> to display an information dialog. Specify the caption of the TextBox, and the message you want to display in it. Any other dialog or loading bar will be closed. The screen will be darkened, and the dialog will appear in the center. All other widget interactions are disabled until the dialog is closed. You can manually close a dialog using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#af5d95dcaa7c74d3345308e4f4e3035e8" title="Hides whatever dialog is currently showing. ">OgreBites::TrayManager::closeDialog</a></code>. To respond to information dialog closing events, see the TrayListenersection below.', '</p>'), ('<p>', 'Same as the Information Dialog except it asks the user something and displays a Yes button and a No button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a85d47aa11d761742884dc6457ec11cdf" title="Pops up a question dialog with Yes and No buttons. ">OgreBites::TrayManager::showYesNoDialog</a></code> to display a question dialog. Specify the caption of the TextBox, and the question you want to display in it. To respond to question dialog closing events, see the TrayListener section below.', '</p>'), ('<p>', "This class contains handlers for all the different events that your widgets can fire. The TrayManager class itself is an TrayListener, because it responds to events from its special widgets. You should extend your sample class from TrayListener as well as Sample if you want to handle widget events. If you're using SdkSample, you're all set because it's already an TrayListener. Some widgets give you an option of not firing an event when you change their state. This is helpful for initialising or resetting a widget, in which case there shouldn't be a response of any sort. For example, if you're initialising your slider bar before the scene is set up, and your slider bar is used to control some part of your scene, firing an event would cause an error. Below is a list of the different handlers. All handlers have return type void.", '</p>'), ('<p>', 'Getting access to widgets: </p><div class="fragment"><div class="line">Button* b;</div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);  <span class="comment">// by tray and position</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by tray and name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#af968c01a627ee654409f558e4ef55537">getWidgetIterator</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>).<a class="code" href="class_ogre_1_1_vector_iterator_wrapper.html#a2460c8adb6819235849de954db6a0f64">getNext</a>();  <span class="comment">// by iterator</span></div></div><!-- fragment --><p> Counting widgets: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>();  <span class="comment">// total</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);  <span class="comment">// by tray</span></div></div><!-- fragment --><p> Moving widgets to other trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div></div><!-- fragment --><p> Removing widgets from trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a04a1085bdee61d7234849663cce08664">TL_NONE</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a77ba6e4d641c146e262b6cdd2c8b04a0">clearTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9787ec5e8989bf6cfa89d03c6ddd27b6">clearAllTrays</a>();</div></div><!-- fragment --><p> Destroying widgets: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4a89cd6f7d87e0e538aa842f1a42a7bc">destroyAllWidgetsInTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aadb1f5a3b7e3b5397b10bdd3449e1603">destroyAllWidgets</a>();</div></div><!-- fragment --><p> Finding the position of a widget in a tray: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa993d2b60cfbcb903aecbff1c4896b67">locateWidgetInTray</a>(b);</div></div><!-- fragment --><p> Finding the tray a widget is in: </p><div class="fragment"><div class="line"><a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530">TrayLocation</a> trayLoc = b-&gt;getTrayLocation();</div></div><!-- fragment --><p> Changing the tray listener object: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a3235fea714a0c61e463dee69ae308be8">setListener</a>(newListener);</div></div><!-- fragment --><p> Toggling system visibility: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a075805136b2241cbb03eeb2c3d27b40d">showAll</a>();</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a188f1d5f5ca16af3b28d11ecd553105a">hideAll</a>();</div></div><!-- fragment --><p> Changing horizontal widget alignment in one tray: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#adfbbc97615fd5f1a939be6e7a1f00c07">setTrayWidgetAlignment</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <a class="code" href="group___overlays.html#gga3396780cdb2d731aa5e4389148bdc5f3a270f18cf07dbe4e75e1b790d02924205">GHA_RIGHT</a>);</div></div><!-- fragment --><p> Changing spacing and padding: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a33a3e3f66a3989dd3de48b4c4577422f">setWidgetSpacing</a>(5);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a52d3fc8638533540232232c37b257de6">setWidgetPadding</a>(3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a866229b6d88dc9d3a609115eaab46e67">setTrayPadding</a>(12);</div></div><!-- fragment --><p> Casting 3D ray from under cursor into the scene: </p><div class="fragment"><div class="line">Ray r = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9dd5d303968329462e9bf4225f59722e">getCursorRay</a>(mCamera);</div></div><!-- fragment --><p> Casting 3D ray from any 2D screen coordinate into the scene: </p><div class="fragment"><div class="line">Ray r = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#a6833f46b0303b559a050f310fa0204fc">OgreBites::TrayManager::screenToScene</a>(mCamera, Vector2(320, 240));</div></div><!-- fragment --><p> Converting a 3D scene coordinate to a 2D screen coordinate: ', '</p>'), ('<p>', 'This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.', '</p>'), ('<p>', 'Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.', '</p>'), ('<p>', 'Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.', '</p>'), ('<p>', 'But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.', '</p>'), ('<p>', 'Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.', '</p>'), ('<p>', 'Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.', '</p>'), ('<p>', 'For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.', '</p>'), ('<p>', 'It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.', '</p>'), ('<p>', 'Materials are still useful for:', '</p>'), ('<p>', 'You could be thinking the reason I came up with these two is to fit with D3D11s grand scheme of things while being compatible with OpenGL. But thats a half truth and an awesome side effect. Ive been developing the Hlms using OpenGL this whole time.', '</p>'), ('<p>', 'An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and theyre right about that.', '</p>'), ('<p>', 'However, there are big advantages for using blocks:', '</p>'), ('<p>', 'Of course its not perfect, it cant fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); youll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. Were aiming the general use case.', '</p>'), ('<p>', 'These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since Im not used to driver development. However from an engine perspective, blocks make sense.', '</p>'), ('<p>', 'Were introducing the concept of Datablocks. A Datablock is a material from the users perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.', '</p>'), ('<p>', 'The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.', '</p>'), ('<p>', 'The Hlms will parse the template files from the template folder according to the following rules:', '</p>'), ('<p>', "The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.", '</p>'), ('<p>', 'The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.', '</p>'), ('<p>', 'For example </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can\'t evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can\'t check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable IncludeLightingEquals2 and check whether it\'s non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms\'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can\'t see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you\'ll depend on the driver implementation having a good macro preprocessor.', '</p>'), ('<p>', 'The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:', '</p>'), ('<p>', "Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.", '</p>'), ('<p>', 'The logical operands &amp;&amp; || ! are valid.', '</p>'), ('<p>', 'Examples: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \\<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \\@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: ', '</p>'), ('<p>', 'Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.', '</p>'), ('<p>', 'Newlines are very important, as they will be printed with the loop.', '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', '<b>Attention #1!</b>', '</p>'), ('<p>', "Don't use the common letter i for the loop counter. It will conflict with other keywords.", '</p>'), ('<p>', 'i.e. @foreach( 1, i )@insertpiece( pieceName )@end will print 0nsertpiece( pieceName ) which is probably not what you intended.', '</p>'), ('<p>', '<b>Attention #2!</b>', '</p>'), ('<p>', 'foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.', '</p>'), ('<p>', 'i.e. The following code will not work:', '</p>'), ('<p>', 'Because psub will be evaluated before expanding the foreach. ', '</p>'), ('<p>', "Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.", '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', "Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. ", '</p>'), ('<p>', "Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.", '</p>'), ('<p>', 'Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c', '</p>'), ('<p>', 'Useful in combination with @counter and @value', '</p>'), ('<p>', 'Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won\'t be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Analogous to <a href="#toc304"><em>the family of math functions without the \'p\' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.', '</p>'), ('<p>', 'i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )', '</p>'), ('<p>', "One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.", '</p>'), ('<p>', 'If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.', '</p>'), ('<p>', 'There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:', '</p>'), ('<p>', 'When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.', '</p>'), ('<p>', "If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).", '</p>'), ('<p>', 'The following graph summarizes the process:', '</p>'), ('<p>', 'Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a <a href="#toc567"><em>pass hash</em></a> instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).', '</p>'), ('<p>', "While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:", '</p>'), ('<p>', 'Note: This section is relevant to those seeking to write their own Hlms implementation.', '</p>'), ('<p>', 'C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set key to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod', '</p>'), ('<p>', 'To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.', '</p>'), ('<p>', 'The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.', '</p>'), ('<p>', 'In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.', '</p>'), ('<p>', "Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.", '</p>'), ('<p>', 'For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.', '</p>'), ('<p>', 'The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.', '</p>'), ('<p>', "Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.", '</p>'), ('<p>', "Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.", '</p>'), ('<p>', 'For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.', '</p>'), ('<p>', 'Properties in underscore_case are set from C++; propierties in camelCase are set from the template.', '</p>'), ('<p>', "Propierties and pieces starting with 'custom_' are for user customizations of the template", '</p>'), ('<p>', 'TBD', '</p>'), ('<p>', "By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.", '</p>'), ('<p>', 'Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.', '</p>'), ('<p>', 'In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.', '</p>'), ('<p>', "Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.", '</p>'), ('<p>', 'Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.', '</p>'), ('<p>', 'There are different levels in which an Hlms implementation can be customized:', '</p>'), ('<p>', "Ever wanted really simple GUI controls for your sample? Don't want to write one from scratch, but CEGUI's just a little too much? The Trays system was created to address this issue. It's a simple GUI system based on the OGRE Overlay system and designed just for samples. Because it's simple, you're not going to be able to skin it or build very unique interfaces, but you'll also find it much easier to use. The entire system is based on the OGRE Overlay system.", '</p>'), ('<p>', 'Why trays? The concept of trays is central to the system in that it removes the need for the GUI designer (you) to calculate or specify positional coordinates of any kind. Think about the widget locations in a typical GUI. They are almost always in any of the four corners, along any of the four edges or, on the rare occasion, in the center of the screen. In Trays, there are nine "trays", one in each of the locations previously mentioned. When you create a widget, you specify one of these nine locations, and the widget will be added to the tray at that location. Your widget will be added directly beneath the last widget in that tray. When you add a widget to a tray, the tray grows in size. Trays along the top of the screen grow downward, Trays along the bottom grow upward, and the trays in the middle row grow vertically in both directions. Visually, the trays are semi-transparent panels that fit the widgets they contain. Only non-empty trays are visible. If this is hard to visualise, don\'t worry, here\'s a picture to help you out. ', '</p>'), ('<p>', 'To use Trays, you have to create an TrayManager. This is the class through which you will create and manage all your widgets, manipulate the cursor, change the backdrop image, adjust tray properties, pop up dialogs, show/hide the loading bar, etc. You can have multiple tray managers in one application. For example, the OGRE Sample Browser uses its own tray manager and hides it when a sample is running, and the SDK samples also have their own tray managers, which are hidden when the samples are paused by the browser. The TrayManager requires "Trays.zip", so you can only create it after loading that resource. Also, make sure you\'re using the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> namespace (Trays is part of the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Samples Framework). Create your tray manager like so: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>* mTrayMgr = <span class="keyword">new</span> <a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>(<span class="stringliteral">&quot;InterfaceName&quot;</span>, mWindow, <span class="keyword">this</span>);</div></div><!-- fragment --><p> You must pass in a name for your interface, an <code><a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a></code> and an <code><a class="el" href="class_ogre_bites_1_1_tray_listener.html" title="Listener class for responding to tray events. ">OgreBites::TrayListener</a></code>. You can extend your sample or sample context to be a tray listener. Destroy your tray manager like so: </p><div class="fragment"><div class="line"><span class="keyword">delete</span> mTrayMgr;</div><div class="line">mTrayMgr = 0;</div></div><!-- fragment --><p> Once you have your tray manager, make sure you relay your OIS events to it. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> mousePressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseDown(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseReleased(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseUp(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseMoved(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_motion_event.html">OgreBites::MouseMotionEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseMove(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> The injection methods return true if the event was relevant to the tray manager, and should not be processed again by you. For example, if you click a button that is over an interactive part of your scene, you want the button to be pressed, but you don\'t want the scene interaction to take place. So the injection methods double as filters for your mouse events.', '</p>'), ('<p>', 'You\'re now free to create widgets! Try adding a button to the top-left tray: </p><div class="fragment"><div class="line">Button* b = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">createButton</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530afe04de8736168ab0dd6e7938e679c292">TL_TOPLEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <span class="stringliteral">&quot;Click Me!&quot;</span>);</div></div><!-- fragment --><p> TrayManager is a huge class, and you can do tons of things with it. For some examples, see the Things to Try section below.', '</p>'), ('<p>', 'The cursor has three parts in the Trays system: The layer it moves around in Overlay, the container which positions the cursor (OverlayContainer), and the cursor image, which is a child of the container (OverlayElement). When hiding/showing the cursor, the entire cursor layer is hidden/shown. The top left corner of the cursor container is used as the hotspot of the cursor. By positioning the cursor image relative to the cursor container, you can basically decide which part of the cursor image is the "clicking part". For the default arrow cursor, the image is simply lined up with the container, meaning the top left is the hotspot. However, for something like a crosshair cursor, you could move the cursor image so that its center is over the top left corner of the cursor container. To show the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1cc48ac157278b5845d425abbe9acefd" title="Displays specified material on cursor, or the last material used if none specified. ">OgreBites::TrayManager::showCursor</a></code>, which takes an optional material name for the cursor image. If unspecified, the cursor image is not changed. To hide the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a979ff2ad2d729223259b3bebb237cafb">OgreBites::TrayManager::hideCursor</a></code>. You can get the cursor\'s different parts using getCursorLayer, getCursorContainer, and getCursorImage. Note that if the cursor is hidden, all interactions with widgets are disabled.', '</p>'), ('<p>', 'If you want to show a backdrop, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ad554418c27edb907f0e3bead8659b83c" title="Displays specified material on backdrop, or the last material used if none specified. ">OgreBites::TrayManager::showBackdrop</a></code>, which takes an optional material name for the backdrop. If unspecified, the backdrop image is not changed. To hide it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a6129a1e92ac22789a4602cf36f9c5394">OgreBites::TrayManager::hideBackdrop</a></code>.', '</p>'), ('<p>', 'There are 10 basic widgets. Each widget is just an instance of an OverlayElement template, and all widgets use {LEX()}pixel{LEX} metrics. You can get access to any widget\'s underlying OverlayElement through <code><a class="el" href="class_ogre_bites_1_1_widget.html#a379d3f1a2ca6eaf13fc5c52afaafd0d2">OgreBites::Widget::getOverlayElement</a></code>. Do not instantiate and delete widgets manually. Create and destroy them using the TrayManager. The first argument to any one of TrayManager\'s widget creation methods is the location of the tray you want the widget to be in. This is of the enumerated type TrayLocation. The second argument is the name of your widget (this is not your widget\'s caption, but a unique string identifier for your widget). The rest of the arguments are specific to the type of widget.', '</p>'), ('<p>', 'This is the most basic widget of all. To create a button, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">OgreBites::TrayManager::createButton</a></code>. In addition to a tray location and a name, you must specify a caption for your button, and an optional width. If width is not specified, the button will automatically resize to fit its caption. There are no button states. You only get notified when a button is pushed. To see how to respond to button push events, see the TrayListener section below.', '</p>'), ('<p>', 'This widget consists of a bold caption bar and a text area that can be scrolled vertically. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a07a8d212939266339e877ff2118250a6">OgreBites::TrayManager::createTextBox</a></code> takes a caption, width, and height. You can set/get the caption, the text area contents, text padding, text alignment, manually change the scroll bar position, among other things.', '</p>'), ('<p>', 'A basic drop-down menu. To create it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a60864ca00d65b2bf1b97bb8545fab737">OgreBites::TrayManager::createLongSelectMenu</a></code> or <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a98f478c8daa5084b53146de03adbc216">OgreBites::TrayManager::createThickSelectMenu</a></code>. Both these methods return a SelectMenu object, but they give one of two different visual styles to the widget. One is thicker, but shorter, because it places the caption over the item box. This style of menu is good for putting in the side trays. The other is longer, but thinner, because it places the item box next to the caption. This style of menu is good for putting in the top or bottom trays. createThickSelectMenu takes a tray location, a name, a caption, the width of the whole widget, the maximum number of visible items when expanded, and an optional string vector of items. The medthod <code>createLongSelectMenu</code> takes nearly the same arguments, except that it needs the width of the text box that shows the currently selected item. Also, for long menus, it is optional to specify the total width because it will automatically resize to fit the item box and the caption. You can set/get the caption, and set/get the items in many different ways. You can also manually change the selection, with the option of not firing an event. To see how to respond to menu item selection events, see the TrayListener section below.', '</p>'), ('<p>', 'A big, semi-transparent, tabby-looking label. This widget uses a different font from the rest of the widgets, and is good for section headings and such. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a15375d59b5c57059c9c6549fc5a1bfcd">OgreBites::TrayManager::createLabel</a></code> takes a caption, and an optional width. If the width is not specified, the label automatically adjusts its width to fill the tray it\'s currently in, so it matches the other contents of the tray. Labels can also be clicked. To see how to respond to label click events, see the TrayListener section below.', '</p>'), ('<p>', "A horizontal line which looks like it was etched into the tray. Good for dividing up other widgets into sections without taking up as much space as a label. <code>TrayManager::createSeparator</code> takes a tray location, name, and an optional width. If the width is not specified, the behaviour is the same as a Label's.", '</p>'), ('<p>', 'A slider bar consists of a container box, a small text box to display the value, and a track + handle. Sliders are type-agnostic. Using three parameters - a minimum value, a maximum value, and the number of "snapping points", you can give your slider track of any kind of discrete scale - integer, floating point, or even nominal. Snapping points are basically the "steps" on your slider track. By specifying how many of them there are, you are in effect specifying an entire range of values all the way from your minimum value to your maximum value. Let\'s say you have minimum value 0, maximum value 1, and 6 snapping points. Underneath the surface, each slider stores a floating point value, so in this case you would be able to display 6 floating point values: {0, 0.2, 0.4, 0.6, 0.8, 1}. The slider will display your value in the cleanest way possible (using <code><a class="el" href="class_ogre_1_1_string_converter.html#a45fb498a2f798c82bbf88116a5a34c53" title="Converts a float to a String. ">Ogre::StringConverter::toString</a></code>). This means that if all your values happen to land on integers, then they will be displayed as integers without decimals. You can also exploit this by using your slider\'s integer values as indices into an array of string values, and manually set your slider\'s value to the new string value. Basically, you can make your slider display things like Low, Medium, High, 1/4, 3/4, $4.00, N/A, etc. This requires you to respond to slider move events. More on this in the TrayListener section below. Then your Like select menus, sliders also come in two flavours - thick and long. The thick style places the caption and the value box above the track, while the long style places the caption, track, and value box side by side in that order. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a597ec173c1b424980e18fd92e0c56905">OgreBites::TrayManager::createThickSlider</a></code> takes a tray location, name, caption, total width, value box width, minimum value, maximum value, and the number of snapping points. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a321429ade975d3a63dfc1125b4375e78">OgreBites::TrayManager::createLongSlider</a></code> takes a an optional total width, track width, value box width, minimum value, maximum value, and the number of snapping points. If the total width is not specified, the slider will automatically scale to fit the track, the value box, and the caption text. You can get/set the slider\'s caption, displayed value, actual value, and range of values. When you change the range, the value is reset to be the minimum value. When you change the value, you also have the option of not firing an event. To respond to slider move events, see the TrayListener section below.', '</p>'), ('<p>', 'This panel displays an arbitrary number of parameters and their values. This could be anything you want. For example, the stats panel in the SDK samples shows the average framerate, best framerate, batch count, etc. The details panel in the SDK samples shows the texture filtering technique, the polygon mode, and the camera position and orientation. To create a ParamsPanel, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a5ae6b66603e05193b3077f30900209eb">OgreBites::TrayManager::createParamsPanel</a></code>, which takes a tray location, a name, a width, and then either a string vector of parameter names or the number of parameters (lines) to leave room for. The parameter names will be left justified, and their values will be right justified on the same line. At any time, you can set/get the parameter names and values either one at a time, or all at once using a string vector.', '</p>'), ('<p>', 'Self-explanatory. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7433f3e89c5b3a1b1b0012dfcb121f1d">OgreBites::TrayManager::createCheckBox</a></code> takes a tray location, name, caption, and an optional width. Unspecified width means auto-fit to caption. You can set/get the state of the check box, with the option of not triggering an event. To respond to check box state change events, see the TrayListener section below. ', '</p>'), ('<p>', 'This widget takes any OverlayElement template, and creates a widget out of it. If you want to put your own picture, icons, or other static objects into the trays, make an OverlayElement template out of it, and then turn it into a DecorWidget. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a24d1b3a3b95ddcf274bf899b7600deba">OgreBites::TrayManager::createDecorWidget</a></code> takes a tray location, a name, and an OverlayElement template name. These are basically the same things you would normally use to create an OverlayElement from a template. The OGRE logo in the SDK samples is a DecorWidget. ', '</p>'), ('<p>', 'A progress bar with a caption, a comment/details box, and a meter that fills up. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a431a347db6465bbf66af82ef363c875f">OgreBites::TrayManager::createProgressBar</a></code> takes a tray location, a name, a caption, a total width, and comment box width. You can use progress bars to show any kind of progress you want, but for the most common kind (loading resources), there\'s a special instance of ProgressBar already created by TrayManager which you can use. See Loading Bar below.', '</p>'), ('<p>', 'In addition to the nine trays you can place your widgets in, there is also a "null tray". This is an imaginary tray, whose location is specified by <code>TL_NONE</code>. This tray is virtual, invisible, and does not arrange widgets within it. Basically, if you place a widget in this tray, it becomes "free-floating", and you\'re allowed to manually position it anywhere on the screen. Widgets must always reside in a tray for as long as they exist, so when a widget is removed from a tray, it is automatically placed in the null tray.', '</p>'), ('<p>', 'Some widgets are so common they deserve special treatment.', '</p>'), ('<p>', 'This is not exactly one widget, but a combination of Label that displays the current FPS, and a ParamsPanel that displays advanced frame statistics (such as average FPS and batch count). Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a49e2f792fee94e75b1b472826bcc8019" title="Shows frame statistics widget set in the specified location. ">OgreBites::TrayManager::showFrameStats</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1c2e9618a3e6b061a9cfeac4f2cb55e9" title="Hides frame statistics widget set. ">OgreBites::TrayManager::hideFrameStats</a></code> to show/hide this special widget. You can choose where to put it. When the user clicks the FPS label, it toggles the visibility of the advanced frame stats, so they can be out of the way when they\'re unwanted. You can also manually toggle the visibility of the advanced frame stats using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aed00f8a1009f2ebf6806774cb894d0d7" title="Toggles visibility of advanced statistics. ">OgreBites::TrayManager::toggleAdvancedFrameStats</a></code>.', '</p>'), ('<p>', 'This is just a decor widget of the OGRE logo. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#affee57f47066e25437649d64daaa7dd9" title="Shows logo in the specified location. ">OgreBites::TrayManager::showLogo</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ac1ee637b7ef5e887170c8a9aca1c4c7b">OgreBites::TrayManager::hideLogo</a></code> to show/hide the logo. You can choose where to put it.', '</p>'), ('<p>', 'This is a progress bar that shows you the progress of your current resource loading job. The comment box will show the current resource being loaded. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a0d51005a4b148a4df2c1c6b55e34f085" title="Shows loading bar. ">OgreBites::TrayManager::showLoadingBar</a></code> before you begin your loading job. Specify the number of resource groups you will initialise, the number of groups you will load, and, if you want to, the proportion of time you think will go to initialisation (default estimate is 70%). You cannot decide where to place this loading bar. The screen will be darkened, and the loading bar will appear in the center. Any other dialog or loading bar will be closed. When you finish your loading job, call <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aab014a2c48c8f91556182e42684d44ad">OgreBites::TrayManager::hideLoadingBar</a></code>.', '</p>'), ('<p>', 'This is a dialog which tells the user something and displays an OK button. It\'s a combination of a TextBox and a Button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#abf3bd8e4ef9a6d0d76f27535a6010623" title="Pops up a message dialog with an OK button. ">OgreBites::TrayManager::showOkDialog</a></code> to display an information dialog. Specify the caption of the TextBox, and the message you want to display in it. Any other dialog or loading bar will be closed. The screen will be darkened, and the dialog will appear in the center. All other widget interactions are disabled until the dialog is closed. You can manually close a dialog using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#af5d95dcaa7c74d3345308e4f4e3035e8" title="Hides whatever dialog is currently showing. ">OgreBites::TrayManager::closeDialog</a></code>. To respond to information dialog closing events, see the TrayListenersection below.', '</p>'), ('<p>', 'Same as the Information Dialog except it asks the user something and displays a Yes button and a No button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a85d47aa11d761742884dc6457ec11cdf" title="Pops up a question dialog with Yes and No buttons. ">OgreBites::TrayManager::showYesNoDialog</a></code> to display a question dialog. Specify the caption of the TextBox, and the question you want to display in it. To respond to question dialog closing events, see the TrayListener section below.', '</p>'), ('<p>', "This class contains handlers for all the different events that your widgets can fire. The TrayManager class itself is an TrayListener, because it responds to events from its special widgets. You should extend your sample class from TrayListener as well as Sample if you want to handle widget events. If you're using SdkSample, you're all set because it's already an TrayListener. Some widgets give you an option of not firing an event when you change their state. This is helpful for initialising or resetting a widget, in which case there shouldn't be a response of any sort. For example, if you're initialising your slider bar before the scene is set up, and your slider bar is used to control some part of your scene, firing an event would cause an error. Below is a list of the different handlers. All handlers have return type void.", '</p>'), ('<p>', 'Getting access to widgets: </p><div class="fragment"><div class="line">Button* b;</div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);  <span class="comment">// by tray and position</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by tray and name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#af968c01a627ee654409f558e4ef55537">getWidgetIterator</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>).<a class="code" href="class_ogre_1_1_vector_iterator_wrapper.html#a2460c8adb6819235849de954db6a0f64">getNext</a>();  <span class="comment">// by iterator</span></div></div><!-- fragment --><p> Counting widgets: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>();  <span class="comment">// total</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);  <span class="comment">// by tray</span></div></div><!-- fragment --><p> Moving widgets to other trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div></div><!-- fragment --><p> Removing widgets from trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a04a1085bdee61d7234849663cce08664">TL_NONE</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a77ba6e4d641c146e262b6cdd2c8b04a0">clearTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9787ec5e8989bf6cfa89d03c6ddd27b6">clearAllTrays</a>();</div></div><!-- fragment --><p> Destroying widgets: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4a89cd6f7d87e0e538aa842f1a42a7bc">destroyAllWidgetsInTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aadb1f5a3b7e3b5397b10bdd3449e1603">destroyAllWidgets</a>();</div></div><!-- fragment --><p> Finding the position of a widget in a tray: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa993d2b60cfbcb903aecbff1c4896b67">locateWidgetInTray</a>(b);</div></div><!-- fragment --><p> Finding the tray a widget is in: </p><div class="fragment"><div class="line"><a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530">TrayLocation</a> trayLoc = b-&gt;getTrayLocation();</div></div><!-- fragment --><p> Changing the tray listener object: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a3235fea714a0c61e463dee69ae308be8">setListener</a>(newListener);</div></div><!-- fragment --><p> Toggling system visibility: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a075805136b2241cbb03eeb2c3d27b40d">showAll</a>();</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a188f1d5f5ca16af3b28d11ecd553105a">hideAll</a>();</div></div><!-- fragment --><p> Changing horizontal widget alignment in one tray: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#adfbbc97615fd5f1a939be6e7a1f00c07">setTrayWidgetAlignment</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <a class="code" href="group___overlays.html#gga3396780cdb2d731aa5e4389148bdc5f3a270f18cf07dbe4e75e1b790d02924205">GHA_RIGHT</a>);</div></div><!-- fragment --><p> Changing spacing and padding: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a33a3e3f66a3989dd3de48b4c4577422f">setWidgetSpacing</a>(5);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a52d3fc8638533540232232c37b257de6">setWidgetPadding</a>(3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a866229b6d88dc9d3a609115eaab46e67">setTrayPadding</a>(12);</div></div><!-- fragment --><p> Casting 3D ray from under cursor into the scene: </p><div class="fragment"><div class="line">Ray r = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9dd5d303968329462e9bf4225f59722e">getCursorRay</a>(mCamera);</div></div><!-- fragment --><p> Casting 3D ray from any 2D screen coordinate into the scene: </p><div class="fragment"><div class="line">Ray r = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#a6833f46b0303b559a050f310fa0204fc">OgreBites::TrayManager::screenToScene</a>(mCamera, Vector2(320, 240));</div></div><!-- fragment --><p> Converting a 3D scene coordinate to a 2D screen coordinate: ', '</p>'), ('<p>', 'This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.', '</p>'), ('<p>', 'Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.', '</p>'), ('<p>', 'Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.', '</p>'), ('<p>', 'But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.', '</p>'), ('<p>', 'Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.', '</p>'), ('<p>', 'Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.', '</p>'), ('<p>', 'For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.', '</p>'), ('<p>', 'It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.', '</p>'), ('<p>', 'Materials are still useful for:', '</p>'), ('<p>', 'You could be thinking the reason I came up with these two is to fit with D3D11s grand scheme of things while being compatible with OpenGL. But thats a half truth and an awesome side effect. Ive been developing the Hlms using OpenGL this whole time.', '</p>'), ('<p>', 'An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and theyre right about that.', '</p>'), ('<p>', 'However, there are big advantages for using blocks:', '</p>'), ('<p>', 'Of course its not perfect, it cant fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); youll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. Were aiming the general use case.', '</p>'), ('<p>', 'These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since Im not used to driver development. However from an engine perspective, blocks make sense.', '</p>'), ('<p>', 'Were introducing the concept of Datablocks. A Datablock is a material from the users perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.', '</p>'), ('<p>', 'The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.', '</p>'), ('<p>', 'The Hlms will parse the template files from the template folder according to the following rules:', '</p>'), ('<p>', "The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.", '</p>'), ('<p>', 'The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.', '</p>'), ('<p>', 'For example </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can\'t evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can\'t check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable IncludeLightingEquals2 and check whether it\'s non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms\'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can\'t see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you\'ll depend on the driver implementation having a good macro preprocessor.', '</p>'), ('<p>', 'The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:', '</p>'), ('<p>', "Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.", '</p>'), ('<p>', 'The logical operands &amp;&amp; || ! are valid.', '</p>'), ('<p>', 'Examples: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \\<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \\@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: ', '</p>'), ('<p>', 'Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.', '</p>'), ('<p>', 'Newlines are very important, as they will be printed with the loop.', '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', '<b>Attention #1!</b>', '</p>'), ('<p>', "Don't use the common letter i for the loop counter. It will conflict with other keywords.", '</p>'), ('<p>', 'i.e. @foreach( 1, i )@insertpiece( pieceName )@end will print 0nsertpiece( pieceName ) which is probably not what you intended.', '</p>'), ('<p>', '<b>Attention #2!</b>', '</p>'), ('<p>', 'foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.', '</p>'), ('<p>', 'i.e. The following code will not work:', '</p>'), ('<p>', 'Because psub will be evaluated before expanding the foreach. ', '</p>'), ('<p>', "Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.", '</p>'), ('<p>', 'Examples: ', '</p>'), ('<p>', "Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. ", '</p>'), ('<p>', "Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.", '</p>'), ('<p>', 'Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c', '</p>'), ('<p>', 'Useful in combination with @counter and @value', '</p>'), ('<p>', 'Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won\'t be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.', '</p>'), ('<p>', 'Example: ', '</p>'), ('<p>', 'Analogous to <a href="#toc304"><em>the family of math functions without the \'p\' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.', '</p>'), ('<p>', 'i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )', '</p>'), ('<p>', "One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.", '</p>'), ('<p>', 'If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.', '</p>'), ('<p>', 'There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:', '</p>'), ('<p>', 'When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.', '</p>'), ('<p>', "If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).", '</p>'), ('<p>', 'The following graph summarizes the process:', '</p>'), ('<p>', 'Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a <a href="#toc567"><em>pass hash</em></a> instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).', '</p>'), ('<p>', "While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:", '</p>'), ('<p>', 'Note: This section is relevant to those seeking to write their own Hlms implementation.', '</p>'), ('<p>', 'C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set key to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod', '</p>'), ('<p>', 'To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.', '</p>'), ('<p>', 'The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.', '</p>'), ('<p>', 'In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.', '</p>'), ('<p>', "Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.", '</p>'), ('<p>', 'For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.', '</p>'), ('<p>', 'The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.', '</p>'), ('<p>', "Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.", '</p>'), ('<p>', "Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.", '</p>'), ('<p>', 'For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.', '</p>'), ('<p>', 'Properties in underscore_case are set from C++; propierties in camelCase are set from the template.', '</p>'), ('<p>', "Propierties and pieces starting with 'custom_' are for user customizations of the template", '</p>'), ('<p>', 'TBD', '</p>'), ('<p>', "By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.", '</p>'), ('<p>', 'Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.', '</p>'), ('<p>', 'In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.', '</p>'), ('<p>', "Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.", '</p>'), ('<p>', 'Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.', '</p>'), ('<p>', 'There are different levels in which an Hlms implementation can be customized:', '</p>'), ('<p>', "Welcome to the Volume Component of OGRE. It is a component to render volumes. It can handle any volume data but featurewise has a tedency towards terrains. The terrain aspect means, that it's all about huge meshes being displayed with high performance via a level of detail mechanism. Thanks to volume rendering, caves, cliffes, holes and similar geometry can be displayed. Also constructive solid geometry gets easy.", '</p>'), ('<p>', 'A dense list of the features:', '</p>'), ('<p>', 'This documentation is only intended for the usage of the Volume Component, not the algorithms which make it work. If you want to get to know the theory behind it, you can read the articles on this page: <a href="http://volume-gfx.com/">http://volume-gfx.com/</a>', '</p>'), ('<p>', 'Here is an example loading the volume scene from a configuration file. The configuration file must be findable by the resource system of course. Only "OgreVolumeChunk.h" has to be included. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> <a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a>();</div><div class="line">SceneNode *volumeRootNode = mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(<span class="stringliteral">&quot;VolumeParent&quot;</span>);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, mSceneMgr, <span class="stringliteral">&quot;volumeTerrain.cfg&quot;</span>);</div></div><!-- fragment --><p> The first line creates the volume chunk which is the MovableObject holding the Volume-Root. Next, a SceneNode is created where the volume(-tree) is attached to. And lastly, the volume is loaded from the configuration file "volumeTerrain.cfg". mSceneMgr is the SceneManager who should show the volume. Later, when you don\'t need it anymore, you have to free the volumeRoot Chunk via OGRE_DELETE.', '</p>'), ('<p>', 'This example skips the configuration file and loads a simple CSG-Scene: An union of a 3D Texture and a sphere with 5 LOD levels. It also setups a material LOD system. First, create a sphere with the radius 5 at the coordinates 128, 150, 128: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_sphere_source.html">Ogre::Volume::CSGSphereSource</a> sphere (5, Vector3(128, 150, 128));</div></div><!-- fragment --><p> Now a 3D texture from "volumeTerrainBig.dds" which has the world dimensions 256, 256, 256. The next flag indicates that the trilinear interpolation of the value-selection should be activated. We switch off the trilinear interpolation and the sobel filter of the normal for the sake of faster loading times: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_texture_source.html">Ogre::Volume::TextureSource</a> volumeTexture (<span class="stringliteral">&quot;volumeTerrainBig.dds&quot;</span>, 256, 256, 256, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div></div><!-- fragment --><p> Now combine them: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_union_source.html">Ogre::Volume::CSGUnionSource</a> unionSrc (&amp;sphere, &amp;volumeTexture);</div></div><!-- fragment --><p> Set the general parameters, see the comments for their meaning: </p><div class="fragment"><div class="line"><a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html">Ogre::Volume::ChunkParameters</a> parameters;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a3e154a179b8c824f79b1b426608743ad">sceneManager</a> = mSceneMgr;       <span class="comment">// The SceneManager to use</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a> = &amp;unionSrc;                <span class="comment">// The just created density source.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a4444eac27c71e02886615dcf7fbfed27">baseError</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.8;          <span class="comment">// The error of the highest LOD-level</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aa6186649b7323f937b83828eb86711fa">errorMultiplicator</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.9; <span class="comment">// The factor between each LOD-level (error = baseError * errorMultiplicator  * level)</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a986b4a97b153d50f65603ab507bb4614">skirtFactor</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.7;        <span class="comment">// Controls how long the skirts are. The lower the number, the shorter the skirts are. This saves geometry. But if they are too short, cracks might occure.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#af6ed62b76c67d04eb98424414fb1dc72">scale</a> = 10;                     <span class="comment">// The displayed volume will be scaled by this factor.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#ae125003c00de0d6c0a1a4bd6b99c4ebf">maxScreenSpaceError</a> = 30;       <span class="comment">// The screen space error controlling when the LOD-levels change.</span></div></div><!-- fragment --><p>Create the root-chunk and load now. The two vectors define the area to be scanned in the volume-source. The following integer determines the amount of LOD-levels. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> Chunk();</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(mVolumeRootNode, Vector3::ZERO, Vector3(256), 5, &amp;parameters);</div></div><!-- fragment --><p> Now setup the global volume material: ', '</p>'), ('<p>', "When you want to integrate the volume triangles in a physics engine for example, you need to hand over the exact triangles. For this scenario, the ChunkParameters hold a pointer to a ''MeshBuilderCallback'' and a number ''lodCallbackLod''. The first is an interface with a single function ''trianglesReady'' which is called, when the triangles of a chunk are ready. The chunks are chosen via the ''lodCallbackLod''. If you build a volume with 3 LOD levels and you want the triangles of the highest detail level, you set this parameter to 3. Example:", '</p>'), ('<p>', 'And using it like this: </p><div class="fragment"><div class="line"><a class="code" href="group___volume.html#ga89fbc5eed010b8802358563eb88e674a">ChunkParameters</a> parameters;</div><div class="line">...</div><div class="line">MyMeshBuilderCallback callback;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a6403e2875cc7b81aefd43ba9f22c2b31">lodCallback</a> = &amp;callback;</div><div class="line">parameters.lodCallbackLod = 3;</div><div class="line">...</div><div class="line">rootChunk-&gt;load(parent, from, to, 3, &amp;parameters);</div></div><!-- fragment --><p> Or in case of loading from a configuration file: </p><div class="fragment"><div class="line">MyMeshBuilderCallback callback;</div><div class="line">rootChunk-&gt;load(parent, sceneManager, <span class="stringliteral">&quot;myVolume.cfg&quot;</span>, 0, &amp;callback, 3);</div></div><!-- fragment --><p>You might have seen, that a pointer to a SimpleRenderable is handed in, too. This is actually the Chunk whose triangles are loaded. It\'s parent class is used to not create a circular dependency. You might get the triangle data from it, too by getting the Renderoperation.', '</p>'), ('<p>', 'When you want to do something exactly on the volume surface, you can cast rays and find their first intersection point. Behold that the triangle representation might be slightly different than the actual volume surface. And you have to scale the ray origin just like the volume. Here is an example which uses the negative z-axis of the camera as ray as it might be done like in an ego-shooter: ', '</p>'), ('<p>', "A usecase is realtime editing of volume terrain as seen as in the sample. Let's union the terrain with a sphere of the radius 2.5 and the center 123/123/123. <b>volumeRoot</b> is the Chunk instance with which the terrain was initially loaded. The factor 1.5 is just to have a save border arround the sphere which also gets updated. The rest of the parameters are 5 LOD levels and a volume mesh covering an area of 384^3. ", '</p>'), ('<p>', "Ever wanted really simple GUI controls for your sample? Don't want to write one from scratch, but CEGUI's just a little too much? The Trays system was created to address this issue. It's a simple GUI system based on the OGRE Overlay system and designed just for samples. Because it's simple, you're not going to be able to skin it or build very unique interfaces, but you'll also find it much easier to use. The entire system is based on the OGRE Overlay system.", '</p>'), ('<p>', 'Why trays? The concept of trays is central to the system in that it removes the need for the GUI designer (you) to calculate or specify positional coordinates of any kind. Think about the widget locations in a typical GUI. They are almost always in any of the four corners, along any of the four edges or, on the rare occasion, in the center of the screen. In Trays, there are nine "trays", one in each of the locations previously mentioned. When you create a widget, you specify one of these nine locations, and the widget will be added to the tray at that location. Your widget will be added directly beneath the last widget in that tray. When you add a widget to a tray, the tray grows in size. Trays along the top of the screen grow downward, Trays along the bottom grow upward, and the trays in the middle row grow vertically in both directions. Visually, the trays are semi-transparent panels that fit the widgets they contain. Only non-empty trays are visible. If this is hard to visualise, don\'t worry, here\'s a picture to help you out. ', '</p>'), ('<p>', 'To use Trays, you have to create an TrayManager. This is the class through which you will create and manage all your widgets, manipulate the cursor, change the backdrop image, adjust tray properties, pop up dialogs, show/hide the loading bar, etc. You can have multiple tray managers in one application. For example, the OGRE Sample Browser uses its own tray manager and hides it when a sample is running, and the SDK samples also have their own tray managers, which are hidden when the samples are paused by the browser. The TrayManager requires "Trays.zip", so you can only create it after loading that resource. Also, make sure you\'re using the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> namespace (Trays is part of the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Samples Framework). Create your tray manager like so: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>* mTrayMgr = <span class="keyword">new</span> <a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>(<span class="stringliteral">&quot;InterfaceName&quot;</span>, mWindow, <span class="keyword">this</span>);</div></div><!-- fragment --><p> You must pass in a name for your interface, an <code><a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a></code> and an <code><a class="el" href="class_ogre_bites_1_1_tray_listener.html" title="Listener class for responding to tray events. ">OgreBites::TrayListener</a></code>. You can extend your sample or sample context to be a tray listener. Destroy your tray manager like so: </p><div class="fragment"><div class="line"><span class="keyword">delete</span> mTrayMgr;</div><div class="line">mTrayMgr = 0;</div></div><!-- fragment --><p> Once you have your tray manager, make sure you relay your OIS events to it. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> mousePressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseDown(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseReleased(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseUp(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseMoved(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_motion_event.html">OgreBites::MouseMotionEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseMove(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> The injection methods return true if the event was relevant to the tray manager, and should not be processed again by you. For example, if you click a button that is over an interactive part of your scene, you want the button to be pressed, but you don\'t want the scene interaction to take place. So the injection methods double as filters for your mouse events.', '</p>'), ('<p>', 'You\'re now free to create widgets! Try adding a button to the top-left tray: </p><div class="fragment"><div class="line">Button* b = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">createButton</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530afe04de8736168ab0dd6e7938e679c292">TL_TOPLEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <span class="stringliteral">&quot;Click Me!&quot;</span>);</div></div><!-- fragment --><p> TrayManager is a huge class, and you can do tons of things with it. For some examples, see the Things to Try section below.', '</p>'), ('<p>', 'The cursor has three parts in the Trays system: The layer it moves around in Overlay, the container which positions the cursor (OverlayContainer), and the cursor image, which is a child of the container (OverlayElement). When hiding/showing the cursor, the entire cursor layer is hidden/shown. The top left corner of the cursor container is used as the hotspot of the cursor. By positioning the cursor image relative to the cursor container, you can basically decide which part of the cursor image is the "clicking part". For the default arrow cursor, the image is simply lined up with the container, meaning the top left is the hotspot. However, for something like a crosshair cursor, you could move the cursor image so that its center is over the top left corner of the cursor container. To show the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1cc48ac157278b5845d425abbe9acefd" title="Displays specified material on cursor, or the last material used if none specified. ">OgreBites::TrayManager::showCursor</a></code>, which takes an optional material name for the cursor image. If unspecified, the cursor image is not changed. To hide the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a979ff2ad2d729223259b3bebb237cafb">OgreBites::TrayManager::hideCursor</a></code>. You can get the cursor\'s different parts using getCursorLayer, getCursorContainer, and getCursorImage. Note that if the cursor is hidden, all interactions with widgets are disabled.', '</p>'), ('<p>', 'If you want to show a backdrop, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ad554418c27edb907f0e3bead8659b83c" title="Displays specified material on backdrop, or the last material used if none specified. ">OgreBites::TrayManager::showBackdrop</a></code>, which takes an optional material name for the backdrop. If unspecified, the backdrop image is not changed. To hide it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a6129a1e92ac22789a4602cf36f9c5394">OgreBites::TrayManager::hideBackdrop</a></code>.', '</p>'), ('<p>', 'There are 10 basic widgets. Each widget is just an instance of an OverlayElement template, and all widgets use {LEX()}pixel{LEX} metrics. You can get access to any widget\'s underlying OverlayElement through <code><a class="el" href="class_ogre_bites_1_1_widget.html#a379d3f1a2ca6eaf13fc5c52afaafd0d2">OgreBites::Widget::getOverlayElement</a></code>. Do not instantiate and delete widgets manually. Create and destroy them using the TrayManager. The first argument to any one of TrayManager\'s widget creation methods is the location of the tray you want the widget to be in. This is of the enumerated type TrayLocation. The second argument is the name of your widget (this is not your widget\'s caption, but a unique string identifier for your widget). The rest of the arguments are specific to the type of widget.', '</p>'), ('<p>', 'This is the most basic widget of all. To create a button, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">OgreBites::TrayManager::createButton</a></code>. In addition to a tray location and a name, you must specify a caption for your button, and an optional width. If width is not specified, the button will automatically resize to fit its caption. There are no button states. You only get notified when a button is pushed. To see how to respond to button push events, see the TrayListener section below.', '</p>'), ('<p>', 'This widget consists of a bold caption bar and a text area that can be scrolled vertically. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a07a8d212939266339e877ff2118250a6">OgreBites::TrayManager::createTextBox</a></code> takes a caption, width, and height. You can set/get the caption, the text area contents, text padding, text alignment, manually change the scroll bar position, among other things.', '</p>'), ('<p>', 'A basic drop-down menu. To create it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a60864ca00d65b2bf1b97bb8545fab737">OgreBites::TrayManager::createLongSelectMenu</a></code> or <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a98f478c8daa5084b53146de03adbc216">OgreBites::TrayManager::createThickSelectMenu</a></code>. Both these methods return a SelectMenu object, but they give one of two different visual styles to the widget. One is thicker, but shorter, because it places the caption over the item box. This style of menu is good for putting in the side trays. The other is longer, but thinner, because it places the item box next to the caption. This style of menu is good for putting in the top or bottom trays. createThickSelectMenu takes a tray location, a name, a caption, the width of the whole widget, the maximum number of visible items when expanded, and an optional string vector of items. The medthod <code>createLongSelectMenu</code> takes nearly the same arguments, except that it needs the width of the text box that shows the currently selected item. Also, for long menus, it is optional to specify the total width because it will automatically resize to fit the item box and the caption. You can set/get the caption, and set/get the items in many different ways. You can also manually change the selection, with the option of not firing an event. To see how to respond to menu item selection events, see the TrayListener section below.', '</p>'), ('<p>', 'A big, semi-transparent, tabby-looking label. This widget uses a different font from the rest of the widgets, and is good for section headings and such. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a15375d59b5c57059c9c6549fc5a1bfcd">OgreBites::TrayManager::createLabel</a></code> takes a caption, and an optional width. If the width is not specified, the label automatically adjusts its width to fill the tray it\'s currently in, so it matches the other contents of the tray. Labels can also be clicked. To see how to respond to label click events, see the TrayListener section below.', '</p>'), ('<p>', "A horizontal line which looks like it was etched into the tray. Good for dividing up other widgets into sections without taking up as much space as a label. <code>TrayManager::createSeparator</code> takes a tray location, name, and an optional width. If the width is not specified, the behaviour is the same as a Label's.", '</p>'), ('<p>', 'A slider bar consists of a container box, a small text box to display the value, and a track + handle. Sliders are type-agnostic. Using three parameters - a minimum value, a maximum value, and the number of "snapping points", you can give your slider track of any kind of discrete scale - integer, floating point, or even nominal. Snapping points are basically the "steps" on your slider track. By specifying how many of them there are, you are in effect specifying an entire range of values all the way from your minimum value to your maximum value. Let\'s say you have minimum value 0, maximum value 1, and 6 snapping points. Underneath the surface, each slider stores a floating point value, so in this case you would be able to display 6 floating point values: {0, 0.2, 0.4, 0.6, 0.8, 1}. The slider will display your value in the cleanest way possible (using <code><a class="el" href="class_ogre_1_1_string_converter.html#a45fb498a2f798c82bbf88116a5a34c53" title="Converts a float to a String. ">Ogre::StringConverter::toString</a></code>). This means that if all your values happen to land on integers, then they will be displayed as integers without decimals. You can also exploit this by using your slider\'s integer values as indices into an array of string values, and manually set your slider\'s value to the new string value. Basically, you can make your slider display things like Low, Medium, High, 1/4, 3/4, $4.00, N/A, etc. This requires you to respond to slider move events. More on this in the TrayListener section below. Then your Like select menus, sliders also come in two flavours - thick and long. The thick style places the caption and the value box above the track, while the long style places the caption, track, and value box side by side in that order. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a597ec173c1b424980e18fd92e0c56905">OgreBites::TrayManager::createThickSlider</a></code> takes a tray location, name, caption, total width, value box width, minimum value, maximum value, and the number of snapping points. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a321429ade975d3a63dfc1125b4375e78">OgreBites::TrayManager::createLongSlider</a></code> takes a an optional total width, track width, value box width, minimum value, maximum value, and the number of snapping points. If the total width is not specified, the slider will automatically scale to fit the track, the value box, and the caption text. You can get/set the slider\'s caption, displayed value, actual value, and range of values. When you change the range, the value is reset to be the minimum value. When you change the value, you also have the option of not firing an event. To respond to slider move events, see the TrayListener section below.', '</p>'), ('<p>', 'This panel displays an arbitrary number of parameters and their values. This could be anything you want. For example, the stats panel in the SDK samples shows the average framerate, best framerate, batch count, etc. The details panel in the SDK samples shows the texture filtering technique, the polygon mode, and the camera position and orientation. To create a ParamsPanel, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a5ae6b66603e05193b3077f30900209eb">OgreBites::TrayManager::createParamsPanel</a></code>, which takes a tray location, a name, a width, and then either a string vector of parameter names or the number of parameters (lines) to leave room for. The parameter names will be left justified, and their values will be right justified on the same line. At any time, you can set/get the parameter names and values either one at a time, or all at once using a string vector.', '</p>'), ('<p>', 'Self-explanatory. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7433f3e89c5b3a1b1b0012dfcb121f1d">OgreBites::TrayManager::createCheckBox</a></code> takes a tray location, name, caption, and an optional width. Unspecified width means auto-fit to caption. You can set/get the state of the check box, with the option of not triggering an event. To respond to check box state change events, see the TrayListener section below. ', '</p>'), ('<p>', 'This widget takes any OverlayElement template, and creates a widget out of it. If you want to put your own picture, icons, or other static objects into the trays, make an OverlayElement template out of it, and then turn it into a DecorWidget. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a24d1b3a3b95ddcf274bf899b7600deba">OgreBites::TrayManager::createDecorWidget</a></code> takes a tray location, a name, and an OverlayElement template name. These are basically the same things you would normally use to create an OverlayElement from a template. The OGRE logo in the SDK samples is a DecorWidget. ', '</p>'), ('<p>', 'A progress bar with a caption, a comment/details box, and a meter that fills up. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a431a347db6465bbf66af82ef363c875f">OgreBites::TrayManager::createProgressBar</a></code> takes a tray location, a name, a caption, a total width, and comment box width. You can use progress bars to show any kind of progress you want, but for the most common kind (loading resources), there\'s a special instance of ProgressBar already created by TrayManager which you can use. See Loading Bar below.', '</p>'), ('<p>', 'In addition to the nine trays you can place your widgets in, there is also a "null tray". This is an imaginary tray, whose location is specified by <code>TL_NONE</code>. This tray is virtual, invisible, and does not arrange widgets within it. Basically, if you place a widget in this tray, it becomes "free-floating", and you\'re allowed to manually position it anywhere on the screen. Widgets must always reside in a tray for as long as they exist, so when a widget is removed from a tray, it is automatically placed in the null tray.', '</p>'), ('<p>', 'Some widgets are so common they deserve special treatment.', '</p>'), ('<p>', 'This is not exactly one widget, but a combination of Label that displays the current FPS, and a ParamsPanel that displays advanced frame statistics (such as average FPS and batch count). Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a49e2f792fee94e75b1b472826bcc8019" title="Shows frame statistics widget set in the specified location. ">OgreBites::TrayManager::showFrameStats</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1c2e9618a3e6b061a9cfeac4f2cb55e9" title="Hides frame statistics widget set. ">OgreBites::TrayManager::hideFrameStats</a></code> to show/hide this special widget. You can choose where to put it. When the user clicks the FPS label, it toggles the visibility of the advanced frame stats, so they can be out of the way when they\'re unwanted. You can also manually toggle the visibility of the advanced frame stats using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aed00f8a1009f2ebf6806774cb894d0d7" title="Toggles visibility of advanced statistics. ">OgreBites::TrayManager::toggleAdvancedFrameStats</a></code>.', '</p>'), ('<p>', 'This is just a decor widget of the OGRE logo. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#affee57f47066e25437649d64daaa7dd9" title="Shows logo in the specified location. ">OgreBites::TrayManager::showLogo</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ac1ee637b7ef5e887170c8a9aca1c4c7b">OgreBites::TrayManager::hideLogo</a></code> to show/hide the logo. You can choose where to put it.', '</p>'), ('<p>', 'This is a progress bar that shows you the progress of your current resource loading job. The comment box will show the current resource being loaded. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a0d51005a4b148a4df2c1c6b55e34f085" title="Shows loading bar. ">OgreBites::TrayManager::showLoadingBar</a></code> before you begin your loading job. Specify the number of resource groups you will initialise, the number of groups you will load, and, if you want to, the proportion of time you think will go to initialisation (default estimate is 70%). You cannot decide where to place this loading bar. The screen will be darkened, and the loading bar will appear in the center. Any other dialog or loading bar will be closed. When you finish your loading job, call <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aab014a2c48c8f91556182e42684d44ad">OgreBites::TrayManager::hideLoadingBar</a></code>.', '</p>'), ('<p>', 'This is a dialog which tells the user something and displays an OK button. It\'s a combination of a TextBox and a Button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#abf3bd8e4ef9a6d0d76f27535a6010623" title="Pops up a message dialog with an OK button. ">OgreBites::TrayManager::showOkDialog</a></code> to display an information dialog. Specify the caption of the TextBox, and the message you want to display in it. Any other dialog or loading bar will be closed. The screen will be darkened, and the dialog will appear in the center. All other widget interactions are disabled until the dialog is closed. You can manually close a dialog using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#af5d95dcaa7c74d3345308e4f4e3035e8" title="Hides whatever dialog is currently showing. ">OgreBites::TrayManager::closeDialog</a></code>. To respond to information dialog closing events, see the TrayListenersection below.', '</p>'), ('<p>', 'Same as the Information Dialog except it asks the user something and displays a Yes button and a No button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a85d47aa11d761742884dc6457ec11cdf" title="Pops up a question dialog with Yes and No buttons. ">OgreBites::TrayManager::showYesNoDialog</a></code> to display a question dialog. Specify the caption of the TextBox, and the question you want to display in it. To respond to question dialog closing events, see the TrayListener section below.', '</p>'), ('<p>', "This class contains handlers for all the different events that your widgets can fire. The TrayManager class itself is an TrayListener, because it responds to events from its special widgets. You should extend your sample class from TrayListener as well as Sample if you want to handle widget events. If you're using SdkSample, you're all set because it's already an TrayListener. Some widgets give you an option of not firing an event when you change their state. This is helpful for initialising or resetting a widget, in which case there shouldn't be a response of any sort. For example, if you're initialising your slider bar before the scene is set up, and your slider bar is used to control some part of your scene, firing an event would cause an error. Below is a list of the different handlers. All handlers have return type void.", '</p>'), ('<p>', 'Getting access to widgets: </p><div class="fragment"><div class="line">Button* b;</div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);  <span class="comment">// by tray and position</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by tray and name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#af968c01a627ee654409f558e4ef55537">getWidgetIterator</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>).<a class="code" href="class_ogre_1_1_vector_iterator_wrapper.html#a2460c8adb6819235849de954db6a0f64">getNext</a>();  <span class="comment">// by iterator</span></div></div><!-- fragment --><p> Counting widgets: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>();  <span class="comment">// total</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);  <span class="comment">// by tray</span></div></div><!-- fragment --><p> Moving widgets to other trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div></div><!-- fragment --><p> Removing widgets from trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a04a1085bdee61d7234849663cce08664">TL_NONE</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a77ba6e4d641c146e262b6cdd2c8b04a0">clearTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9787ec5e8989bf6cfa89d03c6ddd27b6">clearAllTrays</a>();</div></div><!-- fragment --><p> Destroying widgets: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4a89cd6f7d87e0e538aa842f1a42a7bc">destroyAllWidgetsInTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aadb1f5a3b7e3b5397b10bdd3449e1603">destroyAllWidgets</a>();</div></div><!-- fragment --><p> Finding the position of a widget in a tray: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa993d2b60cfbcb903aecbff1c4896b67">locateWidgetInTray</a>(b);</div></div><!-- fragment --><p> Finding the tray a widget is in: </p><div class="fragment"><div class="line"><a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530">TrayLocation</a> trayLoc = b-&gt;getTrayLocation();</div></div><!-- fragment --><p> Changing the tray listener object: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a3235fea714a0c61e463dee69ae308be8">setListener</a>(newListener);</div></div><!-- fragment --><p> Toggling system visibility: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a075805136b2241cbb03eeb2c3d27b40d">showAll</a>();</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a188f1d5f5ca16af3b28d11ecd553105a">hideAll</a>();</div></div><!-- fragment --><p> Changing horizontal widget alignment in one tray: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#adfbbc97615fd5f1a939be6e7a1f00c07">setTrayWidgetAlignment</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <a class="code" href="group___overlays.html#gga3396780cdb2d731aa5e4389148bdc5f3a270f18cf07dbe4e75e1b790d02924205">GHA_RIGHT</a>);</div></div><!-- fragment --><p> Changing spacing and padding: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a33a3e3f66a3989dd3de48b4c4577422f">setWidgetSpacing</a>(5);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a52d3fc8638533540232232c37b257de6">setWidgetPadding</a>(3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a866229b6d88dc9d3a609115eaab46e67">setTrayPadding</a>(12);</div></div><!-- fragment --><p> Casting 3D ray from under cursor into the scene: </p><div class="fragment"><div class="line">Ray r = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9dd5d303968329462e9bf4225f59722e">getCursorRay</a>(mCamera);</div></div><!-- fragment --><p> Casting 3D ray from any 2D screen coordinate into the scene: </p><div class="fragment"><div class="line">Ray r = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#a6833f46b0303b559a050f310fa0204fc">OgreBites::TrayManager::screenToScene</a>(mCamera, Vector2(320, 240));</div></div><!-- fragment --><p> Converting a 3D scene coordinate to a 2D screen coordinate: ', '</p>'), ('<p>', "Welcome to the Volume Component of OGRE. It is a component to render volumes. It can handle any volume data but featurewise has a tedency towards terrains. The terrain aspect means, that it's all about huge meshes being displayed with high performance via a level of detail mechanism. Thanks to volume rendering, caves, cliffes, holes and similar geometry can be displayed. Also constructive solid geometry gets easy.", '</p>'), ('<p>', 'A dense list of the features:', '</p>'), ('<p>', 'This documentation is only intended for the usage of the Volume Component, not the algorithms which make it work. If you want to get to know the theory behind it, you can read the articles on this page: <a href="http://volume-gfx.com/">http://volume-gfx.com/</a>', '</p>'), ('<p>', 'Here is an example loading the volume scene from a configuration file. The configuration file must be findable by the resource system of course. Only "OgreVolumeChunk.h" has to be included. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> <a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a>();</div><div class="line">SceneNode *volumeRootNode = mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(<span class="stringliteral">&quot;VolumeParent&quot;</span>);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, mSceneMgr, <span class="stringliteral">&quot;volumeTerrain.cfg&quot;</span>);</div></div><!-- fragment --><p> The first line creates the volume chunk which is the MovableObject holding the Volume-Root. Next, a SceneNode is created where the volume(-tree) is attached to. And lastly, the volume is loaded from the configuration file "volumeTerrain.cfg". mSceneMgr is the SceneManager who should show the volume. Later, when you don\'t need it anymore, you have to free the volumeRoot Chunk via OGRE_DELETE.', '</p>'), ('<p>', 'This example skips the configuration file and loads a simple CSG-Scene: An union of a 3D Texture and a sphere with 5 LOD levels. It also setups a material LOD system. First, create a sphere with the radius 5 at the coordinates 128, 150, 128: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_sphere_source.html">Ogre::Volume::CSGSphereSource</a> sphere (5, Vector3(128, 150, 128));</div></div><!-- fragment --><p> Now a 3D texture from "volumeTerrainBig.dds" which has the world dimensions 256, 256, 256. The next flag indicates that the trilinear interpolation of the value-selection should be activated. We switch off the trilinear interpolation and the sobel filter of the normal for the sake of faster loading times: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_texture_source.html">Ogre::Volume::TextureSource</a> volumeTexture (<span class="stringliteral">&quot;volumeTerrainBig.dds&quot;</span>, 256, 256, 256, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div></div><!-- fragment --><p> Now combine them: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_union_source.html">Ogre::Volume::CSGUnionSource</a> unionSrc (&amp;sphere, &amp;volumeTexture);</div></div><!-- fragment --><p> Set the general parameters, see the comments for their meaning: </p><div class="fragment"><div class="line"><a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html">Ogre::Volume::ChunkParameters</a> parameters;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a3e154a179b8c824f79b1b426608743ad">sceneManager</a> = mSceneMgr;       <span class="comment">// The SceneManager to use</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a> = &amp;unionSrc;                <span class="comment">// The just created density source.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a4444eac27c71e02886615dcf7fbfed27">baseError</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.8;          <span class="comment">// The error of the highest LOD-level</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aa6186649b7323f937b83828eb86711fa">errorMultiplicator</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.9; <span class="comment">// The factor between each LOD-level (error = baseError * errorMultiplicator  * level)</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a986b4a97b153d50f65603ab507bb4614">skirtFactor</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.7;        <span class="comment">// Controls how long the skirts are. The lower the number, the shorter the skirts are. This saves geometry. But if they are too short, cracks might occure.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#af6ed62b76c67d04eb98424414fb1dc72">scale</a> = 10;                     <span class="comment">// The displayed volume will be scaled by this factor.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#ae125003c00de0d6c0a1a4bd6b99c4ebf">maxScreenSpaceError</a> = 30;       <span class="comment">// The screen space error controlling when the LOD-levels change.</span></div></div><!-- fragment --><p>Create the root-chunk and load now. The two vectors define the area to be scanned in the volume-source. The following integer determines the amount of LOD-levels. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> Chunk();</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(mVolumeRootNode, Vector3::ZERO, Vector3(256), 5, &amp;parameters);</div></div><!-- fragment --><p> Now setup the global volume material: ', '</p>'), ('<p>', "When you want to integrate the volume triangles in a physics engine for example, you need to hand over the exact triangles. For this scenario, the ChunkParameters hold a pointer to a ''MeshBuilderCallback'' and a number ''lodCallbackLod''. The first is an interface with a single function ''trianglesReady'' which is called, when the triangles of a chunk are ready. The chunks are chosen via the ''lodCallbackLod''. If you build a volume with 3 LOD levels and you want the triangles of the highest detail level, you set this parameter to 3. Example:", '</p>'), ('<p>', 'And using it like this: </p><div class="fragment"><div class="line"><a class="code" href="group___volume.html#ga89fbc5eed010b8802358563eb88e674a">ChunkParameters</a> parameters;</div><div class="line">...</div><div class="line">MyMeshBuilderCallback callback;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a6403e2875cc7b81aefd43ba9f22c2b31">lodCallback</a> = &amp;callback;</div><div class="line">parameters.lodCallbackLod = 3;</div><div class="line">...</div><div class="line">rootChunk-&gt;load(parent, from, to, 3, &amp;parameters);</div></div><!-- fragment --><p> Or in case of loading from a configuration file: </p><div class="fragment"><div class="line">MyMeshBuilderCallback callback;</div><div class="line">rootChunk-&gt;load(parent, sceneManager, <span class="stringliteral">&quot;myVolume.cfg&quot;</span>, 0, &amp;callback, 3);</div></div><!-- fragment --><p>You might have seen, that a pointer to a SimpleRenderable is handed in, too. This is actually the Chunk whose triangles are loaded. It\'s parent class is used to not create a circular dependency. You might get the triangle data from it, too by getting the Renderoperation.', '</p>'), ('<p>', 'When you want to do something exactly on the volume surface, you can cast rays and find their first intersection point. Behold that the triangle representation might be slightly different than the actual volume surface. And you have to scale the ray origin just like the volume. Here is an example which uses the negative z-axis of the camera as ray as it might be done like in an ego-shooter: ', '</p>'), ('<p>', "A usecase is realtime editing of volume terrain as seen as in the sample. Let's union the terrain with a sphere of the radius 2.5 and the center 123/123/123. <b>volumeRoot</b> is the Chunk instance with which the terrain was initially loaded. The factor 1.5 is just to have a save border arround the sphere which also gets updated. The rest of the parameters are 5 LOD levels and a volume mesh covering an area of 384^3. ", '</p>'), ('<p>', "Welcome to the Volume Component of OGRE. It is a component to render volumes. It can handle any volume data but featurewise has a tedency towards terrains. The terrain aspect means, that it's all about huge meshes being displayed with high performance via a level of detail mechanism. Thanks to volume rendering, caves, cliffes, holes and similar geometry can be displayed. Also constructive solid geometry gets easy.", '</p>'), ('<p>', 'A dense list of the features:', '</p>'), ('<p>', 'This documentation is only intended for the usage of the Volume Component, not the algorithms which make it work. If you want to get to know the theory behind it, you can read the articles on this page: <a href="http://volume-gfx.com/">http://volume-gfx.com/</a>', '</p>'), ('<p>', 'Here is an example loading the volume scene from a configuration file. The configuration file must be findable by the resource system of course. Only "OgreVolumeChunk.h" has to be included. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> <a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a>();</div><div class="line">SceneNode *volumeRootNode = mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(<span class="stringliteral">&quot;VolumeParent&quot;</span>);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, mSceneMgr, <span class="stringliteral">&quot;volumeTerrain.cfg&quot;</span>);</div></div><!-- fragment --><p> The first line creates the volume chunk which is the MovableObject holding the Volume-Root. Next, a SceneNode is created where the volume(-tree) is attached to. And lastly, the volume is loaded from the configuration file "volumeTerrain.cfg". mSceneMgr is the SceneManager who should show the volume. Later, when you don\'t need it anymore, you have to free the volumeRoot Chunk via OGRE_DELETE.', '</p>'), ('<p>', 'This example skips the configuration file and loads a simple CSG-Scene: An union of a 3D Texture and a sphere with 5 LOD levels. It also setups a material LOD system. First, create a sphere with the radius 5 at the coordinates 128, 150, 128: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_sphere_source.html">Ogre::Volume::CSGSphereSource</a> sphere (5, Vector3(128, 150, 128));</div></div><!-- fragment --><p> Now a 3D texture from "volumeTerrainBig.dds" which has the world dimensions 256, 256, 256. The next flag indicates that the trilinear interpolation of the value-selection should be activated. We switch off the trilinear interpolation and the sobel filter of the normal for the sake of faster loading times: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_texture_source.html">Ogre::Volume::TextureSource</a> volumeTexture (<span class="stringliteral">&quot;volumeTerrainBig.dds&quot;</span>, 256, 256, 256, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div></div><!-- fragment --><p> Now combine them: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_union_source.html">Ogre::Volume::CSGUnionSource</a> unionSrc (&amp;sphere, &amp;volumeTexture);</div></div><!-- fragment --><p> Set the general parameters, see the comments for their meaning: </p><div class="fragment"><div class="line"><a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html">Ogre::Volume::ChunkParameters</a> parameters;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a3e154a179b8c824f79b1b426608743ad">sceneManager</a> = mSceneMgr;       <span class="comment">// The SceneManager to use</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a> = &amp;unionSrc;                <span class="comment">// The just created density source.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a4444eac27c71e02886615dcf7fbfed27">baseError</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.8;          <span class="comment">// The error of the highest LOD-level</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aa6186649b7323f937b83828eb86711fa">errorMultiplicator</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.9; <span class="comment">// The factor between each LOD-level (error = baseError * errorMultiplicator  * level)</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a986b4a97b153d50f65603ab507bb4614">skirtFactor</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.7;        <span class="comment">// Controls how long the skirts are. The lower the number, the shorter the skirts are. This saves geometry. But if they are too short, cracks might occure.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#af6ed62b76c67d04eb98424414fb1dc72">scale</a> = 10;                     <span class="comment">// The displayed volume will be scaled by this factor.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#ae125003c00de0d6c0a1a4bd6b99c4ebf">maxScreenSpaceError</a> = 30;       <span class="comment">// The screen space error controlling when the LOD-levels change.</span></div></div><!-- fragment --><p>Create the root-chunk and load now. The two vectors define the area to be scanned in the volume-source. The following integer determines the amount of LOD-levels. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> Chunk();</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(mVolumeRootNode, Vector3::ZERO, Vector3(256), 5, &amp;parameters);</div></div><!-- fragment --><p> Now setup the global volume material: ', '</p>'), ('<p>', "When you want to integrate the volume triangles in a physics engine for example, you need to hand over the exact triangles. For this scenario, the ChunkParameters hold a pointer to a ''MeshBuilderCallback'' and a number ''lodCallbackLod''. The first is an interface with a single function ''trianglesReady'' which is called, when the triangles of a chunk are ready. The chunks are chosen via the ''lodCallbackLod''. If you build a volume with 3 LOD levels and you want the triangles of the highest detail level, you set this parameter to 3. Example:", '</p>'), ('<p>', 'And using it like this: </p><div class="fragment"><div class="line"><a class="code" href="group___volume.html#ga89fbc5eed010b8802358563eb88e674a">ChunkParameters</a> parameters;</div><div class="line">...</div><div class="line">MyMeshBuilderCallback callback;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a6403e2875cc7b81aefd43ba9f22c2b31">lodCallback</a> = &amp;callback;</div><div class="line">parameters.lodCallbackLod = 3;</div><div class="line">...</div><div class="line">rootChunk-&gt;load(parent, from, to, 3, &amp;parameters);</div></div><!-- fragment --><p> Or in case of loading from a configuration file: </p><div class="fragment"><div class="line">MyMeshBuilderCallback callback;</div><div class="line">rootChunk-&gt;load(parent, sceneManager, <span class="stringliteral">&quot;myVolume.cfg&quot;</span>, 0, &amp;callback, 3);</div></div><!-- fragment --><p>You might have seen, that a pointer to a SimpleRenderable is handed in, too. This is actually the Chunk whose triangles are loaded. It\'s parent class is used to not create a circular dependency. You might get the triangle data from it, too by getting the Renderoperation.', '</p>'), ('<p>', 'When you want to do something exactly on the volume surface, you can cast rays and find their first intersection point. Behold that the triangle representation might be slightly different than the actual volume surface. And you have to scale the ray origin just like the volume. Here is an example which uses the negative z-axis of the camera as ray as it might be done like in an ego-shooter: ', '</p>'), ('<p>', "A usecase is realtime editing of volume terrain as seen as in the sample. Let's union the terrain with a sphere of the radius 2.5 and the center 123/123/123. <b>volumeRoot</b> is the Chunk instance with which the terrain was initially loaded. The factor 1.5 is just to have a save border arround the sphere which also gets updated. The rest of the parameters are 5 LOD levels and a volume mesh covering an area of 384^3. ", '</p>'), ('<p>', "Welcome to the Volume Component of OGRE. It is a component to render volumes. It can handle any volume data but featurewise has a tedency towards terrains. The terrain aspect means, that it's all about huge meshes being displayed with high performance via a level of detail mechanism. Thanks to volume rendering, caves, cliffes, holes and similar geometry can be displayed. Also constructive solid geometry gets easy.", '</p>'), ('<p>', 'A dense list of the features:', '</p>'), ('<p>', 'This documentation is only intended for the usage of the Volume Component, not the algorithms which make it work. If you want to get to know the theory behind it, you can read the articles on this page: <a href="http://volume-gfx.com/">http://volume-gfx.com/</a>', '</p>'), ('<p>', 'Here is an example loading the volume scene from a configuration file. The configuration file must be findable by the resource system of course. Only "OgreVolumeChunk.h" has to be included. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> <a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a>();</div><div class="line">SceneNode *volumeRootNode = mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(<span class="stringliteral">&quot;VolumeParent&quot;</span>);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, mSceneMgr, <span class="stringliteral">&quot;volumeTerrain.cfg&quot;</span>);</div></div><!-- fragment --><p> The first line creates the volume chunk which is the MovableObject holding the Volume-Root. Next, a SceneNode is created where the volume(-tree) is attached to. And lastly, the volume is loaded from the configuration file "volumeTerrain.cfg". mSceneMgr is the SceneManager who should show the volume. Later, when you don\'t need it anymore, you have to free the volumeRoot Chunk via OGRE_DELETE.', '</p>'), ('<p>', 'This example skips the configuration file and loads a simple CSG-Scene: An union of a 3D Texture and a sphere with 5 LOD levels. It also setups a material LOD system. First, create a sphere with the radius 5 at the coordinates 128, 150, 128: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_sphere_source.html">Ogre::Volume::CSGSphereSource</a> sphere (5, Vector3(128, 150, 128));</div></div><!-- fragment --><p> Now a 3D texture from "volumeTerrainBig.dds" which has the world dimensions 256, 256, 256. The next flag indicates that the trilinear interpolation of the value-selection should be activated. We switch off the trilinear interpolation and the sobel filter of the normal for the sake of faster loading times: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_texture_source.html">Ogre::Volume::TextureSource</a> volumeTexture (<span class="stringliteral">&quot;volumeTerrainBig.dds&quot;</span>, 256, 256, 256, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div></div><!-- fragment --><p> Now combine them: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_union_source.html">Ogre::Volume::CSGUnionSource</a> unionSrc (&amp;sphere, &amp;volumeTexture);</div></div><!-- fragment --><p> Set the general parameters, see the comments for their meaning: </p><div class="fragment"><div class="line"><a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html">Ogre::Volume::ChunkParameters</a> parameters;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a3e154a179b8c824f79b1b426608743ad">sceneManager</a> = mSceneMgr;       <span class="comment">// The SceneManager to use</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a> = &amp;unionSrc;                <span class="comment">// The just created density source.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a4444eac27c71e02886615dcf7fbfed27">baseError</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.8;          <span class="comment">// The error of the highest LOD-level</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aa6186649b7323f937b83828eb86711fa">errorMultiplicator</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.9; <span class="comment">// The factor between each LOD-level (error = baseError * errorMultiplicator  * level)</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a986b4a97b153d50f65603ab507bb4614">skirtFactor</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.7;        <span class="comment">// Controls how long the skirts are. The lower the number, the shorter the skirts are. This saves geometry. But if they are too short, cracks might occure.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#af6ed62b76c67d04eb98424414fb1dc72">scale</a> = 10;                     <span class="comment">// The displayed volume will be scaled by this factor.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#ae125003c00de0d6c0a1a4bd6b99c4ebf">maxScreenSpaceError</a> = 30;       <span class="comment">// The screen space error controlling when the LOD-levels change.</span></div></div><!-- fragment --><p>Create the root-chunk and load now. The two vectors define the area to be scanned in the volume-source. The following integer determines the amount of LOD-levels. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> Chunk();</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(mVolumeRootNode, Vector3::ZERO, Vector3(256), 5, &amp;parameters);</div></div><!-- fragment --><p> Now setup the global volume material: ', '</p>'), ('<p>', "When you want to integrate the volume triangles in a physics engine for example, you need to hand over the exact triangles. For this scenario, the ChunkParameters hold a pointer to a ''MeshBuilderCallback'' and a number ''lodCallbackLod''. The first is an interface with a single function ''trianglesReady'' which is called, when the triangles of a chunk are ready. The chunks are chosen via the ''lodCallbackLod''. If you build a volume with 3 LOD levels and you want the triangles of the highest detail level, you set this parameter to 3. Example:", '</p>'), ('<p>', 'And using it like this: </p><div class="fragment"><div class="line"><a class="code" href="group___volume.html#ga89fbc5eed010b8802358563eb88e674a">ChunkParameters</a> parameters;</div><div class="line">...</div><div class="line">MyMeshBuilderCallback callback;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a6403e2875cc7b81aefd43ba9f22c2b31">lodCallback</a> = &amp;callback;</div><div class="line">parameters.lodCallbackLod = 3;</div><div class="line">...</div><div class="line">rootChunk-&gt;load(parent, from, to, 3, &amp;parameters);</div></div><!-- fragment --><p> Or in case of loading from a configuration file: </p><div class="fragment"><div class="line">MyMeshBuilderCallback callback;</div><div class="line">rootChunk-&gt;load(parent, sceneManager, <span class="stringliteral">&quot;myVolume.cfg&quot;</span>, 0, &amp;callback, 3);</div></div><!-- fragment --><p>You might have seen, that a pointer to a SimpleRenderable is handed in, too. This is actually the Chunk whose triangles are loaded. It\'s parent class is used to not create a circular dependency. You might get the triangle data from it, too by getting the Renderoperation.', '</p>'), ('<p>', 'When you want to do something exactly on the volume surface, you can cast rays and find their first intersection point. Behold that the triangle representation might be slightly different than the actual volume surface. And you have to scale the ray origin just like the volume. Here is an example which uses the negative z-axis of the camera as ray as it might be done like in an ego-shooter: ', '</p>'), ('<p>', "A usecase is realtime editing of volume terrain as seen as in the sample. Let's union the terrain with a sphere of the radius 2.5 and the center 123/123/123. <b>volumeRoot</b> is the Chunk instance with which the terrain was initially loaded. The factor 1.5 is just to have a save border arround the sphere which also gets updated. The rest of the parameters are 5 LOD levels and a volume mesh covering an area of 384^3. ", '</p>'), ('<p>', "Ever wanted really simple GUI controls for your sample? Don't want to write one from scratch, but CEGUI's just a little too much? The Trays system was created to address this issue. It's a simple GUI system based on the OGRE Overlay system and designed just for samples. Because it's simple, you're not going to be able to skin it or build very unique interfaces, but you'll also find it much easier to use. The entire system is based on the OGRE Overlay system.", '</p>'), ('<p>', 'Why trays? The concept of trays is central to the system in that it removes the need for the GUI designer (you) to calculate or specify positional coordinates of any kind. Think about the widget locations in a typical GUI. They are almost always in any of the four corners, along any of the four edges or, on the rare occasion, in the center of the screen. In Trays, there are nine "trays", one in each of the locations previously mentioned. When you create a widget, you specify one of these nine locations, and the widget will be added to the tray at that location. Your widget will be added directly beneath the last widget in that tray. When you add a widget to a tray, the tray grows in size. Trays along the top of the screen grow downward, Trays along the bottom grow upward, and the trays in the middle row grow vertically in both directions. Visually, the trays are semi-transparent panels that fit the widgets they contain. Only non-empty trays are visible. If this is hard to visualise, don\'t worry, here\'s a picture to help you out. ', '</p>'), ('<p>', 'To use Trays, you have to create an TrayManager. This is the class through which you will create and manage all your widgets, manipulate the cursor, change the backdrop image, adjust tray properties, pop up dialogs, show/hide the loading bar, etc. You can have multiple tray managers in one application. For example, the OGRE Sample Browser uses its own tray manager and hides it when a sample is running, and the SDK samples also have their own tray managers, which are hidden when the samples are paused by the browser. The TrayManager requires "Trays.zip", so you can only create it after loading that resource. Also, make sure you\'re using the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> namespace (Trays is part of the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Samples Framework). Create your tray manager like so: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>* mTrayMgr = <span class="keyword">new</span> <a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>(<span class="stringliteral">&quot;InterfaceName&quot;</span>, mWindow, <span class="keyword">this</span>);</div></div><!-- fragment --><p> You must pass in a name for your interface, an <code><a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a></code> and an <code><a class="el" href="class_ogre_bites_1_1_tray_listener.html" title="Listener class for responding to tray events. ">OgreBites::TrayListener</a></code>. You can extend your sample or sample context to be a tray listener. Destroy your tray manager like so: </p><div class="fragment"><div class="line"><span class="keyword">delete</span> mTrayMgr;</div><div class="line">mTrayMgr = 0;</div></div><!-- fragment --><p> Once you have your tray manager, make sure you relay your OIS events to it. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> mousePressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseDown(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseReleased(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseUp(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseMoved(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_motion_event.html">OgreBites::MouseMotionEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseMove(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> The injection methods return true if the event was relevant to the tray manager, and should not be processed again by you. For example, if you click a button that is over an interactive part of your scene, you want the button to be pressed, but you don\'t want the scene interaction to take place. So the injection methods double as filters for your mouse events.', '</p>'), ('<p>', 'You\'re now free to create widgets! Try adding a button to the top-left tray: </p><div class="fragment"><div class="line">Button* b = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">createButton</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530afe04de8736168ab0dd6e7938e679c292">TL_TOPLEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <span class="stringliteral">&quot;Click Me!&quot;</span>);</div></div><!-- fragment --><p> TrayManager is a huge class, and you can do tons of things with it. For some examples, see the Things to Try section below.', '</p>'), ('<p>', 'The cursor has three parts in the Trays system: The layer it moves around in Overlay, the container which positions the cursor (OverlayContainer), and the cursor image, which is a child of the container (OverlayElement). When hiding/showing the cursor, the entire cursor layer is hidden/shown. The top left corner of the cursor container is used as the hotspot of the cursor. By positioning the cursor image relative to the cursor container, you can basically decide which part of the cursor image is the "clicking part". For the default arrow cursor, the image is simply lined up with the container, meaning the top left is the hotspot. However, for something like a crosshair cursor, you could move the cursor image so that its center is over the top left corner of the cursor container. To show the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1cc48ac157278b5845d425abbe9acefd" title="Displays specified material on cursor, or the last material used if none specified. ">OgreBites::TrayManager::showCursor</a></code>, which takes an optional material name for the cursor image. If unspecified, the cursor image is not changed. To hide the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a979ff2ad2d729223259b3bebb237cafb">OgreBites::TrayManager::hideCursor</a></code>. You can get the cursor\'s different parts using getCursorLayer, getCursorContainer, and getCursorImage. Note that if the cursor is hidden, all interactions with widgets are disabled.', '</p>'), ('<p>', 'If you want to show a backdrop, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ad554418c27edb907f0e3bead8659b83c" title="Displays specified material on backdrop, or the last material used if none specified. ">OgreBites::TrayManager::showBackdrop</a></code>, which takes an optional material name for the backdrop. If unspecified, the backdrop image is not changed. To hide it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a6129a1e92ac22789a4602cf36f9c5394">OgreBites::TrayManager::hideBackdrop</a></code>.', '</p>'), ('<p>', 'There are 10 basic widgets. Each widget is just an instance of an OverlayElement template, and all widgets use {LEX()}pixel{LEX} metrics. You can get access to any widget\'s underlying OverlayElement through <code><a class="el" href="class_ogre_bites_1_1_widget.html#a379d3f1a2ca6eaf13fc5c52afaafd0d2">OgreBites::Widget::getOverlayElement</a></code>. Do not instantiate and delete widgets manually. Create and destroy them using the TrayManager. The first argument to any one of TrayManager\'s widget creation methods is the location of the tray you want the widget to be in. This is of the enumerated type TrayLocation. The second argument is the name of your widget (this is not your widget\'s caption, but a unique string identifier for your widget). The rest of the arguments are specific to the type of widget.', '</p>'), ('<p>', 'This is the most basic widget of all. To create a button, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">OgreBites::TrayManager::createButton</a></code>. In addition to a tray location and a name, you must specify a caption for your button, and an optional width. If width is not specified, the button will automatically resize to fit its caption. There are no button states. You only get notified when a button is pushed. To see how to respond to button push events, see the TrayListener section below.', '</p>'), ('<p>', 'This widget consists of a bold caption bar and a text area that can be scrolled vertically. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a07a8d212939266339e877ff2118250a6">OgreBites::TrayManager::createTextBox</a></code> takes a caption, width, and height. You can set/get the caption, the text area contents, text padding, text alignment, manually change the scroll bar position, among other things.', '</p>'), ('<p>', 'A basic drop-down menu. To create it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a60864ca00d65b2bf1b97bb8545fab737">OgreBites::TrayManager::createLongSelectMenu</a></code> or <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a98f478c8daa5084b53146de03adbc216">OgreBites::TrayManager::createThickSelectMenu</a></code>. Both these methods return a SelectMenu object, but they give one of two different visual styles to the widget. One is thicker, but shorter, because it places the caption over the item box. This style of menu is good for putting in the side trays. The other is longer, but thinner, because it places the item box next to the caption. This style of menu is good for putting in the top or bottom trays. createThickSelectMenu takes a tray location, a name, a caption, the width of the whole widget, the maximum number of visible items when expanded, and an optional string vector of items. The medthod <code>createLongSelectMenu</code> takes nearly the same arguments, except that it needs the width of the text box that shows the currently selected item. Also, for long menus, it is optional to specify the total width because it will automatically resize to fit the item box and the caption. You can set/get the caption, and set/get the items in many different ways. You can also manually change the selection, with the option of not firing an event. To see how to respond to menu item selection events, see the TrayListener section below.', '</p>'), ('<p>', 'A big, semi-transparent, tabby-looking label. This widget uses a different font from the rest of the widgets, and is good for section headings and such. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a15375d59b5c57059c9c6549fc5a1bfcd">OgreBites::TrayManager::createLabel</a></code> takes a caption, and an optional width. If the width is not specified, the label automatically adjusts its width to fill the tray it\'s currently in, so it matches the other contents of the tray. Labels can also be clicked. To see how to respond to label click events, see the TrayListener section below.', '</p>'), ('<p>', "A horizontal line which looks like it was etched into the tray. Good for dividing up other widgets into sections without taking up as much space as a label. <code>TrayManager::createSeparator</code> takes a tray location, name, and an optional width. If the width is not specified, the behaviour is the same as a Label's.", '</p>'), ('<p>', 'A slider bar consists of a container box, a small text box to display the value, and a track + handle. Sliders are type-agnostic. Using three parameters - a minimum value, a maximum value, and the number of "snapping points", you can give your slider track of any kind of discrete scale - integer, floating point, or even nominal. Snapping points are basically the "steps" on your slider track. By specifying how many of them there are, you are in effect specifying an entire range of values all the way from your minimum value to your maximum value. Let\'s say you have minimum value 0, maximum value 1, and 6 snapping points. Underneath the surface, each slider stores a floating point value, so in this case you would be able to display 6 floating point values: {0, 0.2, 0.4, 0.6, 0.8, 1}. The slider will display your value in the cleanest way possible (using <code><a class="el" href="class_ogre_1_1_string_converter.html#a45fb498a2f798c82bbf88116a5a34c53" title="Converts a float to a String. ">Ogre::StringConverter::toString</a></code>). This means that if all your values happen to land on integers, then they will be displayed as integers without decimals. You can also exploit this by using your slider\'s integer values as indices into an array of string values, and manually set your slider\'s value to the new string value. Basically, you can make your slider display things like Low, Medium, High, 1/4, 3/4, $4.00, N/A, etc. This requires you to respond to slider move events. More on this in the TrayListener section below. Then your Like select menus, sliders also come in two flavours - thick and long. The thick style places the caption and the value box above the track, while the long style places the caption, track, and value box side by side in that order. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a597ec173c1b424980e18fd92e0c56905">OgreBites::TrayManager::createThickSlider</a></code> takes a tray location, name, caption, total width, value box width, minimum value, maximum value, and the number of snapping points. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a321429ade975d3a63dfc1125b4375e78">OgreBites::TrayManager::createLongSlider</a></code> takes a an optional total width, track width, value box width, minimum value, maximum value, and the number of snapping points. If the total width is not specified, the slider will automatically scale to fit the track, the value box, and the caption text. You can get/set the slider\'s caption, displayed value, actual value, and range of values. When you change the range, the value is reset to be the minimum value. When you change the value, you also have the option of not firing an event. To respond to slider move events, see the TrayListener section below.', '</p>'), ('<p>', 'This panel displays an arbitrary number of parameters and their values. This could be anything you want. For example, the stats panel in the SDK samples shows the average framerate, best framerate, batch count, etc. The details panel in the SDK samples shows the texture filtering technique, the polygon mode, and the camera position and orientation. To create a ParamsPanel, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a5ae6b66603e05193b3077f30900209eb">OgreBites::TrayManager::createParamsPanel</a></code>, which takes a tray location, a name, a width, and then either a string vector of parameter names or the number of parameters (lines) to leave room for. The parameter names will be left justified, and their values will be right justified on the same line. At any time, you can set/get the parameter names and values either one at a time, or all at once using a string vector.', '</p>'), ('<p>', 'Self-explanatory. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7433f3e89c5b3a1b1b0012dfcb121f1d">OgreBites::TrayManager::createCheckBox</a></code> takes a tray location, name, caption, and an optional width. Unspecified width means auto-fit to caption. You can set/get the state of the check box, with the option of not triggering an event. To respond to check box state change events, see the TrayListener section below. ', '</p>'), ('<p>', 'This widget takes any OverlayElement template, and creates a widget out of it. If you want to put your own picture, icons, or other static objects into the trays, make an OverlayElement template out of it, and then turn it into a DecorWidget. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a24d1b3a3b95ddcf274bf899b7600deba">OgreBites::TrayManager::createDecorWidget</a></code> takes a tray location, a name, and an OverlayElement template name. These are basically the same things you would normally use to create an OverlayElement from a template. The OGRE logo in the SDK samples is a DecorWidget. ', '</p>'), ('<p>', 'A progress bar with a caption, a comment/details box, and a meter that fills up. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a431a347db6465bbf66af82ef363c875f">OgreBites::TrayManager::createProgressBar</a></code> takes a tray location, a name, a caption, a total width, and comment box width. You can use progress bars to show any kind of progress you want, but for the most common kind (loading resources), there\'s a special instance of ProgressBar already created by TrayManager which you can use. See Loading Bar below.', '</p>'), ('<p>', 'In addition to the nine trays you can place your widgets in, there is also a "null tray". This is an imaginary tray, whose location is specified by <code>TL_NONE</code>. This tray is virtual, invisible, and does not arrange widgets within it. Basically, if you place a widget in this tray, it becomes "free-floating", and you\'re allowed to manually position it anywhere on the screen. Widgets must always reside in a tray for as long as they exist, so when a widget is removed from a tray, it is automatically placed in the null tray.', '</p>'), ('<p>', 'Some widgets are so common they deserve special treatment.', '</p>'), ('<p>', 'This is not exactly one widget, but a combination of Label that displays the current FPS, and a ParamsPanel that displays advanced frame statistics (such as average FPS and batch count). Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a49e2f792fee94e75b1b472826bcc8019" title="Shows frame statistics widget set in the specified location. ">OgreBites::TrayManager::showFrameStats</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1c2e9618a3e6b061a9cfeac4f2cb55e9" title="Hides frame statistics widget set. ">OgreBites::TrayManager::hideFrameStats</a></code> to show/hide this special widget. You can choose where to put it. When the user clicks the FPS label, it toggles the visibility of the advanced frame stats, so they can be out of the way when they\'re unwanted. You can also manually toggle the visibility of the advanced frame stats using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aed00f8a1009f2ebf6806774cb894d0d7" title="Toggles visibility of advanced statistics. ">OgreBites::TrayManager::toggleAdvancedFrameStats</a></code>.', '</p>'), ('<p>', 'This is just a decor widget of the OGRE logo. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#affee57f47066e25437649d64daaa7dd9" title="Shows logo in the specified location. ">OgreBites::TrayManager::showLogo</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ac1ee637b7ef5e887170c8a9aca1c4c7b">OgreBites::TrayManager::hideLogo</a></code> to show/hide the logo. You can choose where to put it.', '</p>'), ('<p>', 'This is a progress bar that shows you the progress of your current resource loading job. The comment box will show the current resource being loaded. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a0d51005a4b148a4df2c1c6b55e34f085" title="Shows loading bar. ">OgreBites::TrayManager::showLoadingBar</a></code> before you begin your loading job. Specify the number of resource groups you will initialise, the number of groups you will load, and, if you want to, the proportion of time you think will go to initialisation (default estimate is 70%). You cannot decide where to place this loading bar. The screen will be darkened, and the loading bar will appear in the center. Any other dialog or loading bar will be closed. When you finish your loading job, call <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aab014a2c48c8f91556182e42684d44ad">OgreBites::TrayManager::hideLoadingBar</a></code>.', '</p>'), ('<p>', 'This is a dialog which tells the user something and displays an OK button. It\'s a combination of a TextBox and a Button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#abf3bd8e4ef9a6d0d76f27535a6010623" title="Pops up a message dialog with an OK button. ">OgreBites::TrayManager::showOkDialog</a></code> to display an information dialog. Specify the caption of the TextBox, and the message you want to display in it. Any other dialog or loading bar will be closed. The screen will be darkened, and the dialog will appear in the center. All other widget interactions are disabled until the dialog is closed. You can manually close a dialog using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#af5d95dcaa7c74d3345308e4f4e3035e8" title="Hides whatever dialog is currently showing. ">OgreBites::TrayManager::closeDialog</a></code>. To respond to information dialog closing events, see the TrayListenersection below.', '</p>'), ('<p>', 'Same as the Information Dialog except it asks the user something and displays a Yes button and a No button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a85d47aa11d761742884dc6457ec11cdf" title="Pops up a question dialog with Yes and No buttons. ">OgreBites::TrayManager::showYesNoDialog</a></code> to display a question dialog. Specify the caption of the TextBox, and the question you want to display in it. To respond to question dialog closing events, see the TrayListener section below.', '</p>'), ('<p>', "This class contains handlers for all the different events that your widgets can fire. The TrayManager class itself is an TrayListener, because it responds to events from its special widgets. You should extend your sample class from TrayListener as well as Sample if you want to handle widget events. If you're using SdkSample, you're all set because it's already an TrayListener. Some widgets give you an option of not firing an event when you change their state. This is helpful for initialising or resetting a widget, in which case there shouldn't be a response of any sort. For example, if you're initialising your slider bar before the scene is set up, and your slider bar is used to control some part of your scene, firing an event would cause an error. Below is a list of the different handlers. All handlers have return type void.", '</p>'), ('<p>', 'Getting access to widgets: </p><div class="fragment"><div class="line">Button* b;</div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);  <span class="comment">// by tray and position</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by tray and name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#af968c01a627ee654409f558e4ef55537">getWidgetIterator</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>).<a class="code" href="class_ogre_1_1_vector_iterator_wrapper.html#a2460c8adb6819235849de954db6a0f64">getNext</a>();  <span class="comment">// by iterator</span></div></div><!-- fragment --><p> Counting widgets: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>();  <span class="comment">// total</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);  <span class="comment">// by tray</span></div></div><!-- fragment --><p> Moving widgets to other trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div></div><!-- fragment --><p> Removing widgets from trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a04a1085bdee61d7234849663cce08664">TL_NONE</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a77ba6e4d641c146e262b6cdd2c8b04a0">clearTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9787ec5e8989bf6cfa89d03c6ddd27b6">clearAllTrays</a>();</div></div><!-- fragment --><p> Destroying widgets: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4a89cd6f7d87e0e538aa842f1a42a7bc">destroyAllWidgetsInTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aadb1f5a3b7e3b5397b10bdd3449e1603">destroyAllWidgets</a>();</div></div><!-- fragment --><p> Finding the position of a widget in a tray: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa993d2b60cfbcb903aecbff1c4896b67">locateWidgetInTray</a>(b);</div></div><!-- fragment --><p> Finding the tray a widget is in: </p><div class="fragment"><div class="line"><a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530">TrayLocation</a> trayLoc = b-&gt;getTrayLocation();</div></div><!-- fragment --><p> Changing the tray listener object: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a3235fea714a0c61e463dee69ae308be8">setListener</a>(newListener);</div></div><!-- fragment --><p> Toggling system visibility: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a075805136b2241cbb03eeb2c3d27b40d">showAll</a>();</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a188f1d5f5ca16af3b28d11ecd553105a">hideAll</a>();</div></div><!-- fragment --><p> Changing horizontal widget alignment in one tray: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#adfbbc97615fd5f1a939be6e7a1f00c07">setTrayWidgetAlignment</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <a class="code" href="group___overlays.html#gga3396780cdb2d731aa5e4389148bdc5f3a270f18cf07dbe4e75e1b790d02924205">GHA_RIGHT</a>);</div></div><!-- fragment --><p> Changing spacing and padding: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a33a3e3f66a3989dd3de48b4c4577422f">setWidgetSpacing</a>(5);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a52d3fc8638533540232232c37b257de6">setWidgetPadding</a>(3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a866229b6d88dc9d3a609115eaab46e67">setTrayPadding</a>(12);</div></div><!-- fragment --><p> Casting 3D ray from under cursor into the scene: </p><div class="fragment"><div class="line">Ray r = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9dd5d303968329462e9bf4225f59722e">getCursorRay</a>(mCamera);</div></div><!-- fragment --><p> Casting 3D ray from any 2D screen coordinate into the scene: </p><div class="fragment"><div class="line">Ray r = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#a6833f46b0303b559a050f310fa0204fc">OgreBites::TrayManager::screenToScene</a>(mCamera, Vector2(320, 240));</div></div><!-- fragment --><p> Converting a 3D scene coordinate to a 2D screen coordinate: ', '</p>'), ('<p>', "Ever wanted really simple GUI controls for your sample? Don't want to write one from scratch, but CEGUI's just a little too much? The Trays system was created to address this issue. It's a simple GUI system based on the OGRE Overlay system and designed just for samples. Because it's simple, you're not going to be able to skin it or build very unique interfaces, but you'll also find it much easier to use. The entire system is based on the OGRE Overlay system.", '</p>'), ('<p>', 'Why trays? The concept of trays is central to the system in that it removes the need for the GUI designer (you) to calculate or specify positional coordinates of any kind. Think about the widget locations in a typical GUI. They are almost always in any of the four corners, along any of the four edges or, on the rare occasion, in the center of the screen. In Trays, there are nine "trays", one in each of the locations previously mentioned. When you create a widget, you specify one of these nine locations, and the widget will be added to the tray at that location. Your widget will be added directly beneath the last widget in that tray. When you add a widget to a tray, the tray grows in size. Trays along the top of the screen grow downward, Trays along the bottom grow upward, and the trays in the middle row grow vertically in both directions. Visually, the trays are semi-transparent panels that fit the widgets they contain. Only non-empty trays are visible. If this is hard to visualise, don\'t worry, here\'s a picture to help you out. ', '</p>'), ('<p>', 'To use Trays, you have to create an TrayManager. This is the class through which you will create and manage all your widgets, manipulate the cursor, change the backdrop image, adjust tray properties, pop up dialogs, show/hide the loading bar, etc. You can have multiple tray managers in one application. For example, the OGRE Sample Browser uses its own tray manager and hides it when a sample is running, and the SDK samples also have their own tray managers, which are hidden when the samples are paused by the browser. The TrayManager requires "Trays.zip", so you can only create it after loading that resource. Also, make sure you\'re using the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> namespace (Trays is part of the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Samples Framework). Create your tray manager like so: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>* mTrayMgr = <span class="keyword">new</span> <a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>(<span class="stringliteral">&quot;InterfaceName&quot;</span>, mWindow, <span class="keyword">this</span>);</div></div><!-- fragment --><p> You must pass in a name for your interface, an <code><a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a></code> and an <code><a class="el" href="class_ogre_bites_1_1_tray_listener.html" title="Listener class for responding to tray events. ">OgreBites::TrayListener</a></code>. You can extend your sample or sample context to be a tray listener. Destroy your tray manager like so: </p><div class="fragment"><div class="line"><span class="keyword">delete</span> mTrayMgr;</div><div class="line">mTrayMgr = 0;</div></div><!-- fragment --><p> Once you have your tray manager, make sure you relay your OIS events to it. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> mousePressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseDown(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseReleased(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseUp(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseMoved(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_motion_event.html">OgreBites::MouseMotionEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseMove(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> The injection methods return true if the event was relevant to the tray manager, and should not be processed again by you. For example, if you click a button that is over an interactive part of your scene, you want the button to be pressed, but you don\'t want the scene interaction to take place. So the injection methods double as filters for your mouse events.', '</p>'), ('<p>', 'You\'re now free to create widgets! Try adding a button to the top-left tray: </p><div class="fragment"><div class="line">Button* b = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">createButton</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530afe04de8736168ab0dd6e7938e679c292">TL_TOPLEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <span class="stringliteral">&quot;Click Me!&quot;</span>);</div></div><!-- fragment --><p> TrayManager is a huge class, and you can do tons of things with it. For some examples, see the Things to Try section below.', '</p>'), ('<p>', 'The cursor has three parts in the Trays system: The layer it moves around in Overlay, the container which positions the cursor (OverlayContainer), and the cursor image, which is a child of the container (OverlayElement). When hiding/showing the cursor, the entire cursor layer is hidden/shown. The top left corner of the cursor container is used as the hotspot of the cursor. By positioning the cursor image relative to the cursor container, you can basically decide which part of the cursor image is the "clicking part". For the default arrow cursor, the image is simply lined up with the container, meaning the top left is the hotspot. However, for something like a crosshair cursor, you could move the cursor image so that its center is over the top left corner of the cursor container. To show the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1cc48ac157278b5845d425abbe9acefd" title="Displays specified material on cursor, or the last material used if none specified. ">OgreBites::TrayManager::showCursor</a></code>, which takes an optional material name for the cursor image. If unspecified, the cursor image is not changed. To hide the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a979ff2ad2d729223259b3bebb237cafb">OgreBites::TrayManager::hideCursor</a></code>. You can get the cursor\'s different parts using getCursorLayer, getCursorContainer, and getCursorImage. Note that if the cursor is hidden, all interactions with widgets are disabled.', '</p>'), ('<p>', 'If you want to show a backdrop, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ad554418c27edb907f0e3bead8659b83c" title="Displays specified material on backdrop, or the last material used if none specified. ">OgreBites::TrayManager::showBackdrop</a></code>, which takes an optional material name for the backdrop. If unspecified, the backdrop image is not changed. To hide it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a6129a1e92ac22789a4602cf36f9c5394">OgreBites::TrayManager::hideBackdrop</a></code>.', '</p>'), ('<p>', 'There are 10 basic widgets. Each widget is just an instance of an OverlayElement template, and all widgets use {LEX()}pixel{LEX} metrics. You can get access to any widget\'s underlying OverlayElement through <code><a class="el" href="class_ogre_bites_1_1_widget.html#a379d3f1a2ca6eaf13fc5c52afaafd0d2">OgreBites::Widget::getOverlayElement</a></code>. Do not instantiate and delete widgets manually. Create and destroy them using the TrayManager. The first argument to any one of TrayManager\'s widget creation methods is the location of the tray you want the widget to be in. This is of the enumerated type TrayLocation. The second argument is the name of your widget (this is not your widget\'s caption, but a unique string identifier for your widget). The rest of the arguments are specific to the type of widget.', '</p>'), ('<p>', 'This is the most basic widget of all. To create a button, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">OgreBites::TrayManager::createButton</a></code>. In addition to a tray location and a name, you must specify a caption for your button, and an optional width. If width is not specified, the button will automatically resize to fit its caption. There are no button states. You only get notified when a button is pushed. To see how to respond to button push events, see the TrayListener section below.', '</p>'), ('<p>', 'This widget consists of a bold caption bar and a text area that can be scrolled vertically. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a07a8d212939266339e877ff2118250a6">OgreBites::TrayManager::createTextBox</a></code> takes a caption, width, and height. You can set/get the caption, the text area contents, text padding, text alignment, manually change the scroll bar position, among other things.', '</p>'), ('<p>', 'A basic drop-down menu. To create it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a60864ca00d65b2bf1b97bb8545fab737">OgreBites::TrayManager::createLongSelectMenu</a></code> or <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a98f478c8daa5084b53146de03adbc216">OgreBites::TrayManager::createThickSelectMenu</a></code>. Both these methods return a SelectMenu object, but they give one of two different visual styles to the widget. One is thicker, but shorter, because it places the caption over the item box. This style of menu is good for putting in the side trays. The other is longer, but thinner, because it places the item box next to the caption. This style of menu is good for putting in the top or bottom trays. createThickSelectMenu takes a tray location, a name, a caption, the width of the whole widget, the maximum number of visible items when expanded, and an optional string vector of items. The medthod <code>createLongSelectMenu</code> takes nearly the same arguments, except that it needs the width of the text box that shows the currently selected item. Also, for long menus, it is optional to specify the total width because it will automatically resize to fit the item box and the caption. You can set/get the caption, and set/get the items in many different ways. You can also manually change the selection, with the option of not firing an event. To see how to respond to menu item selection events, see the TrayListener section below.', '</p>'), ('<p>', 'A big, semi-transparent, tabby-looking label. This widget uses a different font from the rest of the widgets, and is good for section headings and such. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a15375d59b5c57059c9c6549fc5a1bfcd">OgreBites::TrayManager::createLabel</a></code> takes a caption, and an optional width. If the width is not specified, the label automatically adjusts its width to fill the tray it\'s currently in, so it matches the other contents of the tray. Labels can also be clicked. To see how to respond to label click events, see the TrayListener section below.', '</p>'), ('<p>', "A horizontal line which looks like it was etched into the tray. Good for dividing up other widgets into sections without taking up as much space as a label. <code>TrayManager::createSeparator</code> takes a tray location, name, and an optional width. If the width is not specified, the behaviour is the same as a Label's.", '</p>'), ('<p>', 'A slider bar consists of a container box, a small text box to display the value, and a track + handle. Sliders are type-agnostic. Using three parameters - a minimum value, a maximum value, and the number of "snapping points", you can give your slider track of any kind of discrete scale - integer, floating point, or even nominal. Snapping points are basically the "steps" on your slider track. By specifying how many of them there are, you are in effect specifying an entire range of values all the way from your minimum value to your maximum value. Let\'s say you have minimum value 0, maximum value 1, and 6 snapping points. Underneath the surface, each slider stores a floating point value, so in this case you would be able to display 6 floating point values: {0, 0.2, 0.4, 0.6, 0.8, 1}. The slider will display your value in the cleanest way possible (using <code><a class="el" href="class_ogre_1_1_string_converter.html#a45fb498a2f798c82bbf88116a5a34c53" title="Converts a float to a String. ">Ogre::StringConverter::toString</a></code>). This means that if all your values happen to land on integers, then they will be displayed as integers without decimals. You can also exploit this by using your slider\'s integer values as indices into an array of string values, and manually set your slider\'s value to the new string value. Basically, you can make your slider display things like Low, Medium, High, 1/4, 3/4, $4.00, N/A, etc. This requires you to respond to slider move events. More on this in the TrayListener section below. Then your Like select menus, sliders also come in two flavours - thick and long. The thick style places the caption and the value box above the track, while the long style places the caption, track, and value box side by side in that order. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a597ec173c1b424980e18fd92e0c56905">OgreBites::TrayManager::createThickSlider</a></code> takes a tray location, name, caption, total width, value box width, minimum value, maximum value, and the number of snapping points. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a321429ade975d3a63dfc1125b4375e78">OgreBites::TrayManager::createLongSlider</a></code> takes a an optional total width, track width, value box width, minimum value, maximum value, and the number of snapping points. If the total width is not specified, the slider will automatically scale to fit the track, the value box, and the caption text. You can get/set the slider\'s caption, displayed value, actual value, and range of values. When you change the range, the value is reset to be the minimum value. When you change the value, you also have the option of not firing an event. To respond to slider move events, see the TrayListener section below.', '</p>'), ('<p>', 'This panel displays an arbitrary number of parameters and their values. This could be anything you want. For example, the stats panel in the SDK samples shows the average framerate, best framerate, batch count, etc. The details panel in the SDK samples shows the texture filtering technique, the polygon mode, and the camera position and orientation. To create a ParamsPanel, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a5ae6b66603e05193b3077f30900209eb">OgreBites::TrayManager::createParamsPanel</a></code>, which takes a tray location, a name, a width, and then either a string vector of parameter names or the number of parameters (lines) to leave room for. The parameter names will be left justified, and their values will be right justified on the same line. At any time, you can set/get the parameter names and values either one at a time, or all at once using a string vector.', '</p>'), ('<p>', 'Self-explanatory. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7433f3e89c5b3a1b1b0012dfcb121f1d">OgreBites::TrayManager::createCheckBox</a></code> takes a tray location, name, caption, and an optional width. Unspecified width means auto-fit to caption. You can set/get the state of the check box, with the option of not triggering an event. To respond to check box state change events, see the TrayListener section below. ', '</p>'), ('<p>', 'This widget takes any OverlayElement template, and creates a widget out of it. If you want to put your own picture, icons, or other static objects into the trays, make an OverlayElement template out of it, and then turn it into a DecorWidget. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a24d1b3a3b95ddcf274bf899b7600deba">OgreBites::TrayManager::createDecorWidget</a></code> takes a tray location, a name, and an OverlayElement template name. These are basically the same things you would normally use to create an OverlayElement from a template. The OGRE logo in the SDK samples is a DecorWidget. ', '</p>'), ('<p>', 'A progress bar with a caption, a comment/details box, and a meter that fills up. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a431a347db6465bbf66af82ef363c875f">OgreBites::TrayManager::createProgressBar</a></code> takes a tray location, a name, a caption, a total width, and comment box width. You can use progress bars to show any kind of progress you want, but for the most common kind (loading resources), there\'s a special instance of ProgressBar already created by TrayManager which you can use. See Loading Bar below.', '</p>'), ('<p>', 'In addition to the nine trays you can place your widgets in, there is also a "null tray". This is an imaginary tray, whose location is specified by <code>TL_NONE</code>. This tray is virtual, invisible, and does not arrange widgets within it. Basically, if you place a widget in this tray, it becomes "free-floating", and you\'re allowed to manually position it anywhere on the screen. Widgets must always reside in a tray for as long as they exist, so when a widget is removed from a tray, it is automatically placed in the null tray.', '</p>'), ('<p>', 'Some widgets are so common they deserve special treatment.', '</p>'), ('<p>', 'This is not exactly one widget, but a combination of Label that displays the current FPS, and a ParamsPanel that displays advanced frame statistics (such as average FPS and batch count). Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a49e2f792fee94e75b1b472826bcc8019" title="Shows frame statistics widget set in the specified location. ">OgreBites::TrayManager::showFrameStats</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1c2e9618a3e6b061a9cfeac4f2cb55e9" title="Hides frame statistics widget set. ">OgreBites::TrayManager::hideFrameStats</a></code> to show/hide this special widget. You can choose where to put it. When the user clicks the FPS label, it toggles the visibility of the advanced frame stats, so they can be out of the way when they\'re unwanted. You can also manually toggle the visibility of the advanced frame stats using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aed00f8a1009f2ebf6806774cb894d0d7" title="Toggles visibility of advanced statistics. ">OgreBites::TrayManager::toggleAdvancedFrameStats</a></code>.', '</p>'), ('<p>', 'This is just a decor widget of the OGRE logo. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#affee57f47066e25437649d64daaa7dd9" title="Shows logo in the specified location. ">OgreBites::TrayManager::showLogo</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ac1ee637b7ef5e887170c8a9aca1c4c7b">OgreBites::TrayManager::hideLogo</a></code> to show/hide the logo. You can choose where to put it.', '</p>'), ('<p>', 'This is a progress bar that shows you the progress of your current resource loading job. The comment box will show the current resource being loaded. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a0d51005a4b148a4df2c1c6b55e34f085" title="Shows loading bar. ">OgreBites::TrayManager::showLoadingBar</a></code> before you begin your loading job. Specify the number of resource groups you will initialise, the number of groups you will load, and, if you want to, the proportion of time you think will go to initialisation (default estimate is 70%). You cannot decide where to place this loading bar. The screen will be darkened, and the loading bar will appear in the center. Any other dialog or loading bar will be closed. When you finish your loading job, call <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aab014a2c48c8f91556182e42684d44ad">OgreBites::TrayManager::hideLoadingBar</a></code>.', '</p>'), ('<p>', 'This is a dialog which tells the user something and displays an OK button. It\'s a combination of a TextBox and a Button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#abf3bd8e4ef9a6d0d76f27535a6010623" title="Pops up a message dialog with an OK button. ">OgreBites::TrayManager::showOkDialog</a></code> to display an information dialog. Specify the caption of the TextBox, and the message you want to display in it. Any other dialog or loading bar will be closed. The screen will be darkened, and the dialog will appear in the center. All other widget interactions are disabled until the dialog is closed. You can manually close a dialog using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#af5d95dcaa7c74d3345308e4f4e3035e8" title="Hides whatever dialog is currently showing. ">OgreBites::TrayManager::closeDialog</a></code>. To respond to information dialog closing events, see the TrayListenersection below.', '</p>'), ('<p>', 'Same as the Information Dialog except it asks the user something and displays a Yes button and a No button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a85d47aa11d761742884dc6457ec11cdf" title="Pops up a question dialog with Yes and No buttons. ">OgreBites::TrayManager::showYesNoDialog</a></code> to display a question dialog. Specify the caption of the TextBox, and the question you want to display in it. To respond to question dialog closing events, see the TrayListener section below.', '</p>'), ('<p>', "This class contains handlers for all the different events that your widgets can fire. The TrayManager class itself is an TrayListener, because it responds to events from its special widgets. You should extend your sample class from TrayListener as well as Sample if you want to handle widget events. If you're using SdkSample, you're all set because it's already an TrayListener. Some widgets give you an option of not firing an event when you change their state. This is helpful for initialising or resetting a widget, in which case there shouldn't be a response of any sort. For example, if you're initialising your slider bar before the scene is set up, and your slider bar is used to control some part of your scene, firing an event would cause an error. Below is a list of the different handlers. All handlers have return type void.", '</p>'), ('<p>', 'Getting access to widgets: </p><div class="fragment"><div class="line">Button* b;</div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);  <span class="comment">// by tray and position</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by tray and name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#af968c01a627ee654409f558e4ef55537">getWidgetIterator</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>).<a class="code" href="class_ogre_1_1_vector_iterator_wrapper.html#a2460c8adb6819235849de954db6a0f64">getNext</a>();  <span class="comment">// by iterator</span></div></div><!-- fragment --><p> Counting widgets: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>();  <span class="comment">// total</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);  <span class="comment">// by tray</span></div></div><!-- fragment --><p> Moving widgets to other trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div></div><!-- fragment --><p> Removing widgets from trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a04a1085bdee61d7234849663cce08664">TL_NONE</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a77ba6e4d641c146e262b6cdd2c8b04a0">clearTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9787ec5e8989bf6cfa89d03c6ddd27b6">clearAllTrays</a>();</div></div><!-- fragment --><p> Destroying widgets: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4a89cd6f7d87e0e538aa842f1a42a7bc">destroyAllWidgetsInTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aadb1f5a3b7e3b5397b10bdd3449e1603">destroyAllWidgets</a>();</div></div><!-- fragment --><p> Finding the position of a widget in a tray: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa993d2b60cfbcb903aecbff1c4896b67">locateWidgetInTray</a>(b);</div></div><!-- fragment --><p> Finding the tray a widget is in: </p><div class="fragment"><div class="line"><a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530">TrayLocation</a> trayLoc = b-&gt;getTrayLocation();</div></div><!-- fragment --><p> Changing the tray listener object: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a3235fea714a0c61e463dee69ae308be8">setListener</a>(newListener);</div></div><!-- fragment --><p> Toggling system visibility: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a075805136b2241cbb03eeb2c3d27b40d">showAll</a>();</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a188f1d5f5ca16af3b28d11ecd553105a">hideAll</a>();</div></div><!-- fragment --><p> Changing horizontal widget alignment in one tray: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#adfbbc97615fd5f1a939be6e7a1f00c07">setTrayWidgetAlignment</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <a class="code" href="group___overlays.html#gga3396780cdb2d731aa5e4389148bdc5f3a270f18cf07dbe4e75e1b790d02924205">GHA_RIGHT</a>);</div></div><!-- fragment --><p> Changing spacing and padding: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a33a3e3f66a3989dd3de48b4c4577422f">setWidgetSpacing</a>(5);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a52d3fc8638533540232232c37b257de6">setWidgetPadding</a>(3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a866229b6d88dc9d3a609115eaab46e67">setTrayPadding</a>(12);</div></div><!-- fragment --><p> Casting 3D ray from under cursor into the scene: </p><div class="fragment"><div class="line">Ray r = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9dd5d303968329462e9bf4225f59722e">getCursorRay</a>(mCamera);</div></div><!-- fragment --><p> Casting 3D ray from any 2D screen coordinate into the scene: </p><div class="fragment"><div class="line">Ray r = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#a6833f46b0303b559a050f310fa0204fc">OgreBites::TrayManager::screenToScene</a>(mCamera, Vector2(320, 240));</div></div><!-- fragment --><p> Converting a 3D scene coordinate to a 2D screen coordinate: ', '</p>'), ('<p>', "Ever wanted really simple GUI controls for your sample? Don't want to write one from scratch, but CEGUI's just a little too much? The Trays system was created to address this issue. It's a simple GUI system based on the OGRE Overlay system and designed just for samples. Because it's simple, you're not going to be able to skin it or build very unique interfaces, but you'll also find it much easier to use. The entire system is based on the OGRE Overlay system.", '</p>'), ('<p>', 'Why trays? The concept of trays is central to the system in that it removes the need for the GUI designer (you) to calculate or specify positional coordinates of any kind. Think about the widget locations in a typical GUI. They are almost always in any of the four corners, along any of the four edges or, on the rare occasion, in the center of the screen. In Trays, there are nine "trays", one in each of the locations previously mentioned. When you create a widget, you specify one of these nine locations, and the widget will be added to the tray at that location. Your widget will be added directly beneath the last widget in that tray. When you add a widget to a tray, the tray grows in size. Trays along the top of the screen grow downward, Trays along the bottom grow upward, and the trays in the middle row grow vertically in both directions. Visually, the trays are semi-transparent panels that fit the widgets they contain. Only non-empty trays are visible. If this is hard to visualise, don\'t worry, here\'s a picture to help you out. ', '</p>'), ('<p>', 'To use Trays, you have to create an TrayManager. This is the class through which you will create and manage all your widgets, manipulate the cursor, change the backdrop image, adjust tray properties, pop up dialogs, show/hide the loading bar, etc. You can have multiple tray managers in one application. For example, the OGRE Sample Browser uses its own tray manager and hides it when a sample is running, and the SDK samples also have their own tray managers, which are hidden when the samples are paused by the browser. The TrayManager requires "Trays.zip", so you can only create it after loading that resource. Also, make sure you\'re using the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> namespace (Trays is part of the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Samples Framework). Create your tray manager like so: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>* mTrayMgr = <span class="keyword">new</span> <a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>(<span class="stringliteral">&quot;InterfaceName&quot;</span>, mWindow, <span class="keyword">this</span>);</div></div><!-- fragment --><p> You must pass in a name for your interface, an <code><a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a></code> and an <code><a class="el" href="class_ogre_bites_1_1_tray_listener.html" title="Listener class for responding to tray events. ">OgreBites::TrayListener</a></code>. You can extend your sample or sample context to be a tray listener. Destroy your tray manager like so: </p><div class="fragment"><div class="line"><span class="keyword">delete</span> mTrayMgr;</div><div class="line">mTrayMgr = 0;</div></div><!-- fragment --><p> Once you have your tray manager, make sure you relay your OIS events to it. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> mousePressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseDown(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseReleased(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseUp(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseMoved(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_motion_event.html">OgreBites::MouseMotionEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseMove(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> The injection methods return true if the event was relevant to the tray manager, and should not be processed again by you. For example, if you click a button that is over an interactive part of your scene, you want the button to be pressed, but you don\'t want the scene interaction to take place. So the injection methods double as filters for your mouse events.', '</p>'), ('<p>', 'You\'re now free to create widgets! Try adding a button to the top-left tray: </p><div class="fragment"><div class="line">Button* b = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">createButton</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530afe04de8736168ab0dd6e7938e679c292">TL_TOPLEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <span class="stringliteral">&quot;Click Me!&quot;</span>);</div></div><!-- fragment --><p> TrayManager is a huge class, and you can do tons of things with it. For some examples, see the Things to Try section below.', '</p>'), ('<p>', 'The cursor has three parts in the Trays system: The layer it moves around in Overlay, the container which positions the cursor (OverlayContainer), and the cursor image, which is a child of the container (OverlayElement). When hiding/showing the cursor, the entire cursor layer is hidden/shown. The top left corner of the cursor container is used as the hotspot of the cursor. By positioning the cursor image relative to the cursor container, you can basically decide which part of the cursor image is the "clicking part". For the default arrow cursor, the image is simply lined up with the container, meaning the top left is the hotspot. However, for something like a crosshair cursor, you could move the cursor image so that its center is over the top left corner of the cursor container. To show the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1cc48ac157278b5845d425abbe9acefd" title="Displays specified material on cursor, or the last material used if none specified. ">OgreBites::TrayManager::showCursor</a></code>, which takes an optional material name for the cursor image. If unspecified, the cursor image is not changed. To hide the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a979ff2ad2d729223259b3bebb237cafb">OgreBites::TrayManager::hideCursor</a></code>. You can get the cursor\'s different parts using getCursorLayer, getCursorContainer, and getCursorImage. Note that if the cursor is hidden, all interactions with widgets are disabled.', '</p>'), ('<p>', 'If you want to show a backdrop, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ad554418c27edb907f0e3bead8659b83c" title="Displays specified material on backdrop, or the last material used if none specified. ">OgreBites::TrayManager::showBackdrop</a></code>, which takes an optional material name for the backdrop. If unspecified, the backdrop image is not changed. To hide it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a6129a1e92ac22789a4602cf36f9c5394">OgreBites::TrayManager::hideBackdrop</a></code>.', '</p>'), ('<p>', 'There are 10 basic widgets. Each widget is just an instance of an OverlayElement template, and all widgets use {LEX()}pixel{LEX} metrics. You can get access to any widget\'s underlying OverlayElement through <code><a class="el" href="class_ogre_bites_1_1_widget.html#a379d3f1a2ca6eaf13fc5c52afaafd0d2">OgreBites::Widget::getOverlayElement</a></code>. Do not instantiate and delete widgets manually. Create and destroy them using the TrayManager. The first argument to any one of TrayManager\'s widget creation methods is the location of the tray you want the widget to be in. This is of the enumerated type TrayLocation. The second argument is the name of your widget (this is not your widget\'s caption, but a unique string identifier for your widget). The rest of the arguments are specific to the type of widget.', '</p>'), ('<p>', 'This is the most basic widget of all. To create a button, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">OgreBites::TrayManager::createButton</a></code>. In addition to a tray location and a name, you must specify a caption for your button, and an optional width. If width is not specified, the button will automatically resize to fit its caption. There are no button states. You only get notified when a button is pushed. To see how to respond to button push events, see the TrayListener section below.', '</p>'), ('<p>', 'This widget consists of a bold caption bar and a text area that can be scrolled vertically. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a07a8d212939266339e877ff2118250a6">OgreBites::TrayManager::createTextBox</a></code> takes a caption, width, and height. You can set/get the caption, the text area contents, text padding, text alignment, manually change the scroll bar position, among other things.', '</p>'), ('<p>', 'A basic drop-down menu. To create it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a60864ca00d65b2bf1b97bb8545fab737">OgreBites::TrayManager::createLongSelectMenu</a></code> or <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a98f478c8daa5084b53146de03adbc216">OgreBites::TrayManager::createThickSelectMenu</a></code>. Both these methods return a SelectMenu object, but they give one of two different visual styles to the widget. One is thicker, but shorter, because it places the caption over the item box. This style of menu is good for putting in the side trays. The other is longer, but thinner, because it places the item box next to the caption. This style of menu is good for putting in the top or bottom trays. createThickSelectMenu takes a tray location, a name, a caption, the width of the whole widget, the maximum number of visible items when expanded, and an optional string vector of items. The medthod <code>createLongSelectMenu</code> takes nearly the same arguments, except that it needs the width of the text box that shows the currently selected item. Also, for long menus, it is optional to specify the total width because it will automatically resize to fit the item box and the caption. You can set/get the caption, and set/get the items in many different ways. You can also manually change the selection, with the option of not firing an event. To see how to respond to menu item selection events, see the TrayListener section below.', '</p>'), ('<p>', 'A big, semi-transparent, tabby-looking label. This widget uses a different font from the rest of the widgets, and is good for section headings and such. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a15375d59b5c57059c9c6549fc5a1bfcd">OgreBites::TrayManager::createLabel</a></code> takes a caption, and an optional width. If the width is not specified, the label automatically adjusts its width to fill the tray it\'s currently in, so it matches the other contents of the tray. Labels can also be clicked. To see how to respond to label click events, see the TrayListener section below.', '</p>'), ('<p>', "A horizontal line which looks like it was etched into the tray. Good for dividing up other widgets into sections without taking up as much space as a label. <code>TrayManager::createSeparator</code> takes a tray location, name, and an optional width. If the width is not specified, the behaviour is the same as a Label's.", '</p>'), ('<p>', 'A slider bar consists of a container box, a small text box to display the value, and a track + handle. Sliders are type-agnostic. Using three parameters - a minimum value, a maximum value, and the number of "snapping points", you can give your slider track of any kind of discrete scale - integer, floating point, or even nominal. Snapping points are basically the "steps" on your slider track. By specifying how many of them there are, you are in effect specifying an entire range of values all the way from your minimum value to your maximum value. Let\'s say you have minimum value 0, maximum value 1, and 6 snapping points. Underneath the surface, each slider stores a floating point value, so in this case you would be able to display 6 floating point values: {0, 0.2, 0.4, 0.6, 0.8, 1}. The slider will display your value in the cleanest way possible (using <code><a class="el" href="class_ogre_1_1_string_converter.html#a45fb498a2f798c82bbf88116a5a34c53" title="Converts a float to a String. ">Ogre::StringConverter::toString</a></code>). This means that if all your values happen to land on integers, then they will be displayed as integers without decimals. You can also exploit this by using your slider\'s integer values as indices into an array of string values, and manually set your slider\'s value to the new string value. Basically, you can make your slider display things like Low, Medium, High, 1/4, 3/4, $4.00, N/A, etc. This requires you to respond to slider move events. More on this in the TrayListener section below. Then your Like select menus, sliders also come in two flavours - thick and long. The thick style places the caption and the value box above the track, while the long style places the caption, track, and value box side by side in that order. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a597ec173c1b424980e18fd92e0c56905">OgreBites::TrayManager::createThickSlider</a></code> takes a tray location, name, caption, total width, value box width, minimum value, maximum value, and the number of snapping points. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a321429ade975d3a63dfc1125b4375e78">OgreBites::TrayManager::createLongSlider</a></code> takes a an optional total width, track width, value box width, minimum value, maximum value, and the number of snapping points. If the total width is not specified, the slider will automatically scale to fit the track, the value box, and the caption text. You can get/set the slider\'s caption, displayed value, actual value, and range of values. When you change the range, the value is reset to be the minimum value. When you change the value, you also have the option of not firing an event. To respond to slider move events, see the TrayListener section below.', '</p>'), ('<p>', 'This panel displays an arbitrary number of parameters and their values. This could be anything you want. For example, the stats panel in the SDK samples shows the average framerate, best framerate, batch count, etc. The details panel in the SDK samples shows the texture filtering technique, the polygon mode, and the camera position and orientation. To create a ParamsPanel, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a5ae6b66603e05193b3077f30900209eb">OgreBites::TrayManager::createParamsPanel</a></code>, which takes a tray location, a name, a width, and then either a string vector of parameter names or the number of parameters (lines) to leave room for. The parameter names will be left justified, and their values will be right justified on the same line. At any time, you can set/get the parameter names and values either one at a time, or all at once using a string vector.', '</p>'), ('<p>', 'Self-explanatory. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7433f3e89c5b3a1b1b0012dfcb121f1d">OgreBites::TrayManager::createCheckBox</a></code> takes a tray location, name, caption, and an optional width. Unspecified width means auto-fit to caption. You can set/get the state of the check box, with the option of not triggering an event. To respond to check box state change events, see the TrayListener section below. ', '</p>'), ('<p>', 'This widget takes any OverlayElement template, and creates a widget out of it. If you want to put your own picture, icons, or other static objects into the trays, make an OverlayElement template out of it, and then turn it into a DecorWidget. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a24d1b3a3b95ddcf274bf899b7600deba">OgreBites::TrayManager::createDecorWidget</a></code> takes a tray location, a name, and an OverlayElement template name. These are basically the same things you would normally use to create an OverlayElement from a template. The OGRE logo in the SDK samples is a DecorWidget. ', '</p>'), ('<p>', 'A progress bar with a caption, a comment/details box, and a meter that fills up. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a431a347db6465bbf66af82ef363c875f">OgreBites::TrayManager::createProgressBar</a></code> takes a tray location, a name, a caption, a total width, and comment box width. You can use progress bars to show any kind of progress you want, but for the most common kind (loading resources), there\'s a special instance of ProgressBar already created by TrayManager which you can use. See Loading Bar below.', '</p>'), ('<p>', 'In addition to the nine trays you can place your widgets in, there is also a "null tray". This is an imaginary tray, whose location is specified by <code>TL_NONE</code>. This tray is virtual, invisible, and does not arrange widgets within it. Basically, if you place a widget in this tray, it becomes "free-floating", and you\'re allowed to manually position it anywhere on the screen. Widgets must always reside in a tray for as long as they exist, so when a widget is removed from a tray, it is automatically placed in the null tray.', '</p>'), ('<p>', 'Some widgets are so common they deserve special treatment.', '</p>'), ('<p>', 'This is not exactly one widget, but a combination of Label that displays the current FPS, and a ParamsPanel that displays advanced frame statistics (such as average FPS and batch count). Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a49e2f792fee94e75b1b472826bcc8019" title="Shows frame statistics widget set in the specified location. ">OgreBites::TrayManager::showFrameStats</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1c2e9618a3e6b061a9cfeac4f2cb55e9" title="Hides frame statistics widget set. ">OgreBites::TrayManager::hideFrameStats</a></code> to show/hide this special widget. You can choose where to put it. When the user clicks the FPS label, it toggles the visibility of the advanced frame stats, so they can be out of the way when they\'re unwanted. You can also manually toggle the visibility of the advanced frame stats using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aed00f8a1009f2ebf6806774cb894d0d7" title="Toggles visibility of advanced statistics. ">OgreBites::TrayManager::toggleAdvancedFrameStats</a></code>.', '</p>'), ('<p>', 'This is just a decor widget of the OGRE logo. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#affee57f47066e25437649d64daaa7dd9" title="Shows logo in the specified location. ">OgreBites::TrayManager::showLogo</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ac1ee637b7ef5e887170c8a9aca1c4c7b">OgreBites::TrayManager::hideLogo</a></code> to show/hide the logo. You can choose where to put it.', '</p>'), ('<p>', 'This is a progress bar that shows you the progress of your current resource loading job. The comment box will show the current resource being loaded. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a0d51005a4b148a4df2c1c6b55e34f085" title="Shows loading bar. ">OgreBites::TrayManager::showLoadingBar</a></code> before you begin your loading job. Specify the number of resource groups you will initialise, the number of groups you will load, and, if you want to, the proportion of time you think will go to initialisation (default estimate is 70%). You cannot decide where to place this loading bar. The screen will be darkened, and the loading bar will appear in the center. Any other dialog or loading bar will be closed. When you finish your loading job, call <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aab014a2c48c8f91556182e42684d44ad">OgreBites::TrayManager::hideLoadingBar</a></code>.', '</p>'), ('<p>', 'This is a dialog which tells the user something and displays an OK button. It\'s a combination of a TextBox and a Button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#abf3bd8e4ef9a6d0d76f27535a6010623" title="Pops up a message dialog with an OK button. ">OgreBites::TrayManager::showOkDialog</a></code> to display an information dialog. Specify the caption of the TextBox, and the message you want to display in it. Any other dialog or loading bar will be closed. The screen will be darkened, and the dialog will appear in the center. All other widget interactions are disabled until the dialog is closed. You can manually close a dialog using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#af5d95dcaa7c74d3345308e4f4e3035e8" title="Hides whatever dialog is currently showing. ">OgreBites::TrayManager::closeDialog</a></code>. To respond to information dialog closing events, see the TrayListenersection below.', '</p>'), ('<p>', 'Same as the Information Dialog except it asks the user something and displays a Yes button and a No button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a85d47aa11d761742884dc6457ec11cdf" title="Pops up a question dialog with Yes and No buttons. ">OgreBites::TrayManager::showYesNoDialog</a></code> to display a question dialog. Specify the caption of the TextBox, and the question you want to display in it. To respond to question dialog closing events, see the TrayListener section below.', '</p>'), ('<p>', "This class contains handlers for all the different events that your widgets can fire. The TrayManager class itself is an TrayListener, because it responds to events from its special widgets. You should extend your sample class from TrayListener as well as Sample if you want to handle widget events. If you're using SdkSample, you're all set because it's already an TrayListener. Some widgets give you an option of not firing an event when you change their state. This is helpful for initialising or resetting a widget, in which case there shouldn't be a response of any sort. For example, if you're initialising your slider bar before the scene is set up, and your slider bar is used to control some part of your scene, firing an event would cause an error. Below is a list of the different handlers. All handlers have return type void.", '</p>'), ('<p>', 'Getting access to widgets: </p><div class="fragment"><div class="line">Button* b;</div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);  <span class="comment">// by tray and position</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by tray and name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#af968c01a627ee654409f558e4ef55537">getWidgetIterator</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>).<a class="code" href="class_ogre_1_1_vector_iterator_wrapper.html#a2460c8adb6819235849de954db6a0f64">getNext</a>();  <span class="comment">// by iterator</span></div></div><!-- fragment --><p> Counting widgets: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>();  <span class="comment">// total</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);  <span class="comment">// by tray</span></div></div><!-- fragment --><p> Moving widgets to other trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div></div><!-- fragment --><p> Removing widgets from trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a04a1085bdee61d7234849663cce08664">TL_NONE</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a77ba6e4d641c146e262b6cdd2c8b04a0">clearTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9787ec5e8989bf6cfa89d03c6ddd27b6">clearAllTrays</a>();</div></div><!-- fragment --><p> Destroying widgets: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4a89cd6f7d87e0e538aa842f1a42a7bc">destroyAllWidgetsInTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aadb1f5a3b7e3b5397b10bdd3449e1603">destroyAllWidgets</a>();</div></div><!-- fragment --><p> Finding the position of a widget in a tray: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa993d2b60cfbcb903aecbff1c4896b67">locateWidgetInTray</a>(b);</div></div><!-- fragment --><p> Finding the tray a widget is in: </p><div class="fragment"><div class="line"><a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530">TrayLocation</a> trayLoc = b-&gt;getTrayLocation();</div></div><!-- fragment --><p> Changing the tray listener object: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a3235fea714a0c61e463dee69ae308be8">setListener</a>(newListener);</div></div><!-- fragment --><p> Toggling system visibility: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a075805136b2241cbb03eeb2c3d27b40d">showAll</a>();</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a188f1d5f5ca16af3b28d11ecd553105a">hideAll</a>();</div></div><!-- fragment --><p> Changing horizontal widget alignment in one tray: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#adfbbc97615fd5f1a939be6e7a1f00c07">setTrayWidgetAlignment</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <a class="code" href="group___overlays.html#gga3396780cdb2d731aa5e4389148bdc5f3a270f18cf07dbe4e75e1b790d02924205">GHA_RIGHT</a>);</div></div><!-- fragment --><p> Changing spacing and padding: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a33a3e3f66a3989dd3de48b4c4577422f">setWidgetSpacing</a>(5);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a52d3fc8638533540232232c37b257de6">setWidgetPadding</a>(3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a866229b6d88dc9d3a609115eaab46e67">setTrayPadding</a>(12);</div></div><!-- fragment --><p> Casting 3D ray from under cursor into the scene: </p><div class="fragment"><div class="line">Ray r = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9dd5d303968329462e9bf4225f59722e">getCursorRay</a>(mCamera);</div></div><!-- fragment --><p> Casting 3D ray from any 2D screen coordinate into the scene: </p><div class="fragment"><div class="line">Ray r = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#a6833f46b0303b559a050f310fa0204fc">OgreBites::TrayManager::screenToScene</a>(mCamera, Vector2(320, 240));</div></div><!-- fragment --><p> Converting a 3D scene coordinate to a 2D screen coordinate: ', '</p>'), ('<p>', 'Shadow mapping, an algorithm introduced by Lance Williams \xa0<a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the lights snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.', '</p>'), ('<p>', 'In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.', '</p>'), ('<p>', 'Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.', '</p>'), ('<p>', 'Mathematically, the process can be represented as follows: Let \\(P_l\\) and \\(P_c\\) be the projection matrices for the light and camera respectively. Let \\(M_l\\) and \\(M_c\\) be the modelview matrices for the light and camera coordinate systems. Let \\(\\vec{x} = [x_1,x_2,x_3,1]^t\\) be a point in object space, \\(\\vec{y} = [y_1,y_2,y_3,1]^t\\) the screen space coordinates, and \\(\\vec{u} = [u_1,u_2,u_3,1]^t\\) the shadow map coordinates.', '</p>'), ('<p>', 'These equations can be written more concisely as: \\(\\vec{u}w_l = P_l M_l \\vec{x}\\) and \\(\\vec{y} w_c = P_c M_c \\vec{x}\\). Division of \\(\\vec{u}w_l\\) and \\(\\vec{y}w_c\\) by their respective homogeneous coordinates yields the Euclidean representations \\(\\vec{u}\\) and \\(\\vec{y}\\).', '</p>'), ('<p>', 'Note that while \\(P_c\\) and \\(M_c\\) are completely determined by the camera image we want to produce, we have some ambiguity in the \\(P_l\\) and \\(M_l\\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.', '</p>'), ('<p>', 'Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \\(u_3\\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the lights image plane to represent boundaries between shadow texels. The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dots depth is saved. However, note that from the cameras perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map samples interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map samples depth farther (to the 2nd red dot), we can achieve correct shadow determination.', '</p>'), ('<p>', 'One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \\(u_3\\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \\(u_3 = u_3(u_1, u_2)\\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\), where we have treated \\(u_3\\) as a function of \\(u_1\\) and \\(u_2\\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobians Frobenius norm).', '</p>'), ('<p>', 'But even if the light is staring at a plane straight on (view direciton lines up with planes normal), making \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\) both zero, we would still need a slight offset because rounding due to the floats finite representation may still cause shadow acne. In this case, wed like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with lights position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogres example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engines chosen scale, you can easily change this choice. At any rate, the relevant quantity is \\(\\frac{\\partial u_3}{\\partial X_3}\\) where \\(\\vec{X} = M_l \\vec{x}\\).', '</p>'), ('<p>', 'The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.', '</p>'), ('<p>', 'Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.', '</p>'), ('<p>', 'where \\(V_l\\) is the viewport matrix for the light and \\(i=1,2,3\\). \\(q_l\\) turns out to be \\(1/w_l\\).', '</p>'), ('<p>', 'where \\(\\vec{n}\\) is the normal at point \\(\\vec{x}\\) and \\(j=1,2\\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.', '</p>'), ('<p>', 'Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.', '</p>'), ('<p>', 'As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. Wed like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in \xa0<a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogres example code implements the bilinear analogue.', '</p>'), ('<p>', 'There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:', '</p>'), ('<p>', 'Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.', '</p>'), ('<p>', 'One example of this is Deep Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community \xa0<a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.', '</p>'), ('<p>', 'While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:', '</p>'), ('<p>', 'Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.', '</p>'), ('<p>', 'Adaptive Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.', '</p>'), ('<p>', 'There are various heuristic approaches for choosing \\(P_l\\) and \\(M_l\\), but here we will focus on one method, the Plane Optimal algorithm \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \\(P_l\\) and \\(M_l\\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).', '</p>'), ('<p>', 'A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there dont seem to more step-by-step expositions available at this moment.', '</p>'), ('<p>', 'There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.', '</p>'), ('<p>', 'We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.', '</p>'), ('<p>', 'The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless were rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.', '</p>'), ('<p>', 'In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If youre going to change hardware, might as well aim for true optimality.', '</p>'), ('<p>', 'Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as normal shadow maps, no matter the perspective warp used to affect sampling.', '</p>'), ('<p>', 'The terms perspective and projective aliasing appeared in the Perspective Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.', '</p>'), ('<p>', 'The setShadowTechnique call is all that is required for Ogres default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.', '</p>'), ('<p>', 'The <code>DepthShadowmap.material</code> script is given below:', '</p>'), ('<p>', ' The material uses unified programs for HLSL, GLSL and GLSLES. Well present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \\(u_3\\) is less evocative of depth than \\(z\\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.', '</p>'), ('<p>', 'This is a pretty standard vertex shader.', '</p>'), ('<p>', 'Just write out the depth values here. We compute the bias and derivatives in the receiver.', '</p>'), ('<p>', 'This is a pretty standard vertex shader as well.', '</p>'), ('<p>', 'This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.', '</p>'), ('<p>', 'Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.', '</p>'), ('<p>', 'The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.', '</p>'), ('<p>', "Welcome to the Volume Component of OGRE. It is a component to render volumes. It can handle any volume data but featurewise has a tedency towards terrains. The terrain aspect means, that it's all about huge meshes being displayed with high performance via a level of detail mechanism. Thanks to volume rendering, caves, cliffes, holes and similar geometry can be displayed. Also constructive solid geometry gets easy.", '</p>'), ('<p>', 'A dense list of the features:', '</p>'), ('<p>', 'This documentation is only intended for the usage of the Volume Component, not the algorithms which make it work. If you want to get to know the theory behind it, you can read the articles on this page: <a href="http://volume-gfx.com/">http://volume-gfx.com/</a>', '</p>'), ('<p>', 'Here is an example loading the volume scene from a configuration file. The configuration file must be findable by the resource system of course. Only "OgreVolumeChunk.h" has to be included. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> <a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a>();</div><div class="line">SceneNode *volumeRootNode = mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(<span class="stringliteral">&quot;VolumeParent&quot;</span>);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, mSceneMgr, <span class="stringliteral">&quot;volumeTerrain.cfg&quot;</span>);</div></div><!-- fragment --><p> The first line creates the volume chunk which is the MovableObject holding the Volume-Root. Next, a SceneNode is created where the volume(-tree) is attached to. And lastly, the volume is loaded from the configuration file "volumeTerrain.cfg". mSceneMgr is the SceneManager who should show the volume. Later, when you don\'t need it anymore, you have to free the volumeRoot Chunk via OGRE_DELETE.', '</p>'), ('<p>', 'This example skips the configuration file and loads a simple CSG-Scene: An union of a 3D Texture and a sphere with 5 LOD levels. It also setups a material LOD system. First, create a sphere with the radius 5 at the coordinates 128, 150, 128: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_sphere_source.html">Ogre::Volume::CSGSphereSource</a> sphere (5, Vector3(128, 150, 128));</div></div><!-- fragment --><p> Now a 3D texture from "volumeTerrainBig.dds" which has the world dimensions 256, 256, 256. The next flag indicates that the trilinear interpolation of the value-selection should be activated. We switch off the trilinear interpolation and the sobel filter of the normal for the sake of faster loading times: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_texture_source.html">Ogre::Volume::TextureSource</a> volumeTexture (<span class="stringliteral">&quot;volumeTerrainBig.dds&quot;</span>, 256, 256, 256, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div></div><!-- fragment --><p> Now combine them: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_union_source.html">Ogre::Volume::CSGUnionSource</a> unionSrc (&amp;sphere, &amp;volumeTexture);</div></div><!-- fragment --><p> Set the general parameters, see the comments for their meaning: </p><div class="fragment"><div class="line"><a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html">Ogre::Volume::ChunkParameters</a> parameters;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a3e154a179b8c824f79b1b426608743ad">sceneManager</a> = mSceneMgr;       <span class="comment">// The SceneManager to use</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a> = &amp;unionSrc;                <span class="comment">// The just created density source.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a4444eac27c71e02886615dcf7fbfed27">baseError</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.8;          <span class="comment">// The error of the highest LOD-level</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aa6186649b7323f937b83828eb86711fa">errorMultiplicator</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.9; <span class="comment">// The factor between each LOD-level (error = baseError * errorMultiplicator  * level)</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a986b4a97b153d50f65603ab507bb4614">skirtFactor</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.7;        <span class="comment">// Controls how long the skirts are. The lower the number, the shorter the skirts are. This saves geometry. But if they are too short, cracks might occure.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#af6ed62b76c67d04eb98424414fb1dc72">scale</a> = 10;                     <span class="comment">// The displayed volume will be scaled by this factor.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#ae125003c00de0d6c0a1a4bd6b99c4ebf">maxScreenSpaceError</a> = 30;       <span class="comment">// The screen space error controlling when the LOD-levels change.</span></div></div><!-- fragment --><p>Create the root-chunk and load now. The two vectors define the area to be scanned in the volume-source. The following integer determines the amount of LOD-levels. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> Chunk();</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(mVolumeRootNode, Vector3::ZERO, Vector3(256), 5, &amp;parameters);</div></div><!-- fragment --><p> Now setup the global volume material: ', '</p>'), ('<p>', "When you want to integrate the volume triangles in a physics engine for example, you need to hand over the exact triangles. For this scenario, the ChunkParameters hold a pointer to a ''MeshBuilderCallback'' and a number ''lodCallbackLod''. The first is an interface with a single function ''trianglesReady'' which is called, when the triangles of a chunk are ready. The chunks are chosen via the ''lodCallbackLod''. If you build a volume with 3 LOD levels and you want the triangles of the highest detail level, you set this parameter to 3. Example:", '</p>'), ('<p>', 'And using it like this: </p><div class="fragment"><div class="line"><a class="code" href="group___volume.html#ga89fbc5eed010b8802358563eb88e674a">ChunkParameters</a> parameters;</div><div class="line">...</div><div class="line">MyMeshBuilderCallback callback;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a6403e2875cc7b81aefd43ba9f22c2b31">lodCallback</a> = &amp;callback;</div><div class="line">parameters.lodCallbackLod = 3;</div><div class="line">...</div><div class="line">rootChunk-&gt;load(parent, from, to, 3, &amp;parameters);</div></div><!-- fragment --><p> Or in case of loading from a configuration file: </p><div class="fragment"><div class="line">MyMeshBuilderCallback callback;</div><div class="line">rootChunk-&gt;load(parent, sceneManager, <span class="stringliteral">&quot;myVolume.cfg&quot;</span>, 0, &amp;callback, 3);</div></div><!-- fragment --><p>You might have seen, that a pointer to a SimpleRenderable is handed in, too. This is actually the Chunk whose triangles are loaded. It\'s parent class is used to not create a circular dependency. You might get the triangle data from it, too by getting the Renderoperation.', '</p>'), ('<p>', 'When you want to do something exactly on the volume surface, you can cast rays and find their first intersection point. Behold that the triangle representation might be slightly different than the actual volume surface. And you have to scale the ray origin just like the volume. Here is an example which uses the negative z-axis of the camera as ray as it might be done like in an ego-shooter: ', '</p>'), ('<p>', "A usecase is realtime editing of volume terrain as seen as in the sample. Let's union the terrain with a sphere of the radius 2.5 and the center 123/123/123. <b>volumeRoot</b> is the Chunk instance with which the terrain was initially loaded. The factor 1.5 is just to have a save border arround the sphere which also gets updated. The rest of the parameters are 5 LOD levels and a volume mesh covering an area of 384^3. ", '</p>'), ('<p>', 'Shadow mapping, an algorithm introduced by Lance Williams \xa0<a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the lights snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.', '</p>'), ('<p>', 'In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.', '</p>'), ('<p>', 'Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.', '</p>'), ('<p>', 'Mathematically, the process can be represented as follows: Let \\(P_l\\) and \\(P_c\\) be the projection matrices for the light and camera respectively. Let \\(M_l\\) and \\(M_c\\) be the modelview matrices for the light and camera coordinate systems. Let \\(\\vec{x} = [x_1,x_2,x_3,1]^t\\) be a point in object space, \\(\\vec{y} = [y_1,y_2,y_3,1]^t\\) the screen space coordinates, and \\(\\vec{u} = [u_1,u_2,u_3,1]^t\\) the shadow map coordinates.', '</p>'), ('<p>', 'These equations can be written more concisely as: \\(\\vec{u}w_l = P_l M_l \\vec{x}\\) and \\(\\vec{y} w_c = P_c M_c \\vec{x}\\). Division of \\(\\vec{u}w_l\\) and \\(\\vec{y}w_c\\) by their respective homogeneous coordinates yields the Euclidean representations \\(\\vec{u}\\) and \\(\\vec{y}\\).', '</p>'), ('<p>', 'Note that while \\(P_c\\) and \\(M_c\\) are completely determined by the camera image we want to produce, we have some ambiguity in the \\(P_l\\) and \\(M_l\\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.', '</p>'), ('<p>', 'Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \\(u_3\\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the lights image plane to represent boundaries between shadow texels. The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dots depth is saved. However, note that from the cameras perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map samples interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map samples depth farther (to the 2nd red dot), we can achieve correct shadow determination.', '</p>'), ('<p>', 'One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \\(u_3\\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \\(u_3 = u_3(u_1, u_2)\\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\), where we have treated \\(u_3\\) as a function of \\(u_1\\) and \\(u_2\\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobians Frobenius norm).', '</p>'), ('<p>', 'But even if the light is staring at a plane straight on (view direciton lines up with planes normal), making \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\) both zero, we would still need a slight offset because rounding due to the floats finite representation may still cause shadow acne. In this case, wed like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with lights position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogres example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engines chosen scale, you can easily change this choice. At any rate, the relevant quantity is \\(\\frac{\\partial u_3}{\\partial X_3}\\) where \\(\\vec{X} = M_l \\vec{x}\\).', '</p>'), ('<p>', 'The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.', '</p>'), ('<p>', 'Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.', '</p>'), ('<p>', 'where \\(V_l\\) is the viewport matrix for the light and \\(i=1,2,3\\). \\(q_l\\) turns out to be \\(1/w_l\\).', '</p>'), ('<p>', 'where \\(\\vec{n}\\) is the normal at point \\(\\vec{x}\\) and \\(j=1,2\\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.', '</p>'), ('<p>', 'Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.', '</p>'), ('<p>', 'As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. Wed like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in \xa0<a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogres example code implements the bilinear analogue.', '</p>'), ('<p>', 'There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:', '</p>'), ('<p>', 'Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.', '</p>'), ('<p>', 'One example of this is Deep Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community \xa0<a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.', '</p>'), ('<p>', 'While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:', '</p>'), ('<p>', 'Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.', '</p>'), ('<p>', 'Adaptive Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.', '</p>'), ('<p>', 'There are various heuristic approaches for choosing \\(P_l\\) and \\(M_l\\), but here we will focus on one method, the Plane Optimal algorithm \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \\(P_l\\) and \\(M_l\\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).', '</p>'), ('<p>', 'A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there dont seem to more step-by-step expositions available at this moment.', '</p>'), ('<p>', 'There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.', '</p>'), ('<p>', 'We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.', '</p>'), ('<p>', 'The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless were rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.', '</p>'), ('<p>', 'In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If youre going to change hardware, might as well aim for true optimality.', '</p>'), ('<p>', 'Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as normal shadow maps, no matter the perspective warp used to affect sampling.', '</p>'), ('<p>', 'The terms perspective and projective aliasing appeared in the Perspective Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.', '</p>'), ('<p>', 'The setShadowTechnique call is all that is required for Ogres default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.', '</p>'), ('<p>', 'The <code>DepthShadowmap.material</code> script is given below:', '</p>'), ('<p>', ' The material uses unified programs for HLSL, GLSL and GLSLES. Well present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \\(u_3\\) is less evocative of depth than \\(z\\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.', '</p>'), ('<p>', 'This is a pretty standard vertex shader.', '</p>'), ('<p>', 'Just write out the depth values here. We compute the bias and derivatives in the receiver.', '</p>'), ('<p>', 'This is a pretty standard vertex shader as well.', '</p>'), ('<p>', 'This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.', '</p>'), ('<p>', 'Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.', '</p>'), ('<p>', 'The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.', '</p>'), ('<p>', "Welcome to the Volume Component of OGRE. It is a component to render volumes. It can handle any volume data but featurewise has a tedency towards terrains. The terrain aspect means, that it's all about huge meshes being displayed with high performance via a level of detail mechanism. Thanks to volume rendering, caves, cliffes, holes and similar geometry can be displayed. Also constructive solid geometry gets easy.", '</p>'), ('<p>', 'A dense list of the features:', '</p>'), ('<p>', 'This documentation is only intended for the usage of the Volume Component, not the algorithms which make it work. If you want to get to know the theory behind it, you can read the articles on this page: <a href="http://volume-gfx.com/">http://volume-gfx.com/</a>', '</p>'), ('<p>', 'Here is an example loading the volume scene from a configuration file. The configuration file must be findable by the resource system of course. Only "OgreVolumeChunk.h" has to be included. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> <a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a>();</div><div class="line">SceneNode *volumeRootNode = mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(<span class="stringliteral">&quot;VolumeParent&quot;</span>);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, mSceneMgr, <span class="stringliteral">&quot;volumeTerrain.cfg&quot;</span>);</div></div><!-- fragment --><p> The first line creates the volume chunk which is the MovableObject holding the Volume-Root. Next, a SceneNode is created where the volume(-tree) is attached to. And lastly, the volume is loaded from the configuration file "volumeTerrain.cfg". mSceneMgr is the SceneManager who should show the volume. Later, when you don\'t need it anymore, you have to free the volumeRoot Chunk via OGRE_DELETE.', '</p>'), ('<p>', 'This example skips the configuration file and loads a simple CSG-Scene: An union of a 3D Texture and a sphere with 5 LOD levels. It also setups a material LOD system. First, create a sphere with the radius 5 at the coordinates 128, 150, 128: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_sphere_source.html">Ogre::Volume::CSGSphereSource</a> sphere (5, Vector3(128, 150, 128));</div></div><!-- fragment --><p> Now a 3D texture from "volumeTerrainBig.dds" which has the world dimensions 256, 256, 256. The next flag indicates that the trilinear interpolation of the value-selection should be activated. We switch off the trilinear interpolation and the sobel filter of the normal for the sake of faster loading times: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_texture_source.html">Ogre::Volume::TextureSource</a> volumeTexture (<span class="stringliteral">&quot;volumeTerrainBig.dds&quot;</span>, 256, 256, 256, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div></div><!-- fragment --><p> Now combine them: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_union_source.html">Ogre::Volume::CSGUnionSource</a> unionSrc (&amp;sphere, &amp;volumeTexture);</div></div><!-- fragment --><p> Set the general parameters, see the comments for their meaning: </p><div class="fragment"><div class="line"><a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html">Ogre::Volume::ChunkParameters</a> parameters;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a3e154a179b8c824f79b1b426608743ad">sceneManager</a> = mSceneMgr;       <span class="comment">// The SceneManager to use</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a> = &amp;unionSrc;                <span class="comment">// The just created density source.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a4444eac27c71e02886615dcf7fbfed27">baseError</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.8;          <span class="comment">// The error of the highest LOD-level</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aa6186649b7323f937b83828eb86711fa">errorMultiplicator</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.9; <span class="comment">// The factor between each LOD-level (error = baseError * errorMultiplicator  * level)</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a986b4a97b153d50f65603ab507bb4614">skirtFactor</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.7;        <span class="comment">// Controls how long the skirts are. The lower the number, the shorter the skirts are. This saves geometry. But if they are too short, cracks might occure.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#af6ed62b76c67d04eb98424414fb1dc72">scale</a> = 10;                     <span class="comment">// The displayed volume will be scaled by this factor.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#ae125003c00de0d6c0a1a4bd6b99c4ebf">maxScreenSpaceError</a> = 30;       <span class="comment">// The screen space error controlling when the LOD-levels change.</span></div></div><!-- fragment --><p>Create the root-chunk and load now. The two vectors define the area to be scanned in the volume-source. The following integer determines the amount of LOD-levels. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> Chunk();</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(mVolumeRootNode, Vector3::ZERO, Vector3(256), 5, &amp;parameters);</div></div><!-- fragment --><p> Now setup the global volume material: ', '</p>'), ('<p>', "When you want to integrate the volume triangles in a physics engine for example, you need to hand over the exact triangles. For this scenario, the ChunkParameters hold a pointer to a ''MeshBuilderCallback'' and a number ''lodCallbackLod''. The first is an interface with a single function ''trianglesReady'' which is called, when the triangles of a chunk are ready. The chunks are chosen via the ''lodCallbackLod''. If you build a volume with 3 LOD levels and you want the triangles of the highest detail level, you set this parameter to 3. Example:", '</p>'), ('<p>', 'And using it like this: </p><div class="fragment"><div class="line"><a class="code" href="group___volume.html#ga89fbc5eed010b8802358563eb88e674a">ChunkParameters</a> parameters;</div><div class="line">...</div><div class="line">MyMeshBuilderCallback callback;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a6403e2875cc7b81aefd43ba9f22c2b31">lodCallback</a> = &amp;callback;</div><div class="line">parameters.lodCallbackLod = 3;</div><div class="line">...</div><div class="line">rootChunk-&gt;load(parent, from, to, 3, &amp;parameters);</div></div><!-- fragment --><p> Or in case of loading from a configuration file: </p><div class="fragment"><div class="line">MyMeshBuilderCallback callback;</div><div class="line">rootChunk-&gt;load(parent, sceneManager, <span class="stringliteral">&quot;myVolume.cfg&quot;</span>, 0, &amp;callback, 3);</div></div><!-- fragment --><p>You might have seen, that a pointer to a SimpleRenderable is handed in, too. This is actually the Chunk whose triangles are loaded. It\'s parent class is used to not create a circular dependency. You might get the triangle data from it, too by getting the Renderoperation.', '</p>'), ('<p>', 'When you want to do something exactly on the volume surface, you can cast rays and find their first intersection point. Behold that the triangle representation might be slightly different than the actual volume surface. And you have to scale the ray origin just like the volume. Here is an example which uses the negative z-axis of the camera as ray as it might be done like in an ego-shooter: ', '</p>'), ('<p>', "A usecase is realtime editing of volume terrain as seen as in the sample. Let's union the terrain with a sphere of the radius 2.5 and the center 123/123/123. <b>volumeRoot</b> is the Chunk instance with which the terrain was initially loaded. The factor 1.5 is just to have a save border arround the sphere which also gets updated. The rest of the parameters are 5 LOD levels and a volume mesh covering an area of 384^3. ", '</p>'), ('<p>', 'Shadow mapping, an algorithm introduced by Lance Williams \xa0<a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the lights snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.', '</p>'), ('<p>', 'In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.', '</p>'), ('<p>', 'Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.', '</p>'), ('<p>', 'Mathematically, the process can be represented as follows: Let \\(P_l\\) and \\(P_c\\) be the projection matrices for the light and camera respectively. Let \\(M_l\\) and \\(M_c\\) be the modelview matrices for the light and camera coordinate systems. Let \\(\\vec{x} = [x_1,x_2,x_3,1]^t\\) be a point in object space, \\(\\vec{y} = [y_1,y_2,y_3,1]^t\\) the screen space coordinates, and \\(\\vec{u} = [u_1,u_2,u_3,1]^t\\) the shadow map coordinates.', '</p>'), ('<p>', 'These equations can be written more concisely as: \\(\\vec{u}w_l = P_l M_l \\vec{x}\\) and \\(\\vec{y} w_c = P_c M_c \\vec{x}\\). Division of \\(\\vec{u}w_l\\) and \\(\\vec{y}w_c\\) by their respective homogeneous coordinates yields the Euclidean representations \\(\\vec{u}\\) and \\(\\vec{y}\\).', '</p>'), ('<p>', 'Note that while \\(P_c\\) and \\(M_c\\) are completely determined by the camera image we want to produce, we have some ambiguity in the \\(P_l\\) and \\(M_l\\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.', '</p>'), ('<p>', 'Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \\(u_3\\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the lights image plane to represent boundaries between shadow texels. The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dots depth is saved. However, note that from the cameras perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map samples interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map samples depth farther (to the 2nd red dot), we can achieve correct shadow determination.', '</p>'), ('<p>', 'One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \\(u_3\\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \\(u_3 = u_3(u_1, u_2)\\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\), where we have treated \\(u_3\\) as a function of \\(u_1\\) and \\(u_2\\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobians Frobenius norm).', '</p>'), ('<p>', 'But even if the light is staring at a plane straight on (view direciton lines up with planes normal), making \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\) both zero, we would still need a slight offset because rounding due to the floats finite representation may still cause shadow acne. In this case, wed like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with lights position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogres example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engines chosen scale, you can easily change this choice. At any rate, the relevant quantity is \\(\\frac{\\partial u_3}{\\partial X_3}\\) where \\(\\vec{X} = M_l \\vec{x}\\).', '</p>'), ('<p>', 'The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.', '</p>'), ('<p>', 'Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.', '</p>'), ('<p>', 'where \\(V_l\\) is the viewport matrix for the light and \\(i=1,2,3\\). \\(q_l\\) turns out to be \\(1/w_l\\).', '</p>'), ('<p>', 'where \\(\\vec{n}\\) is the normal at point \\(\\vec{x}\\) and \\(j=1,2\\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.', '</p>'), ('<p>', 'Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.', '</p>'), ('<p>', 'As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. Wed like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in \xa0<a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogres example code implements the bilinear analogue.', '</p>'), ('<p>', 'There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:', '</p>'), ('<p>', 'Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.', '</p>'), ('<p>', 'One example of this is Deep Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community \xa0<a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.', '</p>'), ('<p>', 'While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:', '</p>'), ('<p>', 'Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.', '</p>'), ('<p>', 'Adaptive Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.', '</p>'), ('<p>', 'There are various heuristic approaches for choosing \\(P_l\\) and \\(M_l\\), but here we will focus on one method, the Plane Optimal algorithm \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \\(P_l\\) and \\(M_l\\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).', '</p>'), ('<p>', 'A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there dont seem to more step-by-step expositions available at this moment.', '</p>'), ('<p>', 'There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.', '</p>'), ('<p>', 'We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.', '</p>'), ('<p>', 'The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless were rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.', '</p>'), ('<p>', 'In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If youre going to change hardware, might as well aim for true optimality.', '</p>'), ('<p>', 'Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as normal shadow maps, no matter the perspective warp used to affect sampling.', '</p>'), ('<p>', 'The terms perspective and projective aliasing appeared in the Perspective Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.', '</p>'), ('<p>', 'The setShadowTechnique call is all that is required for Ogres default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.', '</p>'), ('<p>', 'The <code>DepthShadowmap.material</code> script is given below:', '</p>'), ('<p>', ' The material uses unified programs for HLSL, GLSL and GLSLES. Well present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \\(u_3\\) is less evocative of depth than \\(z\\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.', '</p>'), ('<p>', 'This is a pretty standard vertex shader.', '</p>'), ('<p>', 'Just write out the depth values here. We compute the bias and derivatives in the receiver.', '</p>'), ('<p>', 'This is a pretty standard vertex shader as well.', '</p>'), ('<p>', 'This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.', '</p>'), ('<p>', 'Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.', '</p>'), ('<p>', 'The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.', '</p>'), ('<p>', 'Shadow mapping, an algorithm introduced by Lance Williams \xa0<a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the lights snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.', '</p>'), ('<p>', 'In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.', '</p>'), ('<p>', 'Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.', '</p>'), ('<p>', 'Mathematically, the process can be represented as follows: Let \\(P_l\\) and \\(P_c\\) be the projection matrices for the light and camera respectively. Let \\(M_l\\) and \\(M_c\\) be the modelview matrices for the light and camera coordinate systems. Let \\(\\vec{x} = [x_1,x_2,x_3,1]^t\\) be a point in object space, \\(\\vec{y} = [y_1,y_2,y_3,1]^t\\) the screen space coordinates, and \\(\\vec{u} = [u_1,u_2,u_3,1]^t\\) the shadow map coordinates.', '</p>'), ('<p>', 'These equations can be written more concisely as: \\(\\vec{u}w_l = P_l M_l \\vec{x}\\) and \\(\\vec{y} w_c = P_c M_c \\vec{x}\\). Division of \\(\\vec{u}w_l\\) and \\(\\vec{y}w_c\\) by their respective homogeneous coordinates yields the Euclidean representations \\(\\vec{u}\\) and \\(\\vec{y}\\).', '</p>'), ('<p>', 'Note that while \\(P_c\\) and \\(M_c\\) are completely determined by the camera image we want to produce, we have some ambiguity in the \\(P_l\\) and \\(M_l\\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.', '</p>'), ('<p>', 'Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \\(u_3\\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the lights image plane to represent boundaries between shadow texels. The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dots depth is saved. However, note that from the cameras perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map samples interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map samples depth farther (to the 2nd red dot), we can achieve correct shadow determination.', '</p>'), ('<p>', 'One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \\(u_3\\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \\(u_3 = u_3(u_1, u_2)\\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\), where we have treated \\(u_3\\) as a function of \\(u_1\\) and \\(u_2\\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobians Frobenius norm).', '</p>'), ('<p>', 'But even if the light is staring at a plane straight on (view direciton lines up with planes normal), making \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\) both zero, we would still need a slight offset because rounding due to the floats finite representation may still cause shadow acne. In this case, wed like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with lights position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogres example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engines chosen scale, you can easily change this choice. At any rate, the relevant quantity is \\(\\frac{\\partial u_3}{\\partial X_3}\\) where \\(\\vec{X} = M_l \\vec{x}\\).', '</p>'), ('<p>', 'The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.', '</p>'), ('<p>', 'Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.', '</p>'), ('<p>', 'where \\(V_l\\) is the viewport matrix for the light and \\(i=1,2,3\\). \\(q_l\\) turns out to be \\(1/w_l\\).', '</p>'), ('<p>', 'where \\(\\vec{n}\\) is the normal at point \\(\\vec{x}\\) and \\(j=1,2\\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.', '</p>'), ('<p>', 'Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.', '</p>'), ('<p>', 'As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. Wed like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in \xa0<a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogres example code implements the bilinear analogue.', '</p>'), ('<p>', 'There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:', '</p>'), ('<p>', 'Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.', '</p>'), ('<p>', 'One example of this is Deep Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community \xa0<a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.', '</p>'), ('<p>', 'While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:', '</p>'), ('<p>', 'Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.', '</p>'), ('<p>', 'Adaptive Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.', '</p>'), ('<p>', 'There are various heuristic approaches for choosing \\(P_l\\) and \\(M_l\\), but here we will focus on one method, the Plane Optimal algorithm \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \\(P_l\\) and \\(M_l\\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).', '</p>'), ('<p>', 'A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there dont seem to more step-by-step expositions available at this moment.', '</p>'), ('<p>', 'There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.', '</p>'), ('<p>', 'We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.', '</p>'), ('<p>', 'The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless were rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.', '</p>'), ('<p>', 'In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If youre going to change hardware, might as well aim for true optimality.', '</p>'), ('<p>', 'Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as normal shadow maps, no matter the perspective warp used to affect sampling.', '</p>'), ('<p>', 'The terms perspective and projective aliasing appeared in the Perspective Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.', '</p>'), ('<p>', 'The setShadowTechnique call is all that is required for Ogres default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.', '</p>'), ('<p>', 'The <code>DepthShadowmap.material</code> script is given below:', '</p>'), ('<p>', ' The material uses unified programs for HLSL, GLSL and GLSLES. Well present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \\(u_3\\) is less evocative of depth than \\(z\\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.', '</p>'), ('<p>', 'This is a pretty standard vertex shader.', '</p>'), ('<p>', 'Just write out the depth values here. We compute the bias and derivatives in the receiver.', '</p>'), ('<p>', 'This is a pretty standard vertex shader as well.', '</p>'), ('<p>', 'This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.', '</p>'), ('<p>', 'Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.', '</p>'), ('<p>', 'The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.', '</p>'), ('<p>', 'First you want to initialize the Profiler like this: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">Ogre::Profiler::getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#a91c40e21a3fc96003504ea21fec80d77">setEnabled</a>(<span class="keyword">true</span>);</div></div><!-- fragment --><p> This sets up the media that the profiler uses. The reason this is not in the constructor is because the profiler contains media dependencies that people who aren\'t using the profiler shouldn\'t have to worry about. The profiler will need you to specify the main program loop. To do this, you call the following at the very beginning of the frameStarted() function in your FrameListener class: </p><div class="fragment"><div class="line"><a class="code" href="_ogre_profiler_8h.html#af9d7ab83c5a5d7de7579eebe9d27e53d">OgreProfileBegin</a>(<span class="stringliteral">&quot;Ogre Main Loop&quot;</span>);</div></div><!-- fragment --><p> and add this at the very end of the frameEnded() function: </p><div class="fragment"><div class="line"><a class="code" href="_ogre_profiler_8h.html#a292ec22b5d851ef26fa9d7685c18b1f5">OgreProfileEnd</a>(<span class="stringliteral">&quot;Ogre Main Loop&quot;</span>);</div></div><!-- fragment --><p> Make sure the names match exactly, otherwise the profiler will fail an assert. Next you want to profile some of your code. You do this by calling <a class="el" href="_ogre_profiler_8h.html#a1654899e6cfdec9f0972a45f3fa3fee7">OgreProfile()</a> and using braces ({}) to limit the scope. Note that OgreProfile cannot be called in the same scope as another <a class="el" href="_ogre_profiler_8h.html#a1654899e6cfdec9f0972a45f3fa3fee7">OgreProfile()</a>. Doing so will result in a compile-time error. Here is an example of using OgreProfile: </p><div class="fragment"><div class="line">{</div><div class="line">   <a class="code" href="_ogre_profiler_8h.html#a1654899e6cfdec9f0972a45f3fa3fee7">OgreProfile</a>(<span class="stringliteral">&quot;Collision Detection&quot;</span>);</div><div class="line">   mISQR = mISQ-&gt;execute();</div><div class="line">}</div><div class="line">{</div><div class="line">   <a class="code" href="_ogre_profiler_8h.html#a1654899e6cfdec9f0972a45f3fa3fee7">OgreProfile</a>(<span class="stringliteral">&quot;Collision Response&quot;</span>);</div><div class="line">   SceneQueryMovableIntersectionList::iterator iter;</div><div class="line">   <span class="keywordflow">for</span> (iter = mISQR.movables2movables.begin(); iter != mISQR.movables2movables.end(); iter++) {</div><div class="line">      <span class="comment">// do stuff</span></div><div class="line">      <a class="code" href="_ogre_profiler_8h.html#a1654899e6cfdec9f0972a45f3fa3fee7">OgreProfile</a>(<span class="stringliteral">&quot;Explosions&quot;</span>);</div><div class="line">      createExplosion();</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p> If you want a profile to last outside of its scope, use <a class="el" href="_ogre_profiler_8h.html#af9d7ab83c5a5d7de7579eebe9d27e53d">OgreProfileBegin(&lt;name&gt;)</a> and <a class="el" href="_ogre_profiler_8h.html#a292ec22b5d851ef26fa9d7685c18b1f5">OgreProfileEnd(&lt;name&gt;)</a> like you did when creating the main loop profile.', '</p>'), ('<p>', "On the left side are the profile names with a number in parentheses next to it. This number is the number of times this profile was called during this frame. If this number is 0, that means that the profile was called before, but is not being called currently. The bars on the left represent the frame time statistics. You can see indicators above which show that a profile can take anywhere from 0% to 100% of the frame time. The big yellow bars show the current frame percentage that the profile is taking. The green line shows the minimum frame time, the red line is the maximum frame time, and the blue line is the average frame time. Big discrepancies between the average and maximum can possibly be the sign of a performance bottleneck (however it could be the profiler acting strangely, see the ''Known Issues'' section). These results will be printed to the log when the application ends or you can manually do it by calling logResults().", '</p>'), ('<p>', 'You can disable the profiler by calling: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">Ogre::Profiler::getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#a91c40e21a3fc96003504ea21fec80d77">setEnabled</a>(<span class="keyword">false</span>);</div></div><!-- fragment --><p> and enable it again by calling: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">Ogre::Profiler::getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#a91c40e21a3fc96003504ea21fec80d77">setEnabled</a>(<span class="keyword">true</span>);</div></div><!-- fragment --><p> Note that this is a temporary solution. If you want to completely disable the profiler for your release version, see the section \'\'Release Version Considerations\'\'.', '</p>'), ('<p>', 'Disabling profiles can be useful if there are certain core functions that you want to profile on occasion. For example, you could profile certain rendering operations when you are checking general performance and then disable those profiles when you want to profile your AI code. You can disable a profile like this: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#a144fc3944f41b1198a44590beda4ce3f">disableProfile</a>(<span class="stringliteral">&quot;&lt;profile name&gt;&quot;</span>);</div></div><!-- fragment --><p> and you can enable it again with this: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#a52e2f0d3530febbbf7199173d91ad4e2">enableProfile</a>(<span class="stringliteral">&quot;&lt;profile name&gt;&quot;</span>);</div></div><!-- fragment --><p> Please note that trying to enable or disable a profile while that profile is running will have no effect.', '</p>'), ('<p>', 'It is helpful to see the state of your application when a profile reaches a maximum level or some other condition. To check if a specific has reached a new maximum level, use: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#afc737d10ba6b5732df9a538a196ee3e6">watchForMax</a>(<span class="stringliteral">&quot;&lt;profile name&gt;&quot;</span>); <span class="comment">// return true if it reaches a new maximum</span></div></div><!-- fragment --><p> or to see if a profile has reached a new minimum level, use: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#ad37efd3a99cf736a0424fd0c1c92efb4">watchForMin</a>(<span class="stringliteral">&quot;&lt;profile name&gt;&quot;</span>); <span class="comment">// returns true if it reaches a new minimum</span></div></div><!-- fragment --><p> or to set an arbitrary level: </p><div class="fragment"><div class="line"><span class="comment">//returns true when AI code takes over 60% of the frame time</span></div><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#adfd868a7f9213baece5687bd36e23279">watchForLimit</a>(<span class="stringliteral">&quot;AI code&quot;</span>, .6, <span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">//returns true when graphics code takes less than 10% of the frame time</span></div><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#adfd868a7f9213baece5687bd36e23279">watchForLimit</a>(<span class="stringliteral">&quot;Graphics code&quot;</span>, .1, <span class="keyword">false</span>);</div></div><!-- fragment --><p>These functions should be used at the end of the main game loop for more accuracy. Otherwise, it will represent the results of the previous frame.', '</p>'), ('<p>', 'You can log the results of the current profiler statistics like this: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#a456a0f133ccea3eb515626edd22963ec">logResults</a>();</div></div><!-- fragment --><p> This is called automatically when you quit your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> application.', '</p>'), ('<p>', 'You can change how frequently the display is updated to suit your tastes like this: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#ac29d425e0f0b531f2c7f643907c9402d">setUpdateDisplayFrequency</a>(&lt;numberOfFrames&gt;);</div></div><!-- fragment --><p> Basically the tradeoff is between how accurate the display is and the amount of flicker. The default is that the display is updated every 10 frames.', '</p>'), ('<p>', "I've tried to minimize the performance hit from using the profiler. However, like anything else, it still takes some time to perform the necessary calculations. There are some steps you can take to increase the accuracy of the results. Firstly, although the profiler supports multiple calls of a profile during each frame, doing this more than a few times can cause the profiler to take significantly longer than the actual code you are trying to profile. Therefore it is recommended that you move the profile up one level (such as outside of a for loop) so that it is called fewer times.", '</p>'), ('<p>', 'To maximize the accuracy of a profile, it is best to remove the child profiles of the profile you are analysing. Child profiles increases the frame time of the parent due to the overhead of using the profiler.', '</p>'), ('<p>', "Some tests I've conducted show that the profiling code will max out unexpectedly, so take the maximum frame time value with a grain of salt (See the <em>Known Issues</em> section). I think this only happens when a profile is first created, so you can possibly get around this issue by calling the reset() function after the first frame.", '</p>'), ('<p>', 'For the release version of your app, you should set <code>OGRE_PROFILING=OFF</code> in CMake. If the build you are using has been compiled with the <code>OGRE_PROFILING=OFF</code> and you still want to use the profiler without recompiling your SDK, a quick workaround is to instantiate a dummy profiler like this:', '</p>'), ('<p>', 'The profiler will now work but the 3 OgreProfile macro will not work. You will have to manually use the beginProfile() and endProfile() method. You can also instantiate scope-limited Profile objects or simply define your own macros somewhere in your code.', '</p>'), ('<p>', 'Shadow mapping, an algorithm introduced by Lance Williams \xa0<a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the lights snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.', '</p>'), ('<p>', 'In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.', '</p>'), ('<p>', 'Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.', '</p>'), ('<p>', 'Mathematically, the process can be represented as follows: Let \\(P_l\\) and \\(P_c\\) be the projection matrices for the light and camera respectively. Let \\(M_l\\) and \\(M_c\\) be the modelview matrices for the light and camera coordinate systems. Let \\(\\vec{x} = [x_1,x_2,x_3,1]^t\\) be a point in object space, \\(\\vec{y} = [y_1,y_2,y_3,1]^t\\) the screen space coordinates, and \\(\\vec{u} = [u_1,u_2,u_3,1]^t\\) the shadow map coordinates.', '</p>'), ('<p>', 'These equations can be written more concisely as: \\(\\vec{u}w_l = P_l M_l \\vec{x}\\) and \\(\\vec{y} w_c = P_c M_c \\vec{x}\\). Division of \\(\\vec{u}w_l\\) and \\(\\vec{y}w_c\\) by their respective homogeneous coordinates yields the Euclidean representations \\(\\vec{u}\\) and \\(\\vec{y}\\).', '</p>'), ('<p>', 'Note that while \\(P_c\\) and \\(M_c\\) are completely determined by the camera image we want to produce, we have some ambiguity in the \\(P_l\\) and \\(M_l\\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.', '</p>'), ('<p>', 'Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \\(u_3\\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the lights image plane to represent boundaries between shadow texels. The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dots depth is saved. However, note that from the cameras perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map samples interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map samples depth farther (to the 2nd red dot), we can achieve correct shadow determination.', '</p>'), ('<p>', 'One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \\(u_3\\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \\(u_3 = u_3(u_1, u_2)\\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\), where we have treated \\(u_3\\) as a function of \\(u_1\\) and \\(u_2\\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobians Frobenius norm).', '</p>'), ('<p>', 'But even if the light is staring at a plane straight on (view direciton lines up with planes normal), making \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\) both zero, we would still need a slight offset because rounding due to the floats finite representation may still cause shadow acne. In this case, wed like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with lights position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogres example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engines chosen scale, you can easily change this choice. At any rate, the relevant quantity is \\(\\frac{\\partial u_3}{\\partial X_3}\\) where \\(\\vec{X} = M_l \\vec{x}\\).', '</p>'), ('<p>', 'The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.', '</p>'), ('<p>', 'Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.', '</p>'), ('<p>', 'where \\(V_l\\) is the viewport matrix for the light and \\(i=1,2,3\\). \\(q_l\\) turns out to be \\(1/w_l\\).', '</p>'), ('<p>', 'where \\(\\vec{n}\\) is the normal at point \\(\\vec{x}\\) and \\(j=1,2\\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.', '</p>'), ('<p>', 'Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.', '</p>'), ('<p>', 'As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. Wed like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in \xa0<a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogres example code implements the bilinear analogue.', '</p>'), ('<p>', 'There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:', '</p>'), ('<p>', 'Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.', '</p>'), ('<p>', 'One example of this is Deep Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community \xa0<a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.', '</p>'), ('<p>', 'While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:', '</p>'), ('<p>', 'Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.', '</p>'), ('<p>', 'Adaptive Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.', '</p>'), ('<p>', 'There are various heuristic approaches for choosing \\(P_l\\) and \\(M_l\\), but here we will focus on one method, the Plane Optimal algorithm \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \\(P_l\\) and \\(M_l\\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).', '</p>'), ('<p>', 'A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there dont seem to more step-by-step expositions available at this moment.', '</p>'), ('<p>', 'There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.', '</p>'), ('<p>', 'We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.', '</p>'), ('<p>', 'The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless were rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.', '</p>'), ('<p>', 'In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If youre going to change hardware, might as well aim for true optimality.', '</p>'), ('<p>', 'Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as normal shadow maps, no matter the perspective warp used to affect sampling.', '</p>'), ('<p>', 'The terms perspective and projective aliasing appeared in the Perspective Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.', '</p>'), ('<p>', 'The setShadowTechnique call is all that is required for Ogres default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.', '</p>'), ('<p>', 'The <code>DepthShadowmap.material</code> script is given below:', '</p>'), ('<p>', ' The material uses unified programs for HLSL, GLSL and GLSLES. Well present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \\(u_3\\) is less evocative of depth than \\(z\\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.', '</p>'), ('<p>', 'This is a pretty standard vertex shader.', '</p>'), ('<p>', 'Just write out the depth values here. We compute the bias and derivatives in the receiver.', '</p>'), ('<p>', 'This is a pretty standard vertex shader as well.', '</p>'), ('<p>', 'This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.', '</p>'), ('<p>', 'Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.', '</p>'), ('<p>', 'The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.', '</p>'), ('<p>', 'Shadow mapping, an algorithm introduced by Lance Williams \xa0<a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the lights snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.', '</p>'), ('<p>', 'In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.', '</p>'), ('<p>', 'Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.', '</p>'), ('<p>', 'Mathematically, the process can be represented as follows: Let \\(P_l\\) and \\(P_c\\) be the projection matrices for the light and camera respectively. Let \\(M_l\\) and \\(M_c\\) be the modelview matrices for the light and camera coordinate systems. Let \\(\\vec{x} = [x_1,x_2,x_3,1]^t\\) be a point in object space, \\(\\vec{y} = [y_1,y_2,y_3,1]^t\\) the screen space coordinates, and \\(\\vec{u} = [u_1,u_2,u_3,1]^t\\) the shadow map coordinates.', '</p>'), ('<p>', 'These equations can be written more concisely as: \\(\\vec{u}w_l = P_l M_l \\vec{x}\\) and \\(\\vec{y} w_c = P_c M_c \\vec{x}\\). Division of \\(\\vec{u}w_l\\) and \\(\\vec{y}w_c\\) by their respective homogeneous coordinates yields the Euclidean representations \\(\\vec{u}\\) and \\(\\vec{y}\\).', '</p>'), ('<p>', 'Note that while \\(P_c\\) and \\(M_c\\) are completely determined by the camera image we want to produce, we have some ambiguity in the \\(P_l\\) and \\(M_l\\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.', '</p>'), ('<p>', 'Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \\(u_3\\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the lights image plane to represent boundaries between shadow texels. The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dots depth is saved. However, note that from the cameras perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map samples interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map samples depth farther (to the 2nd red dot), we can achieve correct shadow determination.', '</p>'), ('<p>', 'One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \\(u_3\\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \\(u_3 = u_3(u_1, u_2)\\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\), where we have treated \\(u_3\\) as a function of \\(u_1\\) and \\(u_2\\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobians Frobenius norm).', '</p>'), ('<p>', 'But even if the light is staring at a plane straight on (view direciton lines up with planes normal), making \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\) both zero, we would still need a slight offset because rounding due to the floats finite representation may still cause shadow acne. In this case, wed like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with lights position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogres example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engines chosen scale, you can easily change this choice. At any rate, the relevant quantity is \\(\\frac{\\partial u_3}{\\partial X_3}\\) where \\(\\vec{X} = M_l \\vec{x}\\).', '</p>'), ('<p>', 'The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.', '</p>'), ('<p>', 'Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.', '</p>'), ('<p>', 'where \\(V_l\\) is the viewport matrix for the light and \\(i=1,2,3\\). \\(q_l\\) turns out to be \\(1/w_l\\).', '</p>'), ('<p>', 'where \\(\\vec{n}\\) is the normal at point \\(\\vec{x}\\) and \\(j=1,2\\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.', '</p>'), ('<p>', 'Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.', '</p>'), ('<p>', 'As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. Wed like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in \xa0<a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogres example code implements the bilinear analogue.', '</p>'), ('<p>', 'There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:', '</p>'), ('<p>', 'Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.', '</p>'), ('<p>', 'One example of this is Deep Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community \xa0<a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.', '</p>'), ('<p>', 'While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:', '</p>'), ('<p>', 'Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.', '</p>'), ('<p>', 'Adaptive Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.', '</p>'), ('<p>', 'There are various heuristic approaches for choosing \\(P_l\\) and \\(M_l\\), but here we will focus on one method, the Plane Optimal algorithm \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \\(P_l\\) and \\(M_l\\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).', '</p>'), ('<p>', 'A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there dont seem to more step-by-step expositions available at this moment.', '</p>'), ('<p>', 'There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.', '</p>'), ('<p>', 'We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.', '</p>'), ('<p>', 'The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless were rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.', '</p>'), ('<p>', 'In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If youre going to change hardware, might as well aim for true optimality.', '</p>'), ('<p>', 'Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as normal shadow maps, no matter the perspective warp used to affect sampling.', '</p>'), ('<p>', 'The terms perspective and projective aliasing appeared in the Perspective Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.', '</p>'), ('<p>', 'The setShadowTechnique call is all that is required for Ogres default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.', '</p>'), ('<p>', 'The <code>DepthShadowmap.material</code> script is given below:', '</p>'), ('<p>', ' The material uses unified programs for HLSL, GLSL and GLSLES. Well present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \\(u_3\\) is less evocative of depth than \\(z\\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.', '</p>'), ('<p>', 'This is a pretty standard vertex shader.', '</p>'), ('<p>', 'Just write out the depth values here. We compute the bias and derivatives in the receiver.', '</p>'), ('<p>', 'This is a pretty standard vertex shader as well.', '</p>'), ('<p>', 'This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.', '</p>'), ('<p>', 'Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.', '</p>'), ('<p>', 'The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.', '</p>'), ('<p>', 'Shadow mapping, an algorithm introduced by Lance Williams \xa0<a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the lights snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.', '</p>'), ('<p>', 'In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.', '</p>'), ('<p>', 'Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.', '</p>'), ('<p>', 'Mathematically, the process can be represented as follows: Let \\(P_l\\) and \\(P_c\\) be the projection matrices for the light and camera respectively. Let \\(M_l\\) and \\(M_c\\) be the modelview matrices for the light and camera coordinate systems. Let \\(\\vec{x} = [x_1,x_2,x_3,1]^t\\) be a point in object space, \\(\\vec{y} = [y_1,y_2,y_3,1]^t\\) the screen space coordinates, and \\(\\vec{u} = [u_1,u_2,u_3,1]^t\\) the shadow map coordinates.', '</p>'), ('<p>', 'These equations can be written more concisely as: \\(\\vec{u}w_l = P_l M_l \\vec{x}\\) and \\(\\vec{y} w_c = P_c M_c \\vec{x}\\). Division of \\(\\vec{u}w_l\\) and \\(\\vec{y}w_c\\) by their respective homogeneous coordinates yields the Euclidean representations \\(\\vec{u}\\) and \\(\\vec{y}\\).', '</p>'), ('<p>', 'Note that while \\(P_c\\) and \\(M_c\\) are completely determined by the camera image we want to produce, we have some ambiguity in the \\(P_l\\) and \\(M_l\\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.', '</p>'), ('<p>', 'Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \\(u_3\\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the lights image plane to represent boundaries between shadow texels. The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dots depth is saved. However, note that from the cameras perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map samples interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map samples depth farther (to the 2nd red dot), we can achieve correct shadow determination.', '</p>'), ('<p>', 'One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \\(u_3\\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \\(u_3 = u_3(u_1, u_2)\\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\), where we have treated \\(u_3\\) as a function of \\(u_1\\) and \\(u_2\\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobians Frobenius norm).', '</p>'), ('<p>', 'But even if the light is staring at a plane straight on (view direciton lines up with planes normal), making \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\) both zero, we would still need a slight offset because rounding due to the floats finite representation may still cause shadow acne. In this case, wed like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with lights position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogres example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engines chosen scale, you can easily change this choice. At any rate, the relevant quantity is \\(\\frac{\\partial u_3}{\\partial X_3}\\) where \\(\\vec{X} = M_l \\vec{x}\\).', '</p>'), ('<p>', 'The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.', '</p>'), ('<p>', 'Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.', '</p>'), ('<p>', 'where \\(V_l\\) is the viewport matrix for the light and \\(i=1,2,3\\). \\(q_l\\) turns out to be \\(1/w_l\\).', '</p>'), ('<p>', 'where \\(\\vec{n}\\) is the normal at point \\(\\vec{x}\\) and \\(j=1,2\\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.', '</p>'), ('<p>', 'Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.', '</p>'), ('<p>', 'As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. Wed like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in \xa0<a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogres example code implements the bilinear analogue.', '</p>'), ('<p>', 'There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:', '</p>'), ('<p>', 'Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.', '</p>'), ('<p>', 'One example of this is Deep Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community \xa0<a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.', '</p>'), ('<p>', 'While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:', '</p>'), ('<p>', 'Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.', '</p>'), ('<p>', 'Adaptive Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.', '</p>'), ('<p>', 'There are various heuristic approaches for choosing \\(P_l\\) and \\(M_l\\), but here we will focus on one method, the Plane Optimal algorithm \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \\(P_l\\) and \\(M_l\\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).', '</p>'), ('<p>', 'A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there dont seem to more step-by-step expositions available at this moment.', '</p>'), ('<p>', 'There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.', '</p>'), ('<p>', 'We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.', '</p>'), ('<p>', 'The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless were rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.', '</p>'), ('<p>', 'In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If youre going to change hardware, might as well aim for true optimality.', '</p>'), ('<p>', 'Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as normal shadow maps, no matter the perspective warp used to affect sampling.', '</p>'), ('<p>', 'The terms perspective and projective aliasing appeared in the Perspective Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.', '</p>'), ('<p>', 'The setShadowTechnique call is all that is required for Ogres default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.', '</p>'), ('<p>', 'The <code>DepthShadowmap.material</code> script is given below:', '</p>'), ('<p>', ' The material uses unified programs for HLSL, GLSL and GLSLES. Well present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \\(u_3\\) is less evocative of depth than \\(z\\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.', '</p>'), ('<p>', 'This is a pretty standard vertex shader.', '</p>'), ('<p>', 'Just write out the depth values here. We compute the bias and derivatives in the receiver.', '</p>'), ('<p>', 'This is a pretty standard vertex shader as well.', '</p>'), ('<p>', 'This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.', '</p>'), ('<p>', 'Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.', '</p>'), ('<p>', 'The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.', '</p>'), ('<p>', 'Shadow mapping, an algorithm introduced by Lance Williams \xa0<a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the lights snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.', '</p>'), ('<p>', 'In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.', '</p>'), ('<p>', 'Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.', '</p>'), ('<p>', 'Mathematically, the process can be represented as follows: Let \\(P_l\\) and \\(P_c\\) be the projection matrices for the light and camera respectively. Let \\(M_l\\) and \\(M_c\\) be the modelview matrices for the light and camera coordinate systems. Let \\(\\vec{x} = [x_1,x_2,x_3,1]^t\\) be a point in object space, \\(\\vec{y} = [y_1,y_2,y_3,1]^t\\) the screen space coordinates, and \\(\\vec{u} = [u_1,u_2,u_3,1]^t\\) the shadow map coordinates.', '</p>'), ('<p>', 'These equations can be written more concisely as: \\(\\vec{u}w_l = P_l M_l \\vec{x}\\) and \\(\\vec{y} w_c = P_c M_c \\vec{x}\\). Division of \\(\\vec{u}w_l\\) and \\(\\vec{y}w_c\\) by their respective homogeneous coordinates yields the Euclidean representations \\(\\vec{u}\\) and \\(\\vec{y}\\).', '</p>'), ('<p>', 'Note that while \\(P_c\\) and \\(M_c\\) are completely determined by the camera image we want to produce, we have some ambiguity in the \\(P_l\\) and \\(M_l\\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.', '</p>'), ('<p>', 'Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \\(u_3\\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the lights image plane to represent boundaries between shadow texels. The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dots depth is saved. However, note that from the cameras perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map samples interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map samples depth farther (to the 2nd red dot), we can achieve correct shadow determination.', '</p>'), ('<p>', 'One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \\(u_3\\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \\(u_3 = u_3(u_1, u_2)\\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\), where we have treated \\(u_3\\) as a function of \\(u_1\\) and \\(u_2\\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobians Frobenius norm).', '</p>'), ('<p>', 'But even if the light is staring at a plane straight on (view direciton lines up with planes normal), making \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\) both zero, we would still need a slight offset because rounding due to the floats finite representation may still cause shadow acne. In this case, wed like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with lights position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogres example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engines chosen scale, you can easily change this choice. At any rate, the relevant quantity is \\(\\frac{\\partial u_3}{\\partial X_3}\\) where \\(\\vec{X} = M_l \\vec{x}\\).', '</p>'), ('<p>', 'The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.', '</p>'), ('<p>', 'Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.', '</p>'), ('<p>', 'where \\(V_l\\) is the viewport matrix for the light and \\(i=1,2,3\\). \\(q_l\\) turns out to be \\(1/w_l\\).', '</p>'), ('<p>', 'where \\(\\vec{n}\\) is the normal at point \\(\\vec{x}\\) and \\(j=1,2\\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.', '</p>'), ('<p>', 'Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.', '</p>'), ('<p>', 'As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. Wed like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in \xa0<a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogres example code implements the bilinear analogue.', '</p>'), ('<p>', 'There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:', '</p>'), ('<p>', 'Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.', '</p>'), ('<p>', 'One example of this is Deep Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community \xa0<a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.', '</p>'), ('<p>', 'While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:', '</p>'), ('<p>', 'Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.', '</p>'), ('<p>', 'Adaptive Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.', '</p>'), ('<p>', 'There are various heuristic approaches for choosing \\(P_l\\) and \\(M_l\\), but here we will focus on one method, the Plane Optimal algorithm \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \\(P_l\\) and \\(M_l\\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).', '</p>'), ('<p>', 'A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there dont seem to more step-by-step expositions available at this moment.', '</p>'), ('<p>', 'There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.', '</p>'), ('<p>', 'We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.', '</p>'), ('<p>', 'The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless were rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.', '</p>'), ('<p>', 'In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If youre going to change hardware, might as well aim for true optimality.', '</p>'), ('<p>', 'Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as normal shadow maps, no matter the perspective warp used to affect sampling.', '</p>'), ('<p>', 'The terms perspective and projective aliasing appeared in the Perspective Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.', '</p>'), ('<p>', 'The setShadowTechnique call is all that is required for Ogres default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.', '</p>'), ('<p>', 'The <code>DepthShadowmap.material</code> script is given below:', '</p>'), ('<p>', ' The material uses unified programs for HLSL, GLSL and GLSLES. Well present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \\(u_3\\) is less evocative of depth than \\(z\\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.', '</p>'), ('<p>', 'This is a pretty standard vertex shader.', '</p>'), ('<p>', 'Just write out the depth values here. We compute the bias and derivatives in the receiver.', '</p>'), ('<p>', 'This is a pretty standard vertex shader as well.', '</p>'), ('<p>', 'This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.', '</p>'), ('<p>', 'Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.', '</p>'), ('<p>', 'The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.', '</p>'), ('<p>', 'Shadow mapping, an algorithm introduced by Lance Williams \xa0<a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the lights snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.', '</p>'), ('<p>', 'In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.', '</p>'), ('<p>', 'Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.', '</p>'), ('<p>', 'Mathematically, the process can be represented as follows: Let \\(P_l\\) and \\(P_c\\) be the projection matrices for the light and camera respectively. Let \\(M_l\\) and \\(M_c\\) be the modelview matrices for the light and camera coordinate systems. Let \\(\\vec{x} = [x_1,x_2,x_3,1]^t\\) be a point in object space, \\(\\vec{y} = [y_1,y_2,y_3,1]^t\\) the screen space coordinates, and \\(\\vec{u} = [u_1,u_2,u_3,1]^t\\) the shadow map coordinates.', '</p>'), ('<p>', 'These equations can be written more concisely as: \\(\\vec{u}w_l = P_l M_l \\vec{x}\\) and \\(\\vec{y} w_c = P_c M_c \\vec{x}\\). Division of \\(\\vec{u}w_l\\) and \\(\\vec{y}w_c\\) by their respective homogeneous coordinates yields the Euclidean representations \\(\\vec{u}\\) and \\(\\vec{y}\\).', '</p>'), ('<p>', 'Note that while \\(P_c\\) and \\(M_c\\) are completely determined by the camera image we want to produce, we have some ambiguity in the \\(P_l\\) and \\(M_l\\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.', '</p>'), ('<p>', 'Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \\(u_3\\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the lights image plane to represent boundaries between shadow texels. The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dots depth is saved. However, note that from the cameras perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map samples interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map samples depth farther (to the 2nd red dot), we can achieve correct shadow determination.', '</p>'), ('<p>', 'One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \\(u_3\\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \\(u_3 = u_3(u_1, u_2)\\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\), where we have treated \\(u_3\\) as a function of \\(u_1\\) and \\(u_2\\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobians Frobenius norm).', '</p>'), ('<p>', 'But even if the light is staring at a plane straight on (view direciton lines up with planes normal), making \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\) both zero, we would still need a slight offset because rounding due to the floats finite representation may still cause shadow acne. In this case, wed like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with lights position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogres example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engines chosen scale, you can easily change this choice. At any rate, the relevant quantity is \\(\\frac{\\partial u_3}{\\partial X_3}\\) where \\(\\vec{X} = M_l \\vec{x}\\).', '</p>'), ('<p>', 'The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.', '</p>'), ('<p>', 'Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.', '</p>'), ('<p>', 'where \\(V_l\\) is the viewport matrix for the light and \\(i=1,2,3\\). \\(q_l\\) turns out to be \\(1/w_l\\).', '</p>'), ('<p>', 'where \\(\\vec{n}\\) is the normal at point \\(\\vec{x}\\) and \\(j=1,2\\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.', '</p>'), ('<p>', 'Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.', '</p>'), ('<p>', 'As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. Wed like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in \xa0<a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogres example code implements the bilinear analogue.', '</p>'), ('<p>', 'There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:', '</p>'), ('<p>', 'Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.', '</p>'), ('<p>', 'One example of this is Deep Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community \xa0<a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.', '</p>'), ('<p>', 'While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:', '</p>'), ('<p>', 'Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.', '</p>'), ('<p>', 'Adaptive Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.', '</p>'), ('<p>', 'There are various heuristic approaches for choosing \\(P_l\\) and \\(M_l\\), but here we will focus on one method, the Plane Optimal algorithm \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \\(P_l\\) and \\(M_l\\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).', '</p>'), ('<p>', 'A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there dont seem to more step-by-step expositions available at this moment.', '</p>'), ('<p>', 'There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.', '</p>'), ('<p>', 'We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.', '</p>'), ('<p>', 'The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless were rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.', '</p>'), ('<p>', 'In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If youre going to change hardware, might as well aim for true optimality.', '</p>'), ('<p>', 'Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as normal shadow maps, no matter the perspective warp used to affect sampling.', '</p>'), ('<p>', 'The terms perspective and projective aliasing appeared in the Perspective Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.', '</p>'), ('<p>', 'The setShadowTechnique call is all that is required for Ogres default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.', '</p>'), ('<p>', 'The <code>DepthShadowmap.material</code> script is given below:', '</p>'), ('<p>', ' The material uses unified programs for HLSL, GLSL and GLSLES. Well present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \\(u_3\\) is less evocative of depth than \\(z\\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.', '</p>'), ('<p>', 'This is a pretty standard vertex shader.', '</p>'), ('<p>', 'Just write out the depth values here. We compute the bias and derivatives in the receiver.', '</p>'), ('<p>', 'This is a pretty standard vertex shader as well.', '</p>'), ('<p>', 'This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.', '</p>'), ('<p>', 'Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.', '</p>'), ('<p>', 'The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.', '</p>'), ('<p>', 'Shadow mapping, an algorithm introduced by Lance Williams \xa0<a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the lights snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.', '</p>'), ('<p>', 'In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.', '</p>'), ('<p>', 'Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.', '</p>'), ('<p>', 'Mathematically, the process can be represented as follows: Let \\(P_l\\) and \\(P_c\\) be the projection matrices for the light and camera respectively. Let \\(M_l\\) and \\(M_c\\) be the modelview matrices for the light and camera coordinate systems. Let \\(\\vec{x} = [x_1,x_2,x_3,1]^t\\) be a point in object space, \\(\\vec{y} = [y_1,y_2,y_3,1]^t\\) the screen space coordinates, and \\(\\vec{u} = [u_1,u_2,u_3,1]^t\\) the shadow map coordinates.', '</p>'), ('<p>', 'These equations can be written more concisely as: \\(\\vec{u}w_l = P_l M_l \\vec{x}\\) and \\(\\vec{y} w_c = P_c M_c \\vec{x}\\). Division of \\(\\vec{u}w_l\\) and \\(\\vec{y}w_c\\) by their respective homogeneous coordinates yields the Euclidean representations \\(\\vec{u}\\) and \\(\\vec{y}\\).', '</p>'), ('<p>', 'Note that while \\(P_c\\) and \\(M_c\\) are completely determined by the camera image we want to produce, we have some ambiguity in the \\(P_l\\) and \\(M_l\\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.', '</p>'), ('<p>', 'Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \\(u_3\\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the lights image plane to represent boundaries between shadow texels. The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dots depth is saved. However, note that from the cameras perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map samples interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map samples depth farther (to the 2nd red dot), we can achieve correct shadow determination.', '</p>'), ('<p>', 'One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \\(u_3\\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \\(u_3 = u_3(u_1, u_2)\\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\), where we have treated \\(u_3\\) as a function of \\(u_1\\) and \\(u_2\\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobians Frobenius norm).', '</p>'), ('<p>', 'But even if the light is staring at a plane straight on (view direciton lines up with planes normal), making \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\) both zero, we would still need a slight offset because rounding due to the floats finite representation may still cause shadow acne. In this case, wed like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with lights position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogres example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engines chosen scale, you can easily change this choice. At any rate, the relevant quantity is \\(\\frac{\\partial u_3}{\\partial X_3}\\) where \\(\\vec{X} = M_l \\vec{x}\\).', '</p>'), ('<p>', 'The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.', '</p>'), ('<p>', 'Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.', '</p>'), ('<p>', 'where \\(V_l\\) is the viewport matrix for the light and \\(i=1,2,3\\). \\(q_l\\) turns out to be \\(1/w_l\\).', '</p>'), ('<p>', 'where \\(\\vec{n}\\) is the normal at point \\(\\vec{x}\\) and \\(j=1,2\\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.', '</p>'), ('<p>', 'Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.', '</p>'), ('<p>', 'As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. Wed like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in \xa0<a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogres example code implements the bilinear analogue.', '</p>'), ('<p>', 'There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:', '</p>'), ('<p>', 'Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.', '</p>'), ('<p>', 'One example of this is Deep Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community \xa0<a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.', '</p>'), ('<p>', 'While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:', '</p>'), ('<p>', 'Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.', '</p>'), ('<p>', 'Adaptive Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.', '</p>'), ('<p>', 'There are various heuristic approaches for choosing \\(P_l\\) and \\(M_l\\), but here we will focus on one method, the Plane Optimal algorithm \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \\(P_l\\) and \\(M_l\\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).', '</p>'), ('<p>', 'A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there dont seem to more step-by-step expositions available at this moment.', '</p>'), ('<p>', 'There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.', '</p>'), ('<p>', 'We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.', '</p>'), ('<p>', 'The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless were rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.', '</p>'), ('<p>', 'In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If youre going to change hardware, might as well aim for true optimality.', '</p>'), ('<p>', 'Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as normal shadow maps, no matter the perspective warp used to affect sampling.', '</p>'), ('<p>', 'The terms perspective and projective aliasing appeared in the Perspective Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.', '</p>'), ('<p>', 'The setShadowTechnique call is all that is required for Ogres default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.', '</p>'), ('<p>', 'The <code>DepthShadowmap.material</code> script is given below:', '</p>'), ('<p>', ' The material uses unified programs for HLSL, GLSL and GLSLES. Well present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \\(u_3\\) is less evocative of depth than \\(z\\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.', '</p>'), ('<p>', 'This is a pretty standard vertex shader.', '</p>'), ('<p>', 'Just write out the depth values here. We compute the bias and derivatives in the receiver.', '</p>'), ('<p>', 'This is a pretty standard vertex shader as well.', '</p>'), ('<p>', 'This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.', '</p>'), ('<p>', 'Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.', '</p>'), ('<p>', 'The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.', '</p>'), ('<p>', 'Shadow mapping, an algorithm introduced by Lance Williams \xa0<a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the lights snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.', '</p>'), ('<p>', 'In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.', '</p>'), ('<p>', 'Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.', '</p>'), ('<p>', 'Mathematically, the process can be represented as follows: Let \\(P_l\\) and \\(P_c\\) be the projection matrices for the light and camera respectively. Let \\(M_l\\) and \\(M_c\\) be the modelview matrices for the light and camera coordinate systems. Let \\(\\vec{x} = [x_1,x_2,x_3,1]^t\\) be a point in object space, \\(\\vec{y} = [y_1,y_2,y_3,1]^t\\) the screen space coordinates, and \\(\\vec{u} = [u_1,u_2,u_3,1]^t\\) the shadow map coordinates.', '</p>'), ('<p>', 'These equations can be written more concisely as: \\(\\vec{u}w_l = P_l M_l \\vec{x}\\) and \\(\\vec{y} w_c = P_c M_c \\vec{x}\\). Division of \\(\\vec{u}w_l\\) and \\(\\vec{y}w_c\\) by their respective homogeneous coordinates yields the Euclidean representations \\(\\vec{u}\\) and \\(\\vec{y}\\).', '</p>'), ('<p>', 'Note that while \\(P_c\\) and \\(M_c\\) are completely determined by the camera image we want to produce, we have some ambiguity in the \\(P_l\\) and \\(M_l\\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.', '</p>'), ('<p>', 'Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \\(u_3\\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the lights image plane to represent boundaries between shadow texels. The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dots depth is saved. However, note that from the cameras perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map samples interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map samples depth farther (to the 2nd red dot), we can achieve correct shadow determination.', '</p>'), ('<p>', 'One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \\(u_3\\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \\(u_3 = u_3(u_1, u_2)\\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\), where we have treated \\(u_3\\) as a function of \\(u_1\\) and \\(u_2\\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobians Frobenius norm).', '</p>'), ('<p>', 'But even if the light is staring at a plane straight on (view direciton lines up with planes normal), making \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\) both zero, we would still need a slight offset because rounding due to the floats finite representation may still cause shadow acne. In this case, wed like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with lights position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogres example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engines chosen scale, you can easily change this choice. At any rate, the relevant quantity is \\(\\frac{\\partial u_3}{\\partial X_3}\\) where \\(\\vec{X} = M_l \\vec{x}\\).', '</p>'), ('<p>', 'The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.', '</p>'), ('<p>', 'Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.', '</p>'), ('<p>', 'where \\(V_l\\) is the viewport matrix for the light and \\(i=1,2,3\\). \\(q_l\\) turns out to be \\(1/w_l\\).', '</p>'), ('<p>', 'where \\(\\vec{n}\\) is the normal at point \\(\\vec{x}\\) and \\(j=1,2\\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.', '</p>'), ('<p>', 'Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.', '</p>'), ('<p>', 'As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. Wed like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in \xa0<a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogres example code implements the bilinear analogue.', '</p>'), ('<p>', 'There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:', '</p>'), ('<p>', 'Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.', '</p>'), ('<p>', 'One example of this is Deep Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community \xa0<a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.', '</p>'), ('<p>', 'While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:', '</p>'), ('<p>', 'Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.', '</p>'), ('<p>', 'Adaptive Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.', '</p>'), ('<p>', 'There are various heuristic approaches for choosing \\(P_l\\) and \\(M_l\\), but here we will focus on one method, the Plane Optimal algorithm \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \\(P_l\\) and \\(M_l\\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).', '</p>'), ('<p>', 'A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there dont seem to more step-by-step expositions available at this moment.', '</p>'), ('<p>', 'There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.', '</p>'), ('<p>', 'We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.', '</p>'), ('<p>', 'The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless were rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.', '</p>'), ('<p>', 'In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If youre going to change hardware, might as well aim for true optimality.', '</p>'), ('<p>', 'Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as normal shadow maps, no matter the perspective warp used to affect sampling.', '</p>'), ('<p>', 'The terms perspective and projective aliasing appeared in the Perspective Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.', '</p>'), ('<p>', 'The setShadowTechnique call is all that is required for Ogres default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.', '</p>'), ('<p>', 'The <code>DepthShadowmap.material</code> script is given below:', '</p>'), ('<p>', ' The material uses unified programs for HLSL, GLSL and GLSLES. Well present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \\(u_3\\) is less evocative of depth than \\(z\\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.', '</p>'), ('<p>', 'This is a pretty standard vertex shader.', '</p>'), ('<p>', 'Just write out the depth values here. We compute the bias and derivatives in the receiver.', '</p>'), ('<p>', 'This is a pretty standard vertex shader as well.', '</p>'), ('<p>', 'This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.', '</p>'), ('<p>', 'Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.', '</p>'), ('<p>', 'The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.', '</p>'), ('<p>', 'Shadow mapping, an algorithm introduced by Lance Williams \xa0<a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the lights snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.', '</p>'), ('<p>', 'In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.', '</p>'), ('<p>', 'Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.', '</p>'), ('<p>', 'Mathematically, the process can be represented as follows: Let \\(P_l\\) and \\(P_c\\) be the projection matrices for the light and camera respectively. Let \\(M_l\\) and \\(M_c\\) be the modelview matrices for the light and camera coordinate systems. Let \\(\\vec{x} = [x_1,x_2,x_3,1]^t\\) be a point in object space, \\(\\vec{y} = [y_1,y_2,y_3,1]^t\\) the screen space coordinates, and \\(\\vec{u} = [u_1,u_2,u_3,1]^t\\) the shadow map coordinates.', '</p>'), ('<p>', 'These equations can be written more concisely as: \\(\\vec{u}w_l = P_l M_l \\vec{x}\\) and \\(\\vec{y} w_c = P_c M_c \\vec{x}\\). Division of \\(\\vec{u}w_l\\) and \\(\\vec{y}w_c\\) by their respective homogeneous coordinates yields the Euclidean representations \\(\\vec{u}\\) and \\(\\vec{y}\\).', '</p>'), ('<p>', 'Note that while \\(P_c\\) and \\(M_c\\) are completely determined by the camera image we want to produce, we have some ambiguity in the \\(P_l\\) and \\(M_l\\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.', '</p>'), ('<p>', 'Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \\(u_3\\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the lights image plane to represent boundaries between shadow texels. The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dots depth is saved. However, note that from the cameras perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map samples interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map samples depth farther (to the 2nd red dot), we can achieve correct shadow determination.', '</p>'), ('<p>', 'One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \\(u_3\\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \\(u_3 = u_3(u_1, u_2)\\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\), where we have treated \\(u_3\\) as a function of \\(u_1\\) and \\(u_2\\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobians Frobenius norm).', '</p>'), ('<p>', 'But even if the light is staring at a plane straight on (view direciton lines up with planes normal), making \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\) both zero, we would still need a slight offset because rounding due to the floats finite representation may still cause shadow acne. In this case, wed like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with lights position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogres example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engines chosen scale, you can easily change this choice. At any rate, the relevant quantity is \\(\\frac{\\partial u_3}{\\partial X_3}\\) where \\(\\vec{X} = M_l \\vec{x}\\).', '</p>'), ('<p>', 'The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.', '</p>'), ('<p>', 'Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.', '</p>'), ('<p>', 'where \\(V_l\\) is the viewport matrix for the light and \\(i=1,2,3\\). \\(q_l\\) turns out to be \\(1/w_l\\).', '</p>'), ('<p>', 'where \\(\\vec{n}\\) is the normal at point \\(\\vec{x}\\) and \\(j=1,2\\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.', '</p>'), ('<p>', 'Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.', '</p>'), ('<p>', 'As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. Wed like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in \xa0<a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogres example code implements the bilinear analogue.', '</p>'), ('<p>', 'There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:', '</p>'), ('<p>', 'Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.', '</p>'), ('<p>', 'One example of this is Deep Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community \xa0<a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.', '</p>'), ('<p>', 'While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:', '</p>'), ('<p>', 'Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.', '</p>'), ('<p>', 'Adaptive Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.', '</p>'), ('<p>', 'There are various heuristic approaches for choosing \\(P_l\\) and \\(M_l\\), but here we will focus on one method, the Plane Optimal algorithm \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \\(P_l\\) and \\(M_l\\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).', '</p>'), ('<p>', 'A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there dont seem to more step-by-step expositions available at this moment.', '</p>'), ('<p>', 'There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.', '</p>'), ('<p>', 'We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.', '</p>'), ('<p>', 'The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless were rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.', '</p>'), ('<p>', 'In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If youre going to change hardware, might as well aim for true optimality.', '</p>'), ('<p>', 'Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as normal shadow maps, no matter the perspective warp used to affect sampling.', '</p>'), ('<p>', 'The terms perspective and projective aliasing appeared in the Perspective Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.', '</p>'), ('<p>', 'The setShadowTechnique call is all that is required for Ogres default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.', '</p>'), ('<p>', 'The <code>DepthShadowmap.material</code> script is given below:', '</p>'), ('<p>', ' The material uses unified programs for HLSL, GLSL and GLSLES. Well present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \\(u_3\\) is less evocative of depth than \\(z\\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.', '</p>'), ('<p>', 'This is a pretty standard vertex shader.', '</p>'), ('<p>', 'Just write out the depth values here. We compute the bias and derivatives in the receiver.', '</p>'), ('<p>', 'This is a pretty standard vertex shader as well.', '</p>'), ('<p>', 'This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.', '</p>'), ('<p>', 'Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.', '</p>'), ('<p>', 'The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.', '</p>'), ('<p>', 'This wiki article is complementary to the deferred shading demo that is part of the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> SDK. It will reference the code quite a bit and explain some of the decisions made when implementing the deferred shading framework for the demo.', '</p>'), ('<p>', 'Deferred shading is an alternative approach to rendering 3d scenes. The classic rendering approach involves rendering each object and applying lighting passes to it. So, if an ogre head is affected by 6 lights, it will be rendered 6 times, once for each light, in order to accumulate the affection of each light. Deferred shading takes another approach : In the beginning, all of the objects render their "lighting related info" to a texture, often called the G-Buffer. This means their colours, normals, depths and any other info that might be relevant to calculating their final colour. Afterwards, the lights in the scene are rendered as geometry (sphere for point light, cone for spotlight and full screen quad for directional light), and they use the G-buffer to calculate the colour contribution of that light to that pixel.', '</p>'), ('<p>', 'See the links in <a class="el" href="deferred.html#further">Further reading</a> to read more about it. It is recommended to understand deferred shading before reading this article, as the article focuses on implementing it in ogre, and not explaining how it works.', '</p>'), ('<p>', "The main reason for using deferred shading is performance related. Classing rendering (also called forward rendering) can, in the worst case, require num_objects * num_lights batches to render a scene. Deferred shading changes that to num_objects + num_lights, which can often be a lot less. Another reason is that some new post-processing effects are easily achievable using the G-Buffer as input. If you wanted to perform these effects without deferred shading, you would've had to render the whole scene again.", '</p>'), ('<p>', 'There are several algorithmic drawbacks with deferred shading - transparent objects are hard to handle, anti aliasing can not be used in DX9 class hardware, additional memory consumption because of the G-Buffer. In addition to that, deferred shading is harder to implement - it overrides the entire fixed function pipeline. Pretty much everything is rendered using manual shaders - which probably means a lot of shader code.', '</p>'), ('<p>', 'The first part of the deferred shading pipeline involves rendering all the (non-transparent) objects of the scene to the G-Buffer. This is done using a compositor :', '</p>'), ('<p>', ' Things to note about this compositor :', '</p>'), ('<p>', 'This in an important decision in deferred shading, as it has performance and visual implications.', '</p>'), ('<p>', 'Also, the entire pipeline has to be coordinated with this format - all the writing shaders have to write the same data to the same places, and all the reading shaders (for lighting later) have to be synchronized with it.', '</p>'), ('<p>', 'We chose two PF_FLOAT16_RGBA textures. The first one will contain the colour in RGB, specular intensity in A.', '</p>'), ('<p>', 'The second one will contain the view-space-normal in RGB (we keep all 3 coordinates) and the (linear) depth in A.', '</p>'), ('<p>', 'See the references for other possibilities.', '</p>'), ('<p>', 'The only indicator that ogre has when rendering the scene is that the material scheme is different. Material schemes in ogre allow materials to specify different rendering techniques for different scenarios. In this case, we would like to output the lighting related information instead of the lighting calculation result.', '</p>'), ('<p>', "Materials that have a technique associated with the GBuffer scheme will render using that, but we don't want to modify the materials of all the objects in our art pipeline to use them in deferred shading.", '</p>'), ('<p>', 'The solution is to use scheme listeners! The material manager has a method for registering listeners when objects don\'t have a technique defined for the current scheme: <a class="el" href="class_ogre_1_1_material_manager.html#a8ac18f4bd2e6302f1d92ae8f64195694" title="Add a listener to handle material events. ">Ogre::MaterialManager::addListener()</a>.', '</p>'), ('<p>', 'The listener has a callback method that gets called whenever an object is about to be rendered without a matching technique: <a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html#a54bc384ab1102063aa00db4c3a5f3fc4" title="Called if a technique for a given scheme is not found within a material, allows the application to sp...">Ogre::MaterialManager::Listener::handleSchemeNotFound()</a>.', '</p>'), ('<p>', 'We will implement such a listener for the GBuffer scheme. It is GBufferSchemeHandler from the demo. The GBufferSchemeHandlers works like this :', '</p>'), ('<p>', 'For each pass in the technique that would have been used normally, the GBufferSchemeHandler::inspectPass is called, inspects the pass, and returns the PassProperties - does this pass have a texture? a normal map? is it skinned? tranpsarent? Etc. The PassProperties (should) contain all the information required to build a GBuffer technique for an object.', '</p>'), ('<p>', 'After a pass has been inspected and understood, the next stage is to generate the G-Buffer-writing technique. This is done using the class GBufferMaterialGenerator. The class receives the flags of the features needed by the material, and dynamically generates the (CG) shaders and material to render an object with those properties to the G-Buffer. This greatly reduces the number of shaders that you need to manage when using deferred shading, as most of them are created on the fly. Here is an example of what they look like :', '</p>'), ('<p>', ' (This is for an object with a texture and a normal map)', '</p>'), ('<p>', "We don't want to inspect the passes and generate the material each time an object is rendered, so we create a technique in the original material, and fill it with the auto-generated information. After copying the information from the GBuffer technique, texture references have to be updated, to use the correct textures when rendering the object. This happens in <code>GBufferSchemeHandler::fillPass</code>. The next time the object will be rendered, it WILL have a technique for the GBuffer scheme, so the listener won't get called.", '</p>'), ('<p>', "We don't want to render transparent objects to the GBuffer, as it doesn't work properly later.", '</p>'), ('<p>', "To address this, we also create a technique with a scheme called called 'NoGBuffer'. If the inspectPass decided that the object is transparent, we will not add an auto-generated pass to the 'GBuffer' technique, but instead copy the regular pass to the 'NoGBuffer' technique, to render it regularly later.", '</p>'), ('<p>', 'This is how <code>GBufferSchemeHandler::handleSchemeNotFound</code> works:', '</p>'), ('<p>', 'In some cases the automatic material generation will not be good enough. We want to keep the option of manually writing GBuffer materials and shaders.', '</p>'), ('<p>', "How do we do this? Easily! Since GBufferSchemeHandler::handleSchemeNotFound only gets called when an object doesn't already have a GBuffer scheme, adding a 'GBuffer' technique to the material will cause it to not get passed to the listener even once.", '</p>'), ('<p>', "Using tools like NVIDIA's PerfHUD, we can see the texture being built during the frame :", '</p>'), ('<p>', 'Note that nothing has been written to the final output yet (main view is completely black) and that two textures are being written to (see right hand side).', '</p>'), ('<p>', 'In the GBuffer compositor, we built the G-Buffer for the current frame. It is now the time to use it to calculate the final lighting of the scene. This is what the compositor looks like :', '</p>'), ('<p>', " Yes, it's a long one. Here is a breakdown of the compositor :", '</p>'), ('<p>', 'There are four target passes in this compositor.', '</p>'), ('<p>', 'This is mainly a limitation of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Ideally, we could use a single target_output pass and do all the passes there. The problem is that material_scheme is at the target scope and not at the pass scope. This is hard to change, because material schemes are resolved during scene preparing time and not during scene rendering. So even if the scope would change, it would not affect the rendering, as the material scheme will not get tested after we switch to it. Perhaps this will be addressed, and then this compositor will get simplified.', '</p>'), ('<p>', "The geometry that we want to render to calculate lighting information doesn't really fit in any classic category. It is not really a part of the scene, as the light geometry aren't objects in the world. But it is geometry (not always a quad) that needs to be rendered.", '</p>'), ('<p>', 'For these kind of operations, the render_custom target pass was introduced into <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. It is possible to register custom (named) composition passes that will be performed in the compositor. In this case, it is \'DeferredLight\'. The composition pass will receive a call each frame telling it \'it\'s your turn, do your thing\'. The class in the demo is DeferredLightCP.', '</p>'), ('<p>', 'The registration of the custom composition pass has to be done once, using <a class="el" href="class_ogre_1_1_compositor_manager.html#ae9b8ca4c2a51c0720bb31393d20fe7c9" title="Register a custom composition pass. ">Ogre::CompositorManager::registerCustomCompositionPass()</a>.', '</p>'), ('<p>', 'CustomCompositionPass is essentially just a factory for RenderSystemOperations, which are the operations that get executed during a compositor chain. This is the single API call: <a class="el" href="class_ogre_1_1_custom_composition_pass.html#a6b8c7a3743f9bb44e27c0348a0035e7b" title="Create a custom composition operation. ">Ogre::CustomCompositionPass::createOperation()</a>.', '</p>'), ('<p>', 'So, now we get called exactly when we want, after the G-Buffer has been built and the (early) skies have been rendered. What will we do?', '</p>'), ('<p>', "Since we rendered the original scene to a different RTT, the depth buffer won't necessarily get reused for the output target, so we need to rebuild it so that future objects (lights and non-g-buffer objects) will be able to interact with the depth naturally.", '</p>'), ('<p>', "Also, we need to apply the ambient light to the scene. For the purpose of the demo, the ambient light is not a separate colour channel, just the object's original textures applied with the scene's global ambient light factor. In theory, you could set up a different G-Buffer to allow more flexibility, but we didn't do that.", '</p>'), ('<p>', 'These two actions happen in a single full-screen quad render, that comes from the AmbientLight class.', '</p>'), ('<p>', "The most important stage is the light geometry. The code scans the original scene's lights, builds a matching DLight (deferred light) instance for each light in the scene, and renders away using the G-Buffer.", '</p>'), ('<p>', 'These lights use pretty sophisticated shaders, since they perform the lighting calculations of the fixed function pipeline themselves, and have to account for many options (specularity, attenuation, different light types and shadows, which will get talked about soon). In contrast to the G-Buffer building stage, the shaders here do not get generated on the fly. There is one big shader (sometimes referred to as an Uber-Shader) with many preprocessor options that account for all the options. (See LightMaterial_ps.cg) Note that the shaders have to be synchronized with the G-Buffer layout. A change in the layout would need a parallel change in the deferred lighting shaders.', '</p>'), ('<p>', 'The material generator for this section (LightMaterialGenerator class) just scans the flags of input and generates the correct preprocessor defines for the uber-shader. Some people prefer to use this approach for the G-Buffer stage as well, but I wanted to show both options in the demo.', '</p>'), ('<p>', 'In order to dispatch render operations manually, the following call exists in SceneManager: <a class="el" href="class_ogre_1_1_scene_manager.html#a1593fab748d1b0820e93e49d5732350b" title="Render something as if it came from the current queue. ">Ogre::SceneManager::_injectRenderWithPass()</a>.', '</p>'), ('<p>', 'When rendering a light, we pass the light we are rendering as the manual light list in order to have the auto params for that light available in the shader.', '</p>'), ('<p>', "The 'classic' approach to rendering texture shadows is to prepare all of them before the scene rendering starts, and then apply them to the rendered objects using shadow receiver passes or integrated shaders. The downside of this approach is that you need to allocate a texture per-light (5 shadow casting lights -&gt; 5 shadow textures) and that if you don't integrate it in your shaders you also contribute even more passes to the scene.", '</p>'), ('<p>', "One of the advantages of deferred shading is that we render the lights completely, and one by one. So, we can generate the shadow texture for a light just before the light's geometry is rendered, allowing us to reuse the same texture for as many lights as we want. (We still have an overhead of rendering the scene from the light's perspective per-light).", '</p>'), ('<p>', 'The API call that prepares shadow textures on demand is <a class="el" href="class_ogre_1_1_scene_manager.html#a95cd8ff86a7178c2e37b2fcb485f64fa" title="Method for preparing shadow textures ready for use in a regular render Do not call manually unless be...">Ogre::SceneManager::prepareShadowTextures()</a>. The lightList parameter allows specification of which lights to prepare shadow textures for.', '</p>'), ('<p>', 'Important note - RenderSystemOperations get executed in the middle of scene rendering. This means that there is an active render target being rendered to. In order to render the shadow texture we need to be able to pause rendering mid frame, render the shadow texture, and resume rendering immediately afterwards. For this, SceneManager has two methods that do just that <a class="el" href="class_ogre_1_1_scene_manager.html#a90d0e7484ed4580ec980eef15808bfee" title="Pause rendering of the frame. ">Ogre::SceneManager::_pauseRendering()</a> and <a class="el" href="class_ogre_1_1_scene_manager.html#a794e03ea25dd798346414c1dba31337d" title="Resume rendering of the frame. ">Ogre::SceneManager::_resumeRendering()</a>, so the prepareShadowTextures call has to be inside this.', '</p>'), ('<p>', 'The demo currently supports just spotlight shadow casting (since it is the cheapest to implement) but the other options can be supported as well.', '</p>'), ('<p>', 'Here is a screenshot from PerfHUD of the draw call that renders a spotlight that casts shadows. See the two G-Buffer textures and one shadow texture on the left :', '</p>'), ('<p>', 'Here is a visualization of the texture being built :', '</p>'), ('<p>', 'After all the lights are rendered, the scene is fully lit!', '</p>'), ('<p>', "The compositor framework used to be a post processing framework, but as this article shows - it is now a 'custom render pipeline' framework, allowing different rendering approaches. However, it can still be used to post process the scene, even under deferred rendering.", '</p>'), ('<p>', "'Screen Space Ambient Occlusion' is a global illumination technique that adds a bit of realism to the scene, where classic lighting often fails. However, it requires the normals and depths of the scene in order to calculate its contribution. Normally, the SSAO compositor would have a render_scene directive that does that.", '</p>'), ('<p>', 'However, with deferred shading, we already have that information from the G-Buffer stage, so we just need to access it!', '</p>'), ('<p>', 'This is what the compositor looks like :', '</p>'), ('<p>', 'Some notes :', '</p>'), ('<p>', 'The framework that this demo uses was designed to be pluggable into other projects. Some of the design considerations that contribute to that are :', '</p>'), ('<p>', "The framework created for a demo fits the plugin architecture pretty well. The GBufferSchemeHandler and DeferredLightCompositionPass classes could be instantiated once on plugin setup and registered with ogre's systems. This is not the case currently just to keep the SDK build simpler.", '</p>'), ('<p>', 'So, the steps are :', '</p>'), ('<p>', 'And thats it! In the demo, the DeferredShading class takes care of that.', '</p>'), ('<p>', 'The deferred shading framework in the demo was designed to be usable in real applications. Where would one want to modify it ?', '</p>'), ('<p>', 'Indeed, it means that the framework is not 100% plug and play. But, if understood correctly, it can be adapted to real life scenarios with relative ease.', '</p>'), ('<p>', 'Post processing compositors that rely on certain aspects of the scene (like SSAO does) are now much easier to create and integrate with the earlier processes. An example could be edge-based anti aliasing, to address the lack of anti aliasing in DX9-based deferred shading systems.', '</p>'), ('<p>', 'In addition to that, the deferred shading implementation was focused on simplicity. There are many optimization options and most of them were not done, mainly to keep the demo as simple and understandable as possible.', '</p>'), ('<p>', "Deferred Shading is an advanced rendering technique, that brings a pretty big implementation challenge along with it. This article, along with the demo, shows that it is possible to implement without relying on hacks and bypassing ogre's systems. Yes, it involves more advanced usage of ogre's APIs and requires a bit of knowledge about what happens behind the scenes, but is in no way impossible.", '</p>'), ('<p>', 'Shadow mapping, an algorithm introduced by Lance Williams \xa0<a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the lights snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.', '</p>'), ('<p>', 'In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.', '</p>'), ('<p>', 'Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.', '</p>'), ('<p>', 'Mathematically, the process can be represented as follows: Let \\(P_l\\) and \\(P_c\\) be the projection matrices for the light and camera respectively. Let \\(M_l\\) and \\(M_c\\) be the modelview matrices for the light and camera coordinate systems. Let \\(\\vec{x} = [x_1,x_2,x_3,1]^t\\) be a point in object space, \\(\\vec{y} = [y_1,y_2,y_3,1]^t\\) the screen space coordinates, and \\(\\vec{u} = [u_1,u_2,u_3,1]^t\\) the shadow map coordinates.', '</p>'), ('<p>', 'These equations can be written more concisely as: \\(\\vec{u}w_l = P_l M_l \\vec{x}\\) and \\(\\vec{y} w_c = P_c M_c \\vec{x}\\). Division of \\(\\vec{u}w_l\\) and \\(\\vec{y}w_c\\) by their respective homogeneous coordinates yields the Euclidean representations \\(\\vec{u}\\) and \\(\\vec{y}\\).', '</p>'), ('<p>', 'Note that while \\(P_c\\) and \\(M_c\\) are completely determined by the camera image we want to produce, we have some ambiguity in the \\(P_l\\) and \\(M_l\\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.', '</p>'), ('<p>', 'Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \\(u_3\\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the lights image plane to represent boundaries between shadow texels. The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dots depth is saved. However, note that from the cameras perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map samples interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map samples depth farther (to the 2nd red dot), we can achieve correct shadow determination.', '</p>'), ('<p>', 'One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \\(u_3\\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \\(u_3 = u_3(u_1, u_2)\\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\), where we have treated \\(u_3\\) as a function of \\(u_1\\) and \\(u_2\\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobians Frobenius norm).', '</p>'), ('<p>', 'But even if the light is staring at a plane straight on (view direciton lines up with planes normal), making \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\) both zero, we would still need a slight offset because rounding due to the floats finite representation may still cause shadow acne. In this case, wed like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with lights position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogres example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engines chosen scale, you can easily change this choice. At any rate, the relevant quantity is \\(\\frac{\\partial u_3}{\\partial X_3}\\) where \\(\\vec{X} = M_l \\vec{x}\\).', '</p>'), ('<p>', 'The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.', '</p>'), ('<p>', 'Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.', '</p>'), ('<p>', 'where \\(V_l\\) is the viewport matrix for the light and \\(i=1,2,3\\). \\(q_l\\) turns out to be \\(1/w_l\\).', '</p>'), ('<p>', 'where \\(\\vec{n}\\) is the normal at point \\(\\vec{x}\\) and \\(j=1,2\\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.', '</p>'), ('<p>', 'Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.', '</p>'), ('<p>', 'As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. Wed like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in \xa0<a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogres example code implements the bilinear analogue.', '</p>'), ('<p>', 'There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:', '</p>'), ('<p>', 'Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.', '</p>'), ('<p>', 'One example of this is Deep Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community \xa0<a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.', '</p>'), ('<p>', 'While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:', '</p>'), ('<p>', 'Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.', '</p>'), ('<p>', 'Adaptive Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.', '</p>'), ('<p>', 'There are various heuristic approaches for choosing \\(P_l\\) and \\(M_l\\), but here we will focus on one method, the Plane Optimal algorithm \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \\(P_l\\) and \\(M_l\\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).', '</p>'), ('<p>', 'A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there dont seem to more step-by-step expositions available at this moment.', '</p>'), ('<p>', 'There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.', '</p>'), ('<p>', 'We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.', '</p>'), ('<p>', 'The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless were rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.', '</p>'), ('<p>', 'In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If youre going to change hardware, might as well aim for true optimality.', '</p>'), ('<p>', 'Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as normal shadow maps, no matter the perspective warp used to affect sampling.', '</p>'), ('<p>', 'The terms perspective and projective aliasing appeared in the Perspective Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.', '</p>'), ('<p>', 'The setShadowTechnique call is all that is required for Ogres default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.', '</p>'), ('<p>', 'The <code>DepthShadowmap.material</code> script is given below:', '</p>'), ('<p>', ' The material uses unified programs for HLSL, GLSL and GLSLES. Well present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \\(u_3\\) is less evocative of depth than \\(z\\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.', '</p>'), ('<p>', 'This is a pretty standard vertex shader.', '</p>'), ('<p>', 'Just write out the depth values here. We compute the bias and derivatives in the receiver.', '</p>'), ('<p>', 'This is a pretty standard vertex shader as well.', '</p>'), ('<p>', 'This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.', '</p>'), ('<p>', 'Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.', '</p>'), ('<p>', 'The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.', '</p>'), ('<p>', 'This wiki article is complementary to the deferred shading demo that is part of the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> SDK. It will reference the code quite a bit and explain some of the decisions made when implementing the deferred shading framework for the demo.', '</p>'), ('<p>', 'Deferred shading is an alternative approach to rendering 3d scenes. The classic rendering approach involves rendering each object and applying lighting passes to it. So, if an ogre head is affected by 6 lights, it will be rendered 6 times, once for each light, in order to accumulate the affection of each light. Deferred shading takes another approach : In the beginning, all of the objects render their "lighting related info" to a texture, often called the G-Buffer. This means their colours, normals, depths and any other info that might be relevant to calculating their final colour. Afterwards, the lights in the scene are rendered as geometry (sphere for point light, cone for spotlight and full screen quad for directional light), and they use the G-buffer to calculate the colour contribution of that light to that pixel.', '</p>'), ('<p>', 'See the links in <a class="el" href="deferred.html#further">Further reading</a> to read more about it. It is recommended to understand deferred shading before reading this article, as the article focuses on implementing it in ogre, and not explaining how it works.', '</p>'), ('<p>', "The main reason for using deferred shading is performance related. Classing rendering (also called forward rendering) can, in the worst case, require num_objects * num_lights batches to render a scene. Deferred shading changes that to num_objects + num_lights, which can often be a lot less. Another reason is that some new post-processing effects are easily achievable using the G-Buffer as input. If you wanted to perform these effects without deferred shading, you would've had to render the whole scene again.", '</p>'), ('<p>', 'There are several algorithmic drawbacks with deferred shading - transparent objects are hard to handle, anti aliasing can not be used in DX9 class hardware, additional memory consumption because of the G-Buffer. In addition to that, deferred shading is harder to implement - it overrides the entire fixed function pipeline. Pretty much everything is rendered using manual shaders - which probably means a lot of shader code.', '</p>'), ('<p>', 'The first part of the deferred shading pipeline involves rendering all the (non-transparent) objects of the scene to the G-Buffer. This is done using a compositor :', '</p>'), ('<p>', ' Things to note about this compositor :', '</p>'), ('<p>', 'This in an important decision in deferred shading, as it has performance and visual implications.', '</p>'), ('<p>', 'Also, the entire pipeline has to be coordinated with this format - all the writing shaders have to write the same data to the same places, and all the reading shaders (for lighting later) have to be synchronized with it.', '</p>'), ('<p>', 'We chose two PF_FLOAT16_RGBA textures. The first one will contain the colour in RGB, specular intensity in A.', '</p>'), ('<p>', 'The second one will contain the view-space-normal in RGB (we keep all 3 coordinates) and the (linear) depth in A.', '</p>'), ('<p>', 'See the references for other possibilities.', '</p>'), ('<p>', 'The only indicator that ogre has when rendering the scene is that the material scheme is different. Material schemes in ogre allow materials to specify different rendering techniques for different scenarios. In this case, we would like to output the lighting related information instead of the lighting calculation result.', '</p>'), ('<p>', "Materials that have a technique associated with the GBuffer scheme will render using that, but we don't want to modify the materials of all the objects in our art pipeline to use them in deferred shading.", '</p>'), ('<p>', 'The solution is to use scheme listeners! The material manager has a method for registering listeners when objects don\'t have a technique defined for the current scheme: <a class="el" href="class_ogre_1_1_material_manager.html#a8ac18f4bd2e6302f1d92ae8f64195694" title="Add a listener to handle material events. ">Ogre::MaterialManager::addListener()</a>.', '</p>'), ('<p>', 'The listener has a callback method that gets called whenever an object is about to be rendered without a matching technique: <a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html#a54bc384ab1102063aa00db4c3a5f3fc4" title="Called if a technique for a given scheme is not found within a material, allows the application to sp...">Ogre::MaterialManager::Listener::handleSchemeNotFound()</a>.', '</p>'), ('<p>', 'We will implement such a listener for the GBuffer scheme. It is GBufferSchemeHandler from the demo. The GBufferSchemeHandlers works like this :', '</p>'), ('<p>', 'For each pass in the technique that would have been used normally, the GBufferSchemeHandler::inspectPass is called, inspects the pass, and returns the PassProperties - does this pass have a texture? a normal map? is it skinned? tranpsarent? Etc. The PassProperties (should) contain all the information required to build a GBuffer technique for an object.', '</p>'), ('<p>', 'After a pass has been inspected and understood, the next stage is to generate the G-Buffer-writing technique. This is done using the class GBufferMaterialGenerator. The class receives the flags of the features needed by the material, and dynamically generates the (CG) shaders and material to render an object with those properties to the G-Buffer. This greatly reduces the number of shaders that you need to manage when using deferred shading, as most of them are created on the fly. Here is an example of what they look like :', '</p>'), ('<p>', ' (This is for an object with a texture and a normal map)', '</p>'), ('<p>', "We don't want to inspect the passes and generate the material each time an object is rendered, so we create a technique in the original material, and fill it with the auto-generated information. After copying the information from the GBuffer technique, texture references have to be updated, to use the correct textures when rendering the object. This happens in <code>GBufferSchemeHandler::fillPass</code>. The next time the object will be rendered, it WILL have a technique for the GBuffer scheme, so the listener won't get called.", '</p>'), ('<p>', "We don't want to render transparent objects to the GBuffer, as it doesn't work properly later.", '</p>'), ('<p>', "To address this, we also create a technique with a scheme called called 'NoGBuffer'. If the inspectPass decided that the object is transparent, we will not add an auto-generated pass to the 'GBuffer' technique, but instead copy the regular pass to the 'NoGBuffer' technique, to render it regularly later.", '</p>'), ('<p>', 'This is how <code>GBufferSchemeHandler::handleSchemeNotFound</code> works:', '</p>'), ('<p>', 'In some cases the automatic material generation will not be good enough. We want to keep the option of manually writing GBuffer materials and shaders.', '</p>'), ('<p>', "How do we do this? Easily! Since GBufferSchemeHandler::handleSchemeNotFound only gets called when an object doesn't already have a GBuffer scheme, adding a 'GBuffer' technique to the material will cause it to not get passed to the listener even once.", '</p>'), ('<p>', "Using tools like NVIDIA's PerfHUD, we can see the texture being built during the frame :", '</p>'), ('<p>', 'Note that nothing has been written to the final output yet (main view is completely black) and that two textures are being written to (see right hand side).', '</p>'), ('<p>', 'In the GBuffer compositor, we built the G-Buffer for the current frame. It is now the time to use it to calculate the final lighting of the scene. This is what the compositor looks like :', '</p>'), ('<p>', " Yes, it's a long one. Here is a breakdown of the compositor :", '</p>'), ('<p>', 'There are four target passes in this compositor.', '</p>'), ('<p>', 'This is mainly a limitation of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Ideally, we could use a single target_output pass and do all the passes there. The problem is that material_scheme is at the target scope and not at the pass scope. This is hard to change, because material schemes are resolved during scene preparing time and not during scene rendering. So even if the scope would change, it would not affect the rendering, as the material scheme will not get tested after we switch to it. Perhaps this will be addressed, and then this compositor will get simplified.', '</p>'), ('<p>', "The geometry that we want to render to calculate lighting information doesn't really fit in any classic category. It is not really a part of the scene, as the light geometry aren't objects in the world. But it is geometry (not always a quad) that needs to be rendered.", '</p>'), ('<p>', 'For these kind of operations, the render_custom target pass was introduced into <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. It is possible to register custom (named) composition passes that will be performed in the compositor. In this case, it is \'DeferredLight\'. The composition pass will receive a call each frame telling it \'it\'s your turn, do your thing\'. The class in the demo is DeferredLightCP.', '</p>'), ('<p>', 'The registration of the custom composition pass has to be done once, using <a class="el" href="class_ogre_1_1_compositor_manager.html#ae9b8ca4c2a51c0720bb31393d20fe7c9" title="Register a custom composition pass. ">Ogre::CompositorManager::registerCustomCompositionPass()</a>.', '</p>'), ('<p>', 'CustomCompositionPass is essentially just a factory for RenderSystemOperations, which are the operations that get executed during a compositor chain. This is the single API call: <a class="el" href="class_ogre_1_1_custom_composition_pass.html#a6b8c7a3743f9bb44e27c0348a0035e7b" title="Create a custom composition operation. ">Ogre::CustomCompositionPass::createOperation()</a>.', '</p>'), ('<p>', 'So, now we get called exactly when we want, after the G-Buffer has been built and the (early) skies have been rendered. What will we do?', '</p>'), ('<p>', "Since we rendered the original scene to a different RTT, the depth buffer won't necessarily get reused for the output target, so we need to rebuild it so that future objects (lights and non-g-buffer objects) will be able to interact with the depth naturally.", '</p>'), ('<p>', "Also, we need to apply the ambient light to the scene. For the purpose of the demo, the ambient light is not a separate colour channel, just the object's original textures applied with the scene's global ambient light factor. In theory, you could set up a different G-Buffer to allow more flexibility, but we didn't do that.", '</p>'), ('<p>', 'These two actions happen in a single full-screen quad render, that comes from the AmbientLight class.', '</p>'), ('<p>', "The most important stage is the light geometry. The code scans the original scene's lights, builds a matching DLight (deferred light) instance for each light in the scene, and renders away using the G-Buffer.", '</p>'), ('<p>', 'These lights use pretty sophisticated shaders, since they perform the lighting calculations of the fixed function pipeline themselves, and have to account for many options (specularity, attenuation, different light types and shadows, which will get talked about soon). In contrast to the G-Buffer building stage, the shaders here do not get generated on the fly. There is one big shader (sometimes referred to as an Uber-Shader) with many preprocessor options that account for all the options. (See LightMaterial_ps.cg) Note that the shaders have to be synchronized with the G-Buffer layout. A change in the layout would need a parallel change in the deferred lighting shaders.', '</p>'), ('<p>', 'The material generator for this section (LightMaterialGenerator class) just scans the flags of input and generates the correct preprocessor defines for the uber-shader. Some people prefer to use this approach for the G-Buffer stage as well, but I wanted to show both options in the demo.', '</p>'), ('<p>', 'In order to dispatch render operations manually, the following call exists in SceneManager: <a class="el" href="class_ogre_1_1_scene_manager.html#a1593fab748d1b0820e93e49d5732350b" title="Render something as if it came from the current queue. ">Ogre::SceneManager::_injectRenderWithPass()</a>.', '</p>'), ('<p>', 'When rendering a light, we pass the light we are rendering as the manual light list in order to have the auto params for that light available in the shader.', '</p>'), ('<p>', "The 'classic' approach to rendering texture shadows is to prepare all of them before the scene rendering starts, and then apply them to the rendered objects using shadow receiver passes or integrated shaders. The downside of this approach is that you need to allocate a texture per-light (5 shadow casting lights -&gt; 5 shadow textures) and that if you don't integrate it in your shaders you also contribute even more passes to the scene.", '</p>'), ('<p>', "One of the advantages of deferred shading is that we render the lights completely, and one by one. So, we can generate the shadow texture for a light just before the light's geometry is rendered, allowing us to reuse the same texture for as many lights as we want. (We still have an overhead of rendering the scene from the light's perspective per-light).", '</p>'), ('<p>', 'The API call that prepares shadow textures on demand is <a class="el" href="class_ogre_1_1_scene_manager.html#a95cd8ff86a7178c2e37b2fcb485f64fa" title="Method for preparing shadow textures ready for use in a regular render Do not call manually unless be...">Ogre::SceneManager::prepareShadowTextures()</a>. The lightList parameter allows specification of which lights to prepare shadow textures for.', '</p>'), ('<p>', 'Important note - RenderSystemOperations get executed in the middle of scene rendering. This means that there is an active render target being rendered to. In order to render the shadow texture we need to be able to pause rendering mid frame, render the shadow texture, and resume rendering immediately afterwards. For this, SceneManager has two methods that do just that <a class="el" href="class_ogre_1_1_scene_manager.html#a90d0e7484ed4580ec980eef15808bfee" title="Pause rendering of the frame. ">Ogre::SceneManager::_pauseRendering()</a> and <a class="el" href="class_ogre_1_1_scene_manager.html#a794e03ea25dd798346414c1dba31337d" title="Resume rendering of the frame. ">Ogre::SceneManager::_resumeRendering()</a>, so the prepareShadowTextures call has to be inside this.', '</p>'), ('<p>', 'The demo currently supports just spotlight shadow casting (since it is the cheapest to implement) but the other options can be supported as well.', '</p>'), ('<p>', 'Here is a screenshot from PerfHUD of the draw call that renders a spotlight that casts shadows. See the two G-Buffer textures and one shadow texture on the left :', '</p>'), ('<p>', 'Here is a visualization of the texture being built :', '</p>'), ('<p>', 'After all the lights are rendered, the scene is fully lit!', '</p>'), ('<p>', "The compositor framework used to be a post processing framework, but as this article shows - it is now a 'custom render pipeline' framework, allowing different rendering approaches. However, it can still be used to post process the scene, even under deferred rendering.", '</p>'), ('<p>', "'Screen Space Ambient Occlusion' is a global illumination technique that adds a bit of realism to the scene, where classic lighting often fails. However, it requires the normals and depths of the scene in order to calculate its contribution. Normally, the SSAO compositor would have a render_scene directive that does that.", '</p>'), ('<p>', 'However, with deferred shading, we already have that information from the G-Buffer stage, so we just need to access it!', '</p>'), ('<p>', 'This is what the compositor looks like :', '</p>'), ('<p>', 'Some notes :', '</p>'), ('<p>', 'The framework that this demo uses was designed to be pluggable into other projects. Some of the design considerations that contribute to that are :', '</p>'), ('<p>', "The framework created for a demo fits the plugin architecture pretty well. The GBufferSchemeHandler and DeferredLightCompositionPass classes could be instantiated once on plugin setup and registered with ogre's systems. This is not the case currently just to keep the SDK build simpler.", '</p>'), ('<p>', 'So, the steps are :', '</p>'), ('<p>', 'And thats it! In the demo, the DeferredShading class takes care of that.', '</p>'), ('<p>', 'The deferred shading framework in the demo was designed to be usable in real applications. Where would one want to modify it ?', '</p>'), ('<p>', 'Indeed, it means that the framework is not 100% plug and play. But, if understood correctly, it can be adapted to real life scenarios with relative ease.', '</p>'), ('<p>', 'Post processing compositors that rely on certain aspects of the scene (like SSAO does) are now much easier to create and integrate with the earlier processes. An example could be edge-based anti aliasing, to address the lack of anti aliasing in DX9-based deferred shading systems.', '</p>'), ('<p>', 'In addition to that, the deferred shading implementation was focused on simplicity. There are many optimization options and most of them were not done, mainly to keep the demo as simple and understandable as possible.', '</p>'), ('<p>', "Deferred Shading is an advanced rendering technique, that brings a pretty big implementation challenge along with it. This article, along with the demo, shows that it is possible to implement without relying on hacks and bypassing ogre's systems. Yes, it involves more advanced usage of ogre's APIs and requires a bit of knowledge about what happens behind the scenes, but is in no way impossible.", '</p>'), ('<p>', 'This wiki article is complementary to the deferred shading demo that is part of the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> SDK. It will reference the code quite a bit and explain some of the decisions made when implementing the deferred shading framework for the demo.', '</p>'), ('<p>', 'Deferred shading is an alternative approach to rendering 3d scenes. The classic rendering approach involves rendering each object and applying lighting passes to it. So, if an ogre head is affected by 6 lights, it will be rendered 6 times, once for each light, in order to accumulate the affection of each light. Deferred shading takes another approach : In the beginning, all of the objects render their "lighting related info" to a texture, often called the G-Buffer. This means their colours, normals, depths and any other info that might be relevant to calculating their final colour. Afterwards, the lights in the scene are rendered as geometry (sphere for point light, cone for spotlight and full screen quad for directional light), and they use the G-buffer to calculate the colour contribution of that light to that pixel.', '</p>'), ('<p>', 'See the links in <a class="el" href="deferred.html#further">Further reading</a> to read more about it. It is recommended to understand deferred shading before reading this article, as the article focuses on implementing it in ogre, and not explaining how it works.', '</p>'), ('<p>', "The main reason for using deferred shading is performance related. Classing rendering (also called forward rendering) can, in the worst case, require num_objects * num_lights batches to render a scene. Deferred shading changes that to num_objects + num_lights, which can often be a lot less. Another reason is that some new post-processing effects are easily achievable using the G-Buffer as input. If you wanted to perform these effects without deferred shading, you would've had to render the whole scene again.", '</p>'), ('<p>', 'There are several algorithmic drawbacks with deferred shading - transparent objects are hard to handle, anti aliasing can not be used in DX9 class hardware, additional memory consumption because of the G-Buffer. In addition to that, deferred shading is harder to implement - it overrides the entire fixed function pipeline. Pretty much everything is rendered using manual shaders - which probably means a lot of shader code.', '</p>'), ('<p>', 'The first part of the deferred shading pipeline involves rendering all the (non-transparent) objects of the scene to the G-Buffer. This is done using a compositor :', '</p>'), ('<p>', ' Things to note about this compositor :', '</p>'), ('<p>', 'This in an important decision in deferred shading, as it has performance and visual implications.', '</p>'), ('<p>', 'Also, the entire pipeline has to be coordinated with this format - all the writing shaders have to write the same data to the same places, and all the reading shaders (for lighting later) have to be synchronized with it.', '</p>'), ('<p>', 'We chose two PF_FLOAT16_RGBA textures. The first one will contain the colour in RGB, specular intensity in A.', '</p>'), ('<p>', 'The second one will contain the view-space-normal in RGB (we keep all 3 coordinates) and the (linear) depth in A.', '</p>'), ('<p>', 'See the references for other possibilities.', '</p>'), ('<p>', 'The only indicator that ogre has when rendering the scene is that the material scheme is different. Material schemes in ogre allow materials to specify different rendering techniques for different scenarios. In this case, we would like to output the lighting related information instead of the lighting calculation result.', '</p>'), ('<p>', "Materials that have a technique associated with the GBuffer scheme will render using that, but we don't want to modify the materials of all the objects in our art pipeline to use them in deferred shading.", '</p>'), ('<p>', 'The solution is to use scheme listeners! The material manager has a method for registering listeners when objects don\'t have a technique defined for the current scheme: <a class="el" href="class_ogre_1_1_material_manager.html#a8ac18f4bd2e6302f1d92ae8f64195694" title="Add a listener to handle material events. ">Ogre::MaterialManager::addListener()</a>.', '</p>'), ('<p>', 'The listener has a callback method that gets called whenever an object is about to be rendered without a matching technique: <a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html#a54bc384ab1102063aa00db4c3a5f3fc4" title="Called if a technique for a given scheme is not found within a material, allows the application to sp...">Ogre::MaterialManager::Listener::handleSchemeNotFound()</a>.', '</p>'), ('<p>', 'We will implement such a listener for the GBuffer scheme. It is GBufferSchemeHandler from the demo. The GBufferSchemeHandlers works like this :', '</p>'), ('<p>', 'For each pass in the technique that would have been used normally, the GBufferSchemeHandler::inspectPass is called, inspects the pass, and returns the PassProperties - does this pass have a texture? a normal map? is it skinned? tranpsarent? Etc. The PassProperties (should) contain all the information required to build a GBuffer technique for an object.', '</p>'), ('<p>', 'After a pass has been inspected and understood, the next stage is to generate the G-Buffer-writing technique. This is done using the class GBufferMaterialGenerator. The class receives the flags of the features needed by the material, and dynamically generates the (CG) shaders and material to render an object with those properties to the G-Buffer. This greatly reduces the number of shaders that you need to manage when using deferred shading, as most of them are created on the fly. Here is an example of what they look like :', '</p>'), ('<p>', ' (This is for an object with a texture and a normal map)', '</p>'), ('<p>', "We don't want to inspect the passes and generate the material each time an object is rendered, so we create a technique in the original material, and fill it with the auto-generated information. After copying the information from the GBuffer technique, texture references have to be updated, to use the correct textures when rendering the object. This happens in <code>GBufferSchemeHandler::fillPass</code>. The next time the object will be rendered, it WILL have a technique for the GBuffer scheme, so the listener won't get called.", '</p>'), ('<p>', "We don't want to render transparent objects to the GBuffer, as it doesn't work properly later.", '</p>'), ('<p>', "To address this, we also create a technique with a scheme called called 'NoGBuffer'. If the inspectPass decided that the object is transparent, we will not add an auto-generated pass to the 'GBuffer' technique, but instead copy the regular pass to the 'NoGBuffer' technique, to render it regularly later.", '</p>'), ('<p>', 'This is how <code>GBufferSchemeHandler::handleSchemeNotFound</code> works:', '</p>'), ('<p>', 'In some cases the automatic material generation will not be good enough. We want to keep the option of manually writing GBuffer materials and shaders.', '</p>'), ('<p>', "How do we do this? Easily! Since GBufferSchemeHandler::handleSchemeNotFound only gets called when an object doesn't already have a GBuffer scheme, adding a 'GBuffer' technique to the material will cause it to not get passed to the listener even once.", '</p>'), ('<p>', "Using tools like NVIDIA's PerfHUD, we can see the texture being built during the frame :", '</p>'), ('<p>', 'Note that nothing has been written to the final output yet (main view is completely black) and that two textures are being written to (see right hand side).', '</p>'), ('<p>', 'In the GBuffer compositor, we built the G-Buffer for the current frame. It is now the time to use it to calculate the final lighting of the scene. This is what the compositor looks like :', '</p>'), ('<p>', " Yes, it's a long one. Here is a breakdown of the compositor :", '</p>'), ('<p>', 'There are four target passes in this compositor.', '</p>'), ('<p>', 'This is mainly a limitation of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Ideally, we could use a single target_output pass and do all the passes there. The problem is that material_scheme is at the target scope and not at the pass scope. This is hard to change, because material schemes are resolved during scene preparing time and not during scene rendering. So even if the scope would change, it would not affect the rendering, as the material scheme will not get tested after we switch to it. Perhaps this will be addressed, and then this compositor will get simplified.', '</p>'), ('<p>', "The geometry that we want to render to calculate lighting information doesn't really fit in any classic category. It is not really a part of the scene, as the light geometry aren't objects in the world. But it is geometry (not always a quad) that needs to be rendered.", '</p>'), ('<p>', 'For these kind of operations, the render_custom target pass was introduced into <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. It is possible to register custom (named) composition passes that will be performed in the compositor. In this case, it is \'DeferredLight\'. The composition pass will receive a call each frame telling it \'it\'s your turn, do your thing\'. The class in the demo is DeferredLightCP.', '</p>'), ('<p>', 'The registration of the custom composition pass has to be done once, using <a class="el" href="class_ogre_1_1_compositor_manager.html#ae9b8ca4c2a51c0720bb31393d20fe7c9" title="Register a custom composition pass. ">Ogre::CompositorManager::registerCustomCompositionPass()</a>.', '</p>'), ('<p>', 'CustomCompositionPass is essentially just a factory for RenderSystemOperations, which are the operations that get executed during a compositor chain. This is the single API call: <a class="el" href="class_ogre_1_1_custom_composition_pass.html#a6b8c7a3743f9bb44e27c0348a0035e7b" title="Create a custom composition operation. ">Ogre::CustomCompositionPass::createOperation()</a>.', '</p>'), ('<p>', 'So, now we get called exactly when we want, after the G-Buffer has been built and the (early) skies have been rendered. What will we do?', '</p>'), ('<p>', "Since we rendered the original scene to a different RTT, the depth buffer won't necessarily get reused for the output target, so we need to rebuild it so that future objects (lights and non-g-buffer objects) will be able to interact with the depth naturally.", '</p>'), ('<p>', "Also, we need to apply the ambient light to the scene. For the purpose of the demo, the ambient light is not a separate colour channel, just the object's original textures applied with the scene's global ambient light factor. In theory, you could set up a different G-Buffer to allow more flexibility, but we didn't do that.", '</p>'), ('<p>', 'These two actions happen in a single full-screen quad render, that comes from the AmbientLight class.', '</p>'), ('<p>', "The most important stage is the light geometry. The code scans the original scene's lights, builds a matching DLight (deferred light) instance for each light in the scene, and renders away using the G-Buffer.", '</p>'), ('<p>', 'These lights use pretty sophisticated shaders, since they perform the lighting calculations of the fixed function pipeline themselves, and have to account for many options (specularity, attenuation, different light types and shadows, which will get talked about soon). In contrast to the G-Buffer building stage, the shaders here do not get generated on the fly. There is one big shader (sometimes referred to as an Uber-Shader) with many preprocessor options that account for all the options. (See LightMaterial_ps.cg) Note that the shaders have to be synchronized with the G-Buffer layout. A change in the layout would need a parallel change in the deferred lighting shaders.', '</p>'), ('<p>', 'The material generator for this section (LightMaterialGenerator class) just scans the flags of input and generates the correct preprocessor defines for the uber-shader. Some people prefer to use this approach for the G-Buffer stage as well, but I wanted to show both options in the demo.', '</p>'), ('<p>', 'In order to dispatch render operations manually, the following call exists in SceneManager: <a class="el" href="class_ogre_1_1_scene_manager.html#a1593fab748d1b0820e93e49d5732350b" title="Render something as if it came from the current queue. ">Ogre::SceneManager::_injectRenderWithPass()</a>.', '</p>'), ('<p>', 'When rendering a light, we pass the light we are rendering as the manual light list in order to have the auto params for that light available in the shader.', '</p>'), ('<p>', "The 'classic' approach to rendering texture shadows is to prepare all of them before the scene rendering starts, and then apply them to the rendered objects using shadow receiver passes or integrated shaders. The downside of this approach is that you need to allocate a texture per-light (5 shadow casting lights -&gt; 5 shadow textures) and that if you don't integrate it in your shaders you also contribute even more passes to the scene.", '</p>'), ('<p>', "One of the advantages of deferred shading is that we render the lights completely, and one by one. So, we can generate the shadow texture for a light just before the light's geometry is rendered, allowing us to reuse the same texture for as many lights as we want. (We still have an overhead of rendering the scene from the light's perspective per-light).", '</p>'), ('<p>', 'The API call that prepares shadow textures on demand is <a class="el" href="class_ogre_1_1_scene_manager.html#a95cd8ff86a7178c2e37b2fcb485f64fa" title="Method for preparing shadow textures ready for use in a regular render Do not call manually unless be...">Ogre::SceneManager::prepareShadowTextures()</a>. The lightList parameter allows specification of which lights to prepare shadow textures for.', '</p>'), ('<p>', 'Important note - RenderSystemOperations get executed in the middle of scene rendering. This means that there is an active render target being rendered to. In order to render the shadow texture we need to be able to pause rendering mid frame, render the shadow texture, and resume rendering immediately afterwards. For this, SceneManager has two methods that do just that <a class="el" href="class_ogre_1_1_scene_manager.html#a90d0e7484ed4580ec980eef15808bfee" title="Pause rendering of the frame. ">Ogre::SceneManager::_pauseRendering()</a> and <a class="el" href="class_ogre_1_1_scene_manager.html#a794e03ea25dd798346414c1dba31337d" title="Resume rendering of the frame. ">Ogre::SceneManager::_resumeRendering()</a>, so the prepareShadowTextures call has to be inside this.', '</p>'), ('<p>', 'The demo currently supports just spotlight shadow casting (since it is the cheapest to implement) but the other options can be supported as well.', '</p>'), ('<p>', 'Here is a screenshot from PerfHUD of the draw call that renders a spotlight that casts shadows. See the two G-Buffer textures and one shadow texture on the left :', '</p>'), ('<p>', 'Here is a visualization of the texture being built :', '</p>'), ('<p>', 'After all the lights are rendered, the scene is fully lit!', '</p>'), ('<p>', "The compositor framework used to be a post processing framework, but as this article shows - it is now a 'custom render pipeline' framework, allowing different rendering approaches. However, it can still be used to post process the scene, even under deferred rendering.", '</p>'), ('<p>', "'Screen Space Ambient Occlusion' is a global illumination technique that adds a bit of realism to the scene, where classic lighting often fails. However, it requires the normals and depths of the scene in order to calculate its contribution. Normally, the SSAO compositor would have a render_scene directive that does that.", '</p>'), ('<p>', 'However, with deferred shading, we already have that information from the G-Buffer stage, so we just need to access it!', '</p>'), ('<p>', 'This is what the compositor looks like :', '</p>'), ('<p>', 'Some notes :', '</p>'), ('<p>', 'The framework that this demo uses was designed to be pluggable into other projects. Some of the design considerations that contribute to that are :', '</p>'), ('<p>', "The framework created for a demo fits the plugin architecture pretty well. The GBufferSchemeHandler and DeferredLightCompositionPass classes could be instantiated once on plugin setup and registered with ogre's systems. This is not the case currently just to keep the SDK build simpler.", '</p>'), ('<p>', 'So, the steps are :', '</p>'), ('<p>', 'And thats it! In the demo, the DeferredShading class takes care of that.', '</p>'), ('<p>', 'The deferred shading framework in the demo was designed to be usable in real applications. Where would one want to modify it ?', '</p>'), ('<p>', 'Indeed, it means that the framework is not 100% plug and play. But, if understood correctly, it can be adapted to real life scenarios with relative ease.', '</p>'), ('<p>', 'Post processing compositors that rely on certain aspects of the scene (like SSAO does) are now much easier to create and integrate with the earlier processes. An example could be edge-based anti aliasing, to address the lack of anti aliasing in DX9-based deferred shading systems.', '</p>'), ('<p>', 'In addition to that, the deferred shading implementation was focused on simplicity. There are many optimization options and most of them were not done, mainly to keep the demo as simple and understandable as possible.', '</p>'), ('<p>', "Deferred Shading is an advanced rendering technique, that brings a pretty big implementation challenge along with it. This article, along with the demo, shows that it is possible to implement without relying on hacks and bypassing ogre's systems. Yes, it involves more advanced usage of ogre's APIs and requires a bit of knowledge about what happens behind the scenes, but is in no way impossible.", '</p>'), ('<p>', 'Shadow mapping, an algorithm introduced by Lance Williams \xa0<a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the lights snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.', '</p>'), ('<p>', 'In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.', '</p>'), ('<p>', 'Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.', '</p>'), ('<p>', 'Mathematically, the process can be represented as follows: Let \\(P_l\\) and \\(P_c\\) be the projection matrices for the light and camera respectively. Let \\(M_l\\) and \\(M_c\\) be the modelview matrices for the light and camera coordinate systems. Let \\(\\vec{x} = [x_1,x_2,x_3,1]^t\\) be a point in object space, \\(\\vec{y} = [y_1,y_2,y_3,1]^t\\) the screen space coordinates, and \\(\\vec{u} = [u_1,u_2,u_3,1]^t\\) the shadow map coordinates.', '</p>'), ('<p>', 'These equations can be written more concisely as: \\(\\vec{u}w_l = P_l M_l \\vec{x}\\) and \\(\\vec{y} w_c = P_c M_c \\vec{x}\\). Division of \\(\\vec{u}w_l\\) and \\(\\vec{y}w_c\\) by their respective homogeneous coordinates yields the Euclidean representations \\(\\vec{u}\\) and \\(\\vec{y}\\).', '</p>'), ('<p>', 'Note that while \\(P_c\\) and \\(M_c\\) are completely determined by the camera image we want to produce, we have some ambiguity in the \\(P_l\\) and \\(M_l\\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.', '</p>'), ('<p>', 'Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \\(u_3\\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the lights image plane to represent boundaries between shadow texels. The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dots depth is saved. However, note that from the cameras perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map samples interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map samples depth farther (to the 2nd red dot), we can achieve correct shadow determination.', '</p>'), ('<p>', 'One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \\(u_3\\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \\(u_3 = u_3(u_1, u_2)\\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\), where we have treated \\(u_3\\) as a function of \\(u_1\\) and \\(u_2\\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobians Frobenius norm).', '</p>'), ('<p>', 'But even if the light is staring at a plane straight on (view direciton lines up with planes normal), making \\(\\frac{du_3}{du_1}\\) and \\(\\frac{du_3}{du_2}\\) both zero, we would still need a slight offset because rounding due to the floats finite representation may still cause shadow acne. In this case, wed like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with lights position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogres example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engines chosen scale, you can easily change this choice. At any rate, the relevant quantity is \\(\\frac{\\partial u_3}{\\partial X_3}\\) where \\(\\vec{X} = M_l \\vec{x}\\).', '</p>'), ('<p>', 'The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.', '</p>'), ('<p>', 'Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.', '</p>'), ('<p>', 'where \\(V_l\\) is the viewport matrix for the light and \\(i=1,2,3\\). \\(q_l\\) turns out to be \\(1/w_l\\).', '</p>'), ('<p>', 'where \\(\\vec{n}\\) is the normal at point \\(\\vec{x}\\) and \\(j=1,2\\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.', '</p>'), ('<p>', 'Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.', '</p>'), ('<p>', 'As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. Wed like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in \xa0<a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogres example code implements the bilinear analogue.', '</p>'), ('<p>', 'There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:', '</p>'), ('<p>', 'Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.', '</p>'), ('<p>', 'One example of this is Deep Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community \xa0<a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.', '</p>'), ('<p>', 'While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:', '</p>'), ('<p>', 'Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.', '</p>'), ('<p>', 'Adaptive Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.', '</p>'), ('<p>', 'There are various heuristic approaches for choosing \\(P_l\\) and \\(M_l\\), but here we will focus on one method, the Plane Optimal algorithm \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \\(P_l\\) and \\(M_l\\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).', '</p>'), ('<p>', 'A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and \xa0<a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there dont seem to more step-by-step expositions available at this moment.', '</p>'), ('<p>', 'There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.', '</p>'), ('<p>', 'We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.', '</p>'), ('<p>', 'The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless were rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.', '</p>'), ('<p>', 'In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If youre going to change hardware, might as well aim for true optimality.', '</p>'), ('<p>', 'Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as normal shadow maps, no matter the perspective warp used to affect sampling.', '</p>'), ('<p>', 'The terms perspective and projective aliasing appeared in the Perspective Shadow Maps \xa0<a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See \xa0<a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.', '</p>'), ('<p>', '<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.', '</p>'), ('<p>', 'The setShadowTechnique call is all that is required for Ogres default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.', '</p>'), ('<p>', 'The <code>DepthShadowmap.material</code> script is given below:', '</p>'), ('<p>', ' The material uses unified programs for HLSL, GLSL and GLSLES. Well present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \\(u_3\\) is less evocative of depth than \\(z\\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.', '</p>'), ('<p>', 'This is a pretty standard vertex shader.', '</p>'), ('<p>', 'Just write out the depth values here. We compute the bias and derivatives in the receiver.', '</p>'), ('<p>', 'This is a pretty standard vertex shader as well.', '</p>'), ('<p>', 'This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.', '</p>'), ('<p>', 'Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.', '</p>'), ('<p>', 'The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.', '</p>'), ('<p>', 'This wiki article is complementary to the deferred shading demo that is part of the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> SDK. It will reference the code quite a bit and explain some of the decisions made when implementing the deferred shading framework for the demo.', '</p>'), ('<p>', 'Deferred shading is an alternative approach to rendering 3d scenes. The classic rendering approach involves rendering each object and applying lighting passes to it. So, if an ogre head is affected by 6 lights, it will be rendered 6 times, once for each light, in order to accumulate the affection of each light. Deferred shading takes another approach : In the beginning, all of the objects render their "lighting related info" to a texture, often called the G-Buffer. This means their colours, normals, depths and any other info that might be relevant to calculating their final colour. Afterwards, the lights in the scene are rendered as geometry (sphere for point light, cone for spotlight and full screen quad for directional light), and they use the G-buffer to calculate the colour contribution of that light to that pixel.', '</p>'), ('<p>', 'See the links in <a class="el" href="deferred.html#further">Further reading</a> to read more about it. It is recommended to understand deferred shading before reading this article, as the article focuses on implementing it in ogre, and not explaining how it works.', '</p>'), ('<p>', "The main reason for using deferred shading is performance related. Classing rendering (also called forward rendering) can, in the worst case, require num_objects * num_lights batches to render a scene. Deferred shading changes that to num_objects + num_lights, which can often be a lot less. Another reason is that some new post-processing effects are easily achievable using the G-Buffer as input. If you wanted to perform these effects without deferred shading, you would've had to render the whole scene again.", '</p>'), ('<p>', 'There are several algorithmic drawbacks with deferred shading - transparent objects are hard to handle, anti aliasing can not be used in DX9 class hardware, additional memory consumption because of the G-Buffer. In addition to that, deferred shading is harder to implement - it overrides the entire fixed function pipeline. Pretty much everything is rendered using manual shaders - which probably means a lot of shader code.', '</p>'), ('<p>', 'The first part of the deferred shading pipeline involves rendering all the (non-transparent) objects of the scene to the G-Buffer. This is done using a compositor :', '</p>'), ('<p>', ' Things to note about this compositor :', '</p>'), ('<p>', 'This in an important decision in deferred shading, as it has performance and visual implications.', '</p>'), ('<p>', 'Also, the entire pipeline has to be coordinated with this format - all the writing shaders have to write the same data to the same places, and all the reading shaders (for lighting later) have to be synchronized with it.', '</p>'), ('<p>', 'We chose two PF_FLOAT16_RGBA textures. The first one will contain the colour in RGB, specular intensity in A.', '</p>'), ('<p>', 'The second one will contain the view-space-normal in RGB (we keep all 3 coordinates) and the (linear) depth in A.', '</p>'), ('<p>', 'See the references for other possibilities.', '</p>'), ('<p>', 'The only indicator that ogre has when rendering the scene is that the material scheme is different. Material schemes in ogre allow materials to specify different rendering techniques for different scenarios. In this case, we would like to output the lighting related information instead of the lighting calculation result.', '</p>'), ('<p>', "Materials that have a technique associated with the GBuffer scheme will render using that, but we don't want to modify the materials of all the objects in our art pipeline to use them in deferred shading.", '</p>'), ('<p>', 'The solution is to use scheme listeners! The material manager has a method for registering listeners when objects don\'t have a technique defined for the current scheme: <a class="el" href="class_ogre_1_1_material_manager.html#a8ac18f4bd2e6302f1d92ae8f64195694" title="Add a listener to handle material events. ">Ogre::MaterialManager::addListener()</a>.', '</p>'), ('<p>', 'The listener has a callback method that gets called whenever an object is about to be rendered without a matching technique: <a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html#a54bc384ab1102063aa00db4c3a5f3fc4" title="Called if a technique for a given scheme is not found within a material, allows the application to sp...">Ogre::MaterialManager::Listener::handleSchemeNotFound()</a>.', '</p>'), ('<p>', 'We will implement such a listener for the GBuffer scheme. It is GBufferSchemeHandler from the demo. The GBufferSchemeHandlers works like this :', '</p>'), ('<p>', 'For each pass in the technique that would have been used normally, the GBufferSchemeHandler::inspectPass is called, inspects the pass, and returns the PassProperties - does this pass have a texture? a normal map? is it skinned? tranpsarent? Etc. The PassProperties (should) contain all the information required to build a GBuffer technique for an object.', '</p>'), ('<p>', 'After a pass has been inspected and understood, the next stage is to generate the G-Buffer-writing technique. This is done using the class GBufferMaterialGenerator. The class receives the flags of the features needed by the material, and dynamically generates the (CG) shaders and material to render an object with those properties to the G-Buffer. This greatly reduces the number of shaders that you need to manage when using deferred shading, as most of them are created on the fly. Here is an example of what they look like :', '</p>'), ('<p>', ' (This is for an object with a texture and a normal map)', '</p>'), ('<p>', "We don't want to inspect the passes and generate the material each time an object is rendered, so we create a technique in the original material, and fill it with the auto-generated information. After copying the information from the GBuffer technique, texture references have to be updated, to use the correct textures when rendering the object. This happens in <code>GBufferSchemeHandler::fillPass</code>. The next time the object will be rendered, it WILL have a technique for the GBuffer scheme, so the listener won't get called.", '</p>'), ('<p>', "We don't want to render transparent objects to the GBuffer, as it doesn't work properly later.", '</p>'), ('<p>', "To address this, we also create a technique with a scheme called called 'NoGBuffer'. If the inspectPass decided that the object is transparent, we will not add an auto-generated pass to the 'GBuffer' technique, but instead copy the regular pass to the 'NoGBuffer' technique, to render it regularly later.", '</p>'), ('<p>', 'This is how <code>GBufferSchemeHandler::handleSchemeNotFound</code> works:', '</p>'), ('<p>', 'In some cases the automatic material generation will not be good enough. We want to keep the option of manually writing GBuffer materials and shaders.', '</p>'), ('<p>', "How do we do this? Easily! Since GBufferSchemeHandler::handleSchemeNotFound only gets called when an object doesn't already have a GBuffer scheme, adding a 'GBuffer' technique to the material will cause it to not get passed to the listener even once.", '</p>'), ('<p>', "Using tools like NVIDIA's PerfHUD, we can see the texture being built during the frame :", '</p>'), ('<p>', 'Note that nothing has been written to the final output yet (main view is completely black) and that two textures are being written to (see right hand side).', '</p>'), ('<p>', 'In the GBuffer compositor, we built the G-Buffer for the current frame. It is now the time to use it to calculate the final lighting of the scene. This is what the compositor looks like :', '</p>'), ('<p>', " Yes, it's a long one. Here is a breakdown of the compositor :", '</p>'), ('<p>', 'There are four target passes in this compositor.', '</p>'), ('<p>', 'This is mainly a limitation of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Ideally, we could use a single target_output pass and do all the passes there. The problem is that material_scheme is at the target scope and not at the pass scope. This is hard to change, because material schemes are resolved during scene preparing time and not during scene rendering. So even if the scope would change, it would not affect the rendering, as the material scheme will not get tested after we switch to it. Perhaps this will be addressed, and then this compositor will get simplified.', '</p>'), ('<p>', "The geometry that we want to render to calculate lighting information doesn't really fit in any classic category. It is not really a part of the scene, as the light geometry aren't objects in the world. But it is geometry (not always a quad) that needs to be rendered.", '</p>'), ('<p>', 'For these kind of operations, the render_custom target pass was introduced into <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. It is possible to register custom (named) composition passes that will be performed in the compositor. In this case, it is \'DeferredLight\'. The composition pass will receive a call each frame telling it \'it\'s your turn, do your thing\'. The class in the demo is DeferredLightCP.', '</p>'), ('<p>', 'The registration of the custom composition pass has to be done once, using <a class="el" href="class_ogre_1_1_compositor_manager.html#ae9b8ca4c2a51c0720bb31393d20fe7c9" title="Register a custom composition pass. ">Ogre::CompositorManager::registerCustomCompositionPass()</a>.', '</p>'), ('<p>', 'CustomCompositionPass is essentially just a factory for RenderSystemOperations, which are the operations that get executed during a compositor chain. This is the single API call: <a class="el" href="class_ogre_1_1_custom_composition_pass.html#a6b8c7a3743f9bb44e27c0348a0035e7b" title="Create a custom composition operation. ">Ogre::CustomCompositionPass::createOperation()</a>.', '</p>'), ('<p>', 'So, now we get called exactly when we want, after the G-Buffer has been built and the (early) skies have been rendered. What will we do?', '</p>'), ('<p>', "Since we rendered the original scene to a different RTT, the depth buffer won't necessarily get reused for the output target, so we need to rebuild it so that future objects (lights and non-g-buffer objects) will be able to interact with the depth naturally.", '</p>'), ('<p>', "Also, we need to apply the ambient light to the scene. For the purpose of the demo, the ambient light is not a separate colour channel, just the object's original textures applied with the scene's global ambient light factor. In theory, you could set up a different G-Buffer to allow more flexibility, but we didn't do that.", '</p>'), ('<p>', 'These two actions happen in a single full-screen quad render, that comes from the AmbientLight class.', '</p>'), ('<p>', "The most important stage is the light geometry. The code scans the original scene's lights, builds a matching DLight (deferred light) instance for each light in the scene, and renders away using the G-Buffer.", '</p>'), ('<p>', 'These lights use pretty sophisticated shaders, since they perform the lighting calculations of the fixed function pipeline themselves, and have to account for many options (specularity, attenuation, different light types and shadows, which will get talked about soon). In contrast to the G-Buffer building stage, the shaders here do not get generated on the fly. There is one big shader (sometimes referred to as an Uber-Shader) with many preprocessor options that account for all the options. (See LightMaterial_ps.cg) Note that the shaders have to be synchronized with the G-Buffer layout. A change in the layout would need a parallel change in the deferred lighting shaders.', '</p>'), ('<p>', 'The material generator for this section (LightMaterialGenerator class) just scans the flags of input and generates the correct preprocessor defines for the uber-shader. Some people prefer to use this approach for the G-Buffer stage as well, but I wanted to show both options in the demo.', '</p>'), ('<p>', 'In order to dispatch render operations manually, the following call exists in SceneManager: <a class="el" href="class_ogre_1_1_scene_manager.html#a1593fab748d1b0820e93e49d5732350b" title="Render something as if it came from the current queue. ">Ogre::SceneManager::_injectRenderWithPass()</a>.', '</p>'), ('<p>', 'When rendering a light, we pass the light we are rendering as the manual light list in order to have the auto params for that light available in the shader.', '</p>'), ('<p>', "The 'classic' approach to rendering texture shadows is to prepare all of them before the scene rendering starts, and then apply them to the rendered objects using shadow receiver passes or integrated shaders. The downside of this approach is that you need to allocate a texture per-light (5 shadow casting lights -&gt; 5 shadow textures) and that if you don't integrate it in your shaders you also contribute even more passes to the scene.", '</p>'), ('<p>', "One of the advantages of deferred shading is that we render the lights completely, and one by one. So, we can generate the shadow texture for a light just before the light's geometry is rendered, allowing us to reuse the same texture for as many lights as we want. (We still have an overhead of rendering the scene from the light's perspective per-light).", '</p>'), ('<p>', 'The API call that prepares shadow textures on demand is <a class="el" href="class_ogre_1_1_scene_manager.html#a95cd8ff86a7178c2e37b2fcb485f64fa" title="Method for preparing shadow textures ready for use in a regular render Do not call manually unless be...">Ogre::SceneManager::prepareShadowTextures()</a>. The lightList parameter allows specification of which lights to prepare shadow textures for.', '</p>'), ('<p>', 'Important note - RenderSystemOperations get executed in the middle of scene rendering. This means that there is an active render target being rendered to. In order to render the shadow texture we need to be able to pause rendering mid frame, render the shadow texture, and resume rendering immediately afterwards. For this, SceneManager has two methods that do just that <a class="el" href="class_ogre_1_1_scene_manager.html#a90d0e7484ed4580ec980eef15808bfee" title="Pause rendering of the frame. ">Ogre::SceneManager::_pauseRendering()</a> and <a class="el" href="class_ogre_1_1_scene_manager.html#a794e03ea25dd798346414c1dba31337d" title="Resume rendering of the frame. ">Ogre::SceneManager::_resumeRendering()</a>, so the prepareShadowTextures call has to be inside this.', '</p>'), ('<p>', 'The demo currently supports just spotlight shadow casting (since it is the cheapest to implement) but the other options can be supported as well.', '</p>'), ('<p>', 'Here is a screenshot from PerfHUD of the draw call that renders a spotlight that casts shadows. See the two G-Buffer textures and one shadow texture on the left :', '</p>'), ('<p>', 'Here is a visualization of the texture being built :', '</p>'), ('<p>', 'After all the lights are rendered, the scene is fully lit!', '</p>'), ('<p>', "The compositor framework used to be a post processing framework, but as this article shows - it is now a 'custom render pipeline' framework, allowing different rendering approaches. However, it can still be used to post process the scene, even under deferred rendering.", '</p>'), ('<p>', "'Screen Space Ambient Occlusion' is a global illumination technique that adds a bit of realism to the scene, where classic lighting often fails. However, it requires the normals and depths of the scene in order to calculate its contribution. Normally, the SSAO compositor would have a render_scene directive that does that.", '</p>'), ('<p>', 'However, with deferred shading, we already have that information from the G-Buffer stage, so we just need to access it!', '</p>'), ('<p>', 'This is what the compositor looks like :', '</p>'), ('<p>', 'Some notes :', '</p>'), ('<p>', 'The framework that this demo uses was designed to be pluggable into other projects. Some of the design considerations that contribute to that are :', '</p>'), ('<p>', "The framework created for a demo fits the plugin architecture pretty well. The GBufferSchemeHandler and DeferredLightCompositionPass classes could be instantiated once on plugin setup and registered with ogre's systems. This is not the case currently just to keep the SDK build simpler.", '</p>'), ('<p>', 'So, the steps are :', '</p>'), ('<p>', 'And thats it! In the demo, the DeferredShading class takes care of that.', '</p>'), ('<p>', 'The deferred shading framework in the demo was designed to be usable in real applications. Where would one want to modify it ?', '</p>'), ('<p>', 'Indeed, it means that the framework is not 100% plug and play. But, if understood correctly, it can be adapted to real life scenarios with relative ease.', '</p>'), ('<p>', 'Post processing compositors that rely on certain aspects of the scene (like SSAO does) are now much easier to create and integrate with the earlier processes. An example could be edge-based anti aliasing, to address the lack of anti aliasing in DX9-based deferred shading systems.', '</p>'), ('<p>', 'In addition to that, the deferred shading implementation was focused on simplicity. There are many optimization options and most of them were not done, mainly to keep the demo as simple and understandable as possible.', '</p>'), ('<p>', "Deferred Shading is an advanced rendering technique, that brings a pretty big implementation challenge along with it. This article, along with the demo, shows that it is possible to implement without relying on hacks and bypassing ogre's systems. Yes, it involves more advanced usage of ogre's APIs and requires a bit of knowledge about what happens behind the scenes, but is in no way impossible.", '</p>'), ('<p>', 'This tutorial will provide a brief introduction of ExternalTextureSource and ExternalTextureSourceManager classes, their relationship, and how the PlugIns work. For those interested in developing a Texture Source Plugin or maybe just wanting to know more about this system, take a look the ffmpegVideoSystem plugin, which you can find more about on the OGRE forums.', '</p>'), ('<p>', '<a class="anchor" id="What-Is-An-External-Texture-Source_003f"></a>', '</p>'), ('<p>', 'What is a texture source? Well, a texture source could be anything - png, bmp, jpeg, etc. However, loading textures from traditional bitmap files is already handled by another part OGRE. There are, however, other types of sources to get texture data from - i.e. mpeg/avi/etc movie files, flash, run-time generated source, user defined, etc.', '</p>'), ('<p>', 'How do external texture source plugins benefit OGRE? Well, the main answer is: adding support for any type of texture source does not require changing OGRE to support it... all that is involved is writing a new plugin. Additionally, because the manager uses the StringInterface class to issue commands/params, no change to the material script reader is needs to be made. As a result, if a plugin needs a special parameter set, it just creates a new command in its Parameter Dictionary. - see ffmpegVideoSystem plugin for an example. To make this work, two classes have been added to OGRE: ExternalTextureSource &amp; ExternalTextureSourceManager.', '</p>'), ('<p>', '<a class="anchor" id="ExternalTextureSource-Class"></a>', '</p>'), ('<p>', 'The ExternalTextureSource class is the base class that Texture Source PlugIns must be derived from. It provides a generic framework (via StringInterface class) with a very limited amount of functionality. The most common of parameters can be set through the TexturePlugInSource class interface or via the StringInterface commands contained within this class. While this may seem like duplication of code, it is not. By using the string command interface, it becomes extremely easy for derived plugins to add any new types of parameters that it may need.', '</p>'), ('<p>', 'Default Command Parameters defined in ExternalTextureSource base class are:', '</p>'), ('<p>', '<a class="anchor" id="ExternalTextureSourceManager-Class"></a>', '</p>'), ('<p>', 'ExternalTextureSourceManager is responsible for keeping track of loaded Texture Source PlugIns. It also aids in the creation of texture source textures from scripts. It also is the interface you should use when dealing with texture source plugins.', '</p>'), ('<p>', 'Note: The function prototypes shown below are mockups - param names are simplified to better illustrate purpose here... Steps needed to create a new texture via ExternalTextureSourceManager:', '</p>'), ('<p>', 'The manager also provides a method for deleting a texture source material: AdvancedTextureManager::DestroyAdvancedTexture( String sTextureName ); The destroy method works by broadcasting the material name to all loaded TextureSourcePlugIns, and the PlugIn who actually created the material is responsible for the deletion, while other PlugIns will just ignore the request. What this means is that you do not need to worry about which PlugIn created the material, or activating the PlugIn yourself. Just call the manager method to remove the material. Also, all texture plugins should handle cleanup when they are shutdown.', '</p>'), ('<p>', '<a class="anchor" id="Texture-Source-Material-Script"></a>', '</p>'), ('<p>', 'As mentioned earlier, the process of defining/creating texture sources can be done within material script file. Here is an example of a material script definition - Note: This example is based off the ffmpegVideoSystem plugin parameters.', '</p>'), ('<p>', 'Notice that the first two param/value pairs are defined in the ExternalTextureSource base class and that the third parameter/value pair is not defined in the base class... That parameter is added to the param dictionary by the ffmpegVideoPlugin... This shows that extending the functionality with the plugins is extremely easy. Also, pay particular attention to the line: texture_source video. This line identifies that this texture unit will come from a texture source plugin. It requires one parameter that determines which texture plugin will be used. In the example shown, the plugin requested is one that registered with "video" name.', '</p>'), ('<p>', '<a class="anchor" id="Simplified-Diagram-of-Process"></a>', '</p>'), ('<p>', 'This diagram uses ffmpegVideoPlugin as example, but all plug ins will work the same in how they are registered/used here. Also note that TextureSource Plugins are loaded/registered before scripts are parsed. This does not mean that they are initialized... Plugins are not initialized until they are set active! This is to ensure that a rendersystem is set up before the plugins might make a call the rendersystem.', '</p>'), ('<p>', 'This wiki article is complementary to the deferred shading demo that is part of the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> SDK. It will reference the code quite a bit and explain some of the decisions made when implementing the deferred shading framework for the demo.', '</p>'), ('<p>', 'Deferred shading is an alternative approach to rendering 3d scenes. The classic rendering approach involves rendering each object and applying lighting passes to it. So, if an ogre head is affected by 6 lights, it will be rendered 6 times, once for each light, in order to accumulate the affection of each light. Deferred shading takes another approach : In the beginning, all of the objects render their "lighting related info" to a texture, often called the G-Buffer. This means their colours, normals, depths and any other info that might be relevant to calculating their final colour. Afterwards, the lights in the scene are rendered as geometry (sphere for point light, cone for spotlight and full screen quad for directional light), and they use the G-buffer to calculate the colour contribution of that light to that pixel.', '</p>'), ('<p>', 'See the links in <a class="el" href="deferred.html#further">Further reading</a> to read more about it. It is recommended to understand deferred shading before reading this article, as the article focuses on implementing it in ogre, and not explaining how it works.', '</p>'), ('<p>', "The main reason for using deferred shading is performance related. Classing rendering (also called forward rendering) can, in the worst case, require num_objects * num_lights batches to render a scene. Deferred shading changes that to num_objects + num_lights, which can often be a lot less. Another reason is that some new post-processing effects are easily achievable using the G-Buffer as input. If you wanted to perform these effects without deferred shading, you would've had to render the whole scene again.", '</p>'), ('<p>', 'There are several algorithmic drawbacks with deferred shading - transparent objects are hard to handle, anti aliasing can not be used in DX9 class hardware, additional memory consumption because of the G-Buffer. In addition to that, deferred shading is harder to implement - it overrides the entire fixed function pipeline. Pretty much everything is rendered using manual shaders - which probably means a lot of shader code.', '</p>'), ('<p>', 'The first part of the deferred shading pipeline involves rendering all the (non-transparent) objects of the scene to the G-Buffer. This is done using a compositor :', '</p>'), ('<p>', ' Things to note about this compositor :', '</p>'), ('<p>', 'This in an important decision in deferred shading, as it has performance and visual implications.', '</p>'), ('<p>', 'Also, the entire pipeline has to be coordinated with this format - all the writing shaders have to write the same data to the same places, and all the reading shaders (for lighting later) have to be synchronized with it.', '</p>'), ('<p>', 'We chose two PF_FLOAT16_RGBA textures. The first one will contain the colour in RGB, specular intensity in A.', '</p>'), ('<p>', 'The second one will contain the view-space-normal in RGB (we keep all 3 coordinates) and the (linear) depth in A.', '</p>'), ('<p>', 'See the references for other possibilities.', '</p>'), ('<p>', 'The only indicator that ogre has when rendering the scene is that the material scheme is different. Material schemes in ogre allow materials to specify different rendering techniques for different scenarios. In this case, we would like to output the lighting related information instead of the lighting calculation result.', '</p>'), ('<p>', "Materials that have a technique associated with the GBuffer scheme will render using that, but we don't want to modify the materials of all the objects in our art pipeline to use them in deferred shading.", '</p>'), ('<p>', 'The solution is to use scheme listeners! The material manager has a method for registering listeners when objects don\'t have a technique defined for the current scheme: <a class="el" href="class_ogre_1_1_material_manager.html#a8ac18f4bd2e6302f1d92ae8f64195694" title="Add a listener to handle material events. ">Ogre::MaterialManager::addListener()</a>.', '</p>'), ('<p>', 'The listener has a callback method that gets called whenever an object is about to be rendered without a matching technique: <a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html#a54bc384ab1102063aa00db4c3a5f3fc4" title="Called if a technique for a given scheme is not found within a material, allows the application to sp...">Ogre::MaterialManager::Listener::handleSchemeNotFound()</a>.', '</p>'), ('<p>', 'We will implement such a listener for the GBuffer scheme. It is GBufferSchemeHandler from the demo. The GBufferSchemeHandlers works like this :', '</p>'), ('<p>', 'For each pass in the technique that would have been used normally, the GBufferSchemeHandler::inspectPass is called, inspects the pass, and returns the PassProperties - does this pass have a texture? a normal map? is it skinned? tranpsarent? Etc. The PassProperties (should) contain all the information required to build a GBuffer technique for an object.', '</p>'), ('<p>', 'After a pass has been inspected and understood, the next stage is to generate the G-Buffer-writing technique. This is done using the class GBufferMaterialGenerator. The class receives the flags of the features needed by the material, and dynamically generates the (CG) shaders and material to render an object with those properties to the G-Buffer. This greatly reduces the number of shaders that you need to manage when using deferred shading, as most of them are created on the fly. Here is an example of what they look like :', '</p>'), ('<p>', ' (This is for an object with a texture and a normal map)', '</p>'), ('<p>', "We don't want to inspect the passes and generate the material each time an object is rendered, so we create a technique in the original material, and fill it with the auto-generated information. After copying the information from the GBuffer technique, texture references have to be updated, to use the correct textures when rendering the object. This happens in <code>GBufferSchemeHandler::fillPass</code>. The next time the object will be rendered, it WILL have a technique for the GBuffer scheme, so the listener won't get called.", '</p>'), ('<p>', "We don't want to render transparent objects to the GBuffer, as it doesn't work properly later.", '</p>'), ('<p>', "To address this, we also create a technique with a scheme called called 'NoGBuffer'. If the inspectPass decided that the object is transparent, we will not add an auto-generated pass to the 'GBuffer' technique, but instead copy the regular pass to the 'NoGBuffer' technique, to render it regularly later.", '</p>'), ('<p>', 'This is how <code>GBufferSchemeHandler::handleSchemeNotFound</code> works:', '</p>'), ('<p>', 'In some cases the automatic material generation will not be good enough. We want to keep the option of manually writing GBuffer materials and shaders.', '</p>'), ('<p>', "How do we do this? Easily! Since GBufferSchemeHandler::handleSchemeNotFound only gets called when an object doesn't already have a GBuffer scheme, adding a 'GBuffer' technique to the material will cause it to not get passed to the listener even once.", '</p>'), ('<p>', "Using tools like NVIDIA's PerfHUD, we can see the texture being built during the frame :", '</p>'), ('<p>', 'Note that nothing has been written to the final output yet (main view is completely black) and that two textures are being written to (see right hand side).', '</p>'), ('<p>', 'In the GBuffer compositor, we built the G-Buffer for the current frame. It is now the time to use it to calculate the final lighting of the scene. This is what the compositor looks like :', '</p>'), ('<p>', " Yes, it's a long one. Here is a breakdown of the compositor :", '</p>'), ('<p>', 'There are four target passes in this compositor.', '</p>'), ('<p>', 'This is mainly a limitation of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Ideally, we could use a single target_output pass and do all the passes there. The problem is that material_scheme is at the target scope and not at the pass scope. This is hard to change, because material schemes are resolved during scene preparing time and not during scene rendering. So even if the scope would change, it would not affect the rendering, as the material scheme will not get tested after we switch to it. Perhaps this will be addressed, and then this compositor will get simplified.', '</p>'), ('<p>', "The geometry that we want to render to calculate lighting information doesn't really fit in any classic category. It is not really a part of the scene, as the light geometry aren't objects in the world. But it is geometry (not always a quad) that needs to be rendered.", '</p>'), ('<p>', 'For these kind of operations, the render_custom target pass was introduced into <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. It is possible to register custom (named) composition passes that will be performed in the compositor. In this case, it is \'DeferredLight\'. The composition pass will receive a call each frame telling it \'it\'s your turn, do your thing\'. The class in the demo is DeferredLightCP.', '</p>'), ('<p>', 'The registration of the custom composition pass has to be done once, using <a class="el" href="class_ogre_1_1_compositor_manager.html#ae9b8ca4c2a51c0720bb31393d20fe7c9" title="Register a custom composition pass. ">Ogre::CompositorManager::registerCustomCompositionPass()</a>.', '</p>'), ('<p>', 'CustomCompositionPass is essentially just a factory for RenderSystemOperations, which are the operations that get executed during a compositor chain. This is the single API call: <a class="el" href="class_ogre_1_1_custom_composition_pass.html#a6b8c7a3743f9bb44e27c0348a0035e7b" title="Create a custom composition operation. ">Ogre::CustomCompositionPass::createOperation()</a>.', '</p>'), ('<p>', 'So, now we get called exactly when we want, after the G-Buffer has been built and the (early) skies have been rendered. What will we do?', '</p>'), ('<p>', "Since we rendered the original scene to a different RTT, the depth buffer won't necessarily get reused for the output target, so we need to rebuild it so that future objects (lights and non-g-buffer objects) will be able to interact with the depth naturally.", '</p>'), ('<p>', "Also, we need to apply the ambient light to the scene. For the purpose of the demo, the ambient light is not a separate colour channel, just the object's original textures applied with the scene's global ambient light factor. In theory, you could set up a different G-Buffer to allow more flexibility, but we didn't do that.", '</p>'), ('<p>', 'These two actions happen in a single full-screen quad render, that comes from the AmbientLight class.', '</p>'), ('<p>', "The most important stage is the light geometry. The code scans the original scene's lights, builds a matching DLight (deferred light) instance for each light in the scene, and renders away using the G-Buffer.", '</p>'), ('<p>', 'These lights use pretty sophisticated shaders, since they perform the lighting calculations of the fixed function pipeline themselves, and have to account for many options (specularity, attenuation, different light types and shadows, which will get talked about soon). In contrast to the G-Buffer building stage, the shaders here do not get generated on the fly. There is one big shader (sometimes referred to as an Uber-Shader) with many preprocessor options that account for all the options. (See LightMaterial_ps.cg) Note that the shaders have to be synchronized with the G-Buffer layout. A change in the layout would need a parallel change in the deferred lighting shaders.', '</p>'), ('<p>', 'The material generator for this section (LightMaterialGenerator class) just scans the flags of input and generates the correct preprocessor defines for the uber-shader. Some people prefer to use this approach for the G-Buffer stage as well, but I wanted to show both options in the demo.', '</p>'), ('<p>', 'In order to dispatch render operations manually, the following call exists in SceneManager: <a class="el" href="class_ogre_1_1_scene_manager.html#a1593fab748d1b0820e93e49d5732350b" title="Render something as if it came from the current queue. ">Ogre::SceneManager::_injectRenderWithPass()</a>.', '</p>'), ('<p>', 'When rendering a light, we pass the light we are rendering as the manual light list in order to have the auto params for that light available in the shader.', '</p>'), ('<p>', "The 'classic' approach to rendering texture shadows is to prepare all of them before the scene rendering starts, and then apply them to the rendered objects using shadow receiver passes or integrated shaders. The downside of this approach is that you need to allocate a texture per-light (5 shadow casting lights -&gt; 5 shadow textures) and that if you don't integrate it in your shaders you also contribute even more passes to the scene.", '</p>'), ('<p>', "One of the advantages of deferred shading is that we render the lights completely, and one by one. So, we can generate the shadow texture for a light just before the light's geometry is rendered, allowing us to reuse the same texture for as many lights as we want. (We still have an overhead of rendering the scene from the light's perspective per-light).", '</p>'), ('<p>', 'The API call that prepares shadow textures on demand is <a class="el" href="class_ogre_1_1_scene_manager.html#a95cd8ff86a7178c2e37b2fcb485f64fa" title="Method for preparing shadow textures ready for use in a regular render Do not call manually unless be...">Ogre::SceneManager::prepareShadowTextures()</a>. The lightList parameter allows specification of which lights to prepare shadow textures for.', '</p>'), ('<p>', 'Important note - RenderSystemOperations get executed in the middle of scene rendering. This means that there is an active render target being rendered to. In order to render the shadow texture we need to be able to pause rendering mid frame, render the shadow texture, and resume rendering immediately afterwards. For this, SceneManager has two methods that do just that <a class="el" href="class_ogre_1_1_scene_manager.html#a90d0e7484ed4580ec980eef15808bfee" title="Pause rendering of the frame. ">Ogre::SceneManager::_pauseRendering()</a> and <a class="el" href="class_ogre_1_1_scene_manager.html#a794e03ea25dd798346414c1dba31337d" title="Resume rendering of the frame. ">Ogre::SceneManager::_resumeRendering()</a>, so the prepareShadowTextures call has to be inside this.', '</p>'), ('<p>', 'The demo currently supports just spotlight shadow casting (since it is the cheapest to implement) but the other options can be supported as well.', '</p>'), ('<p>', 'Here is a screenshot from PerfHUD of the draw call that renders a spotlight that casts shadows. See the two G-Buffer textures and one shadow texture on the left :', '</p>'), ('<p>', 'Here is a visualization of the texture being built :', '</p>'), ('<p>', 'After all the lights are rendered, the scene is fully lit!', '</p>'), ('<p>', "The compositor framework used to be a post processing framework, but as this article shows - it is now a 'custom render pipeline' framework, allowing different rendering approaches. However, it can still be used to post process the scene, even under deferred rendering.", '</p>'), ('<p>', "'Screen Space Ambient Occlusion' is a global illumination technique that adds a bit of realism to the scene, where classic lighting often fails. However, it requires the normals and depths of the scene in order to calculate its contribution. Normally, the SSAO compositor would have a render_scene directive that does that.", '</p>'), ('<p>', 'However, with deferred shading, we already have that information from the G-Buffer stage, so we just need to access it!', '</p>'), ('<p>', 'This is what the compositor looks like :', '</p>'), ('<p>', 'Some notes :', '</p>'), ('<p>', 'The framework that this demo uses was designed to be pluggable into other projects. Some of the design considerations that contribute to that are :', '</p>'), ('<p>', "The framework created for a demo fits the plugin architecture pretty well. The GBufferSchemeHandler and DeferredLightCompositionPass classes could be instantiated once on plugin setup and registered with ogre's systems. This is not the case currently just to keep the SDK build simpler.", '</p>'), ('<p>', 'So, the steps are :', '</p>'), ('<p>', 'And thats it! In the demo, the DeferredShading class takes care of that.', '</p>'), ('<p>', 'The deferred shading framework in the demo was designed to be usable in real applications. Where would one want to modify it ?', '</p>'), ('<p>', 'Indeed, it means that the framework is not 100% plug and play. But, if understood correctly, it can be adapted to real life scenarios with relative ease.', '</p>'), ('<p>', 'Post processing compositors that rely on certain aspects of the scene (like SSAO does) are now much easier to create and integrate with the earlier processes. An example could be edge-based anti aliasing, to address the lack of anti aliasing in DX9-based deferred shading systems.', '</p>'), ('<p>', 'In addition to that, the deferred shading implementation was focused on simplicity. There are many optimization options and most of them were not done, mainly to keep the demo as simple and understandable as possible.', '</p>'), ('<p>', "Deferred Shading is an advanced rendering technique, that brings a pretty big implementation challenge along with it. This article, along with the demo, shows that it is possible to implement without relying on hacks and bypassing ogre's systems. Yes, it involves more advanced usage of ogre's APIs and requires a bit of knowledge about what happens behind the scenes, but is in no way impossible.", '</p>')]