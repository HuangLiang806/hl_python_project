<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Setting up an OGRE project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('setup.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Setting up an OGRE project </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section note"><dt>Note</dt><dd>see BuildingOgre.md for instructions how to build OGRE itself </dd></dl>
<h1><a class="anchor" id="cmake"></a>
CMake Configuration</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses CMake as its build system. It is recommended that you use it in your project as well. Then all you need is to add the following three lines to your project </p><div class="fragment"><div class="line"><span class="comment"># specify which version you need</span></div><div class="line">find_package(OGRE 1.10 REQUIRED)</div><div class="line"></div><div class="line"><span class="comment"># the search paths</span></div><div class="line">include_directories(${OGRE_INCLUDE_DIRS})</div><div class="line">link_directories(${OGRE_LIBRARY_DIRS})</div><div class="line"></div><div class="line"><span class="comment"># copy essential config files next to our binary where OGRE autodiscovers them</span></div><div class="line">file(COPY ${OGRE_CONFIG_DIR}/plugins.cfg ${OGRE_CONFIG_DIR}/resources.cfg</div><div class="line">     DESTINATION ${CMAKE_BINARY_DIR})</div></div><!-- fragment --><p>These settings include all available components and third party libraries OGRE depends on (e.g. boost) - nothing more to do.</p>
<p>If you installed OGRE in a non-standard path, you will have to set <code>OGRE_DIR</code> to the location of <code>OGREConfig.cmake</code> so <code>find_package</code> can figure out the rest.</p>
<p>For inspecting the detected OGRE installation, the following CMake variables are available</p><ul>
<li><code>OGRE_STATIC</code> - whether ogre was build as static lib</li>
<li><code>OGRE_${COMPONENT}_FOUND</code> - ${COMPONENT} is available</li>
<li><code>OGRE_PLUGIN_DIR</code> - The directory where the OGRE plugins are located</li>
<li><code>OGRE_MEDIA_DIR</code> - The directory where the OGRE sample media is located</li>
<li><code>OGRE_CONFIG_DIR</code> - The directory where the OGRE config files are located</li>
</ul>
<h1><a class="anchor" id="skeleton"></a>
Application skeleton</h1>
<p>The easiest way to get started is the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Component. It handles <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> startup/ tear down (including <a class="el" href="class_ogre_1_1_overlay.html" title="Represents a layer which is rendered on top of the &#39;normal&#39; scene contents. ">Ogre::Overlay</a>, <a class="el" href="rtss.html">RTSS</a>), input using SDL2 and even includes a <a class="el" href="trays.html">Simple GUI System</a>.</p>
<p>This is useful if all you want is to get a Scene with a FPS counter up and running (rapid prototyping). If available it also uses SDL2 for input - you now just have to implement the callbacks.</p>
<p>To use it, simply derive from <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> and if you want to get input events from <a class="el" href="struct_ogre_bites_1_1_input_listener.html" title="the return values of the callbacks are ignored by ApplicationContext however they can be used to cont...">OgreBites::InputListener</a></p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyTestApp : <span class="keyword">public</span> <a class="code" href="class_ogre_bites_1_1_application_context.html">OgreBites::ApplicationContext</a>, <span class="keyword">public</span> <a class="code" href="struct_ogre_bites_1_1_input_listener.html">OgreBites::InputListener</a></div><div class="line">{</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p> in the constructor we set our application name. The ogre configuration files will be stored in a system dependant location specific to our app. </p><div class="fragment"><div class="line">MyTestApp::MyTestApp() : <a class="code" href="namespace_ogre_bites.html">OgreBites</a>::ApplicationContext(<span class="stringliteral">&quot;OgreTutorialApp&quot;</span>)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><p> to handle input events, we then override the according method </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyTestApp::keyPressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_keyboard_event.html">OgreBites::KeyboardEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (evt.<a class="code" href="struct_ogre_bites_1_1_keyboard_event.html#a0d402ed4c6025e4a0a83fdac5eef219c">keysym</a>.<a class="code" href="struct_ogre_bites_1_1_keyboard_event.html#a747c886f46684fab3e14a9b8d751333b">sym</a> == <a class="code" href="_ogre_input_8h.html#abc5c98fcc1211af2b80116dd6e0a035dab050f8c23b43c76246a93e599b7b411f">SDLK_ESCAPE</a>)</div><div class="line">    {</div><div class="line">        getRoot()-&gt;queueEndRendering();</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> the interesting part however is the setup method </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyTestApp::setup(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">// do not forget to call the base first</span></div><div class="line">    <a class="code" href="class_ogre_bites_1_1_application_context.html#ad2bfdfa72c9d95e55657854c2094c610">OgreBites::ApplicationContext::setup</a>();</div><div class="line">    </div><div class="line">    <span class="comment">// register for input events</span></div><div class="line">    addInputListener(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">// get a pointer to the already created root</span></div><div class="line">    <a class="code" href="class_ogre_1_1_root.html">Ogre::Root</a>* root = getRoot();</div><div class="line">    <a class="code" href="class_ogre_1_1_scene_manager.html">Ogre::SceneManager</a>* scnMgr = root-&gt;<a class="code" href="class_ogre_1_1_root.html#a8bb8655f823a98007775f69278c1b0f9">createSceneManager</a>();</div><div class="line"></div><div class="line">    <span class="comment">// register our scene with the RTSS</span></div><div class="line">    <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html">Ogre::RTShader::ShaderGenerator</a>* shadergen = <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">Ogre::RTShader::ShaderGenerator::getSingletonPtr</a>();</div><div class="line">    shadergen-&gt;<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a60704776c069e2a6bd37692f88c56815">addSceneManager</a>(scnMgr);</div><div class="line"></div><div class="line">    <span class="comment">// without light we would just get a black screen    </span></div><div class="line">    <a class="code" href="class_ogre_1_1_light.html">Ogre::Light</a>* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    <a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 10, 15);</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div><div class="line"></div><div class="line">    <span class="comment">// also need to tell where we are</span></div><div class="line">    <a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    camNode-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 0, 15);</div><div class="line">    camNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de">lookAt</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(0, 0, -1), <a class="code" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">Ogre::Node::TS_PARENT</a>);</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    <a class="code" href="class_ogre_1_1_camera.html">Ogre::Camera</a>* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_camera.html#aac250bb57c630543b8241bfc8eb8b88a">setAutoAspectRatio</a>(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(cam);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div><div class="line"></div><div class="line">    <span class="comment">// finally something to render</span></div><div class="line">    <a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a>* ent = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;Sinbad.mesh&quot;</span>);</div><div class="line">    <a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* node = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    node-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ent);</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The above code is explained in detail in <a class="el" href="tut__first_scene.html">Your First Scene</a>.</dd></dl>
<p>finally we start everything as </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">    MyTestApp app;</div><div class="line">    app.initApp();</div><div class="line">    app.getRoot()-&gt;startRendering();</div><div class="line">    app.closeApp();</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You can find the full code of the above example at<ul>
<li><code>Samples/Tutorials/Bootstrap.cpp</code> for C++</li>
<li><code>Samples/Python/bites_sample.py</code> for Python</li>
<li><code>Samples/AndroidJNI/MainActivity.java</code> for Java (Android)</li>
</ul>
</dd></dl>
<p><a class="el" href="namespace_ogre_bites.html">OgreBites</a> itself is also a good starting point if you need more control over the Camera or the Window creation. For instance to render into an existing Qt Window.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_root.html#aeaad25268c0ad8007ce8961a32242c77" title="Updates all the render targets automatically. ">Ogre::Root::renderOneFrame</a> </dd>
<dd>
<a class="el" href="class_ogre_1_1_render_system.html#aaf156b9f935396e6c17f532f6e6c847e" title="Creates a new rendering window. ">Ogre::RenderSystem::_createRenderWindow</a> </dd>
<dd>
<a class="el" href="class_ogre_1_1_render_system.html#a77766da49c29112c390fde51069f543a" title="Tell the rendersystem to perform any prep tasks it needs to directly before other threads which might...">Ogre::RenderSystem::preExtraThreadsStarted</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Setting up an OGRE project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('setup.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Setting up an OGRE project </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section note"><dt>Note</dt><dd>see BuildingOgre.md for instructions how to build OGRE itself </dd></dl>
<h1><a class="anchor" id="cmake"></a>
CMake Configuration</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses CMake as its build system. It is recommended that you use it in your project as well. Then all you need is to add the following three lines to your project </p><div class="fragment"><div class="line"><span class="comment"># specify which version you need</span></div><div class="line">find_package(OGRE 1.10 REQUIRED)</div><div class="line"></div><div class="line"><span class="comment"># the search paths</span></div><div class="line">include_directories(${OGRE_INCLUDE_DIRS})</div><div class="line">link_directories(${OGRE_LIBRARY_DIRS})</div><div class="line"></div><div class="line"><span class="comment"># copy essential config files next to our binary where OGRE autodiscovers them</span></div><div class="line">file(COPY ${OGRE_CONFIG_DIR}/plugins.cfg ${OGRE_CONFIG_DIR}/resources.cfg</div><div class="line">     DESTINATION ${CMAKE_BINARY_DIR})</div></div><!-- fragment --><p>These settings include all available components and third party libraries OGRE depends on (e.g. boost) - nothing more to do.</p>
<p>If you installed OGRE in a non-standard path, you will have to set <code>OGRE_DIR</code> to the location of <code>OGREConfig.cmake</code> so <code>find_package</code> can figure out the rest.</p>
<p>For inspecting the detected OGRE installation, the following CMake variables are available</p><ul>
<li><code>OGRE_STATIC</code> - whether ogre was build as static lib</li>
<li><code>OGRE_${COMPONENT}_FOUND</code> - ${COMPONENT} is available</li>
<li><code>OGRE_PLUGIN_DIR</code> - The directory where the OGRE plugins are located</li>
<li><code>OGRE_MEDIA_DIR</code> - The directory where the OGRE sample media is located</li>
<li><code>OGRE_CONFIG_DIR</code> - The directory where the OGRE config files are located</li>
</ul>
<h1><a class="anchor" id="skeleton"></a>
Application skeleton</h1>
<p>The easiest way to get started is the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Component. It handles <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> startup/ tear down (including <a class="el" href="class_ogre_1_1_overlay.html" title="Represents a layer which is rendered on top of the &#39;normal&#39; scene contents. ">Ogre::Overlay</a>, <a class="el" href="rtss.html">RTSS</a>), input using SDL2 and even includes a <a class="el" href="trays.html">Simple GUI System</a>.</p>
<p>This is useful if all you want is to get a Scene with a FPS counter up and running (rapid prototyping). If available it also uses SDL2 for input - you now just have to implement the callbacks.</p>
<p>To use it, simply derive from <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> and if you want to get input events from <a class="el" href="struct_ogre_bites_1_1_input_listener.html" title="the return values of the callbacks are ignored by ApplicationContext however they can be used to cont...">OgreBites::InputListener</a></p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyTestApp : <span class="keyword">public</span> <a class="code" href="class_ogre_bites_1_1_application_context.html">OgreBites::ApplicationContext</a>, <span class="keyword">public</span> <a class="code" href="struct_ogre_bites_1_1_input_listener.html">OgreBites::InputListener</a></div><div class="line">{</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p> in the constructor we set our application name. The ogre configuration files will be stored in a system dependant location specific to our app. </p><div class="fragment"><div class="line">MyTestApp::MyTestApp() : <a class="code" href="namespace_ogre_bites.html">OgreBites</a>::ApplicationContext(<span class="stringliteral">&quot;OgreTutorialApp&quot;</span>)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><p> to handle input events, we then override the according method </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyTestApp::keyPressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_keyboard_event.html">OgreBites::KeyboardEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (evt.<a class="code" href="struct_ogre_bites_1_1_keyboard_event.html#a0d402ed4c6025e4a0a83fdac5eef219c">keysym</a>.<a class="code" href="struct_ogre_bites_1_1_keyboard_event.html#a747c886f46684fab3e14a9b8d751333b">sym</a> == <a class="code" href="_ogre_input_8h.html#abc5c98fcc1211af2b80116dd6e0a035dab050f8c23b43c76246a93e599b7b411f">SDLK_ESCAPE</a>)</div><div class="line">    {</div><div class="line">        getRoot()-&gt;queueEndRendering();</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> the interesting part however is the setup method </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyTestApp::setup(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">// do not forget to call the base first</span></div><div class="line">    <a class="code" href="class_ogre_bites_1_1_application_context.html#ad2bfdfa72c9d95e55657854c2094c610">OgreBites::ApplicationContext::setup</a>();</div><div class="line">    </div><div class="line">    <span class="comment">// register for input events</span></div><div class="line">    addInputListener(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">// get a pointer to the already created root</span></div><div class="line">    <a class="code" href="class_ogre_1_1_root.html">Ogre::Root</a>* root = getRoot();</div><div class="line">    <a class="code" href="class_ogre_1_1_scene_manager.html">Ogre::SceneManager</a>* scnMgr = root-&gt;<a class="code" href="class_ogre_1_1_root.html#a8bb8655f823a98007775f69278c1b0f9">createSceneManager</a>();</div><div class="line"></div><div class="line">    <span class="comment">// register our scene with the RTSS</span></div><div class="line">    <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html">Ogre::RTShader::ShaderGenerator</a>* shadergen = <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">Ogre::RTShader::ShaderGenerator::getSingletonPtr</a>();</div><div class="line">    shadergen-&gt;<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a60704776c069e2a6bd37692f88c56815">addSceneManager</a>(scnMgr);</div><div class="line"></div><div class="line">    <span class="comment">// without light we would just get a black screen    </span></div><div class="line">    <a class="code" href="class_ogre_1_1_light.html">Ogre::Light</a>* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    <a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 10, 15);</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div><div class="line"></div><div class="line">    <span class="comment">// also need to tell where we are</span></div><div class="line">    <a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    camNode-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 0, 15);</div><div class="line">    camNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de">lookAt</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(0, 0, -1), <a class="code" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">Ogre::Node::TS_PARENT</a>);</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    <a class="code" href="class_ogre_1_1_camera.html">Ogre::Camera</a>* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_camera.html#aac250bb57c630543b8241bfc8eb8b88a">setAutoAspectRatio</a>(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(cam);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div><div class="line"></div><div class="line">    <span class="comment">// finally something to render</span></div><div class="line">    <a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a>* ent = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;Sinbad.mesh&quot;</span>);</div><div class="line">    <a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* node = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    node-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ent);</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The above code is explained in detail in <a class="el" href="tut__first_scene.html">Your First Scene</a>.</dd></dl>
<p>finally we start everything as </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">    MyTestApp app;</div><div class="line">    app.initApp();</div><div class="line">    app.getRoot()-&gt;startRendering();</div><div class="line">    app.closeApp();</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You can find the full code of the above example at<ul>
<li><code>Samples/Tutorials/Bootstrap.cpp</code> for C++</li>
<li><code>Samples/Python/bites_sample.py</code> for Python</li>
<li><code>Samples/AndroidJNI/MainActivity.java</code> for Java (Android)</li>
</ul>
</dd></dl>
<p><a class="el" href="namespace_ogre_bites.html">OgreBites</a> itself is also a good starting point if you need more control over the Camera or the Window creation. For instance to render into an existing Qt Window.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_root.html#aeaad25268c0ad8007ce8961a32242c77" title="Updates all the render targets automatically. ">Ogre::Root::renderOneFrame</a> </dd>
<dd>
<a class="el" href="class_ogre_1_1_render_system.html#aaf156b9f935396e6c17f532f6e6c847e" title="Creates a new rendering window. ">Ogre::RenderSystem::_createRenderWindow</a> </dd>
<dd>
<a class="el" href="class_ogre_1_1_render_system.html#a77766da49c29112c390fde51069f543a" title="Tell the rendersystem to perform any prep tasks it needs to directly before other threads which might...">Ogre::RenderSystem::preExtraThreadsStarted</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Setting up an OGRE project</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('setup.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Setting up an OGRE project </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section note"><dt>Note</dt><dd>see BuildingOgre.md for instructions how to build OGRE itself </dd></dl>
<h1><a class="anchor" id="cmake"></a>
CMake Configuration</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses CMake as its build system. It is recommended that you use it in your project as well. Then all you need is to add the following three lines to your project </p><div class="fragment"><div class="line"><span class="comment"># specify which version you need</span></div><div class="line">find_package(OGRE 1.10 REQUIRED)</div><div class="line"></div><div class="line"><span class="comment"># the search paths</span></div><div class="line">include_directories(${OGRE_INCLUDE_DIRS})</div><div class="line">link_directories(${OGRE_LIBRARY_DIRS})</div><div class="line"></div><div class="line"><span class="comment"># copy essential config files next to our binary where OGRE autodiscovers them</span></div><div class="line">file(COPY ${OGRE_CONFIG_DIR}/plugins.cfg ${OGRE_CONFIG_DIR}/resources.cfg</div><div class="line">     DESTINATION ${CMAKE_BINARY_DIR})</div></div><!-- fragment --><p>These settings include all available components and third party libraries OGRE depends on (e.g. boost) - nothing more to do.</p>
<p>If you installed OGRE in a non-standard path, you will have to set <code>OGRE_DIR</code> to the location of <code>OGREConfig.cmake</code> so <code>find_package</code> can figure out the rest.</p>
<p>For inspecting the detected OGRE installation, the following CMake variables are available</p><ul>
<li><code>OGRE_STATIC</code> - whether ogre was build as static lib</li>
<li><code>OGRE_${COMPONENT}_FOUND</code> - ${COMPONENT} is available</li>
<li><code>OGRE_PLUGIN_DIR</code> - The directory where the OGRE plugins are located</li>
<li><code>OGRE_MEDIA_DIR</code> - The directory where the OGRE sample media is located</li>
<li><code>OGRE_CONFIG_DIR</code> - The directory where the OGRE config files are located</li>
</ul>
<h1><a class="anchor" id="skeleton"></a>
Application skeleton</h1>
<p>The easiest way to get started is the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Component. It handles <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> startup/ tear down (including <a class="el" href="class_ogre_1_1_overlay.html" title="Represents a layer which is rendered on top of the &#39;normal&#39; scene contents. ">Ogre::Overlay</a>, <a class="el" href="rtss.html">RTSS</a>), input using SDL2 and even includes a <a class="el" href="trays.html">Simple GUI System</a>.</p>
<p>This is useful if all you want is to get a Scene with a FPS counter up and running (rapid prototyping). If available it also uses SDL2 for input - you now just have to implement the callbacks.</p>
<p>To use it, simply derive from <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> and if you want to get input events from <a class="el" href="struct_ogre_bites_1_1_input_listener.html" title="the return values of the callbacks are ignored by ApplicationContext however they can be used to cont...">OgreBites::InputListener</a></p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyTestApp : <span class="keyword">public</span> <a class="code" href="class_ogre_bites_1_1_application_context.html">OgreBites::ApplicationContext</a>, <span class="keyword">public</span> <a class="code" href="struct_ogre_bites_1_1_input_listener.html">OgreBites::InputListener</a></div><div class="line">{</div><div class="line">    ...</div><div class="line">}</div></div><!-- fragment --><p> in the constructor we set our application name. The ogre configuration files will be stored in a system dependant location specific to our app. </p><div class="fragment"><div class="line">MyTestApp::MyTestApp() : <a class="code" href="namespace_ogre_bites.html">OgreBites</a>::ApplicationContext(<span class="stringliteral">&quot;OgreTutorialApp&quot;</span>)</div><div class="line">{</div><div class="line">}</div></div><!-- fragment --><p> to handle input events, we then override the according method </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> MyTestApp::keyPressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_keyboard_event.html">OgreBites::KeyboardEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (evt.<a class="code" href="struct_ogre_bites_1_1_keyboard_event.html#a0d402ed4c6025e4a0a83fdac5eef219c">keysym</a>.<a class="code" href="struct_ogre_bites_1_1_keyboard_event.html#a747c886f46684fab3e14a9b8d751333b">sym</a> == <a class="code" href="_ogre_input_8h.html#abc5c98fcc1211af2b80116dd6e0a035dab050f8c23b43c76246a93e599b7b411f">SDLK_ESCAPE</a>)</div><div class="line">    {</div><div class="line">        getRoot()-&gt;queueEndRendering();</div><div class="line">    }</div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> the interesting part however is the setup method </p><div class="fragment"><div class="line"><span class="keywordtype">void</span> MyTestApp::setup(<span class="keywordtype">void</span>)</div><div class="line">{</div><div class="line">    <span class="comment">// do not forget to call the base first</span></div><div class="line">    <a class="code" href="class_ogre_bites_1_1_application_context.html#ad2bfdfa72c9d95e55657854c2094c610">OgreBites::ApplicationContext::setup</a>();</div><div class="line">    </div><div class="line">    <span class="comment">// register for input events</span></div><div class="line">    addInputListener(<span class="keyword">this</span>);</div><div class="line"></div><div class="line">    <span class="comment">// get a pointer to the already created root</span></div><div class="line">    <a class="code" href="class_ogre_1_1_root.html">Ogre::Root</a>* root = getRoot();</div><div class="line">    <a class="code" href="class_ogre_1_1_scene_manager.html">Ogre::SceneManager</a>* scnMgr = root-&gt;<a class="code" href="class_ogre_1_1_root.html#a8bb8655f823a98007775f69278c1b0f9">createSceneManager</a>();</div><div class="line"></div><div class="line">    <span class="comment">// register our scene with the RTSS</span></div><div class="line">    <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html">Ogre::RTShader::ShaderGenerator</a>* shadergen = <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">Ogre::RTShader::ShaderGenerator::getSingletonPtr</a>();</div><div class="line">    shadergen-&gt;<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a60704776c069e2a6bd37692f88c56815">addSceneManager</a>(scnMgr);</div><div class="line"></div><div class="line">    <span class="comment">// without light we would just get a black screen    </span></div><div class="line">    <a class="code" href="class_ogre_1_1_light.html">Ogre::Light</a>* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    <a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 10, 15);</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div><div class="line"></div><div class="line">    <span class="comment">// also need to tell where we are</span></div><div class="line">    <a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    camNode-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 0, 15);</div><div class="line">    camNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de">lookAt</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(0, 0, -1), <a class="code" href="class_ogre_1_1_node.html#ac42e2063379286eb673eaffff6ca5e99a34e6c3ebabc2e9fa00de4f62be0ce7ce">Ogre::Node::TS_PARENT</a>);</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    <a class="code" href="class_ogre_1_1_camera.html">Ogre::Camera</a>* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_camera.html#aac250bb57c630543b8241bfc8eb8b88a">setAutoAspectRatio</a>(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(cam);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div><div class="line"></div><div class="line">    <span class="comment">// finally something to render</span></div><div class="line">    <a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a>* ent = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;Sinbad.mesh&quot;</span>);</div><div class="line">    <a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* node = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    node-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ent);</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>The above code is explained in detail in <a class="el" href="tut__first_scene.html">Your First Scene</a>.</dd></dl>
<p>finally we start everything as </p><div class="fragment"><div class="line"><span class="keywordtype">int</span> main(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[])</div><div class="line">{</div><div class="line">    MyTestApp app;</div><div class="line">    app.initApp();</div><div class="line">    app.getRoot()-&gt;startRendering();</div><div class="line">    app.closeApp();</div><div class="line">    <span class="keywordflow">return</span> 0;</div><div class="line">}</div></div><!-- fragment --><dl class="section note"><dt>Note</dt><dd>You can find the full code of the above example at<ul>
<li><code>Samples/Tutorials/Bootstrap.cpp</code> for C++</li>
<li><code>Samples/Python/bites_sample.py</code> for Python</li>
<li><code>Samples/AndroidJNI/MainActivity.java</code> for Java (Android)</li>
</ul>
</dd></dl>
<p><a class="el" href="namespace_ogre_bites.html">OgreBites</a> itself is also a good starting point if you need more control over the Camera or the Window creation. For instance to render into an existing Qt Window.</p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_root.html#aeaad25268c0ad8007ce8961a32242c77" title="Updates all the render targets automatically. ">Ogre::Root::renderOneFrame</a> </dd>
<dd>
<a class="el" href="class_ogre_1_1_render_system.html#aaf156b9f935396e6c17f532f6e6c847e" title="Creates a new rendering window. ">Ogre::RenderSystem::_createRenderWindow</a> </dd>
<dd>
<a class="el" href="class_ogre_1_1_render_system.html#a77766da49c29112c390fde51069f543a" title="Tell the rendersystem to perform any prep tasks it needs to directly before other threads which might...">Ogre::RenderSystem::preExtraThreadsStarted</a> </dd></dl>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Your First Scene</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__first_scene.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Your First Scene </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howogreworks">How Ogre Works</a><ul><li class="level2"><a href="#scenemanager">SceneManager</a></li>
<li class="level2"><a href="#SceneNode">SceneNode</a></li>
<li class="level2"><a href="#Entity">Entity</a></li>
</ul>
</li>
<li class="level1"><a href="#SettingUptheScene">Setting Up the Scene</a></li>
<li class="level1"><a href="#CoordinatesSystems">Coordinates Systems</a></li>
<li class="level1"><a href="#AddingAnotherEntity">Adding Another Entity</a></li>
<li class="level1"><a href="#MoreAboutEntities">More About Entities</a></li>
<li class="level1"><a href="#MoreAboutSceneNodes">More About SceneNodes</a></li>
<li class="level1"><a href="#ChangingAnEntitysScale">Changing An Entity&#39;s Scale</a></li>
<li class="level1"><a href="#RotatingAnEntity">Rotating An Entity</a></li>
<li class="level1"><a href="#TheOgreEnvironment">The Ogre Environment</a><ul><li class="level2"><a href="#LibrariesandPlugins">Libraries and Plugins</a><ul><li class="level3"><a href="#Mainlibrary">Main library</a></li>
<li class="level3"><a href="#Plugins">Plugins</a></li>
<li class="level3"><a href="#ThirdpartyPlugins">Third-party Plugins</a></li>
<li class="level3"><a href="#TestingvsRelease">Testing vs Release</a></li>
</ul>
</li>
<li class="level2"><a href="#ConfigurationFiles">Configuration Files</a><ul><li class="level3"><a href="#PluginConfiguration">Plugin Configuration</a></li>
<li class="level3"><a href="#ResourceConfiguration">Resource Configuration</a></li>
<li class="level3"><a href="#MediaConfiguration">Media Configuration</a></li>
<li class="level3"><a href="#OgreConfiguration">Ogre Configuration</a></li>
<li class="level3"><a href="#Quake3SettingsConfiguration">Quake 3 Settings Configuration</a></li>
</ul>
</li>
</ul>
</li>
<li class="level1"><a href="#Conclusion1">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This first tutorial will cover the basic elements of building a scene in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. The primary focus will be the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and Entity(external link). An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> is anything represented by a mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is what attaches an object to your scene. Finally, the SceneManager is the object that organizes everything. It keeps track of the entities and nodes in your scene and determines how to display them.</p>
<p>We'll start with an explanation of some of the basic concepts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Don't worry, this first tutorial has a little more explanation than the rest, but that changes very quickly once you get to the later tutorials. We will be building plenty of things. We just have to lay a little groundwork first, so you have somewhere to stand.</p>
<p>The full source for this tutorial (BasicTutorial1.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="howogreworks"></a>
How Ogre Works</h1>
<p>We are going to provide a quick introduction to the basic elements of an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene.</p>
<h2><a class="anchor" id="scenemanager"></a>
SceneManager</h2>
<p>Everything that appears on the screen is managed by the SceneManager. The SceneManager keeps track of the locations and other attributes of the objects in your scene. The SceneManager also manages any cameras that you add to your scene. There are multiples types of SceneManagers. There are managers focused on rendering terrain and other managers focused on rendering BSP maps. The different types of SceneManager are listed <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SceneManagersFAQ">here</a>.</p>
<h2><a class="anchor" id="SceneNode"></a>
SceneNode</h2>
<p>SceneNodes carry information that is used for all of the objects that are attached to it. An Entity is not rendered in your scene until it is attached to a SceneNode. In addition, a SceneNode is not a visible object in your scene. It only holds abstract information like location and orientation. Only when it is connected to something like an Entity is that information used to actually render something in the scene.</p>
<p>SceneNodes can have more than one object attached to them. We may want to have a light that will follow a character around in a scene. To do this, we could attach both the character Entity and the light to the same SceneNode. This will cause them both to share the same location information. We can even attach SceneNodes to other SceneNodes. This is useful in many circumstances. Imagine you have a character and you want to attach a tool to their hand. You wouldn't want to attach the tool to SceneNode for the entire character. Instead, you could attach a SceneNode representing their hand to the character's main SceneNode, and then attach the tool Entity to that "child" SceneNode. more complicated uses of SceneNodes will be covered in later tutorials.</p>
<p>One final thing to keep in mind about SceneNodes is that their position is relative to their parent SceneNode and each SceneManager creates a root Node to which all other SceneNodes are attached.</p>
<h2><a class="anchor" id="Entity"></a>
Entity</h2>
<p>An Entity is one type of object that you can render in your scene. It is anything that is represented by a 3D mesh. Even terrain objects are very large entities. Lights, Billboards, Particles, and Cameras are examples of scene elements that are not entities. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a well-known design pattern that separates renderable objects from information like their location. This means that you don't directly place an Entity into your scene. Instead, you place a SceneNode into your scene, then attach your Entity to that SceneNode. The Entity is then rendered using information taken from the SceneNode.</p>
<h1><a class="anchor" id="SettingUptheScene"></a>
Setting Up the Scene</h1>
<p>It's finally time to start building something in our scene. All source addition will be in "tutorial section" in cpp file of the tutorial TutorialApplication::setup method.</p>
<p>The first thing we want to do is turn on the lights.</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0.5, 0.5, 0.5));</div></div><!-- fragment --><p> The setAmbientLight method takes an <a class="el" href="class_ogre_1_1_colour_value.html" title="Class representing colour. ">Ogre::ColourValue</a>. The three values represent the red, green, and blue values of the colour, and they range between 0 and 1.</p>
<p>scnMgr is a variable that is defined in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>. There are a number of features avariables, like setting up resources and initialization of required routines for rendering. They will be introduced as we need them.</p>
<p>Lights will be covered in detail in the next tutorial, but we will still add a simple one to this scene as a teaser. New Light objects can also be requested from the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. We give the Light a unique name when it is created.</p>
<div class="fragment"><div class="line">    Light* light = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;MainLight&quot;</span>);</div><div class="line">    SceneNode* lightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    lightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(light);</div></div><!-- fragment --><p> Starting from <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.10 camera and lights require to create separate scene node for them so that they need to be attached to them.</p>
<p>Once the Light is created and attached to its SceneNode, we set its position. The three parameters are the x, y, and z coordinates of the location we want to place the Light.</p>
<div class="fragment"><div class="line">    lightNode-&gt;setPosition(20, 80, 50);</div></div><!-- fragment --><p> Next step is to create a camera.</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line"></div><div class="line">    <span class="comment">// create the camera</span></div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div><div class="line">    cam-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a7bc8b601d85642059f23e739fb4438bb">setNearClipDistance</a>(5); <span class="comment">// specific to this sample</span></div><div class="line">    cam-&gt;setAutoAspectRatio(<span class="keyword">true</span>);</div><div class="line">    camNode-&gt;attachObject(cam);</div><div class="line">    camNode-&gt;setPosition(0, 0, 140);</div><div class="line"></div><div class="line">    <span class="comment">// and tell it to render into the main window</span></div><div class="line">    getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p> Details about camera will be covered in the following tutorial.</p>
<p>The next thing we do is ask the SceneManager to create an Entity.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div></div><!-- fragment --><p> The parameter given to this function must be a mesh that was loaded by <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s resource manager. For now, resource loading is one of the many things that <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> is taking care of for us. It will be explained further in later tutorials.</p>
<p>Now that we have an Entity, we need to create a SceneNode so the Entity can be displayed in our scene. Every SceneManager has a root node. That node has a method called createChildSceneNode that will return a new SceneNode attached to the root. In older versions of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, you were required to provide a unique name for your Entities and SceneNodes. This is now optional. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will generate names for them if you do not provide one.</p>
<div class="fragment"><div class="line">    SceneNode* ogreNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div></div><!-- fragment --><p> We save the SceneNode pointer that is returned by the method so that we can attach our Entity to it.</p>
<div class="fragment"><div class="line">    ogreNode-&gt;attachObject(ogreEntity);</div></div><!-- fragment --><p> We now have a basic scene set up. Compile and run your application. You should see an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s head on your screen. This is only the beginning...</p>
<div class="image">
<img src="bt1_first_run.png" alt="bt1_first_run.png"/>
</div>
<h1><a class="anchor" id="CoordinatesSystems"></a>
Coordinates Systems</h1>
<p>Before we go on, let's cover some basics of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s coordinate system. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, like many other graphics engines, uses the x-z plane as the "floor" in a scene. This means that the y-axis is the vertical axis to ensure <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is using a <a href="http://mathworld.wolfram.com/Right-HandedCoordinateSystem.html">right-handed coordinate system</a></p>
<div class="image">
<img src="bt1_display1921.png" alt="bt1_display1921.png"/>
</div>
<p>The x-axis starts with negative values to the left and increases to the right (passing through zero at the origin). The z-axis runs forwards and backwards. The positive direction of the z-axis points "out of the screen". So if a character walks towards the screen, then its z value will be increasing. Finally, the y-axis runs from the bottom to the top. Values that are "below ground" are negative. Don't take these terms in parenthesis literally. You can put the ground wherever you want. It is just to help you orient yourself in the scene.</p>
<p>When you run your application, notice how your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is facing towards the camera down the positive z-axis. This is a property of the mesh itself and the orientation of the camera. Cameras are covered in a later tutorial. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head is sitting at the origin of our world, (0, 0, 0). The direction the head is facing by default is a result of which way it was facing when it was originally modeled. You can effectively change this from within <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> as well, but it will require some knowledge of quaternions, which aren't really covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses a vector class to represent positions and directions. There are vectors defined for 2-4 dimensions. They are called <a class="el" href="class_ogre_1_1_vector2.html" title="Standard 2-dimensional vector. ">Ogre::Vector2</a>, <a class="el" href="class_ogre_1_1_vector3.html" title="Standard 3-dimensional vector. ">Ogre::Vector3</a>, and <a class="el" href="class_ogre_1_1_vector4.html" title="4-dimensional homogeneous vector. ">Ogre::Vector4</a> - Vector3 being the most commonly used by far. If you are not familiar with the concept of vectors it is highly recommended to learn a little before attempting these tutorials. Even though <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is an abstraction over many of the complications involved with OpenGL and DirectX, there is still no escaping some mathematical concepts. Vectors and basic linear algebra will be some of the most useful things you can learn if you intend to proceed with 3D rendering. This <a href="http://www.wildbunny.co.uk/blog/vector-maths-a-primer-for-games-programmers/">site</a> has produced a nice primer on vectors focused on game programmers.</p>
<h1><a class="anchor" id="AddingAnotherEntity"></a>
Adding Another Entity</h1>
<p>It's time to get back to the coding. With our first Entity, we did not specify the location we wanted anywhere. Many of the functions in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have default parameters. The SceneNode::createChildSceneNode(external link) method can take three parameters, but we called it with none. The parameters are the name, position, and rotation of the SceneNode being created. We've already mentioned that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> generates a unique name for us. It also uses (0, 0, 0) as a default position.</p>
<p>First, let's move the camera so we can fit more Entities on screen. Place this call right after you set the ambient light in createScene:</p>
<div class="fragment"><div class="line">    camNode-&gt;setPosition(0, 47, 222);</div></div><!-- fragment --><p> Now, let's create another Entity and SceneNode, but this time we'll give it a new position.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(Vector3(84, 48, 0));</div><div class="line">    ogreNode2-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ogreEntity2);</div></div><!-- fragment --><p> This is the same thing we did the first time, except we are now providing a Vector3 to our createChildSceneNode method. This will override the default position. Remember, the SceneNode's position is always relative to its parent. In this case, the parent SceneNode is the root SceneNode, which is positioned at (0, 0, 0) by default.</p>
<p>Compile and run your application. Your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head should have a buddy.</p>
<div class="image">
<img src="bt1_added_entity.png" alt="bt1_added_entity.png"/>
</div>
<h1><a class="anchor" id="MoreAboutEntities"></a>
More About Entities</h1>
<p>The <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> class is very extensive. We will now introduce just a few more of its methods that will be useful. The Entity class has setVisible and isVisible methods. If you want an Entity to be hidden, but you still need it later, then you can use this function instead of destroying the Entity and rebuilding it later.</p>
<dl class="section note"><dt>Note</dt><dd>Entities do not need to be pooled like they are in some graphics engines. Only one copy of each mesh and texture is ever loaded into memory, so there is not a big savings from trying to minimize the number of Entities.</dd></dl>
<p>The getName method returns the name of an Entity, and the getParentSceneNode method returns the SceneNode that the Entity is attached to. In our case, this would be the root SceneNode.</p>
<h1><a class="anchor" id="MoreAboutSceneNodes"></a>
More About SceneNodes</h1>
<p>The <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> class is very complex. For now, we will only cover some of the most useful methods.</p>
<p>You can set the position after creating the node with setPosition. This is still relative to its parent node. You can move an objective relative to its current position by using translate.</p>
<p>SceneNodes are used to set a lot more than just position. They also manage the scale and rotation of objects. You can set the scale of an object with setScale. And you can use yaw, pitch, and roll to set the object's orientation. You can use resetRotation to return the object to its default orientation. Finally, you can use rotate to perform more complicated rotations. This will again involve the use of quaternions, which will not be covered until the <a href="#">Intermediate Tutorials</a>.</p>
<p>We've already used the attachObject method of a SceneNode. There are few more methods that are useful for dealing with the objects that are attached to a SceneNode. You can use numAttachedObjects to return the number of children attached to your node. You can use one of the many versions of <a class="el" href="class_ogre_1_1_scene_node.html#a2ff8d20961b48225690e1561bc39f993" title="Retrieves a pointer to an attached object. ">Ogre::SceneNode::getAttachedObject</a> to retrieve one of the SceneNode's children. The method detachObject can be used to remove a specific child node, and detachAllObjects can be used to remove all.</p>
<p>Since the position of a child node is relative to its parent, it makes it very easy to move large groups of nodes together. For example, if we changed this line:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>To this:</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a>* ogreNode2 = ogreNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<a class="code" href="class_ogre_1_1_vector3.html">Ogre::Vector3</a>(84, 48, 0));</div></div><!-- fragment --><p>Then our new node would be parented directly to the SceneNode for our first Entity. This would mean that moving ogreNode would also move ogreNode2. It would also mean that the position of ogreNode2 would be relative to ogreNode.</p>
<p>If you're having trouble with the idea of a relative location, then maybe an example will help. Let's say we put our first node, ogreNode, at (10, 10, 10) and attach ogreNode2 directly to ogreNode. Then we set the position of ogreNode2 to be (-10, -10, -10). To figure out where ogreNode2 will be displayed we add its position to the position of its parent.</p>
<div class="fragment"><div class="line">(10, 10, 10) + (-10, -10, -10) = (0, 0, 0)</div><div class="line">  ogreNode        ogreNode2</div><div class="line">   parent           child</div></div><!-- fragment --><p>So this means that ogreNode2 would actually be placed at (0, 0, 0) in our world, even though we set its position to (-10, -10, -10). If we detached this node and reattached it to the root SceneNode, then it would really be displayed at (-10, -10, -10), because:</p>
<div class="fragment"><div class="line">(0, 0, 0) + (-10, -10, -10) = (-10, -10, -10)</div><div class="line">   root        ogreNode2</div><div class="line">  parent         child</div></div><!-- fragment --><p>Take a few seconds to soak this in. Relativity is hard. That's why it took an Einstein to really figure it out.</p>
<p>Lastly, you can get a SceneNode or Entity by its name (if you gave it one), by calling getSceneNode or getEntity, which are <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> methods. This way you don't have to keep a pointer to all of your SceneNodes. You should generally only define pointers for nodes you will use often.</p>
<h1><a class="anchor" id="ChangingAnEntitysScale"></a>
Changing An Entity's Scale</h1>
<p>We can set the scale of an Entity by calling setScale. This method allows us to provide a scale factor for each dimension. Let's add another <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head and give it a different scale for demonstration. We will also position it so it fits well on the screen.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode3 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode3-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(0, 104, 0);</div><div class="line">    ogreNode3-&gt;setScale(2, 1.2, 1);</div><div class="line">    ogreNode3-&gt;attachObject(ogreEntity3);</div></div><!-- fragment --><p> Compile and run your application. You should see a fat <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head up top.</p>
<div class="image">
<img src="bt_1scaled_entity.png" alt="bt_1scaled_entity.png"/>
</div>
<h1><a class="anchor" id="RotatingAnEntity"></a>
Rotating An Entity</h1>
<p>An Entity's rotation can be changed using the yaw, pitch, and roll methods.</p>
<div class="image">
<img src="tiki-download_file_rotation_axis.png" alt="tiki-download_file_rotation_axis.png"/>
</div>
<p>These methods will take either an <a class="el" href="class_ogre_1_1_degree.html" title="Wrapper class which indicates a given angle value is in Degrees. ">Ogre::Degree</a> or <a class="el" href="class_ogre_1_1_radian.html" title="Wrapper class which indicates a given angle value is in Radians. ">Ogre::Radian</a>. As the picture demonstrates, rotation around the y-axis is called yaw, around the x-axis is called pitch, and around the z-axis is called roll. These are terms often used in describing the movements of an aircraft.</p>
<p>There is a well-known trick for remembering which direction is a positive rotation around an axis. It is called the <a href="http://en.wikipedia.org/wiki/Right-hand_rule">right-hand rule</a>. Point your thumb in the direction of the axis, and the direction your fingers curl towards is the positive direction. You can now see why these are often called "right-handed coordinate systems". There are about a million ways of doing the right-hand rule. This is why you might see a group of physics students throwing gang signs while doing their homework. They're trying to remember which direction the magnetic field is headed.</p>
<p>Let's put this to use and place a rotated Entity into our scene. We will also position it nicely.</p>
<div class="fragment"><div class="line">    Entity* ogreEntity4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ogrehead.mesh&quot;</span>);</div><div class="line">    SceneNode* ogreNode4 = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    ogreNode4-&gt;<a class="code" href="class_ogre_1_1_node.html#a72e58d4789cfe29e4538399b4250ce5a">setPosition</a>(-84, 48, 0);</div><div class="line">    ogreNode4-&gt;roll(Degree(-90));</div><div class="line">    ogreNode4-&gt;attachObject(ogreEntity4);</div></div><!-- fragment --><p> Compile and run your application. We should now have a rotated <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> head in our scene.</p>
<div class="image">
<img src="bt1_rotated_entity.png" alt="bt1_rotated_entity.png"/>
</div>
<h1><a class="anchor" id="TheOgreEnvironment"></a>
The Ogre Environment</h1>
<p>The library and configuration files for <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> can be found in the 'bin' folder of your OgreSDK. You should use the debug files when building your application in debug mod</p>
<h2><a class="anchor" id="LibrariesandPlugins"></a>
Libraries and Plugins</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is divided into three shared library groups: main library, plugins, and third-party libraries.</p>
<h3><a class="anchor" id="Mainlibrary"></a>
Main library</h3>
<p>The main library group contains the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library itself and the shared libraries it relies on. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> library is contained within OgreMain.dll or libOgreMain.so depending on your platform. This library must be included in all of your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> applications. OgreMain.dll requires a few other libraries like cg.dll.</p>
<h3><a class="anchor" id="Plugins"></a>
Plugins</h3>
<p>The second group of shared libraries are the plugins. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> pushes a good portion of its functionality into shared libraries so that they may be turned on or off easily. The core plugins that are included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> have names that start with "Plugin_". You can also write your own plugins.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> also uses plugins for the different render systems (such as OpenGL, DirectX, etc). These plugins start with "RenderSystem_". This is also so that you can add only the systems you will need. This can be useful if you write shaders that rely on a particular system, because you can simply remove the incompatible system so that the program won't try to run incorrect code. This also means you can write your own plugins if you want to extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> into another render system.</p>
<h3><a class="anchor" id="ThirdpartyPlugins"></a>
Third-party Plugins</h3>
<p>The last major group contains third-party libraries and other general support libraries. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is focused sharply on being a graphics rendering library. This group makes it easy to integrate external libraries to add things like physics, input, and GUI systems. These libraries are used together to form a full game development environment. You might find this piecemeal approach a little strange, but it is a very common design pattern in large software projects. It is harder to comprehend at first, but it is a much more flexible approach when you want to start building more complicated scenes.</p>
<p>The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> demos and SDK include some of these third-party libraries. The <a href="https://www.libsdl.org/">Simple DirectMedia</a> can be used to manage input events and distribute them to <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. You can also make use of Cg, which is used by CgProgramManager. This library allows you to produce materials with custom shaders. There are other libraries (not included with <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>) that offer functionality such as sound and physics.</p>
<h3><a class="anchor" id="TestingvsRelease"></a>
Testing vs Release</h3>
<p>When you're building your application you can just leave every plugin activated. This will allow you to experiment with using them or not. But when you get ready to distribute a release build of your work, then you will want to deactivate any of the plugins you are not using.</p>
<h2><a class="anchor" id="ConfigurationFiles"></a>
Configuration Files</h2>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> uses several configuration files (*.cfg). They control things like which plugins are loaded and where your application will search for resource files. We will briefly introduce you to each of these files. You'll slowly read more about them as you progress through the tutorials as well.</p>
<h3><a class="anchor" id="PluginConfiguration"></a>
Plugin Configuration</h3>
<p><b>plugins.cfg</b></p>
<p>This file tells <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which plugins to load. You modify this file when you want to load a different set of plugins. It is often most useful to simply "comment out" lines instead of removing them, because you never know when a stroke of inspiration will mean you want to reload some unused plugins. Here is some sample content:</p>
<div class="fragment"><div class="line"># Plugin=RenderSystem_Direct3D9</div><div class="line"># Plugin=RenderSystem_Direct3D10</div><div class="line"># Plugin=RenderSystem_Direct3D11</div><div class="line">Plugin=RenderSystem_GL</div></div><!-- fragment --><p>We have the three DirectX systems commented out, and an active line for OpenGL. On a windows system, you may have this reversed. You can see why it might be helpful not to delete unused lines, because then you have to try and remember whether it was RenderSystem_OpenGL or RenderSystem_GL.</p>
<p>You can also decide where <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> looks for plugins by changing the 'PluginFolder' variable. You can use both absolute and relative paths, but you cannot use environment variables like . For example, if you have built <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from source on a linux machine, then you will need a line like this at the beginning of your file:</p>
<div class="fragment"><div class="line">PluginFolder=/usr/local/lib/OGRE</div></div><!-- fragment --><p>By default, <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> would have been looking in '/usr/lib/OGRE'. This is where it would be placed if you installed <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> from a package manager. You may have to do something similar on Mac.</p>
<h3><a class="anchor" id="ResourceConfiguration"></a>
Resource Configuration</h3>
<p><b>resources.cfg</b></p>
<p>This file contains a list of the directories <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will use to search for resources. Resources include scripts, meshes, textures, GUI layouts, and others. You can also use both absolute and relative paths in this file, but you still cannot use environment variables. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will <b>not</b> search subdirectories, so you have to manually enter them. Here is an example:</p>
<div class="fragment"><div class="line">[General]</div><div class="line">FileSystem=../media</div><div class="line">FileSystem=../media/materials/scripts</div><div class="line">FileSystem=../media/materials/textures</div><div class="line">FileSystem=../media/models</div></div><!-- fragment --><p>Here is an example of a relative path being used and the need to list subdirectories. Including the '../media' directory did not automatically include the '../media/models' directory. This is so that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> doesn't get greedy and waste time loading up unneeded resources.</p>
<h3><a class="anchor" id="MediaConfiguration"></a>
Media Configuration</h3>
<p><b>media.cfg</b></p>
<p>This file provides <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> with more detailed information about some resources. It is unlikely that you will need to modify this file for quite a long time. More information can be found in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manual.</p>
<h3><a class="anchor" id="OgreConfiguration"></a>
Ogre Configuration</h3>
<p><b>ogre.cfg</b></p>
<p>This file is generated by the Render Settings dialog that appears when you run your application. This file will be specific to your own setup. <b>Do not</b> distribute this file with your application. This file will contain your choices for things like screen resolution. Do not modify this file directly. Change the settings with the dialog and it will be automatically updated.</p>
<h3><a class="anchor" id="Quake3SettingsConfiguration"></a>
Quake 3 Settings Configuration</h3>
<p><b>quake3settings.cfg</b></p>
<p>This file is used by the BSPSceneManager. You would only need this file if you were using that SceneManager (the tutorials will not). This should not be distributed with your application.</p>
<p>That covers all of the configuration files that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> manipulates directly. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will look for these files in the same directory as your executable and it must find 'plugins.cfg', 'resources.cfg', and 'media.cfg' to function properly. Later tutorials will cover more of their use.</p>
<h1><a class="anchor" id="Conclusion1"></a>
Conclusion</h1>
<p>You should now have a basic understanding of setting up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> scene. This tutorial provided an introduction to three of the most important objects in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>: <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a>, <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>, and <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a>. These objects allow us to render and manipulate a scene filled with 3D objects.</p>
<p>An <a class="el" href="class_ogre_1_1_entity.html" title="Defines an instance of a discrete, movable object based on a Mesh. ">Ogre::Entity</a> represents anything that has an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> mesh. A <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> is used to hold properties like location, scale, and rotation. It is also the anchor that attaches your Entities to your scene and allows them to be rendered on screen. Finally, The <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> is the object that orchestrates it all. It has methods that allow you to create Entities and SceneNodes and keep them organized within a complicated scene. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Lights, Cameras, and Shadows</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__lights_cameras_shadows.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lights, Cameras, and Shadows </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#bt2TheOgreCameraClass">The Ogre Camera Class</a></li>
<li class="level1"><a href="#bt2CreatingaCamera">Creating a Camera</a></li>
<li class="level1"><a href="#bt2Viewports">Viewports</a></li>
<li class="level1"><a href="#bt2CreatingaViewport">Creating a Viewport</a></li>
<li class="level1"><a href="#bt2BuildingtheScene">Building the Scene</a></li>
<li class="level1"><a href="#bt2UsingShadowsinOgre">Using Shadows in Ogre</a></li>
<li class="level1"><a href="#bt2Lights">Lights</a></li>
<li class="level1"><a href="#CreatingaLight">Creating a Light</a></li>
<li class="level1"><a href="#CreatingMoreLights">Creating More Lights</a></li>
<li class="level1"><a href="#ShadowTypes">Shadow Types</a></li>
<li class="level1"><a href="#Conclusion2">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial will expand on the use of Lights in a scene and using them to cast shadows.</p>
<p>The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="bt2TheOgreCameraClass"></a>
The Ogre Camera Class</h1>
<p>A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera's position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.</p>
<dl class="section note"><dt>Note</dt><dd>Starting from version 1.10 functionality related to rotate and translate camera are deprecated. You should attach camera to <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> and do all transofrmation with this node.</dd></dl>
<h1><a class="anchor" id="bt2CreatingaCamera"></a>
Creating a Camera</h1>
<p>We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div></div><!-- fragment --><p>You can retrieve the Camera by name using the SceneManager's getCamera method.</p>
<p>Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.</p>
<p>The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.</p>
<div class="fragment"><div class="line">    cam-&gt;setNearClipDistance(5);</div><div class="line">    camNode-&gt;attachObject(cam);</div></div><!-- fragment --> <h1><a class="anchor" id="bt2Viewports"></a>
Viewports</h1>
<p>When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.</p>
<p>There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera's view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.</p>
<h1><a class="anchor" id="bt2CreatingaViewport"></a>
Creating a Viewport</h1>
<p>Let's create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.</p>
<p>Now let's set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We've set it to black because we are going to add colored lighting later, and we don't want the background color affecting how we see the lighting.</p>
<p>The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.</p>
<div class="fragment"><div class="line">    cam-&gt;setAspectRatio(<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualWidth()) / <a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualHeight()));</div></div><!-- fragment --><p> We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.</p>
<p>Compile and run your application. You should still only see a black screen, just make sure it runs.</p>
<h1><a class="anchor" id="bt2BuildingtheScene"></a>
Building the Scene</h1>
<p>Before we get to shadows and lighting, let's add some elements to our scene. Let's put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.</p>
<p>We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.</p>
<p>The first thing we'll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here's a picture:</p>
<div class="image">
<img src="bt2_plane_normal.png" alt="bt2_plane_normal.png"/>
</div>
<p>There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.</p>
<p>Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.</p>
<div class="fragment"><div class="line">    MeshManager::getSingleton().createPlane(</div><div class="line">            <span class="stringliteral">&quot;ground&quot;</span>,</div><div class="line">            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,</div><div class="line">            plane,</div><div class="line">            1500, 1500, 20, 20,</div><div class="line">            <span class="keyword">true</span>,</div><div class="line">            1, 5, 5,</div><div class="line">            Vector3::UNIT_Z);</div></div><!-- fragment --><p>This is a complicated method, and we're not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we've created a new mesh called "ground" with a size of 1500x1500.</p>
<p>Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don't confuse the parameter given to createEntity for the Entity's name. It is actually the name of the mesh we just created. We're used to seeing mesh names end with '.mesh'.</p>
<p>We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don't get confused, this means the ground won't cast a shadow, it doesn't mean we can't cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called 'rockwall.tga'. You can find the name yourself by reading the entry in the material script.</p>
<h1><a class="anchor" id="bt2UsingShadowsinOgre"></a>
Using Shadows in Ogre</h1>
<p>Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.</p>
<p>Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0, 0, 0));</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0">setShadowTechnique</a>(<a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af1b698ef34b8d97c261b7ade00010b7f">ShadowTechnique::SHADOWTYPE_STENCIL_MODULATIVE</a>);</div></div><!-- fragment --><p> Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.</p>
<h1><a class="anchor" id="bt2Lights"></a>
Lights</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.</p><ul>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca0d59bfdcfeb338dbfe06e2e2999e752f" title="Point light sources give off light equally in all directions, so require only position not direction...">Ogre::Light::LT_POINT</a> - This Light speads out equally in all directions from a point.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca8fc40a1ccfb026944417ef92b7ddaefe" title="Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff. ">Ogre::Light::LT_SPOTLIGHT</a> - This Light works like a flashlight. It produces a solid cylinder of light that is brighter at the center and fades off.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca4c5582d28848ce40c2b652488494b4a3" title="Directional lights simulate parallel light beams from a distant source, hence have direction but no p...">Ogre::Light::LT_DIRECTIONAL</a> - This Light simulates a huge source that is very far away - like daylight. Light hits the entire scene at the same angle everywhere.</li>
</ul>
<p>The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.</p>
<h1><a class="anchor" id="CreatingaLight"></a>
Creating a Light</h1>
<p>Let's add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We'll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setType(Light::LT_SPOTLIGHT);</div></div><!-- fragment --><p> The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* spotLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    spotLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(spotLight);</div><div class="line">    spotLightNode-&gt;setDirection(-1, -1, 0);</div><div class="line">    spotLightNode-&gt;setPosition(Vector3(200, 200, 0));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must be wondering why we call setDirection for light source and then call the same method for related SceneNode. As long as setDirection is deprecated for Light it has to be attached to SceneNode. Since SceneNode default rotation is NEGATIVE_UNIT_Z we need to set same value for Light. Direction for light by default is not NEGATIVE_UNIT_Z but in the future releases it will be replaced with this value. So this extra call of setDirection for Light could be deleted in future. In other words we need this extra move for future compatibilty.</dd></dl>
<div class="image">
<img src="bt2_light_dir_1.png" alt="bt2_light_dir_1.png"/>
</div>
<p>Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setSpotlightRange(Degree(35), Degree(50));</div></div><!-- fragment --><p>Compile and run the application. You should see the shadowy blue figure of a ninja.</p>
<div class="image">
<img src="bt2_ninja1.jpg" alt="bt2_ninja1.jpg"/>
</div>
<h1><a class="anchor" id="CreatingMoreLights"></a>
Creating More Lights</h1>
<p>Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.</p>
<div class="fragment"><div class="line">    Light* directionalLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;DirectionalLight&quot;</span>);</div><div class="line">    directionalLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_DIRECTIONAL);</div></div><!-- fragment --><p> Now we'll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light's direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.</p>
<div class="fragment"><div class="line">    directionalLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* directionalLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    directionalLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(directionalLight);</div><div class="line">    directionalLightNode-&gt;setDirection(Vector3(0, -1, 1));</div></div><!-- fragment --> <div class="image">
<img src="bt2_light_dir_2.png" alt="bt2_light_dir_2.png"/>
</div>
<p>The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.</p>
<p>Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.</p>
<div class="image">
<img src="bt2_ninja2.jpg" alt="bt2_ninja2.jpg"/>
</div>
<p>To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We'll set the the specular and diffuse colors to a dark gray.</p>
<div class="fragment"><div class="line">    pointLight-&gt;setDiffuseColour(0.3, 0.3, 0.3);</div><div class="line">    pointLight-&gt;setSpecularColour(0.3, 0.3, 0.3);</div></div><!-- fragment --><p> A point light has no direction. It only has a position. We will place our last light above and behind the ninja.</p>
<div class="fragment"><div class="line">    SceneNode* pointLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    pointLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(pointLight);</div><div class="line">    pointLightNode-&gt;setPosition(Vector3(0, 150, 250));</div></div><!-- fragment --><p> Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?</p>
<div class="image">
<img src="bt2_ninja3.jpg" alt="bt2_ninja3.jpg"/>
</div>
<h1><a class="anchor" id="ShadowTypes"></a>
Shadow Types</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.</p>
<p>Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.</p>
<h1><a class="anchor" id="Conclusion2"></a>
Conclusion</h1>
<p>This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.</p>
<p>There are a lot of different settings we've covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you've finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Lights, Cameras, and Shadows</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__lights_cameras_shadows.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lights, Cameras, and Shadows </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#bt2TheOgreCameraClass">The Ogre Camera Class</a></li>
<li class="level1"><a href="#bt2CreatingaCamera">Creating a Camera</a></li>
<li class="level1"><a href="#bt2Viewports">Viewports</a></li>
<li class="level1"><a href="#bt2CreatingaViewport">Creating a Viewport</a></li>
<li class="level1"><a href="#bt2BuildingtheScene">Building the Scene</a></li>
<li class="level1"><a href="#bt2UsingShadowsinOgre">Using Shadows in Ogre</a></li>
<li class="level1"><a href="#bt2Lights">Lights</a></li>
<li class="level1"><a href="#CreatingaLight">Creating a Light</a></li>
<li class="level1"><a href="#CreatingMoreLights">Creating More Lights</a></li>
<li class="level1"><a href="#ShadowTypes">Shadow Types</a></li>
<li class="level1"><a href="#Conclusion2">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial will expand on the use of Lights in a scene and using them to cast shadows.</p>
<p>The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="bt2TheOgreCameraClass"></a>
The Ogre Camera Class</h1>
<p>A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera's position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.</p>
<dl class="section note"><dt>Note</dt><dd>Starting from version 1.10 functionality related to rotate and translate camera are deprecated. You should attach camera to <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> and do all transofrmation with this node.</dd></dl>
<h1><a class="anchor" id="bt2CreatingaCamera"></a>
Creating a Camera</h1>
<p>We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div></div><!-- fragment --><p>You can retrieve the Camera by name using the SceneManager's getCamera method.</p>
<p>Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.</p>
<p>The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.</p>
<div class="fragment"><div class="line">    cam-&gt;setNearClipDistance(5);</div><div class="line">    camNode-&gt;attachObject(cam);</div></div><!-- fragment --> <h1><a class="anchor" id="bt2Viewports"></a>
Viewports</h1>
<p>When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.</p>
<p>There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera's view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.</p>
<h1><a class="anchor" id="bt2CreatingaViewport"></a>
Creating a Viewport</h1>
<p>Let's create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.</p>
<p>Now let's set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We've set it to black because we are going to add colored lighting later, and we don't want the background color affecting how we see the lighting.</p>
<p>The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.</p>
<div class="fragment"><div class="line">    cam-&gt;setAspectRatio(<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualWidth()) / <a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualHeight()));</div></div><!-- fragment --><p> We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.</p>
<p>Compile and run your application. You should still only see a black screen, just make sure it runs.</p>
<h1><a class="anchor" id="bt2BuildingtheScene"></a>
Building the Scene</h1>
<p>Before we get to shadows and lighting, let's add some elements to our scene. Let's put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.</p>
<p>We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.</p>
<p>The first thing we'll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here's a picture:</p>
<div class="image">
<img src="bt2_plane_normal.png" alt="bt2_plane_normal.png"/>
</div>
<p>There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.</p>
<p>Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.</p>
<div class="fragment"><div class="line">    MeshManager::getSingleton().createPlane(</div><div class="line">            <span class="stringliteral">&quot;ground&quot;</span>,</div><div class="line">            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,</div><div class="line">            plane,</div><div class="line">            1500, 1500, 20, 20,</div><div class="line">            <span class="keyword">true</span>,</div><div class="line">            1, 5, 5,</div><div class="line">            Vector3::UNIT_Z);</div></div><!-- fragment --><p>This is a complicated method, and we're not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we've created a new mesh called "ground" with a size of 1500x1500.</p>
<p>Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don't confuse the parameter given to createEntity for the Entity's name. It is actually the name of the mesh we just created. We're used to seeing mesh names end with '.mesh'.</p>
<p>We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don't get confused, this means the ground won't cast a shadow, it doesn't mean we can't cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called 'rockwall.tga'. You can find the name yourself by reading the entry in the material script.</p>
<h1><a class="anchor" id="bt2UsingShadowsinOgre"></a>
Using Shadows in Ogre</h1>
<p>Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.</p>
<p>Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0, 0, 0));</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0">setShadowTechnique</a>(<a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af1b698ef34b8d97c261b7ade00010b7f">ShadowTechnique::SHADOWTYPE_STENCIL_MODULATIVE</a>);</div></div><!-- fragment --><p> Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.</p>
<h1><a class="anchor" id="bt2Lights"></a>
Lights</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.</p><ul>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca0d59bfdcfeb338dbfe06e2e2999e752f" title="Point light sources give off light equally in all directions, so require only position not direction...">Ogre::Light::LT_POINT</a> - This Light speads out equally in all directions from a point.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca8fc40a1ccfb026944417ef92b7ddaefe" title="Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff. ">Ogre::Light::LT_SPOTLIGHT</a> - This Light works like a flashlight. It produces a solid cylinder of light that is brighter at the center and fades off.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca4c5582d28848ce40c2b652488494b4a3" title="Directional lights simulate parallel light beams from a distant source, hence have direction but no p...">Ogre::Light::LT_DIRECTIONAL</a> - This Light simulates a huge source that is very far away - like daylight. Light hits the entire scene at the same angle everywhere.</li>
</ul>
<p>The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.</p>
<h1><a class="anchor" id="CreatingaLight"></a>
Creating a Light</h1>
<p>Let's add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We'll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setType(Light::LT_SPOTLIGHT);</div></div><!-- fragment --><p> The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* spotLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    spotLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(spotLight);</div><div class="line">    spotLightNode-&gt;setDirection(-1, -1, 0);</div><div class="line">    spotLightNode-&gt;setPosition(Vector3(200, 200, 0));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must be wondering why we call setDirection for light source and then call the same method for related SceneNode. As long as setDirection is deprecated for Light it has to be attached to SceneNode. Since SceneNode default rotation is NEGATIVE_UNIT_Z we need to set same value for Light. Direction for light by default is not NEGATIVE_UNIT_Z but in the future releases it will be replaced with this value. So this extra call of setDirection for Light could be deleted in future. In other words we need this extra move for future compatibilty.</dd></dl>
<div class="image">
<img src="bt2_light_dir_1.png" alt="bt2_light_dir_1.png"/>
</div>
<p>Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setSpotlightRange(Degree(35), Degree(50));</div></div><!-- fragment --><p>Compile and run the application. You should see the shadowy blue figure of a ninja.</p>
<div class="image">
<img src="bt2_ninja1.jpg" alt="bt2_ninja1.jpg"/>
</div>
<h1><a class="anchor" id="CreatingMoreLights"></a>
Creating More Lights</h1>
<p>Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.</p>
<div class="fragment"><div class="line">    Light* directionalLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;DirectionalLight&quot;</span>);</div><div class="line">    directionalLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_DIRECTIONAL);</div></div><!-- fragment --><p> Now we'll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light's direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.</p>
<div class="fragment"><div class="line">    directionalLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* directionalLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    directionalLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(directionalLight);</div><div class="line">    directionalLightNode-&gt;setDirection(Vector3(0, -1, 1));</div></div><!-- fragment --> <div class="image">
<img src="bt2_light_dir_2.png" alt="bt2_light_dir_2.png"/>
</div>
<p>The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.</p>
<p>Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.</p>
<div class="image">
<img src="bt2_ninja2.jpg" alt="bt2_ninja2.jpg"/>
</div>
<p>To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We'll set the the specular and diffuse colors to a dark gray.</p>
<div class="fragment"><div class="line">    pointLight-&gt;setDiffuseColour(0.3, 0.3, 0.3);</div><div class="line">    pointLight-&gt;setSpecularColour(0.3, 0.3, 0.3);</div></div><!-- fragment --><p> A point light has no direction. It only has a position. We will place our last light above and behind the ninja.</p>
<div class="fragment"><div class="line">    SceneNode* pointLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    pointLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(pointLight);</div><div class="line">    pointLightNode-&gt;setPosition(Vector3(0, 150, 250));</div></div><!-- fragment --><p> Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?</p>
<div class="image">
<img src="bt2_ninja3.jpg" alt="bt2_ninja3.jpg"/>
</div>
<h1><a class="anchor" id="ShadowTypes"></a>
Shadow Types</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.</p>
<p>Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.</p>
<h1><a class="anchor" id="Conclusion2"></a>
Conclusion</h1>
<p>This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.</p>
<p>There are a lot of different settings we've covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you've finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Lights, Cameras, and Shadows</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__lights_cameras_shadows.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lights, Cameras, and Shadows </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#bt2TheOgreCameraClass">The Ogre Camera Class</a></li>
<li class="level1"><a href="#bt2CreatingaCamera">Creating a Camera</a></li>
<li class="level1"><a href="#bt2Viewports">Viewports</a></li>
<li class="level1"><a href="#bt2CreatingaViewport">Creating a Viewport</a></li>
<li class="level1"><a href="#bt2BuildingtheScene">Building the Scene</a></li>
<li class="level1"><a href="#bt2UsingShadowsinOgre">Using Shadows in Ogre</a></li>
<li class="level1"><a href="#bt2Lights">Lights</a></li>
<li class="level1"><a href="#CreatingaLight">Creating a Light</a></li>
<li class="level1"><a href="#CreatingMoreLights">Creating More Lights</a></li>
<li class="level1"><a href="#ShadowTypes">Shadow Types</a></li>
<li class="level1"><a href="#Conclusion2">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial will expand on the use of Lights in a scene and using them to cast shadows.</p>
<p>The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="bt2TheOgreCameraClass"></a>
The Ogre Camera Class</h1>
<p>A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera's position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.</p>
<dl class="section note"><dt>Note</dt><dd>Starting from version 1.10 functionality related to rotate and translate camera are deprecated. You should attach camera to <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> and do all transofrmation with this node.</dd></dl>
<h1><a class="anchor" id="bt2CreatingaCamera"></a>
Creating a Camera</h1>
<p>We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div></div><!-- fragment --><p>You can retrieve the Camera by name using the SceneManager's getCamera method.</p>
<p>Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.</p>
<p>The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.</p>
<div class="fragment"><div class="line">    cam-&gt;setNearClipDistance(5);</div><div class="line">    camNode-&gt;attachObject(cam);</div></div><!-- fragment --> <h1><a class="anchor" id="bt2Viewports"></a>
Viewports</h1>
<p>When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.</p>
<p>There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera's view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.</p>
<h1><a class="anchor" id="bt2CreatingaViewport"></a>
Creating a Viewport</h1>
<p>Let's create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.</p>
<p>Now let's set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We've set it to black because we are going to add colored lighting later, and we don't want the background color affecting how we see the lighting.</p>
<p>The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.</p>
<div class="fragment"><div class="line">    cam-&gt;setAspectRatio(<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualWidth()) / <a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualHeight()));</div></div><!-- fragment --><p> We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.</p>
<p>Compile and run your application. You should still only see a black screen, just make sure it runs.</p>
<h1><a class="anchor" id="bt2BuildingtheScene"></a>
Building the Scene</h1>
<p>Before we get to shadows and lighting, let's add some elements to our scene. Let's put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.</p>
<p>We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.</p>
<p>The first thing we'll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here's a picture:</p>
<div class="image">
<img src="bt2_plane_normal.png" alt="bt2_plane_normal.png"/>
</div>
<p>There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.</p>
<p>Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.</p>
<div class="fragment"><div class="line">    MeshManager::getSingleton().createPlane(</div><div class="line">            <span class="stringliteral">&quot;ground&quot;</span>,</div><div class="line">            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,</div><div class="line">            plane,</div><div class="line">            1500, 1500, 20, 20,</div><div class="line">            <span class="keyword">true</span>,</div><div class="line">            1, 5, 5,</div><div class="line">            Vector3::UNIT_Z);</div></div><!-- fragment --><p>This is a complicated method, and we're not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we've created a new mesh called "ground" with a size of 1500x1500.</p>
<p>Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don't confuse the parameter given to createEntity for the Entity's name. It is actually the name of the mesh we just created. We're used to seeing mesh names end with '.mesh'.</p>
<p>We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don't get confused, this means the ground won't cast a shadow, it doesn't mean we can't cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called 'rockwall.tga'. You can find the name yourself by reading the entry in the material script.</p>
<h1><a class="anchor" id="bt2UsingShadowsinOgre"></a>
Using Shadows in Ogre</h1>
<p>Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.</p>
<p>Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0, 0, 0));</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0">setShadowTechnique</a>(<a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af1b698ef34b8d97c261b7ade00010b7f">ShadowTechnique::SHADOWTYPE_STENCIL_MODULATIVE</a>);</div></div><!-- fragment --><p> Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.</p>
<h1><a class="anchor" id="bt2Lights"></a>
Lights</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.</p><ul>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca0d59bfdcfeb338dbfe06e2e2999e752f" title="Point light sources give off light equally in all directions, so require only position not direction...">Ogre::Light::LT_POINT</a> - This Light speads out equally in all directions from a point.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca8fc40a1ccfb026944417ef92b7ddaefe" title="Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff. ">Ogre::Light::LT_SPOTLIGHT</a> - This Light works like a flashlight. It produces a solid cylinder of light that is brighter at the center and fades off.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca4c5582d28848ce40c2b652488494b4a3" title="Directional lights simulate parallel light beams from a distant source, hence have direction but no p...">Ogre::Light::LT_DIRECTIONAL</a> - This Light simulates a huge source that is very far away - like daylight. Light hits the entire scene at the same angle everywhere.</li>
</ul>
<p>The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.</p>
<h1><a class="anchor" id="CreatingaLight"></a>
Creating a Light</h1>
<p>Let's add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We'll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setType(Light::LT_SPOTLIGHT);</div></div><!-- fragment --><p> The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* spotLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    spotLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(spotLight);</div><div class="line">    spotLightNode-&gt;setDirection(-1, -1, 0);</div><div class="line">    spotLightNode-&gt;setPosition(Vector3(200, 200, 0));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must be wondering why we call setDirection for light source and then call the same method for related SceneNode. As long as setDirection is deprecated for Light it has to be attached to SceneNode. Since SceneNode default rotation is NEGATIVE_UNIT_Z we need to set same value for Light. Direction for light by default is not NEGATIVE_UNIT_Z but in the future releases it will be replaced with this value. So this extra call of setDirection for Light could be deleted in future. In other words we need this extra move for future compatibilty.</dd></dl>
<div class="image">
<img src="bt2_light_dir_1.png" alt="bt2_light_dir_1.png"/>
</div>
<p>Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setSpotlightRange(Degree(35), Degree(50));</div></div><!-- fragment --><p>Compile and run the application. You should see the shadowy blue figure of a ninja.</p>
<div class="image">
<img src="bt2_ninja1.jpg" alt="bt2_ninja1.jpg"/>
</div>
<h1><a class="anchor" id="CreatingMoreLights"></a>
Creating More Lights</h1>
<p>Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.</p>
<div class="fragment"><div class="line">    Light* directionalLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;DirectionalLight&quot;</span>);</div><div class="line">    directionalLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_DIRECTIONAL);</div></div><!-- fragment --><p> Now we'll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light's direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.</p>
<div class="fragment"><div class="line">    directionalLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* directionalLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    directionalLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(directionalLight);</div><div class="line">    directionalLightNode-&gt;setDirection(Vector3(0, -1, 1));</div></div><!-- fragment --> <div class="image">
<img src="bt2_light_dir_2.png" alt="bt2_light_dir_2.png"/>
</div>
<p>The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.</p>
<p>Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.</p>
<div class="image">
<img src="bt2_ninja2.jpg" alt="bt2_ninja2.jpg"/>
</div>
<p>To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We'll set the the specular and diffuse colors to a dark gray.</p>
<div class="fragment"><div class="line">    pointLight-&gt;setDiffuseColour(0.3, 0.3, 0.3);</div><div class="line">    pointLight-&gt;setSpecularColour(0.3, 0.3, 0.3);</div></div><!-- fragment --><p> A point light has no direction. It only has a position. We will place our last light above and behind the ninja.</p>
<div class="fragment"><div class="line">    SceneNode* pointLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    pointLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(pointLight);</div><div class="line">    pointLightNode-&gt;setPosition(Vector3(0, 150, 250));</div></div><!-- fragment --><p> Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?</p>
<div class="image">
<img src="bt2_ninja3.jpg" alt="bt2_ninja3.jpg"/>
</div>
<h1><a class="anchor" id="ShadowTypes"></a>
Shadow Types</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.</p>
<p>Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.</p>
<h1><a class="anchor" id="Conclusion2"></a>
Conclusion</h1>
<p>This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.</p>
<p>There are a lot of different settings we've covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you've finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Lights, Cameras, and Shadows</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__lights_cameras_shadows.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lights, Cameras, and Shadows </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#bt2TheOgreCameraClass">The Ogre Camera Class</a></li>
<li class="level1"><a href="#bt2CreatingaCamera">Creating a Camera</a></li>
<li class="level1"><a href="#bt2Viewports">Viewports</a></li>
<li class="level1"><a href="#bt2CreatingaViewport">Creating a Viewport</a></li>
<li class="level1"><a href="#bt2BuildingtheScene">Building the Scene</a></li>
<li class="level1"><a href="#bt2UsingShadowsinOgre">Using Shadows in Ogre</a></li>
<li class="level1"><a href="#bt2Lights">Lights</a></li>
<li class="level1"><a href="#CreatingaLight">Creating a Light</a></li>
<li class="level1"><a href="#CreatingMoreLights">Creating More Lights</a></li>
<li class="level1"><a href="#ShadowTypes">Shadow Types</a></li>
<li class="level1"><a href="#Conclusion2">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial will expand on the use of Lights in a scene and using them to cast shadows.</p>
<p>The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="bt2TheOgreCameraClass"></a>
The Ogre Camera Class</h1>
<p>A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera's position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.</p>
<dl class="section note"><dt>Note</dt><dd>Starting from version 1.10 functionality related to rotate and translate camera are deprecated. You should attach camera to <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> and do all transofrmation with this node.</dd></dl>
<h1><a class="anchor" id="bt2CreatingaCamera"></a>
Creating a Camera</h1>
<p>We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div></div><!-- fragment --><p>You can retrieve the Camera by name using the SceneManager's getCamera method.</p>
<p>Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.</p>
<p>The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.</p>
<div class="fragment"><div class="line">    cam-&gt;setNearClipDistance(5);</div><div class="line">    camNode-&gt;attachObject(cam);</div></div><!-- fragment --> <h1><a class="anchor" id="bt2Viewports"></a>
Viewports</h1>
<p>When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.</p>
<p>There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera's view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.</p>
<h1><a class="anchor" id="bt2CreatingaViewport"></a>
Creating a Viewport</h1>
<p>Let's create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.</p>
<p>Now let's set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We've set it to black because we are going to add colored lighting later, and we don't want the background color affecting how we see the lighting.</p>
<p>The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.</p>
<div class="fragment"><div class="line">    cam-&gt;setAspectRatio(<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualWidth()) / <a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualHeight()));</div></div><!-- fragment --><p> We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.</p>
<p>Compile and run your application. You should still only see a black screen, just make sure it runs.</p>
<h1><a class="anchor" id="bt2BuildingtheScene"></a>
Building the Scene</h1>
<p>Before we get to shadows and lighting, let's add some elements to our scene. Let's put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.</p>
<p>We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.</p>
<p>The first thing we'll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here's a picture:</p>
<div class="image">
<img src="bt2_plane_normal.png" alt="bt2_plane_normal.png"/>
</div>
<p>There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.</p>
<p>Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.</p>
<div class="fragment"><div class="line">    MeshManager::getSingleton().createPlane(</div><div class="line">            <span class="stringliteral">&quot;ground&quot;</span>,</div><div class="line">            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,</div><div class="line">            plane,</div><div class="line">            1500, 1500, 20, 20,</div><div class="line">            <span class="keyword">true</span>,</div><div class="line">            1, 5, 5,</div><div class="line">            Vector3::UNIT_Z);</div></div><!-- fragment --><p>This is a complicated method, and we're not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we've created a new mesh called "ground" with a size of 1500x1500.</p>
<p>Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don't confuse the parameter given to createEntity for the Entity's name. It is actually the name of the mesh we just created. We're used to seeing mesh names end with '.mesh'.</p>
<p>We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don't get confused, this means the ground won't cast a shadow, it doesn't mean we can't cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called 'rockwall.tga'. You can find the name yourself by reading the entry in the material script.</p>
<h1><a class="anchor" id="bt2UsingShadowsinOgre"></a>
Using Shadows in Ogre</h1>
<p>Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.</p>
<p>Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0, 0, 0));</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0">setShadowTechnique</a>(<a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af1b698ef34b8d97c261b7ade00010b7f">ShadowTechnique::SHADOWTYPE_STENCIL_MODULATIVE</a>);</div></div><!-- fragment --><p> Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.</p>
<h1><a class="anchor" id="bt2Lights"></a>
Lights</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.</p><ul>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca0d59bfdcfeb338dbfe06e2e2999e752f" title="Point light sources give off light equally in all directions, so require only position not direction...">Ogre::Light::LT_POINT</a> - This Light speads out equally in all directions from a point.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca8fc40a1ccfb026944417ef92b7ddaefe" title="Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff. ">Ogre::Light::LT_SPOTLIGHT</a> - This Light works like a flashlight. It produces a solid cylinder of light that is brighter at the center and fades off.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca4c5582d28848ce40c2b652488494b4a3" title="Directional lights simulate parallel light beams from a distant source, hence have direction but no p...">Ogre::Light::LT_DIRECTIONAL</a> - This Light simulates a huge source that is very far away - like daylight. Light hits the entire scene at the same angle everywhere.</li>
</ul>
<p>The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.</p>
<h1><a class="anchor" id="CreatingaLight"></a>
Creating a Light</h1>
<p>Let's add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We'll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setType(Light::LT_SPOTLIGHT);</div></div><!-- fragment --><p> The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* spotLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    spotLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(spotLight);</div><div class="line">    spotLightNode-&gt;setDirection(-1, -1, 0);</div><div class="line">    spotLightNode-&gt;setPosition(Vector3(200, 200, 0));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must be wondering why we call setDirection for light source and then call the same method for related SceneNode. As long as setDirection is deprecated for Light it has to be attached to SceneNode. Since SceneNode default rotation is NEGATIVE_UNIT_Z we need to set same value for Light. Direction for light by default is not NEGATIVE_UNIT_Z but in the future releases it will be replaced with this value. So this extra call of setDirection for Light could be deleted in future. In other words we need this extra move for future compatibilty.</dd></dl>
<div class="image">
<img src="bt2_light_dir_1.png" alt="bt2_light_dir_1.png"/>
</div>
<p>Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setSpotlightRange(Degree(35), Degree(50));</div></div><!-- fragment --><p>Compile and run the application. You should see the shadowy blue figure of a ninja.</p>
<div class="image">
<img src="bt2_ninja1.jpg" alt="bt2_ninja1.jpg"/>
</div>
<h1><a class="anchor" id="CreatingMoreLights"></a>
Creating More Lights</h1>
<p>Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.</p>
<div class="fragment"><div class="line">    Light* directionalLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;DirectionalLight&quot;</span>);</div><div class="line">    directionalLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_DIRECTIONAL);</div></div><!-- fragment --><p> Now we'll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light's direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.</p>
<div class="fragment"><div class="line">    directionalLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* directionalLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    directionalLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(directionalLight);</div><div class="line">    directionalLightNode-&gt;setDirection(Vector3(0, -1, 1));</div></div><!-- fragment --> <div class="image">
<img src="bt2_light_dir_2.png" alt="bt2_light_dir_2.png"/>
</div>
<p>The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.</p>
<p>Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.</p>
<div class="image">
<img src="bt2_ninja2.jpg" alt="bt2_ninja2.jpg"/>
</div>
<p>To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We'll set the the specular and diffuse colors to a dark gray.</p>
<div class="fragment"><div class="line">    pointLight-&gt;setDiffuseColour(0.3, 0.3, 0.3);</div><div class="line">    pointLight-&gt;setSpecularColour(0.3, 0.3, 0.3);</div></div><!-- fragment --><p> A point light has no direction. It only has a position. We will place our last light above and behind the ninja.</p>
<div class="fragment"><div class="line">    SceneNode* pointLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    pointLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(pointLight);</div><div class="line">    pointLightNode-&gt;setPosition(Vector3(0, 150, 250));</div></div><!-- fragment --><p> Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?</p>
<div class="image">
<img src="bt2_ninja3.jpg" alt="bt2_ninja3.jpg"/>
</div>
<h1><a class="anchor" id="ShadowTypes"></a>
Shadow Types</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.</p>
<p>Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.</p>
<h1><a class="anchor" id="Conclusion2"></a>
Conclusion</h1>
<p>This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.</p>
<p>There are a lot of different settings we've covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you've finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Lights, Cameras, and Shadows</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__lights_cameras_shadows.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lights, Cameras, and Shadows </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#bt2TheOgreCameraClass">The Ogre Camera Class</a></li>
<li class="level1"><a href="#bt2CreatingaCamera">Creating a Camera</a></li>
<li class="level1"><a href="#bt2Viewports">Viewports</a></li>
<li class="level1"><a href="#bt2CreatingaViewport">Creating a Viewport</a></li>
<li class="level1"><a href="#bt2BuildingtheScene">Building the Scene</a></li>
<li class="level1"><a href="#bt2UsingShadowsinOgre">Using Shadows in Ogre</a></li>
<li class="level1"><a href="#bt2Lights">Lights</a></li>
<li class="level1"><a href="#CreatingaLight">Creating a Light</a></li>
<li class="level1"><a href="#CreatingMoreLights">Creating More Lights</a></li>
<li class="level1"><a href="#ShadowTypes">Shadow Types</a></li>
<li class="level1"><a href="#Conclusion2">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial will expand on the use of Lights in a scene and using them to cast shadows.</p>
<p>The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="bt2TheOgreCameraClass"></a>
The Ogre Camera Class</h1>
<p>A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera's position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.</p>
<dl class="section note"><dt>Note</dt><dd>Starting from version 1.10 functionality related to rotate and translate camera are deprecated. You should attach camera to <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> and do all transofrmation with this node.</dd></dl>
<h1><a class="anchor" id="bt2CreatingaCamera"></a>
Creating a Camera</h1>
<p>We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div></div><!-- fragment --><p>You can retrieve the Camera by name using the SceneManager's getCamera method.</p>
<p>Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.</p>
<p>The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.</p>
<div class="fragment"><div class="line">    cam-&gt;setNearClipDistance(5);</div><div class="line">    camNode-&gt;attachObject(cam);</div></div><!-- fragment --> <h1><a class="anchor" id="bt2Viewports"></a>
Viewports</h1>
<p>When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.</p>
<p>There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera's view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.</p>
<h1><a class="anchor" id="bt2CreatingaViewport"></a>
Creating a Viewport</h1>
<p>Let's create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.</p>
<p>Now let's set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We've set it to black because we are going to add colored lighting later, and we don't want the background color affecting how we see the lighting.</p>
<p>The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.</p>
<div class="fragment"><div class="line">    cam-&gt;setAspectRatio(<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualWidth()) / <a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualHeight()));</div></div><!-- fragment --><p> We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.</p>
<p>Compile and run your application. You should still only see a black screen, just make sure it runs.</p>
<h1><a class="anchor" id="bt2BuildingtheScene"></a>
Building the Scene</h1>
<p>Before we get to shadows and lighting, let's add some elements to our scene. Let's put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.</p>
<p>We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.</p>
<p>The first thing we'll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here's a picture:</p>
<div class="image">
<img src="bt2_plane_normal.png" alt="bt2_plane_normal.png"/>
</div>
<p>There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.</p>
<p>Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.</p>
<div class="fragment"><div class="line">    MeshManager::getSingleton().createPlane(</div><div class="line">            <span class="stringliteral">&quot;ground&quot;</span>,</div><div class="line">            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,</div><div class="line">            plane,</div><div class="line">            1500, 1500, 20, 20,</div><div class="line">            <span class="keyword">true</span>,</div><div class="line">            1, 5, 5,</div><div class="line">            Vector3::UNIT_Z);</div></div><!-- fragment --><p>This is a complicated method, and we're not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we've created a new mesh called "ground" with a size of 1500x1500.</p>
<p>Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don't confuse the parameter given to createEntity for the Entity's name. It is actually the name of the mesh we just created. We're used to seeing mesh names end with '.mesh'.</p>
<p>We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don't get confused, this means the ground won't cast a shadow, it doesn't mean we can't cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called 'rockwall.tga'. You can find the name yourself by reading the entry in the material script.</p>
<h1><a class="anchor" id="bt2UsingShadowsinOgre"></a>
Using Shadows in Ogre</h1>
<p>Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.</p>
<p>Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0, 0, 0));</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0">setShadowTechnique</a>(<a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af1b698ef34b8d97c261b7ade00010b7f">ShadowTechnique::SHADOWTYPE_STENCIL_MODULATIVE</a>);</div></div><!-- fragment --><p> Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.</p>
<h1><a class="anchor" id="bt2Lights"></a>
Lights</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.</p><ul>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca0d59bfdcfeb338dbfe06e2e2999e752f" title="Point light sources give off light equally in all directions, so require only position not direction...">Ogre::Light::LT_POINT</a> - This Light speads out equally in all directions from a point.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca8fc40a1ccfb026944417ef92b7ddaefe" title="Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff. ">Ogre::Light::LT_SPOTLIGHT</a> - This Light works like a flashlight. It produces a solid cylinder of light that is brighter at the center and fades off.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca4c5582d28848ce40c2b652488494b4a3" title="Directional lights simulate parallel light beams from a distant source, hence have direction but no p...">Ogre::Light::LT_DIRECTIONAL</a> - This Light simulates a huge source that is very far away - like daylight. Light hits the entire scene at the same angle everywhere.</li>
</ul>
<p>The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.</p>
<h1><a class="anchor" id="CreatingaLight"></a>
Creating a Light</h1>
<p>Let's add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We'll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setType(Light::LT_SPOTLIGHT);</div></div><!-- fragment --><p> The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* spotLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    spotLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(spotLight);</div><div class="line">    spotLightNode-&gt;setDirection(-1, -1, 0);</div><div class="line">    spotLightNode-&gt;setPosition(Vector3(200, 200, 0));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must be wondering why we call setDirection for light source and then call the same method for related SceneNode. As long as setDirection is deprecated for Light it has to be attached to SceneNode. Since SceneNode default rotation is NEGATIVE_UNIT_Z we need to set same value for Light. Direction for light by default is not NEGATIVE_UNIT_Z but in the future releases it will be replaced with this value. So this extra call of setDirection for Light could be deleted in future. In other words we need this extra move for future compatibilty.</dd></dl>
<div class="image">
<img src="bt2_light_dir_1.png" alt="bt2_light_dir_1.png"/>
</div>
<p>Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setSpotlightRange(Degree(35), Degree(50));</div></div><!-- fragment --><p>Compile and run the application. You should see the shadowy blue figure of a ninja.</p>
<div class="image">
<img src="bt2_ninja1.jpg" alt="bt2_ninja1.jpg"/>
</div>
<h1><a class="anchor" id="CreatingMoreLights"></a>
Creating More Lights</h1>
<p>Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.</p>
<div class="fragment"><div class="line">    Light* directionalLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;DirectionalLight&quot;</span>);</div><div class="line">    directionalLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_DIRECTIONAL);</div></div><!-- fragment --><p> Now we'll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light's direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.</p>
<div class="fragment"><div class="line">    directionalLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* directionalLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    directionalLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(directionalLight);</div><div class="line">    directionalLightNode-&gt;setDirection(Vector3(0, -1, 1));</div></div><!-- fragment --> <div class="image">
<img src="bt2_light_dir_2.png" alt="bt2_light_dir_2.png"/>
</div>
<p>The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.</p>
<p>Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.</p>
<div class="image">
<img src="bt2_ninja2.jpg" alt="bt2_ninja2.jpg"/>
</div>
<p>To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We'll set the the specular and diffuse colors to a dark gray.</p>
<div class="fragment"><div class="line">    pointLight-&gt;setDiffuseColour(0.3, 0.3, 0.3);</div><div class="line">    pointLight-&gt;setSpecularColour(0.3, 0.3, 0.3);</div></div><!-- fragment --><p> A point light has no direction. It only has a position. We will place our last light above and behind the ninja.</p>
<div class="fragment"><div class="line">    SceneNode* pointLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    pointLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(pointLight);</div><div class="line">    pointLightNode-&gt;setPosition(Vector3(0, 150, 250));</div></div><!-- fragment --><p> Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?</p>
<div class="image">
<img src="bt2_ninja3.jpg" alt="bt2_ninja3.jpg"/>
</div>
<h1><a class="anchor" id="ShadowTypes"></a>
Shadow Types</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.</p>
<p>Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.</p>
<h1><a class="anchor" id="Conclusion2"></a>
Conclusion</h1>
<p>This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.</p>
<p>There are a lot of different settings we've covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you've finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Lights, Cameras, and Shadows</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__lights_cameras_shadows.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lights, Cameras, and Shadows </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#bt2TheOgreCameraClass">The Ogre Camera Class</a></li>
<li class="level1"><a href="#bt2CreatingaCamera">Creating a Camera</a></li>
<li class="level1"><a href="#bt2Viewports">Viewports</a></li>
<li class="level1"><a href="#bt2CreatingaViewport">Creating a Viewport</a></li>
<li class="level1"><a href="#bt2BuildingtheScene">Building the Scene</a></li>
<li class="level1"><a href="#bt2UsingShadowsinOgre">Using Shadows in Ogre</a></li>
<li class="level1"><a href="#bt2Lights">Lights</a></li>
<li class="level1"><a href="#CreatingaLight">Creating a Light</a></li>
<li class="level1"><a href="#CreatingMoreLights">Creating More Lights</a></li>
<li class="level1"><a href="#ShadowTypes">Shadow Types</a></li>
<li class="level1"><a href="#Conclusion2">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial will expand on the use of Lights in a scene and using them to cast shadows.</p>
<p>The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="bt2TheOgreCameraClass"></a>
The Ogre Camera Class</h1>
<p>A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera's position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.</p>
<dl class="section note"><dt>Note</dt><dd>Starting from version 1.10 functionality related to rotate and translate camera are deprecated. You should attach camera to <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> and do all transofrmation with this node.</dd></dl>
<h1><a class="anchor" id="bt2CreatingaCamera"></a>
Creating a Camera</h1>
<p>We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div></div><!-- fragment --><p>You can retrieve the Camera by name using the SceneManager's getCamera method.</p>
<p>Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.</p>
<p>The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.</p>
<div class="fragment"><div class="line">    cam-&gt;setNearClipDistance(5);</div><div class="line">    camNode-&gt;attachObject(cam);</div></div><!-- fragment --> <h1><a class="anchor" id="bt2Viewports"></a>
Viewports</h1>
<p>When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.</p>
<p>There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera's view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.</p>
<h1><a class="anchor" id="bt2CreatingaViewport"></a>
Creating a Viewport</h1>
<p>Let's create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.</p>
<p>Now let's set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We've set it to black because we are going to add colored lighting later, and we don't want the background color affecting how we see the lighting.</p>
<p>The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.</p>
<div class="fragment"><div class="line">    cam-&gt;setAspectRatio(<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualWidth()) / <a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualHeight()));</div></div><!-- fragment --><p> We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.</p>
<p>Compile and run your application. You should still only see a black screen, just make sure it runs.</p>
<h1><a class="anchor" id="bt2BuildingtheScene"></a>
Building the Scene</h1>
<p>Before we get to shadows and lighting, let's add some elements to our scene. Let's put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.</p>
<p>We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.</p>
<p>The first thing we'll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here's a picture:</p>
<div class="image">
<img src="bt2_plane_normal.png" alt="bt2_plane_normal.png"/>
</div>
<p>There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.</p>
<p>Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.</p>
<div class="fragment"><div class="line">    MeshManager::getSingleton().createPlane(</div><div class="line">            <span class="stringliteral">&quot;ground&quot;</span>,</div><div class="line">            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,</div><div class="line">            plane,</div><div class="line">            1500, 1500, 20, 20,</div><div class="line">            <span class="keyword">true</span>,</div><div class="line">            1, 5, 5,</div><div class="line">            Vector3::UNIT_Z);</div></div><!-- fragment --><p>This is a complicated method, and we're not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we've created a new mesh called "ground" with a size of 1500x1500.</p>
<p>Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don't confuse the parameter given to createEntity for the Entity's name. It is actually the name of the mesh we just created. We're used to seeing mesh names end with '.mesh'.</p>
<p>We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don't get confused, this means the ground won't cast a shadow, it doesn't mean we can't cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called 'rockwall.tga'. You can find the name yourself by reading the entry in the material script.</p>
<h1><a class="anchor" id="bt2UsingShadowsinOgre"></a>
Using Shadows in Ogre</h1>
<p>Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.</p>
<p>Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0, 0, 0));</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0">setShadowTechnique</a>(<a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af1b698ef34b8d97c261b7ade00010b7f">ShadowTechnique::SHADOWTYPE_STENCIL_MODULATIVE</a>);</div></div><!-- fragment --><p> Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.</p>
<h1><a class="anchor" id="bt2Lights"></a>
Lights</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.</p><ul>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca0d59bfdcfeb338dbfe06e2e2999e752f" title="Point light sources give off light equally in all directions, so require only position not direction...">Ogre::Light::LT_POINT</a> - This Light speads out equally in all directions from a point.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca8fc40a1ccfb026944417ef92b7ddaefe" title="Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff. ">Ogre::Light::LT_SPOTLIGHT</a> - This Light works like a flashlight. It produces a solid cylinder of light that is brighter at the center and fades off.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca4c5582d28848ce40c2b652488494b4a3" title="Directional lights simulate parallel light beams from a distant source, hence have direction but no p...">Ogre::Light::LT_DIRECTIONAL</a> - This Light simulates a huge source that is very far away - like daylight. Light hits the entire scene at the same angle everywhere.</li>
</ul>
<p>The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.</p>
<h1><a class="anchor" id="CreatingaLight"></a>
Creating a Light</h1>
<p>Let's add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We'll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setType(Light::LT_SPOTLIGHT);</div></div><!-- fragment --><p> The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* spotLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    spotLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(spotLight);</div><div class="line">    spotLightNode-&gt;setDirection(-1, -1, 0);</div><div class="line">    spotLightNode-&gt;setPosition(Vector3(200, 200, 0));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must be wondering why we call setDirection for light source and then call the same method for related SceneNode. As long as setDirection is deprecated for Light it has to be attached to SceneNode. Since SceneNode default rotation is NEGATIVE_UNIT_Z we need to set same value for Light. Direction for light by default is not NEGATIVE_UNIT_Z but in the future releases it will be replaced with this value. So this extra call of setDirection for Light could be deleted in future. In other words we need this extra move for future compatibilty.</dd></dl>
<div class="image">
<img src="bt2_light_dir_1.png" alt="bt2_light_dir_1.png"/>
</div>
<p>Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setSpotlightRange(Degree(35), Degree(50));</div></div><!-- fragment --><p>Compile and run the application. You should see the shadowy blue figure of a ninja.</p>
<div class="image">
<img src="bt2_ninja1.jpg" alt="bt2_ninja1.jpg"/>
</div>
<h1><a class="anchor" id="CreatingMoreLights"></a>
Creating More Lights</h1>
<p>Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.</p>
<div class="fragment"><div class="line">    Light* directionalLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;DirectionalLight&quot;</span>);</div><div class="line">    directionalLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_DIRECTIONAL);</div></div><!-- fragment --><p> Now we'll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light's direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.</p>
<div class="fragment"><div class="line">    directionalLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* directionalLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    directionalLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(directionalLight);</div><div class="line">    directionalLightNode-&gt;setDirection(Vector3(0, -1, 1));</div></div><!-- fragment --> <div class="image">
<img src="bt2_light_dir_2.png" alt="bt2_light_dir_2.png"/>
</div>
<p>The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.</p>
<p>Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.</p>
<div class="image">
<img src="bt2_ninja2.jpg" alt="bt2_ninja2.jpg"/>
</div>
<p>To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We'll set the the specular and diffuse colors to a dark gray.</p>
<div class="fragment"><div class="line">    pointLight-&gt;setDiffuseColour(0.3, 0.3, 0.3);</div><div class="line">    pointLight-&gt;setSpecularColour(0.3, 0.3, 0.3);</div></div><!-- fragment --><p> A point light has no direction. It only has a position. We will place our last light above and behind the ninja.</p>
<div class="fragment"><div class="line">    SceneNode* pointLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    pointLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(pointLight);</div><div class="line">    pointLightNode-&gt;setPosition(Vector3(0, 150, 250));</div></div><!-- fragment --><p> Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?</p>
<div class="image">
<img src="bt2_ninja3.jpg" alt="bt2_ninja3.jpg"/>
</div>
<h1><a class="anchor" id="ShadowTypes"></a>
Shadow Types</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.</p>
<p>Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.</p>
<h1><a class="anchor" id="Conclusion2"></a>
Conclusion</h1>
<p>This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.</p>
<p>There are a lot of different settings we've covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you've finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Lights, Cameras, and Shadows</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__lights_cameras_shadows.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lights, Cameras, and Shadows </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#bt2TheOgreCameraClass">The Ogre Camera Class</a></li>
<li class="level1"><a href="#bt2CreatingaCamera">Creating a Camera</a></li>
<li class="level1"><a href="#bt2Viewports">Viewports</a></li>
<li class="level1"><a href="#bt2CreatingaViewport">Creating a Viewport</a></li>
<li class="level1"><a href="#bt2BuildingtheScene">Building the Scene</a></li>
<li class="level1"><a href="#bt2UsingShadowsinOgre">Using Shadows in Ogre</a></li>
<li class="level1"><a href="#bt2Lights">Lights</a></li>
<li class="level1"><a href="#CreatingaLight">Creating a Light</a></li>
<li class="level1"><a href="#CreatingMoreLights">Creating More Lights</a></li>
<li class="level1"><a href="#ShadowTypes">Shadow Types</a></li>
<li class="level1"><a href="#Conclusion2">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial will expand on the use of Lights in a scene and using them to cast shadows.</p>
<p>The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="bt2TheOgreCameraClass"></a>
The Ogre Camera Class</h1>
<p>A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera's position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.</p>
<dl class="section note"><dt>Note</dt><dd>Starting from version 1.10 functionality related to rotate and translate camera are deprecated. You should attach camera to <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> and do all transofrmation with this node.</dd></dl>
<h1><a class="anchor" id="bt2CreatingaCamera"></a>
Creating a Camera</h1>
<p>We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div></div><!-- fragment --><p>You can retrieve the Camera by name using the SceneManager's getCamera method.</p>
<p>Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.</p>
<p>The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.</p>
<div class="fragment"><div class="line">    cam-&gt;setNearClipDistance(5);</div><div class="line">    camNode-&gt;attachObject(cam);</div></div><!-- fragment --> <h1><a class="anchor" id="bt2Viewports"></a>
Viewports</h1>
<p>When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.</p>
<p>There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera's view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.</p>
<h1><a class="anchor" id="bt2CreatingaViewport"></a>
Creating a Viewport</h1>
<p>Let's create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.</p>
<p>Now let's set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We've set it to black because we are going to add colored lighting later, and we don't want the background color affecting how we see the lighting.</p>
<p>The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.</p>
<div class="fragment"><div class="line">    cam-&gt;setAspectRatio(<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualWidth()) / <a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualHeight()));</div></div><!-- fragment --><p> We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.</p>
<p>Compile and run your application. You should still only see a black screen, just make sure it runs.</p>
<h1><a class="anchor" id="bt2BuildingtheScene"></a>
Building the Scene</h1>
<p>Before we get to shadows and lighting, let's add some elements to our scene. Let's put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.</p>
<p>We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.</p>
<p>The first thing we'll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here's a picture:</p>
<div class="image">
<img src="bt2_plane_normal.png" alt="bt2_plane_normal.png"/>
</div>
<p>There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.</p>
<p>Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.</p>
<div class="fragment"><div class="line">    MeshManager::getSingleton().createPlane(</div><div class="line">            <span class="stringliteral">&quot;ground&quot;</span>,</div><div class="line">            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,</div><div class="line">            plane,</div><div class="line">            1500, 1500, 20, 20,</div><div class="line">            <span class="keyword">true</span>,</div><div class="line">            1, 5, 5,</div><div class="line">            Vector3::UNIT_Z);</div></div><!-- fragment --><p>This is a complicated method, and we're not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we've created a new mesh called "ground" with a size of 1500x1500.</p>
<p>Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don't confuse the parameter given to createEntity for the Entity's name. It is actually the name of the mesh we just created. We're used to seeing mesh names end with '.mesh'.</p>
<p>We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don't get confused, this means the ground won't cast a shadow, it doesn't mean we can't cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called 'rockwall.tga'. You can find the name yourself by reading the entry in the material script.</p>
<h1><a class="anchor" id="bt2UsingShadowsinOgre"></a>
Using Shadows in Ogre</h1>
<p>Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.</p>
<p>Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0, 0, 0));</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0">setShadowTechnique</a>(<a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af1b698ef34b8d97c261b7ade00010b7f">ShadowTechnique::SHADOWTYPE_STENCIL_MODULATIVE</a>);</div></div><!-- fragment --><p> Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.</p>
<h1><a class="anchor" id="bt2Lights"></a>
Lights</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.</p><ul>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca0d59bfdcfeb338dbfe06e2e2999e752f" title="Point light sources give off light equally in all directions, so require only position not direction...">Ogre::Light::LT_POINT</a> - This Light speads out equally in all directions from a point.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca8fc40a1ccfb026944417ef92b7ddaefe" title="Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff. ">Ogre::Light::LT_SPOTLIGHT</a> - This Light works like a flashlight. It produces a solid cylinder of light that is brighter at the center and fades off.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca4c5582d28848ce40c2b652488494b4a3" title="Directional lights simulate parallel light beams from a distant source, hence have direction but no p...">Ogre::Light::LT_DIRECTIONAL</a> - This Light simulates a huge source that is very far away - like daylight. Light hits the entire scene at the same angle everywhere.</li>
</ul>
<p>The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.</p>
<h1><a class="anchor" id="CreatingaLight"></a>
Creating a Light</h1>
<p>Let's add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We'll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setType(Light::LT_SPOTLIGHT);</div></div><!-- fragment --><p> The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* spotLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    spotLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(spotLight);</div><div class="line">    spotLightNode-&gt;setDirection(-1, -1, 0);</div><div class="line">    spotLightNode-&gt;setPosition(Vector3(200, 200, 0));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must be wondering why we call setDirection for light source and then call the same method for related SceneNode. As long as setDirection is deprecated for Light it has to be attached to SceneNode. Since SceneNode default rotation is NEGATIVE_UNIT_Z we need to set same value for Light. Direction for light by default is not NEGATIVE_UNIT_Z but in the future releases it will be replaced with this value. So this extra call of setDirection for Light could be deleted in future. In other words we need this extra move for future compatibilty.</dd></dl>
<div class="image">
<img src="bt2_light_dir_1.png" alt="bt2_light_dir_1.png"/>
</div>
<p>Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setSpotlightRange(Degree(35), Degree(50));</div></div><!-- fragment --><p>Compile and run the application. You should see the shadowy blue figure of a ninja.</p>
<div class="image">
<img src="bt2_ninja1.jpg" alt="bt2_ninja1.jpg"/>
</div>
<h1><a class="anchor" id="CreatingMoreLights"></a>
Creating More Lights</h1>
<p>Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.</p>
<div class="fragment"><div class="line">    Light* directionalLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;DirectionalLight&quot;</span>);</div><div class="line">    directionalLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_DIRECTIONAL);</div></div><!-- fragment --><p> Now we'll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light's direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.</p>
<div class="fragment"><div class="line">    directionalLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* directionalLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    directionalLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(directionalLight);</div><div class="line">    directionalLightNode-&gt;setDirection(Vector3(0, -1, 1));</div></div><!-- fragment --> <div class="image">
<img src="bt2_light_dir_2.png" alt="bt2_light_dir_2.png"/>
</div>
<p>The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.</p>
<p>Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.</p>
<div class="image">
<img src="bt2_ninja2.jpg" alt="bt2_ninja2.jpg"/>
</div>
<p>To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We'll set the the specular and diffuse colors to a dark gray.</p>
<div class="fragment"><div class="line">    pointLight-&gt;setDiffuseColour(0.3, 0.3, 0.3);</div><div class="line">    pointLight-&gt;setSpecularColour(0.3, 0.3, 0.3);</div></div><!-- fragment --><p> A point light has no direction. It only has a position. We will place our last light above and behind the ninja.</p>
<div class="fragment"><div class="line">    SceneNode* pointLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    pointLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(pointLight);</div><div class="line">    pointLightNode-&gt;setPosition(Vector3(0, 150, 250));</div></div><!-- fragment --><p> Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?</p>
<div class="image">
<img src="bt2_ninja3.jpg" alt="bt2_ninja3.jpg"/>
</div>
<h1><a class="anchor" id="ShadowTypes"></a>
Shadow Types</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.</p>
<p>Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.</p>
<h1><a class="anchor" id="Conclusion2"></a>
Conclusion</h1>
<p>This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.</p>
<p>There are a lot of different settings we've covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you've finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Lights, Cameras, and Shadows</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__lights_cameras_shadows.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lights, Cameras, and Shadows </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#bt2TheOgreCameraClass">The Ogre Camera Class</a></li>
<li class="level1"><a href="#bt2CreatingaCamera">Creating a Camera</a></li>
<li class="level1"><a href="#bt2Viewports">Viewports</a></li>
<li class="level1"><a href="#bt2CreatingaViewport">Creating a Viewport</a></li>
<li class="level1"><a href="#bt2BuildingtheScene">Building the Scene</a></li>
<li class="level1"><a href="#bt2UsingShadowsinOgre">Using Shadows in Ogre</a></li>
<li class="level1"><a href="#bt2Lights">Lights</a></li>
<li class="level1"><a href="#CreatingaLight">Creating a Light</a></li>
<li class="level1"><a href="#CreatingMoreLights">Creating More Lights</a></li>
<li class="level1"><a href="#ShadowTypes">Shadow Types</a></li>
<li class="level1"><a href="#Conclusion2">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial will expand on the use of Lights in a scene and using them to cast shadows.</p>
<p>The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="bt2TheOgreCameraClass"></a>
The Ogre Camera Class</h1>
<p>A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera's position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.</p>
<dl class="section note"><dt>Note</dt><dd>Starting from version 1.10 functionality related to rotate and translate camera are deprecated. You should attach camera to <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> and do all transofrmation with this node.</dd></dl>
<h1><a class="anchor" id="bt2CreatingaCamera"></a>
Creating a Camera</h1>
<p>We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div></div><!-- fragment --><p>You can retrieve the Camera by name using the SceneManager's getCamera method.</p>
<p>Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.</p>
<p>The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.</p>
<div class="fragment"><div class="line">    cam-&gt;setNearClipDistance(5);</div><div class="line">    camNode-&gt;attachObject(cam);</div></div><!-- fragment --> <h1><a class="anchor" id="bt2Viewports"></a>
Viewports</h1>
<p>When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.</p>
<p>There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera's view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.</p>
<h1><a class="anchor" id="bt2CreatingaViewport"></a>
Creating a Viewport</h1>
<p>Let's create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.</p>
<p>Now let's set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We've set it to black because we are going to add colored lighting later, and we don't want the background color affecting how we see the lighting.</p>
<p>The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.</p>
<div class="fragment"><div class="line">    cam-&gt;setAspectRatio(<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualWidth()) / <a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualHeight()));</div></div><!-- fragment --><p> We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.</p>
<p>Compile and run your application. You should still only see a black screen, just make sure it runs.</p>
<h1><a class="anchor" id="bt2BuildingtheScene"></a>
Building the Scene</h1>
<p>Before we get to shadows and lighting, let's add some elements to our scene. Let's put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.</p>
<p>We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.</p>
<p>The first thing we'll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here's a picture:</p>
<div class="image">
<img src="bt2_plane_normal.png" alt="bt2_plane_normal.png"/>
</div>
<p>There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.</p>
<p>Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.</p>
<div class="fragment"><div class="line">    MeshManager::getSingleton().createPlane(</div><div class="line">            <span class="stringliteral">&quot;ground&quot;</span>,</div><div class="line">            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,</div><div class="line">            plane,</div><div class="line">            1500, 1500, 20, 20,</div><div class="line">            <span class="keyword">true</span>,</div><div class="line">            1, 5, 5,</div><div class="line">            Vector3::UNIT_Z);</div></div><!-- fragment --><p>This is a complicated method, and we're not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we've created a new mesh called "ground" with a size of 1500x1500.</p>
<p>Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don't confuse the parameter given to createEntity for the Entity's name. It is actually the name of the mesh we just created. We're used to seeing mesh names end with '.mesh'.</p>
<p>We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don't get confused, this means the ground won't cast a shadow, it doesn't mean we can't cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called 'rockwall.tga'. You can find the name yourself by reading the entry in the material script.</p>
<h1><a class="anchor" id="bt2UsingShadowsinOgre"></a>
Using Shadows in Ogre</h1>
<p>Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.</p>
<p>Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0, 0, 0));</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0">setShadowTechnique</a>(<a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af1b698ef34b8d97c261b7ade00010b7f">ShadowTechnique::SHADOWTYPE_STENCIL_MODULATIVE</a>);</div></div><!-- fragment --><p> Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.</p>
<h1><a class="anchor" id="bt2Lights"></a>
Lights</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.</p><ul>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca0d59bfdcfeb338dbfe06e2e2999e752f" title="Point light sources give off light equally in all directions, so require only position not direction...">Ogre::Light::LT_POINT</a> - This Light speads out equally in all directions from a point.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca8fc40a1ccfb026944417ef92b7ddaefe" title="Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff. ">Ogre::Light::LT_SPOTLIGHT</a> - This Light works like a flashlight. It produces a solid cylinder of light that is brighter at the center and fades off.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca4c5582d28848ce40c2b652488494b4a3" title="Directional lights simulate parallel light beams from a distant source, hence have direction but no p...">Ogre::Light::LT_DIRECTIONAL</a> - This Light simulates a huge source that is very far away - like daylight. Light hits the entire scene at the same angle everywhere.</li>
</ul>
<p>The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.</p>
<h1><a class="anchor" id="CreatingaLight"></a>
Creating a Light</h1>
<p>Let's add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We'll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setType(Light::LT_SPOTLIGHT);</div></div><!-- fragment --><p> The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* spotLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    spotLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(spotLight);</div><div class="line">    spotLightNode-&gt;setDirection(-1, -1, 0);</div><div class="line">    spotLightNode-&gt;setPosition(Vector3(200, 200, 0));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must be wondering why we call setDirection for light source and then call the same method for related SceneNode. As long as setDirection is deprecated for Light it has to be attached to SceneNode. Since SceneNode default rotation is NEGATIVE_UNIT_Z we need to set same value for Light. Direction for light by default is not NEGATIVE_UNIT_Z but in the future releases it will be replaced with this value. So this extra call of setDirection for Light could be deleted in future. In other words we need this extra move for future compatibilty.</dd></dl>
<div class="image">
<img src="bt2_light_dir_1.png" alt="bt2_light_dir_1.png"/>
</div>
<p>Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setSpotlightRange(Degree(35), Degree(50));</div></div><!-- fragment --><p>Compile and run the application. You should see the shadowy blue figure of a ninja.</p>
<div class="image">
<img src="bt2_ninja1.jpg" alt="bt2_ninja1.jpg"/>
</div>
<h1><a class="anchor" id="CreatingMoreLights"></a>
Creating More Lights</h1>
<p>Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.</p>
<div class="fragment"><div class="line">    Light* directionalLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;DirectionalLight&quot;</span>);</div><div class="line">    directionalLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_DIRECTIONAL);</div></div><!-- fragment --><p> Now we'll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light's direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.</p>
<div class="fragment"><div class="line">    directionalLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* directionalLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    directionalLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(directionalLight);</div><div class="line">    directionalLightNode-&gt;setDirection(Vector3(0, -1, 1));</div></div><!-- fragment --> <div class="image">
<img src="bt2_light_dir_2.png" alt="bt2_light_dir_2.png"/>
</div>
<p>The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.</p>
<p>Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.</p>
<div class="image">
<img src="bt2_ninja2.jpg" alt="bt2_ninja2.jpg"/>
</div>
<p>To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We'll set the the specular and diffuse colors to a dark gray.</p>
<div class="fragment"><div class="line">    pointLight-&gt;setDiffuseColour(0.3, 0.3, 0.3);</div><div class="line">    pointLight-&gt;setSpecularColour(0.3, 0.3, 0.3);</div></div><!-- fragment --><p> A point light has no direction. It only has a position. We will place our last light above and behind the ninja.</p>
<div class="fragment"><div class="line">    SceneNode* pointLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    pointLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(pointLight);</div><div class="line">    pointLightNode-&gt;setPosition(Vector3(0, 150, 250));</div></div><!-- fragment --><p> Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?</p>
<div class="image">
<img src="bt2_ninja3.jpg" alt="bt2_ninja3.jpg"/>
</div>
<h1><a class="anchor" id="ShadowTypes"></a>
Shadow Types</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.</p>
<p>Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.</p>
<h1><a class="anchor" id="Conclusion2"></a>
Conclusion</h1>
<p>This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.</p>
<p>There are a lot of different settings we've covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you've finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Lights, Cameras, and Shadows</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__lights_cameras_shadows.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lights, Cameras, and Shadows </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#bt2TheOgreCameraClass">The Ogre Camera Class</a></li>
<li class="level1"><a href="#bt2CreatingaCamera">Creating a Camera</a></li>
<li class="level1"><a href="#bt2Viewports">Viewports</a></li>
<li class="level1"><a href="#bt2CreatingaViewport">Creating a Viewport</a></li>
<li class="level1"><a href="#bt2BuildingtheScene">Building the Scene</a></li>
<li class="level1"><a href="#bt2UsingShadowsinOgre">Using Shadows in Ogre</a></li>
<li class="level1"><a href="#bt2Lights">Lights</a></li>
<li class="level1"><a href="#CreatingaLight">Creating a Light</a></li>
<li class="level1"><a href="#CreatingMoreLights">Creating More Lights</a></li>
<li class="level1"><a href="#ShadowTypes">Shadow Types</a></li>
<li class="level1"><a href="#Conclusion2">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial will expand on the use of Lights in a scene and using them to cast shadows.</p>
<p>The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="bt2TheOgreCameraClass"></a>
The Ogre Camera Class</h1>
<p>A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera's position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.</p>
<dl class="section note"><dt>Note</dt><dd>Starting from version 1.10 functionality related to rotate and translate camera are deprecated. You should attach camera to <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> and do all transofrmation with this node.</dd></dl>
<h1><a class="anchor" id="bt2CreatingaCamera"></a>
Creating a Camera</h1>
<p>We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div></div><!-- fragment --><p>You can retrieve the Camera by name using the SceneManager's getCamera method.</p>
<p>Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.</p>
<p>The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.</p>
<div class="fragment"><div class="line">    cam-&gt;setNearClipDistance(5);</div><div class="line">    camNode-&gt;attachObject(cam);</div></div><!-- fragment --> <h1><a class="anchor" id="bt2Viewports"></a>
Viewports</h1>
<p>When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.</p>
<p>There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera's view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.</p>
<h1><a class="anchor" id="bt2CreatingaViewport"></a>
Creating a Viewport</h1>
<p>Let's create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.</p>
<p>Now let's set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We've set it to black because we are going to add colored lighting later, and we don't want the background color affecting how we see the lighting.</p>
<p>The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.</p>
<div class="fragment"><div class="line">    cam-&gt;setAspectRatio(<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualWidth()) / <a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualHeight()));</div></div><!-- fragment --><p> We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.</p>
<p>Compile and run your application. You should still only see a black screen, just make sure it runs.</p>
<h1><a class="anchor" id="bt2BuildingtheScene"></a>
Building the Scene</h1>
<p>Before we get to shadows and lighting, let's add some elements to our scene. Let's put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.</p>
<p>We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.</p>
<p>The first thing we'll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here's a picture:</p>
<div class="image">
<img src="bt2_plane_normal.png" alt="bt2_plane_normal.png"/>
</div>
<p>There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.</p>
<p>Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.</p>
<div class="fragment"><div class="line">    MeshManager::getSingleton().createPlane(</div><div class="line">            <span class="stringliteral">&quot;ground&quot;</span>,</div><div class="line">            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,</div><div class="line">            plane,</div><div class="line">            1500, 1500, 20, 20,</div><div class="line">            <span class="keyword">true</span>,</div><div class="line">            1, 5, 5,</div><div class="line">            Vector3::UNIT_Z);</div></div><!-- fragment --><p>This is a complicated method, and we're not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we've created a new mesh called "ground" with a size of 1500x1500.</p>
<p>Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don't confuse the parameter given to createEntity for the Entity's name. It is actually the name of the mesh we just created. We're used to seeing mesh names end with '.mesh'.</p>
<p>We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don't get confused, this means the ground won't cast a shadow, it doesn't mean we can't cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called 'rockwall.tga'. You can find the name yourself by reading the entry in the material script.</p>
<h1><a class="anchor" id="bt2UsingShadowsinOgre"></a>
Using Shadows in Ogre</h1>
<p>Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.</p>
<p>Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0, 0, 0));</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0">setShadowTechnique</a>(<a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af1b698ef34b8d97c261b7ade00010b7f">ShadowTechnique::SHADOWTYPE_STENCIL_MODULATIVE</a>);</div></div><!-- fragment --><p> Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.</p>
<h1><a class="anchor" id="bt2Lights"></a>
Lights</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.</p><ul>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca0d59bfdcfeb338dbfe06e2e2999e752f" title="Point light sources give off light equally in all directions, so require only position not direction...">Ogre::Light::LT_POINT</a> - This Light speads out equally in all directions from a point.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca8fc40a1ccfb026944417ef92b7ddaefe" title="Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff. ">Ogre::Light::LT_SPOTLIGHT</a> - This Light works like a flashlight. It produces a solid cylinder of light that is brighter at the center and fades off.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca4c5582d28848ce40c2b652488494b4a3" title="Directional lights simulate parallel light beams from a distant source, hence have direction but no p...">Ogre::Light::LT_DIRECTIONAL</a> - This Light simulates a huge source that is very far away - like daylight. Light hits the entire scene at the same angle everywhere.</li>
</ul>
<p>The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.</p>
<h1><a class="anchor" id="CreatingaLight"></a>
Creating a Light</h1>
<p>Let's add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We'll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setType(Light::LT_SPOTLIGHT);</div></div><!-- fragment --><p> The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* spotLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    spotLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(spotLight);</div><div class="line">    spotLightNode-&gt;setDirection(-1, -1, 0);</div><div class="line">    spotLightNode-&gt;setPosition(Vector3(200, 200, 0));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must be wondering why we call setDirection for light source and then call the same method for related SceneNode. As long as setDirection is deprecated for Light it has to be attached to SceneNode. Since SceneNode default rotation is NEGATIVE_UNIT_Z we need to set same value for Light. Direction for light by default is not NEGATIVE_UNIT_Z but in the future releases it will be replaced with this value. So this extra call of setDirection for Light could be deleted in future. In other words we need this extra move for future compatibilty.</dd></dl>
<div class="image">
<img src="bt2_light_dir_1.png" alt="bt2_light_dir_1.png"/>
</div>
<p>Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setSpotlightRange(Degree(35), Degree(50));</div></div><!-- fragment --><p>Compile and run the application. You should see the shadowy blue figure of a ninja.</p>
<div class="image">
<img src="bt2_ninja1.jpg" alt="bt2_ninja1.jpg"/>
</div>
<h1><a class="anchor" id="CreatingMoreLights"></a>
Creating More Lights</h1>
<p>Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.</p>
<div class="fragment"><div class="line">    Light* directionalLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;DirectionalLight&quot;</span>);</div><div class="line">    directionalLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_DIRECTIONAL);</div></div><!-- fragment --><p> Now we'll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light's direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.</p>
<div class="fragment"><div class="line">    directionalLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* directionalLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    directionalLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(directionalLight);</div><div class="line">    directionalLightNode-&gt;setDirection(Vector3(0, -1, 1));</div></div><!-- fragment --> <div class="image">
<img src="bt2_light_dir_2.png" alt="bt2_light_dir_2.png"/>
</div>
<p>The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.</p>
<p>Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.</p>
<div class="image">
<img src="bt2_ninja2.jpg" alt="bt2_ninja2.jpg"/>
</div>
<p>To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We'll set the the specular and diffuse colors to a dark gray.</p>
<div class="fragment"><div class="line">    pointLight-&gt;setDiffuseColour(0.3, 0.3, 0.3);</div><div class="line">    pointLight-&gt;setSpecularColour(0.3, 0.3, 0.3);</div></div><!-- fragment --><p> A point light has no direction. It only has a position. We will place our last light above and behind the ninja.</p>
<div class="fragment"><div class="line">    SceneNode* pointLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    pointLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(pointLight);</div><div class="line">    pointLightNode-&gt;setPosition(Vector3(0, 150, 250));</div></div><!-- fragment --><p> Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?</p>
<div class="image">
<img src="bt2_ninja3.jpg" alt="bt2_ninja3.jpg"/>
</div>
<h1><a class="anchor" id="ShadowTypes"></a>
Shadow Types</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.</p>
<p>Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.</p>
<h1><a class="anchor" id="Conclusion2"></a>
Conclusion</h1>
<p>This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.</p>
<p>There are a lot of different settings we've covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you've finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Lights, Cameras, and Shadows</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__lights_cameras_shadows.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lights, Cameras, and Shadows </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#bt2TheOgreCameraClass">The Ogre Camera Class</a></li>
<li class="level1"><a href="#bt2CreatingaCamera">Creating a Camera</a></li>
<li class="level1"><a href="#bt2Viewports">Viewports</a></li>
<li class="level1"><a href="#bt2CreatingaViewport">Creating a Viewport</a></li>
<li class="level1"><a href="#bt2BuildingtheScene">Building the Scene</a></li>
<li class="level1"><a href="#bt2UsingShadowsinOgre">Using Shadows in Ogre</a></li>
<li class="level1"><a href="#bt2Lights">Lights</a></li>
<li class="level1"><a href="#CreatingaLight">Creating a Light</a></li>
<li class="level1"><a href="#CreatingMoreLights">Creating More Lights</a></li>
<li class="level1"><a href="#ShadowTypes">Shadow Types</a></li>
<li class="level1"><a href="#Conclusion2">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial will expand on the use of Lights in a scene and using them to cast shadows.</p>
<p>The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="bt2TheOgreCameraClass"></a>
The Ogre Camera Class</h1>
<p>A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera's position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.</p>
<dl class="section note"><dt>Note</dt><dd>Starting from version 1.10 functionality related to rotate and translate camera are deprecated. You should attach camera to <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> and do all transofrmation with this node.</dd></dl>
<h1><a class="anchor" id="bt2CreatingaCamera"></a>
Creating a Camera</h1>
<p>We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div></div><!-- fragment --><p>You can retrieve the Camera by name using the SceneManager's getCamera method.</p>
<p>Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.</p>
<p>The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.</p>
<div class="fragment"><div class="line">    cam-&gt;setNearClipDistance(5);</div><div class="line">    camNode-&gt;attachObject(cam);</div></div><!-- fragment --> <h1><a class="anchor" id="bt2Viewports"></a>
Viewports</h1>
<p>When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.</p>
<p>There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera's view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.</p>
<h1><a class="anchor" id="bt2CreatingaViewport"></a>
Creating a Viewport</h1>
<p>Let's create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.</p>
<p>Now let's set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We've set it to black because we are going to add colored lighting later, and we don't want the background color affecting how we see the lighting.</p>
<p>The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.</p>
<div class="fragment"><div class="line">    cam-&gt;setAspectRatio(<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualWidth()) / <a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualHeight()));</div></div><!-- fragment --><p> We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.</p>
<p>Compile and run your application. You should still only see a black screen, just make sure it runs.</p>
<h1><a class="anchor" id="bt2BuildingtheScene"></a>
Building the Scene</h1>
<p>Before we get to shadows and lighting, let's add some elements to our scene. Let's put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.</p>
<p>We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.</p>
<p>The first thing we'll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here's a picture:</p>
<div class="image">
<img src="bt2_plane_normal.png" alt="bt2_plane_normal.png"/>
</div>
<p>There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.</p>
<p>Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.</p>
<div class="fragment"><div class="line">    MeshManager::getSingleton().createPlane(</div><div class="line">            <span class="stringliteral">&quot;ground&quot;</span>,</div><div class="line">            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,</div><div class="line">            plane,</div><div class="line">            1500, 1500, 20, 20,</div><div class="line">            <span class="keyword">true</span>,</div><div class="line">            1, 5, 5,</div><div class="line">            Vector3::UNIT_Z);</div></div><!-- fragment --><p>This is a complicated method, and we're not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we've created a new mesh called "ground" with a size of 1500x1500.</p>
<p>Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don't confuse the parameter given to createEntity for the Entity's name. It is actually the name of the mesh we just created. We're used to seeing mesh names end with '.mesh'.</p>
<p>We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don't get confused, this means the ground won't cast a shadow, it doesn't mean we can't cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called 'rockwall.tga'. You can find the name yourself by reading the entry in the material script.</p>
<h1><a class="anchor" id="bt2UsingShadowsinOgre"></a>
Using Shadows in Ogre</h1>
<p>Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.</p>
<p>Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0, 0, 0));</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0">setShadowTechnique</a>(<a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af1b698ef34b8d97c261b7ade00010b7f">ShadowTechnique::SHADOWTYPE_STENCIL_MODULATIVE</a>);</div></div><!-- fragment --><p> Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.</p>
<h1><a class="anchor" id="bt2Lights"></a>
Lights</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.</p><ul>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca0d59bfdcfeb338dbfe06e2e2999e752f" title="Point light sources give off light equally in all directions, so require only position not direction...">Ogre::Light::LT_POINT</a> - This Light speads out equally in all directions from a point.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca8fc40a1ccfb026944417ef92b7ddaefe" title="Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff. ">Ogre::Light::LT_SPOTLIGHT</a> - This Light works like a flashlight. It produces a solid cylinder of light that is brighter at the center and fades off.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca4c5582d28848ce40c2b652488494b4a3" title="Directional lights simulate parallel light beams from a distant source, hence have direction but no p...">Ogre::Light::LT_DIRECTIONAL</a> - This Light simulates a huge source that is very far away - like daylight. Light hits the entire scene at the same angle everywhere.</li>
</ul>
<p>The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.</p>
<h1><a class="anchor" id="CreatingaLight"></a>
Creating a Light</h1>
<p>Let's add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We'll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setType(Light::LT_SPOTLIGHT);</div></div><!-- fragment --><p> The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* spotLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    spotLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(spotLight);</div><div class="line">    spotLightNode-&gt;setDirection(-1, -1, 0);</div><div class="line">    spotLightNode-&gt;setPosition(Vector3(200, 200, 0));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must be wondering why we call setDirection for light source and then call the same method for related SceneNode. As long as setDirection is deprecated for Light it has to be attached to SceneNode. Since SceneNode default rotation is NEGATIVE_UNIT_Z we need to set same value for Light. Direction for light by default is not NEGATIVE_UNIT_Z but in the future releases it will be replaced with this value. So this extra call of setDirection for Light could be deleted in future. In other words we need this extra move for future compatibilty.</dd></dl>
<div class="image">
<img src="bt2_light_dir_1.png" alt="bt2_light_dir_1.png"/>
</div>
<p>Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setSpotlightRange(Degree(35), Degree(50));</div></div><!-- fragment --><p>Compile and run the application. You should see the shadowy blue figure of a ninja.</p>
<div class="image">
<img src="bt2_ninja1.jpg" alt="bt2_ninja1.jpg"/>
</div>
<h1><a class="anchor" id="CreatingMoreLights"></a>
Creating More Lights</h1>
<p>Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.</p>
<div class="fragment"><div class="line">    Light* directionalLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;DirectionalLight&quot;</span>);</div><div class="line">    directionalLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_DIRECTIONAL);</div></div><!-- fragment --><p> Now we'll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light's direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.</p>
<div class="fragment"><div class="line">    directionalLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* directionalLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    directionalLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(directionalLight);</div><div class="line">    directionalLightNode-&gt;setDirection(Vector3(0, -1, 1));</div></div><!-- fragment --> <div class="image">
<img src="bt2_light_dir_2.png" alt="bt2_light_dir_2.png"/>
</div>
<p>The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.</p>
<p>Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.</p>
<div class="image">
<img src="bt2_ninja2.jpg" alt="bt2_ninja2.jpg"/>
</div>
<p>To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We'll set the the specular and diffuse colors to a dark gray.</p>
<div class="fragment"><div class="line">    pointLight-&gt;setDiffuseColour(0.3, 0.3, 0.3);</div><div class="line">    pointLight-&gt;setSpecularColour(0.3, 0.3, 0.3);</div></div><!-- fragment --><p> A point light has no direction. It only has a position. We will place our last light above and behind the ninja.</p>
<div class="fragment"><div class="line">    SceneNode* pointLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    pointLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(pointLight);</div><div class="line">    pointLightNode-&gt;setPosition(Vector3(0, 150, 250));</div></div><!-- fragment --><p> Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?</p>
<div class="image">
<img src="bt2_ninja3.jpg" alt="bt2_ninja3.jpg"/>
</div>
<h1><a class="anchor" id="ShadowTypes"></a>
Shadow Types</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.</p>
<p>Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.</p>
<h1><a class="anchor" id="Conclusion2"></a>
Conclusion</h1>
<p>This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.</p>
<p>There are a lot of different settings we've covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you've finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Lights, Cameras, and Shadows</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__lights_cameras_shadows.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lights, Cameras, and Shadows </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#bt2TheOgreCameraClass">The Ogre Camera Class</a></li>
<li class="level1"><a href="#bt2CreatingaCamera">Creating a Camera</a></li>
<li class="level1"><a href="#bt2Viewports">Viewports</a></li>
<li class="level1"><a href="#bt2CreatingaViewport">Creating a Viewport</a></li>
<li class="level1"><a href="#bt2BuildingtheScene">Building the Scene</a></li>
<li class="level1"><a href="#bt2UsingShadowsinOgre">Using Shadows in Ogre</a></li>
<li class="level1"><a href="#bt2Lights">Lights</a></li>
<li class="level1"><a href="#CreatingaLight">Creating a Light</a></li>
<li class="level1"><a href="#CreatingMoreLights">Creating More Lights</a></li>
<li class="level1"><a href="#ShadowTypes">Shadow Types</a></li>
<li class="level1"><a href="#Conclusion2">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial will expand on the use of Lights in a scene and using them to cast shadows.</p>
<p>The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="bt2TheOgreCameraClass"></a>
The Ogre Camera Class</h1>
<p>A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera's position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.</p>
<dl class="section note"><dt>Note</dt><dd>Starting from version 1.10 functionality related to rotate and translate camera are deprecated. You should attach camera to <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> and do all transofrmation with this node.</dd></dl>
<h1><a class="anchor" id="bt2CreatingaCamera"></a>
Creating a Camera</h1>
<p>We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div></div><!-- fragment --><p>You can retrieve the Camera by name using the SceneManager's getCamera method.</p>
<p>Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.</p>
<p>The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.</p>
<div class="fragment"><div class="line">    cam-&gt;setNearClipDistance(5);</div><div class="line">    camNode-&gt;attachObject(cam);</div></div><!-- fragment --> <h1><a class="anchor" id="bt2Viewports"></a>
Viewports</h1>
<p>When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.</p>
<p>There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera's view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.</p>
<h1><a class="anchor" id="bt2CreatingaViewport"></a>
Creating a Viewport</h1>
<p>Let's create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.</p>
<p>Now let's set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We've set it to black because we are going to add colored lighting later, and we don't want the background color affecting how we see the lighting.</p>
<p>The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.</p>
<div class="fragment"><div class="line">    cam-&gt;setAspectRatio(<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualWidth()) / <a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualHeight()));</div></div><!-- fragment --><p> We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.</p>
<p>Compile and run your application. You should still only see a black screen, just make sure it runs.</p>
<h1><a class="anchor" id="bt2BuildingtheScene"></a>
Building the Scene</h1>
<p>Before we get to shadows and lighting, let's add some elements to our scene. Let's put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.</p>
<p>We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.</p>
<p>The first thing we'll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here's a picture:</p>
<div class="image">
<img src="bt2_plane_normal.png" alt="bt2_plane_normal.png"/>
</div>
<p>There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.</p>
<p>Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.</p>
<div class="fragment"><div class="line">    MeshManager::getSingleton().createPlane(</div><div class="line">            <span class="stringliteral">&quot;ground&quot;</span>,</div><div class="line">            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,</div><div class="line">            plane,</div><div class="line">            1500, 1500, 20, 20,</div><div class="line">            <span class="keyword">true</span>,</div><div class="line">            1, 5, 5,</div><div class="line">            Vector3::UNIT_Z);</div></div><!-- fragment --><p>This is a complicated method, and we're not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we've created a new mesh called "ground" with a size of 1500x1500.</p>
<p>Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don't confuse the parameter given to createEntity for the Entity's name. It is actually the name of the mesh we just created. We're used to seeing mesh names end with '.mesh'.</p>
<p>We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don't get confused, this means the ground won't cast a shadow, it doesn't mean we can't cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called 'rockwall.tga'. You can find the name yourself by reading the entry in the material script.</p>
<h1><a class="anchor" id="bt2UsingShadowsinOgre"></a>
Using Shadows in Ogre</h1>
<p>Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.</p>
<p>Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0, 0, 0));</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0">setShadowTechnique</a>(<a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af1b698ef34b8d97c261b7ade00010b7f">ShadowTechnique::SHADOWTYPE_STENCIL_MODULATIVE</a>);</div></div><!-- fragment --><p> Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.</p>
<h1><a class="anchor" id="bt2Lights"></a>
Lights</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.</p><ul>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca0d59bfdcfeb338dbfe06e2e2999e752f" title="Point light sources give off light equally in all directions, so require only position not direction...">Ogre::Light::LT_POINT</a> - This Light speads out equally in all directions from a point.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca8fc40a1ccfb026944417ef92b7ddaefe" title="Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff. ">Ogre::Light::LT_SPOTLIGHT</a> - This Light works like a flashlight. It produces a solid cylinder of light that is brighter at the center and fades off.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca4c5582d28848ce40c2b652488494b4a3" title="Directional lights simulate parallel light beams from a distant source, hence have direction but no p...">Ogre::Light::LT_DIRECTIONAL</a> - This Light simulates a huge source that is very far away - like daylight. Light hits the entire scene at the same angle everywhere.</li>
</ul>
<p>The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.</p>
<h1><a class="anchor" id="CreatingaLight"></a>
Creating a Light</h1>
<p>Let's add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We'll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setType(Light::LT_SPOTLIGHT);</div></div><!-- fragment --><p> The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* spotLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    spotLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(spotLight);</div><div class="line">    spotLightNode-&gt;setDirection(-1, -1, 0);</div><div class="line">    spotLightNode-&gt;setPosition(Vector3(200, 200, 0));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must be wondering why we call setDirection for light source and then call the same method for related SceneNode. As long as setDirection is deprecated for Light it has to be attached to SceneNode. Since SceneNode default rotation is NEGATIVE_UNIT_Z we need to set same value for Light. Direction for light by default is not NEGATIVE_UNIT_Z but in the future releases it will be replaced with this value. So this extra call of setDirection for Light could be deleted in future. In other words we need this extra move for future compatibilty.</dd></dl>
<div class="image">
<img src="bt2_light_dir_1.png" alt="bt2_light_dir_1.png"/>
</div>
<p>Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setSpotlightRange(Degree(35), Degree(50));</div></div><!-- fragment --><p>Compile and run the application. You should see the shadowy blue figure of a ninja.</p>
<div class="image">
<img src="bt2_ninja1.jpg" alt="bt2_ninja1.jpg"/>
</div>
<h1><a class="anchor" id="CreatingMoreLights"></a>
Creating More Lights</h1>
<p>Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.</p>
<div class="fragment"><div class="line">    Light* directionalLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;DirectionalLight&quot;</span>);</div><div class="line">    directionalLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_DIRECTIONAL);</div></div><!-- fragment --><p> Now we'll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light's direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.</p>
<div class="fragment"><div class="line">    directionalLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* directionalLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    directionalLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(directionalLight);</div><div class="line">    directionalLightNode-&gt;setDirection(Vector3(0, -1, 1));</div></div><!-- fragment --> <div class="image">
<img src="bt2_light_dir_2.png" alt="bt2_light_dir_2.png"/>
</div>
<p>The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.</p>
<p>Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.</p>
<div class="image">
<img src="bt2_ninja2.jpg" alt="bt2_ninja2.jpg"/>
</div>
<p>To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We'll set the the specular and diffuse colors to a dark gray.</p>
<div class="fragment"><div class="line">    pointLight-&gt;setDiffuseColour(0.3, 0.3, 0.3);</div><div class="line">    pointLight-&gt;setSpecularColour(0.3, 0.3, 0.3);</div></div><!-- fragment --><p> A point light has no direction. It only has a position. We will place our last light above and behind the ninja.</p>
<div class="fragment"><div class="line">    SceneNode* pointLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    pointLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(pointLight);</div><div class="line">    pointLightNode-&gt;setPosition(Vector3(0, 150, 250));</div></div><!-- fragment --><p> Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?</p>
<div class="image">
<img src="bt2_ninja3.jpg" alt="bt2_ninja3.jpg"/>
</div>
<h1><a class="anchor" id="ShadowTypes"></a>
Shadow Types</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.</p>
<p>Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.</p>
<h1><a class="anchor" id="Conclusion2"></a>
Conclusion</h1>
<p>This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.</p>
<p>There are a lot of different settings we've covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you've finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Lights, Cameras, and Shadows</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('tut__lights_cameras_shadows.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Lights, Cameras, and Shadows </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#bt2TheOgreCameraClass">The Ogre Camera Class</a></li>
<li class="level1"><a href="#bt2CreatingaCamera">Creating a Camera</a></li>
<li class="level1"><a href="#bt2Viewports">Viewports</a></li>
<li class="level1"><a href="#bt2CreatingaViewport">Creating a Viewport</a></li>
<li class="level1"><a href="#bt2BuildingtheScene">Building the Scene</a></li>
<li class="level1"><a href="#bt2UsingShadowsinOgre">Using Shadows in Ogre</a></li>
<li class="level1"><a href="#bt2Lights">Lights</a></li>
<li class="level1"><a href="#CreatingaLight">Creating a Light</a></li>
<li class="level1"><a href="#CreatingMoreLights">Creating More Lights</a></li>
<li class="level1"><a href="#ShadowTypes">Shadow Types</a></li>
<li class="level1"><a href="#Conclusion2">Conclusion</a></li>
</ul>
</div>
<div class="textblock"><p>This tutorial will expand on the use of Lights in a scene and using them to cast shadows.</p>
<p>The full source for this tutorial (BasicTutorial2.cpp) can be found in samples directory <b>Samples/Tutorials</b>.</p>
<dl class="section note"><dt>Note</dt><dd>Refer to <a class="el" href="setup.html">Setting up an OGRE project</a> for instructions how set up an <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> project and compile it successfully.</dd></dl>
<h1><a class="anchor" id="bt2TheOgreCameraClass"></a>
The Ogre Camera Class</h1>
<p>A Camera is the object we use to view our scene. A <a class="el" href="class_ogre_1_1_camera.html" title="A viewpoint from which the scene will be rendered. ">Ogre::Camera</a> is a special object that works similar to a <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a>. It has methods like setPosition and yaw. You can also attach it to a SceneNode. For instance, you might want to temporarily attach your Camera to a SceneNode that follows a path through the sky to create an aerial cutscene. Just like a SceneNode the Camera's position will be relative to its parent SceneNode. The Camera is not a SceneNode (it actually inherits from the Frustum class), but for movement and rotation, you can treat it like a SceneNode.</p>
<dl class="section note"><dt>Note</dt><dd>Starting from version 1.10 functionality related to rotate and translate camera are deprecated. You should attach camera to <a class="el" href="class_ogre_1_1_scene_node.html" title="Class representing a node in the scene graph. ">Ogre::SceneNode</a> and do all transofrmation with this node.</dd></dl>
<h1><a class="anchor" id="bt2CreatingaCamera"></a>
Creating a Camera</h1>
<p>We will now cover camera creation part which we just applied in previous tutorial. We remeber that now we need to have SceneNode for camera. The first step will be doing is creating that SceneNode and asking the SceneManager to create a new Camera. Add the following to create SceneNode and Camera:</p>
<div class="fragment"><div class="line">    SceneNode* camNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    Camera* cam = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a62ca781b4c6d23dc3aab1f3a45d61843">createCamera</a>(<span class="stringliteral">&quot;myCam&quot;</span>);</div></div><!-- fragment --><p>You can retrieve the Camera by name using the SceneManager's getCamera method.</p>
<p>Next, we will position the Camera and use a method called lookAt to set its direction using camNode. </p><div class="fragment"><div class="line">    camNode-&gt;setPosition(200, 300, 400);</div><div class="line">    camNode-&gt;lookAt(Vector3(0, 0, 0), Node::TransformSpace::TS_WORLD);</div></div><!-- fragment --><p>The <a class="el" href="class_ogre_1_1_scene_node.html#a665c4750906917dd061b141c03d432de" title="Points the local -Z direction of this node at a point in space. ">Ogre::SceneNode::lookAt</a> method is very useful. It does exactly what it says. It rotates the SceneNode so that its line of sight focuses on the vector you give it. It makes the Camera "look at" the point.</p>
<p>The last thing we'll do (apart of attachning camera to a SceneNode) is set the near clipping distance to 5 units. This is the distance at which the Camera will no longer render any mesh. If you get very close to a mesh, this will sometimes cut the mesh and allow you to see inside of it. The alternative is filling the entire screen with a tiny, highly magnified piece of the mesh's texture. It's up to you what you want in your scene. For demonstration, we'll set it here.</p>
<div class="fragment"><div class="line">    cam-&gt;setNearClipDistance(5);</div><div class="line">    camNode-&gt;attachObject(cam);</div></div><!-- fragment --> <h1><a class="anchor" id="bt2Viewports"></a>
Viewports</h1>
<p>When dealing with multiple Cameras in a scene, the concept of a Viewport becomes very useful. We will touch on it now, because it will help you understand more about how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> decides which Camera to use when rendering a scene. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> makes it possible to have multiple SceneManagers running at the same time. It also allows you to break up the screen and use separate Cameras to render different views of a scene. This would allow the creation of things like splitscreens and minimaps. These kinds of things will be covered in later tutorials.</p>
<p>There are three constructs that are crucial to understanding how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders a scene: the Camera, the SceneManager, and the RenderWindow. We have not yet covered the RenderWindow. It basically represents the whole window we are rendering to. The SceneManager will create Cameras to view the scene, and then we tell the RenderWindow where to display each Camera's view. The way we tell the RenderWindow which area of the screen to use is by giving it a <a class="el" href="class_ogre_1_1_viewport.html" title="An abstraction of a viewport, i.e. ">Ogre::Viewport</a>. For many circumstances, we will simply create one Camera and create a Viewport which represents the whole screen.</p>
<h1><a class="anchor" id="bt2CreatingaViewport"></a>
Creating a Viewport</h1>
<p>Let's create a Viewport for our scene. To do this, we will use the addViewport method of the RenderWindow. </p><div class="fragment"><div class="line">    Viewport* vp = getRenderWindow()-&gt;addViewport(cam);</div></div><!-- fragment --><p>getRenderWindow() is a method defined for us in <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a> which returns <a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a>.</p>
<p>Now let's set the background color of the Viewport. </p><div class="fragment"><div class="line">    vp-&gt;setBackgroundColour(ColourValue(0, 0, 0));</div></div><!-- fragment --><p> We've set it to black because we are going to add colored lighting later, and we don't want the background color affecting how we see the lighting.</p>
<p>The last thing we are going to do is set the aspect ratio of our Camera. If you are using something other than a standard full-window viewport, then failing to set this can result in a distorted scene. We will set it here for demonstration even though we are using the default aspect ratio.</p>
<div class="fragment"><div class="line">    cam-&gt;setAspectRatio(<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualWidth()) / <a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>(vp-&gt;getActualHeight()));</div></div><!-- fragment --><p> We have retrieved the width and height from the Viewport to set the aspect ratio. As we mentioned, the default is already set to use the full screen's dimensions.</p>
<p>Compile and run your application. You should still only see a black screen, just make sure it runs.</p>
<h1><a class="anchor" id="bt2BuildingtheScene"></a>
Building the Scene</h1>
<p>Before we get to shadows and lighting, let's add some elements to our scene. Let's put a ninja right in the middle of things. Add the following code right after we set the ambient light: </p><div class="fragment"><div class="line">    Entity* ninjaEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ninja.mesh&quot;</span>);</div><div class="line">    ninjaEntity-&gt;<a class="code" href="class_ogre_1_1_movable_object.html#acbfc4840224e8b6ed6e27849d3341675">setCastShadows</a>(<span class="keyword">true</span>);</div><div class="line"></div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(ninjaEntity);</div></div><!-- fragment --><p> This should look familiar, except we are asking the mesh to cast shadows this time. And notice that we have created a child scene node and attached the ninjaEntity all in one call this time.</p>
<p>We will also create something for the ninja to be standing on. We can use the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> to create meshes from scratch. We will use it to generate a textured plane to use as the ground.</p>
<p>The first thing we'll do is create an abstract Plane object. This is not the mesh, it is more of a blueprint. </p><div class="fragment"><div class="line">    Plane plane(Vector3::UNIT_Y, 0);</div></div><!-- fragment --><p> We create a plane by supplying a vector that is normal to our plane and its distance from the origin. So we have created a plane that is perpendicular to the y-axis and zero units from the origin. Here's a picture:</p>
<div class="image">
<img src="bt2_plane_normal.png" alt="bt2_plane_normal.png"/>
</div>
<p>There are other overloads of the Plane constructor that let us pass a second vector instead of a distance from the origin. This allows us to build any plane in 3D space we want.</p>
<p>Now we'll ask the MeshManager to create us a mesh using our Plane blueprint. The MeshManager is already keeping track of the resources we loaded when initializing our application. On top of this, it can create new meshes for us.</p>
<div class="fragment"><div class="line">    MeshManager::getSingleton().createPlane(</div><div class="line">            <span class="stringliteral">&quot;ground&quot;</span>,</div><div class="line">            ResourceGroupManager::DEFAULT_RESOURCE_GROUP_NAME,</div><div class="line">            plane,</div><div class="line">            1500, 1500, 20, 20,</div><div class="line">            <span class="keyword">true</span>,</div><div class="line">            1, 5, 5,</div><div class="line">            Vector3::UNIT_Z);</div></div><!-- fragment --><p>This is a complicated method, and we're not entirely equipped to understand all of it yet. You can read through the <a class="el" href="class_ogre_1_1_mesh_manager.html" title="Handles the management of mesh resources. ">Ogre::MeshManager</a> class specification if you want to learn more now. Basically, we've created a new mesh called "ground" with a size of 1500x1500.</p>
<p>Now we will create a new Entity using this mesh. </p><div class="fragment"><div class="line">    Entity* groundEntity = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#afb393cca49de8b928f7dd60838047185">createEntity</a>(<span class="stringliteral">&quot;ground&quot;</span>);</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(groundEntity);</div></div><!-- fragment --><p> Be careful that you don't confuse the parameter given to createEntity for the Entity's name. It is actually the name of the mesh we just created. We're used to seeing mesh names end with '.mesh'.</p>
<p>We want to tell our SceneManager not to cast shadows from our ground Entity. It would just be a waste. Don't get confused, this means the ground won't cast a shadow, it doesn't mean we can't cast shadows on to the <em>ground</em>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setCastShadows(<span class="keyword">false</span>);</div></div><!-- fragment --><p> And finally we need to give our ground a material. For now, it will be easiest to use a material from the script that <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> includes with its samples. You should have these resources in your SDK or the source directory you downloaded to build <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. </p><div class="fragment"><div class="line">    groundEntity-&gt;setMaterialName(<span class="stringliteral">&quot;Examples/Rockwall&quot;</span>);</div></div><!-- fragment --><p> Make sure you add the texture for the material and the Examples.material script to your resource loading path. In our case, the texture is called 'rockwall.tga'. You can find the name yourself by reading the entry in the material script.</p>
<h1><a class="anchor" id="bt2UsingShadowsinOgre"></a>
Using Shadows in Ogre</h1>
<p>Enabling shadows in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> is easy. The SceneManager class has a <a class="el" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0" title="Sets the general shadow technique to be used in this scene. ">Ogre::SceneManager::setShadowTechnique</a> method we can use. Then whenever we create an Entity, we call setCastShadows to choose which Entities will cast shadows. setShadowTechinique method takes several of different techniques. Refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> for more details.</p>
<p>Let's turn off the ambient light so we can see the full effect of our lights. Add the following changes:</p>
<div class="fragment"><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a7c26cdbb5703cf10a99add1f6a930ca2">setAmbientLight</a>(ColourValue(0, 0, 0));</div><div class="line">    scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ad716d3752418408f073d9be9bbfe62d0">setShadowTechnique</a>(<a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6af1b698ef34b8d97c261b7ade00010b7f">ShadowTechnique::SHADOWTYPE_STENCIL_MODULATIVE</a>);</div></div><!-- fragment --><p> Now the SceneManager will use modulative stencil shadows. Let's add some lights to see this in action.</p>
<h1><a class="anchor" id="bt2Lights"></a>
Lights</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides three types of lighting.</p><ul>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca0d59bfdcfeb338dbfe06e2e2999e752f" title="Point light sources give off light equally in all directions, so require only position not direction...">Ogre::Light::LT_POINT</a> - This Light speads out equally in all directions from a point.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca8fc40a1ccfb026944417ef92b7ddaefe" title="Spotlights simulate a cone of light from a source so require position and direction, plus extra values for falloff. ">Ogre::Light::LT_SPOTLIGHT</a> - This Light works like a flashlight. It produces a solid cylinder of light that is brighter at the center and fades off.</li>
<li><a class="el" href="class_ogre_1_1_light.html#a4f1dea084d1497c6f49e802ade940dbca4c5582d28848ce40c2b652488494b4a3" title="Directional lights simulate parallel light beams from a distant source, hence have direction but no p...">Ogre::Light::LT_DIRECTIONAL</a> - This Light simulates a huge source that is very far away - like daylight. Light hits the entire scene at the same angle everywhere.</li>
</ul>
<p>The <a class="el" href="class_ogre_1_1_light.html" title="Representation of a dynamic light source in the scene. ">Ogre::Light</a> class has a wide range of properties. Two of the most important are the <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Diffuse+%28Light%29">diffuse</a> and <a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=-Specular+%28Light%29">specular</a> color. Each material script defines how much specular and diffuse lighting a material reflects. These properties will be covered in some of the later tutorials.</p>
<h1><a class="anchor" id="CreatingaLight"></a>
Creating a Light</h1>
<p>Let's add a Light to our scene. We do this by calling the <a class="el" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c" title="Creates a light for use in the scene. ">Ogre::SceneManager::createLight</a> method. Add the following code right after we finish creating the groundEntity: </p><div class="fragment"><div class="line">    Light* spotLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;SpotLight&quot;</span>);</div></div><!-- fragment --><p> We'll set the diffuse and specular colors to pure blue. </p><div class="fragment"><div class="line">    spotLight-&gt;setDiffuseColour(0, 0, 1.0);</div><div class="line">    spotLight-&gt;setSpecularColour(0, 0, 1.0);</div></div><!-- fragment --><p> Next we will set the type of the light to spotlight.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setType(Light::LT_SPOTLIGHT);</div></div><!-- fragment --><p> The spotlight requires both a position and a direction - remember it acts like a flashlight. We'll place the spotlight above the right shoulder of the ninja shining down on him at a 45 degree angle.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* spotLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    spotLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(spotLight);</div><div class="line">    spotLightNode-&gt;setDirection(-1, -1, 0);</div><div class="line">    spotLightNode-&gt;setPosition(Vector3(200, 200, 0));</div></div><!-- fragment --> <dl class="section note"><dt>Note</dt><dd>You must be wondering why we call setDirection for light source and then call the same method for related SceneNode. As long as setDirection is deprecated for Light it has to be attached to SceneNode. Since SceneNode default rotation is NEGATIVE_UNIT_Z we need to set same value for Light. Direction for light by default is not NEGATIVE_UNIT_Z but in the future releases it will be replaced with this value. So this extra call of setDirection for Light could be deleted in future. In other words we need this extra move for future compatibilty.</dd></dl>
<div class="image">
<img src="bt2_light_dir_1.png" alt="bt2_light_dir_1.png"/>
</div>
<p>Finally, we set what is called the spotlight range. These are the angles that determine where the light fades from bright in the middle to dimmer on the outside edges.</p>
<div class="fragment"><div class="line">    spotLight-&gt;setSpotlightRange(Degree(35), Degree(50));</div></div><!-- fragment --><p>Compile and run the application. You should see the shadowy blue figure of a ninja.</p>
<div class="image">
<img src="bt2_ninja1.jpg" alt="bt2_ninja1.jpg"/>
</div>
<h1><a class="anchor" id="CreatingMoreLights"></a>
Creating More Lights</h1>
<p>Next we'll add a directional light to our scene. This type of light essentially simulates daylight or moonlight. The light is cast at the same angle across the entire scene equally. As before, we'll start by creating the Light and setting its type.</p>
<div class="fragment"><div class="line">    Light* directionalLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;DirectionalLight&quot;</span>);</div><div class="line">    directionalLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_DIRECTIONAL);</div></div><!-- fragment --><p> Now we'll set the diffuse and specular colors to a dark red. </p><div class="fragment"><div class="line">    directionalLight-&gt;setDiffuseColour(ColourValue(0.4, 0, 0));</div><div class="line">    directionalLight-&gt;setSpecularColour(ColourValue(0.4, 0, 0));</div></div><!-- fragment --><p> Finally, we need to set the Light's direction. A directional light does not have a position because it is modeled as a point light that is infinitely far away.</p>
<div class="fragment"><div class="line">    directionalLight-&gt;setDirection(Vector3::NEGATIVE_UNIT_Z);</div><div class="line"></div><div class="line">    SceneNode* directionalLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    directionalLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(directionalLight);</div><div class="line">    directionalLightNode-&gt;setDirection(Vector3(0, -1, 1));</div></div><!-- fragment --> <div class="image">
<img src="bt2_light_dir_2.png" alt="bt2_light_dir_2.png"/>
</div>
<p>The Light class also defines a <a class="el" href="class_ogre_1_1_light.html#a2880f26669477a55cf01919f906bb65d" title="Sets the attenuation parameters of the light source i.e. ">Ogre::Light::setAttenuation</a> function which allows you to control how the light dissipates as you get farther away from it. After you finish this tutorial, try using this method in your scene to see how it affects your lights.</p>
<p>Compile and run the application. Your ninja should now have a shadow cast behind him, and the scene should be filled with red light.</p>
<div class="image">
<img src="bt2_ninja2.jpg" alt="bt2_ninja2.jpg"/>
</div>
<p>To complete the set, we will now add a point light to our scene. </p><div class="fragment"><div class="line">    Light* pointLight = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#ab127d52207729591dd51cb12a5b2ed2c">createLight</a>(<span class="stringliteral">&quot;PointLight&quot;</span>);</div><div class="line">    pointLight-&gt;<a class="code" href="class_ogre_1_1_light.html#a6019f7fa89624e35316ba444e519d8f8">setType</a>(Light::LT_POINT);</div></div><!-- fragment --><p> We'll set the the specular and diffuse colors to a dark gray.</p>
<div class="fragment"><div class="line">    pointLight-&gt;setDiffuseColour(0.3, 0.3, 0.3);</div><div class="line">    pointLight-&gt;setSpecularColour(0.3, 0.3, 0.3);</div></div><!-- fragment --><p> A point light has no direction. It only has a position. We will place our last light above and behind the ninja.</p>
<div class="fragment"><div class="line">    SceneNode* pointLightNode = scnMgr-&gt;<a class="code" href="class_ogre_1_1_scene_manager.html#a854ef69f989aadd1da0bd79a61f88f9e">getRootSceneNode</a>()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>();</div><div class="line">    pointLightNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(pointLight);</div><div class="line">    pointLightNode-&gt;setPosition(Vector3(0, 150, 250));</div></div><!-- fragment --><p> Compile and run the application. You should see a long shadow cast in front of the ninja now. And you should see the effects of the point light brightening up the area behind the ninja. Try to think about why the colors turn out the way they do. For instance, why does the shadow behind the ninja appear to have no red at all?</p>
<div class="image">
<img src="bt2_ninja3.jpg" alt="bt2_ninja3.jpg"/>
</div>
<h1><a class="anchor" id="ShadowTypes"></a>
Shadow Types</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> supports set of different shadow types. Please refer to <a class="el" href="group___general.html#ga79dcd426d291c31072c1ad6f183715d6" title="An enumeration of broad shadow techniques. ">Ogre::ShadowTechnique</a> enumerator for more details.</p>
<p>Try experimenting with the different shadow types. There are also other shadow-related methods in the <a class="el" href="class_ogre_1_1_scene_manager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e. ">Ogre::SceneManager</a> class that you can play with.</p>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> does not provide soft shadows as part of the engine. You can write your own vertex and fragment programs to implement soft shadows and many other things. The <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual has a full description of <a class="el" href="_shadows.html">Shadows</a>.</p>
<h1><a class="anchor" id="Conclusion2"></a>
Conclusion</h1>
<p>This tutorial introduced the use of lights and shadows into the scene. To begin, we covered how to use the MeshManager to generate meshes from scratch. We then chose which shadow type <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> should use. Finally, we begin adding an example of each type of Light to our scene. We created a spotlight, a directional light, and a point light. You can even extend <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s lighting and shadow systems by writing your own vertex and fragment programs. Refer to the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> Manual for more details.</p>
<p>There are a lot of different settings we've covered that allow you to customize how <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> renders light and shadow. After you've finished each tutorial, it is a good idea to play around with the new tools you have. This will greatly increase your comfort level working with the library, and it is an excellent way to learn how to navigate API documentation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: RTSS: Run Time Shader System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rtss.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">RTSS: Run Time Shader System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#core-feats">Core features of the system</a></li>
<li class="level1"><a href="#rtss_overview">System overview</a><ul><li class="level2"><a href="#rtss_custom_api">Customising via API</a></li>
<li class="level2"><a href="#rtss_custom_mat">Customizing via Material Script</a></li>
</ul>
</li>
<li class="level1"><a href="#rtss_indepth">The RTSS in Depth</a><ul><li class="level2"><a href="#rtss__components">Main components</a></li>
<li class="level2"><a href="#creating-extensions">Creating custom shader extensions</a></li>
<li class="level2"><a href="#debugging">Tips for debugging shaders</a></li>
</ul>
</li>
<li class="level1"><a href="#history">Historical background</a></li>
<li class="level1"><a href="#pros-cons">Pros and Cons</a></li>
</ul>
</div>
<div class="textblock"><p>This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.</p>
<h1><a class="anchor" id="core-feats"></a>
Core features of the system</h1>
<ul>
<li>Runtime shader generation synchronized with scene state. Each time scene settings change, a new set of shaders is generated.</li>
<li>Full Fixed Function Pipeline (FFP) emulation. This feature is most useful combined with render system that doesn't provide any FFP functionality (OpenGL ES 2.0, D3D11 etc).</li>
<li>Shader language independent interface: the logic representation of the shader programs is completely independent from the target shader language. You can generate code for different shader languages from the same program.</li>
<li>Pluggable interface allows extending the target shader languages set.</li>
<li>Pluggable interface allows adding new shader based effects to the system in a seamless way. Each effect code will be automatically combined with the rest of the shader code.</li>
<li>Smart program management: each shader program is created only once and may be used by multiple passes.</li>
<li>Automatic vertex shader compacting mechanism: no more compacting variables by hand. In case the amount of used vertex shader output registers exceeds the maximum allowed (12 to 32, depending on <a href="http://msdn.microsoft.com/en-us/library/bb172918%28v=VS.85%29.aspx">D3DPSHADERCAPS2_0.NumTemps</a>), a compacting algorithm packs the vertex shader outputs and adds unpack code in the fragment shader side.</li>
<li>Material script support, for both export and import.</li>
</ul>
<h1><a class="anchor" id="rtss_overview"></a>
System overview</h1>
<p>The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.</p>
<p>Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.</p>
<p>To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.</p>
<p>After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.</p>
<p>Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates</p>
<div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">uniform mat4    worldviewproj_matrix;</div><div class="line">uniform mat4    texture_matrix1;</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">in  vec4    vertex;</div><div class="line">in  vec4    uv0;</div><div class="line">out vec4    oTexcoord4_0;</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    FFP_Transform(worldviewproj_matrix, vertex, gl_Position);</div><div class="line">    FFP_TransformTexCoord(texture_matrix1, uv0.xy, oTexcoord4_0.xy);</div><div class="line">}</div></div><!-- fragment --><p>It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)</p>
<p>Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.</p>
<p>The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.</p>
<h2><a class="anchor" id="rtss_custom_api"></a>
Customising via API</h2>
<p>The first option is to globally enforce per-pixel lighting, you can do the following</p>
<div class="fragment"><div class="line">        <span class="comment">// Grab the scheme render state.</span></div><div class="line">        <a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">Ogre::RTShader::RenderState</a>* schemRenderState =</div><div class="line">            mShaderGenerator-&gt;getRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line">        <span class="comment">// Add per pixel lighting sub render state to the global scheme render state.</span></div><div class="line">        <span class="comment">// It will override the default FFP lighting sub render state.</span></div><div class="line">        <span class="keywordflow">if</span> (usePerPixelLighting) {</div><div class="line">            <a class="code" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">Ogre::RTShader::SubRenderState</a>* perPixelLightModel =</div><div class="line">                mShaderGenerator-&gt;createSubRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_per_pixel_lighting.html#ae766f76cad4b3a4339a0cd50abbddcc2">Ogre::RTShader::PerPixelLighting::Type</a>);</div><div class="line"></div><div class="line">            schemRenderState-&gt;<a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html#af66edaf33c654e03ef89f1eaec384a1f">addTemplateSubRenderState</a>(perPixelLightModel);</div><div class="line">        }</div></div><!-- fragment --><p> any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.</p>
<h2><a class="anchor" id="rtss_custom_mat"></a>
Customizing via Material Script</h2>
<p>Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following</p>
<div class="fragment"><div class="line">            <span class="comment">// RT Shader system section.</span></div><div class="line">            rtshader_system</div><div class="line">            {       </div><div class="line">                <span class="comment">// Override lighting stage with per pixel lighting.             </span></div><div class="line">                lighting_stage per_pixel                </div><div class="line">            }   </div></div><!-- fragment --><p> for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.</p>
<p>Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:</p>
<ul>
<li><a href="#lighting_stage">lighting_stage</a></li>
<li><a href="#light_count">light_count</a></li>
<li><a href="#triplanarTexturing">triplanarTexturing</a></li>
<li><a href="#integrated_pssm4">integrated_pssm4</a></li>
<li><a href="#layered_blend">layered_blend</a></li>
<li><a href="#source_modifier">source_modifier</a></li>
</ul>
<p><a class="anchor" id="lighting_stage"></a></p>
<h3>lighting_stage</h3>
<p>Force a specific lighting model.</p>
<p>Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code></p>
<p>Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code></p>
<p>Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_r_t_shader_1_1_normal_map_lighting.html#adc6b4bdd1ea31c2232336599d2b30b60" title="Normal map space definition. ">Ogre::RTShader::NormalMapLighting::NormalMapSpace</a> </dd>
<dd>
<a class="el" href="group___general.html#ga21a0186392e9c9ce16d29c5568a773c5" title="High-level filtering options providing shortcuts to settings the minification, magnification and mip ...">Ogre::TextureFilterOptions</a></dd></dl>
<p><a class="anchor" id="light_count"></a></p>
<h3>light_count</h3>
<p>Override dynamic light count. Allows to customize which lights the RTSS will consider.</p>
<p>Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code></p>
<p><a class="anchor" id="triplanarTexturing"></a></p>
<h3>triplanarTexturing</h3>
<p>Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a></p>
<p>Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code></p>
<p>Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureScale</td><td>texture coordinates are multiplied by this. </td></tr>
    <tr><td class="paramname">plateauSize</td><td>plateau on which small components of the normal have no influence. </td></tr>
    <tr><td class="paramname">transitionSpeed</td><td>transitions speed between the three textures Valid values are [0; 0.57] not bigger to avoid division by zero </td></tr>
    <tr><td class="paramname">textureFromX</td><td>Texture for the x-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromY</td><td>Texture for the y-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromZ</td><td>Texture for the z-direction planar mapping</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="integrated_pssm4"></a></p>
<h3>integrated_pssm4</h3>
<p>Integrated PSSM shadow receiver with 3 splits. Custom split points.</p>
<p>Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code></p>
<p><a class="anchor" id="layered_blend"></a></p>
<h3>layered_blend</h3>
<p>Apply photoshop-like blend effects to texture layers</p>
<p>Format: <code>layered_blend &lt;effect&gt;</code></p>
<p>Example: layered_blend luminosity</p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">effect</td><td>one of <code>default, normal, lighten, darken, multiply, average, add, subtract, difference, negation, exclusion, screen, overlay, hard_light, soft_light, color_dodge, color_burn, linear_dodge, linear_burn, linear_light, vivid_light, pin_light, hard_mix, reflect, glow, phoenix, saturation, color, luminosity</code></td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="source_modifier"></a></p>
<h3>source_modifier</h3>
<p>Apply custom modulate effect to texture layer</p>
<p>Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code></p>
<p>Example: <code>source_modifier src1_inverse_modulate custom 2</code></p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>one of <code>src1_modulate, src2_modulate, src1_inverse_modulate, src2_inverse_modulate</code> </td></tr>
    <tr><td class="paramname">parameterNum</td><td>number of the custom shader parameter that controls the operation</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="rtss_indepth"></a>
The RTSS in Depth</h1>
<p>When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.</p>
<p>The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).</p>
<p>Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.</p>
<p>The following steps are executed in order to generate shaders for a given technique:</p>
<ul>
<li>For each pass in the technique the system builds a set of sub render states that describe the logic process of the rendering pipeline from the draw call submission until the final pixel color.</li>
<li>Each render state is translated into a set of logic shader programs (currently only pixel and vertex shader). The logic programs are then sent to specific shader language writers that produce source code for the respective shader language. The source code is used to create the GPU programs that are applied to the destination pass. Before rendering of an object that uses generated shaders the system allows each sub render state to update the GPU constants associated with it.</li>
</ul>
<h2>Initializing the system</h2>
<dl class="section note"><dt>Note</dt><dd>If you are using the <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>, the following steps will be taken automatically for you.</dd></dl>
<p>Initializing the system is composed of the following steps:</p><ul>
<li>Create the internal managers and structures via the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260" title="Initialize the Shader Generator System. ">Ogre::RTShader::ShaderGenerator::initialize()</a></code> method.</li>
<li>Set the target cache path. This is the place on your disk where the output shaders will be written to or will be read from in case they were generated by previous runs of your application.</li>
<li>Verify that the location of the shader libs needed by the system is added to the ResourceGroupManager via the <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d" title="Adds a location to the list of searchable locations for a Resource type. ">Ogre::ResourceGroupManager::addResourceLocation()</a></code> method.</li>
<li>Assign the target scene manager to the shader generator.</li>
<li>Add one or more specialized sub-render states that are to be shared among all materials (per pixel lighting, textured fog, etc...).</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260">Ogre::RTShader::ShaderGenerator::initialize</a>())</div><div class="line">{</div><div class="line">    <span class="comment">// Grab the shader generator pointer.</span></div><div class="line">    mShaderGenerator = <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">Ogre::RTShader::ShaderGenerator::getSingletonPtr</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Add the shader libs resource location. a sample shader lib can be found in Samples\Media\RTShaderLib</span></div><div class="line">    <a class="code" href="class_ogre_1_1_resource_group_manager.html#a45101333f0f9ff132fc381dd5c4a1d60">Ogre::ResourceGroupManager::getSingleton</a>().<a class="code" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d">addResourceLocation</a>(shaderLibPath, <span class="stringliteral">&quot;FileSystem&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Set shader cache path.</span></div><div class="line">    mShaderGenerator-&gt;setShaderCachePath(shaderCachePath);      </div><div class="line"></div><div class="line">    <span class="comment">// Set the scene manager.</span></div><div class="line">    mShaderGenerator-&gt;addSceneManager(sceneMgr);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><h2>Creating shader based technique</h2>
<p>This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.</p>
<p>To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.</p>
<p>Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// Create shader based technique from the default technique of the given material.</span></div><div class="line">mShaderGenerator-&gt;createShaderBasedTechnique(<span class="stringliteral">&quot;Examples/BeachStones&quot;</span>, <a class="code" href="class_ogre_1_1_material_manager.html#a290b828b5d44637ee4d247a09ea81bd6">Ogre::MaterialManager::DEFAULT_SCHEME_NAME</a>, <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line"><span class="comment">// Apply the shader generated based techniques.</span></div><div class="line">mViewport-&gt;setMaterialScheme(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div></div><!-- fragment --> <div class="image">
<object type="image/svg+xml" data="CreateShaderBasedTech.svg">CreateShaderBasedTech.svg</object>
</div>
<h2>Runtime shader generation</h2>
<p>During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.</p>
<div class="image">
<object type="image/svg+xml" data="RuntimeShaderGeneration.svg">RuntimeShaderGeneration.svg</object>
</div>
<h2><a class="anchor" id="rtss__components"></a>
Main components</h2>
<p>The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.</p>
<h3>ShaderGenerator</h3>
<p>The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.</p>
<h3>RenderState classes</h3>
<p>A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.</p>
<p>RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.</p>
<h3>SubRenderState classes</h3>
<p>Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.</p>
<p>There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_transform.html" title="Transform sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTransform</a> - responsible for adding code to the vertex shader which computes the position of the vertex in projection space</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_colour.html" title="Colour sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPColour</a> - responsible for adding code to the shaders that calculate the base diffuse and specular color of the object regardless of lights or textures. The color is calculated based on the ambient, diffuse, specular and emissive properties of the object and scene, color tracking and the specified hardware buffer color.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_lighting.html" title="Lighting sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPLighting</a> - responsible for adding code to the shaders that calculate the luminescence added to the object by light. Then add that value to the color calculated by the color SRS stage.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_texturing.html" title="Texturing sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTexturing</a> - responsible for adding code that modulates the color of the pixels based on textures assigned to the material.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_fog.html" title="Fog sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPFog</a> - responsible for adding code that modulates the color of a pixel based on the scene or object fog parameters.</li>
</ul>
<p>There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...</p>
<h3>SubRenderStateFactory</h3>
<p>As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.</p>
<p>These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.</p>
<h2><a class="anchor" id="creating-extensions"></a>
Creating custom shader extensions</h2>
<p>Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.</p>
<p>In order to extend the system with your own shader effects you'll have to follow these steps:</p><ul>
<li>Implement the SubRenderState interface - This is the main class that is responsible for the actual effect processing such as preparing the destination pass, updating the CPU shader programs, updating the GPU shader parameters etc.</li>
<li>Implement the SubRenderStateFactory interface: This class will allow the RTSS to create instances of the previous class via code or script as well as export it to material script file.</li>
<li>Register the factory to the RTSS using the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac266946244d79b2d4732607ae9479bd9" title="Add sub render state factory. ">Ogre::RTShader::ShaderGenerator::addSubRenderStateFactory</a> method.</li>
<li>Add shader files that will supply all the actual shader functions your SubRenderState needs. In order to support multiple shader languages you should supply code for your entire desired target shading languages (CG, HLSL, GLSL etc). These files should be placed in a way that the resource manager could access them. This can be done by placing them in a valid resource location or by dynamically adding resource location.</li>
</ul>
<p>Implementing the SubRenderState requires overriding the pure methods of the base class.</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#ae91b7b8f76848d67652b6e5832a27a49" title="Get the type of this sub render state. ">Ogre::RTShader::SubRenderState::getType()</a> should return unique string that identify the sub class implementation. That value is shared among all instances and can be stored in a static string variable. It uses to system to match between SubRenderState instance and the factory to should destroy it.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#acb48c34ee231f0220f68c967fb32f1e5" title="Get the execution order of this sub render state. ">Ogre::RTShader::SubRenderState::getExecutionOrder()</a> should return integer value that will use the system to sort all SubRenderState instances of the same render state before each one of them will create its part in the CPU shader programs. Note that:<ul>
<li>The execution order does not imply the order of the parameter definitions and function calls within the generated shader.</li>
<li>If an execution number is set to be the same as one of the basic fixed pipeline SRSs. Than that SRS will be built <b>instead</b> of the fixed pipeline SRS.</li>
</ul>
</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a5dfe9f03413e0fe99ea2640f06c1f13c" title="Copy details from a given sub render state to this one. ">Ogre::RTShader::SubRenderState::copyFrom()</a> a simple copy method that uses the system when coping one instance to another. <b>Note:</b> Only configuration data attributes should be copy here.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4b43c261946926ebbc6456deccc6697a" title="Create sub programs that represents this sub render state as part of a program set. ">Ogre::RTShader::SubRenderState::createCpuSubPrograms</a> - This is the heart of this interface. This method should update the CPU shader programs with the specific details of the overriding class.</li>
</ul>
<p>The SubRenderState supply default implementation for this method which break down this method into three stages:</p><ul>
<li>Resolving parameters: this stage should grab all the needed parameters for this SubRrenderState. In case of the FFPTransform it should resolve the world view projection matrix and vertex shader input and output position parameters.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Function* vsEntry = vsProgram-&gt;getEntryPointFunction();</div><div class="line">    </div><div class="line">    <span class="comment">// Resolve World View Projection Matrix.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#ae0e6b89f6ed3986b0a87e2472e3ff7f1">UniformParameterPtr</a> wvpMatrix = vsProgram-&gt;resolveAutoParameterInt(GpuProgramParameters::ACT_WORLDVIEWPROJ_MATRIX, 0);</div><div class="line">        </div><div class="line">    <span class="comment">// Resolve input position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionIn = vsEntry-&gt;resolveInputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_OBJECT_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>); </div><div class="line">    </div><div class="line">    <span class="comment">// Resolve output position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionOut = vsEntry-&gt;resolveOutputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_PROJECTIVE_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!wvpMatrix || !positionIn || !positionOut)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___general.html#gaf27f0d64dfeb225d37a513c253eaa1a0">OGRE_EXCEPT</a>( Exception::ERR_INTERNAL_ERROR, </div><div class="line">                <span class="stringliteral">&quot;Not all parameters could be constructed for the sub-render state.&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;FFPTransform::createCpuSubPrograms&quot;</span> );</div><div class="line">    }</div></div><!-- fragment --><ul>
<li>Resolving dependencies: this stage should provide the name of the external shader library files that contains the actual shader code needed by this SubRenderState. In case of the FFPTexturing it will add the common and texturing library for both vertex and pixel shader program.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Program* psProgram = programSet-&gt;getCpuFragmentProgram();</div><div class="line"></div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);    </div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);</div></div><!-- fragment --><ul>
<li>Adding function invocations: this stage creates the function calls within this SubRenderState requires. Each function call has two keys that are used by the system to sort it before generating the actual shader code as well as set of in/out parameters. A function invocation is added to either vertex shader program or fragment shader program. In case of the FFPFog it will add vertex depth calculation to the vertex shader program.</li>
</ul>
<div class="fragment"><div class="line">        curFuncInvocation = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> FunctionInvocation(<a class="code" href="group___r_t_shader.html#gabaab1e89270cd7f763f2f8e0258c400e">FFP_FUNC_PIXELFOG_DEPTH</a>, <a class="code" href="group___r_t_shader.html#gga7d20b2397c3eab2b52ec405863c6f274a8b4930a3fd90d5b7222960fc5727b8cf">FFP_VS_FOG</a>);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mWorldViewProjMatrix, Operand::OPS_IN);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSInPos, Operand::OPS_IN);  </div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSOutDepth, Operand::OPS_OUT);  </div><div class="line">        vsMain-&gt;addAtomInstance(curFuncInvocation);     </div></div><!-- fragment --><p> Note:</p><ul>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can add as many function invocations as it needs.</li>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can different function invocations in different ordering.</li>
<li>The ordering of the function invocation is crucial. Use the FFPVertexShaderStage and FFPFragmentShaderStage enumarations to place your invocations in the desired order.</li>
<li>Make sure the parameter semantic (in/out) in the SubRenderState code matches to your shader code implementation you supplied in the library file. GLSL will fail to link to libray functions if it won't be able to find a perfect function declaration match.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4c2acbc15e44c3fe42868abce1116ec2" title="Update GPU programs parameters before a rendering operation occurs. ">Ogre::RTShader::SubRenderState::updateGpuProgramsParams</a> - As the name suggest this method should be overridden only in case your SubRenderState should update some parameter it created before.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#afd08043cfad43a1ae470c3c1be341ba1" title="Called before adding this sub render state to the given render state. ">Ogre::RTShader::SubRenderState::preAddToRenderState()</a>: this method called before adding this SubRenderState to a parent RenderState instances. It allows this SubRenderState to exclude itself from the list in case the source pass is not matching. I.E in case of SubRenderState that perform lighting calculations it can return false when the given source pass specifies that lighting calculations disabled for it.</li>
</ul>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (!srcPass-&gt;getLightingEnabled())</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div></div><!-- fragment --><p> This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.</p>
<p>Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods</p><ul>
<li>Ogre::RTShader::SubRenderStateFactory::createInstanceImpl(): This method should return instance for the SubRenderState sub class.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#a954d30cb82307ae1ba785792b833b689" title="Create an instance of the SubRenderState sub class it suppose to create. ">Ogre::RTShader::SubRenderStateFactory::createInstance()</a>: This method should return instasnce for the SubRenderState sub class using the given script compiler parameters. Implemet this method if you want to be able to creat your custom shader extension from material script.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#ada31909080bae96784504be42d9bd77c" title="Write the given sub-render state instance using the material serializer. ">Ogre::RTShader::SubRenderStateFactory::writeInstance()</a>: This method should write down the parameters of a given SubRenderState instance to material script file. Implement this method if you want to be able to export a material that contains your custom shader extension.</li>
</ul>
<h2><a class="anchor" id="debugging"></a>
Tips for debugging shaders</h2>
<p>A couple of notes on debugging shaders coming from the RTSS:</p><ul>
<li>Call <a class="el" href="class_ogre_bites_1_1_application_context.html#aaad4c1d25a7a5f60dd5c5f3812f1096b" title="make the RTSS write out the generated shaders for caching and debugging ">OgreBites::ApplicationContext::setRTSSWriteShadersToDisk</a>. This will cache the generated shaders onto the disk under the directory <code>{<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> directory}\Samples\Media\RTShaderLib\cache</code>. This is important for 2 reasons:<ul>
<li>It will make compilation problems easier to detect.</li>
<li>Once a shader is written to the disk, as long as you don't change the code behind it, the same shader will be picked up in the next application run even if its content has changed. If you have compilation or visual problems with the shader you can try to manually tinker with it without compiling the code again and again.</li>
</ul>
</li>
<li>Find the file OgreShaderProgramManager.cpp and add a breakpoint at <code>pGpuProgram.setNull();</code> (in createGpuProgram). If a shader will fail to compile it will usually fail there. Once that happens you can find the shader name under the <code>programName</code> parameter, then look for it in the cache directory you created.</li>
<li>Other common problems with creating shaders in RTSS usually occur from defining vertex shader parameters and using them in the pixel shader and vice versa. so watch out for those.</li>
</ul>
<h1><a class="anchor" id="history"></a>
Historical background</h1>
<p>When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).</p>
<p>As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.</p>
<p>Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.</p>
<p>The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.</p>
<p>With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.</p>
<h1><a class="anchor" id="pros-cons"></a>
Pros and Cons</h1>
<p>Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders</p><ul>
<li>Hardware animation (a.k.a hardware skinning)</li>
<li>Soft shadows</li>
<li>Normal/Bump maps</li>
<li>Specular maps</li>
<li>Advanced multi-texturing effects</li>
</ul>
<p>Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.</p>
<p>So why use a runtime shader system anyway?</p>
<ul>
<li>Save development time e.g. when your target scene has dynamic lights and the number changes, fog changes, ... and the number of material attributes increases the total count of needed shaders dramatically. It can easily cross 100 and it becomes a time consuming development task.</li>
<li>Reusable code - once you've written the shader extension you can use it anywhere due to its independent nature.</li>
<li>Custom shaders extension library - enjoy the shared library of effects created by the community. Unlike hand written shader code, which may require many adjustments to be plugged into your own shader code, using the extensions library requires minimum changes. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: RTSS: Run Time Shader System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rtss.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">RTSS: Run Time Shader System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#core-feats">Core features of the system</a></li>
<li class="level1"><a href="#rtss_overview">System overview</a><ul><li class="level2"><a href="#rtss_custom_api">Customising via API</a></li>
<li class="level2"><a href="#rtss_custom_mat">Customizing via Material Script</a></li>
</ul>
</li>
<li class="level1"><a href="#rtss_indepth">The RTSS in Depth</a><ul><li class="level2"><a href="#rtss__components">Main components</a></li>
<li class="level2"><a href="#creating-extensions">Creating custom shader extensions</a></li>
<li class="level2"><a href="#debugging">Tips for debugging shaders</a></li>
</ul>
</li>
<li class="level1"><a href="#history">Historical background</a></li>
<li class="level1"><a href="#pros-cons">Pros and Cons</a></li>
</ul>
</div>
<div class="textblock"><p>This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.</p>
<h1><a class="anchor" id="core-feats"></a>
Core features of the system</h1>
<ul>
<li>Runtime shader generation synchronized with scene state. Each time scene settings change, a new set of shaders is generated.</li>
<li>Full Fixed Function Pipeline (FFP) emulation. This feature is most useful combined with render system that doesn't provide any FFP functionality (OpenGL ES 2.0, D3D11 etc).</li>
<li>Shader language independent interface: the logic representation of the shader programs is completely independent from the target shader language. You can generate code for different shader languages from the same program.</li>
<li>Pluggable interface allows extending the target shader languages set.</li>
<li>Pluggable interface allows adding new shader based effects to the system in a seamless way. Each effect code will be automatically combined with the rest of the shader code.</li>
<li>Smart program management: each shader program is created only once and may be used by multiple passes.</li>
<li>Automatic vertex shader compacting mechanism: no more compacting variables by hand. In case the amount of used vertex shader output registers exceeds the maximum allowed (12 to 32, depending on <a href="http://msdn.microsoft.com/en-us/library/bb172918%28v=VS.85%29.aspx">D3DPSHADERCAPS2_0.NumTemps</a>), a compacting algorithm packs the vertex shader outputs and adds unpack code in the fragment shader side.</li>
<li>Material script support, for both export and import.</li>
</ul>
<h1><a class="anchor" id="rtss_overview"></a>
System overview</h1>
<p>The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.</p>
<p>Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.</p>
<p>To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.</p>
<p>After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.</p>
<p>Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates</p>
<div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">uniform mat4    worldviewproj_matrix;</div><div class="line">uniform mat4    texture_matrix1;</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">in  vec4    vertex;</div><div class="line">in  vec4    uv0;</div><div class="line">out vec4    oTexcoord4_0;</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    FFP_Transform(worldviewproj_matrix, vertex, gl_Position);</div><div class="line">    FFP_TransformTexCoord(texture_matrix1, uv0.xy, oTexcoord4_0.xy);</div><div class="line">}</div></div><!-- fragment --><p>It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)</p>
<p>Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.</p>
<p>The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.</p>
<h2><a class="anchor" id="rtss_custom_api"></a>
Customising via API</h2>
<p>The first option is to globally enforce per-pixel lighting, you can do the following</p>
<div class="fragment"><div class="line">        <span class="comment">// Grab the scheme render state.</span></div><div class="line">        <a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">Ogre::RTShader::RenderState</a>* schemRenderState =</div><div class="line">            mShaderGenerator-&gt;getRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line">        <span class="comment">// Add per pixel lighting sub render state to the global scheme render state.</span></div><div class="line">        <span class="comment">// It will override the default FFP lighting sub render state.</span></div><div class="line">        <span class="keywordflow">if</span> (usePerPixelLighting) {</div><div class="line">            <a class="code" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">Ogre::RTShader::SubRenderState</a>* perPixelLightModel =</div><div class="line">                mShaderGenerator-&gt;createSubRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_per_pixel_lighting.html#ae766f76cad4b3a4339a0cd50abbddcc2">Ogre::RTShader::PerPixelLighting::Type</a>);</div><div class="line"></div><div class="line">            schemRenderState-&gt;<a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html#af66edaf33c654e03ef89f1eaec384a1f">addTemplateSubRenderState</a>(perPixelLightModel);</div><div class="line">        }</div></div><!-- fragment --><p> any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.</p>
<h2><a class="anchor" id="rtss_custom_mat"></a>
Customizing via Material Script</h2>
<p>Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following</p>
<div class="fragment"><div class="line">            <span class="comment">// RT Shader system section.</span></div><div class="line">            rtshader_system</div><div class="line">            {       </div><div class="line">                <span class="comment">// Override lighting stage with per pixel lighting.             </span></div><div class="line">                lighting_stage per_pixel                </div><div class="line">            }   </div></div><!-- fragment --><p> for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.</p>
<p>Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:</p>
<ul>
<li><a href="#lighting_stage">lighting_stage</a></li>
<li><a href="#light_count">light_count</a></li>
<li><a href="#triplanarTexturing">triplanarTexturing</a></li>
<li><a href="#integrated_pssm4">integrated_pssm4</a></li>
<li><a href="#layered_blend">layered_blend</a></li>
<li><a href="#source_modifier">source_modifier</a></li>
</ul>
<p><a class="anchor" id="lighting_stage"></a></p>
<h3>lighting_stage</h3>
<p>Force a specific lighting model.</p>
<p>Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code></p>
<p>Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code></p>
<p>Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_r_t_shader_1_1_normal_map_lighting.html#adc6b4bdd1ea31c2232336599d2b30b60" title="Normal map space definition. ">Ogre::RTShader::NormalMapLighting::NormalMapSpace</a> </dd>
<dd>
<a class="el" href="group___general.html#ga21a0186392e9c9ce16d29c5568a773c5" title="High-level filtering options providing shortcuts to settings the minification, magnification and mip ...">Ogre::TextureFilterOptions</a></dd></dl>
<p><a class="anchor" id="light_count"></a></p>
<h3>light_count</h3>
<p>Override dynamic light count. Allows to customize which lights the RTSS will consider.</p>
<p>Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code></p>
<p><a class="anchor" id="triplanarTexturing"></a></p>
<h3>triplanarTexturing</h3>
<p>Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a></p>
<p>Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code></p>
<p>Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureScale</td><td>texture coordinates are multiplied by this. </td></tr>
    <tr><td class="paramname">plateauSize</td><td>plateau on which small components of the normal have no influence. </td></tr>
    <tr><td class="paramname">transitionSpeed</td><td>transitions speed between the three textures Valid values are [0; 0.57] not bigger to avoid division by zero </td></tr>
    <tr><td class="paramname">textureFromX</td><td>Texture for the x-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromY</td><td>Texture for the y-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromZ</td><td>Texture for the z-direction planar mapping</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="integrated_pssm4"></a></p>
<h3>integrated_pssm4</h3>
<p>Integrated PSSM shadow receiver with 3 splits. Custom split points.</p>
<p>Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code></p>
<p><a class="anchor" id="layered_blend"></a></p>
<h3>layered_blend</h3>
<p>Apply photoshop-like blend effects to texture layers</p>
<p>Format: <code>layered_blend &lt;effect&gt;</code></p>
<p>Example: layered_blend luminosity</p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">effect</td><td>one of <code>default, normal, lighten, darken, multiply, average, add, subtract, difference, negation, exclusion, screen, overlay, hard_light, soft_light, color_dodge, color_burn, linear_dodge, linear_burn, linear_light, vivid_light, pin_light, hard_mix, reflect, glow, phoenix, saturation, color, luminosity</code></td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="source_modifier"></a></p>
<h3>source_modifier</h3>
<p>Apply custom modulate effect to texture layer</p>
<p>Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code></p>
<p>Example: <code>source_modifier src1_inverse_modulate custom 2</code></p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>one of <code>src1_modulate, src2_modulate, src1_inverse_modulate, src2_inverse_modulate</code> </td></tr>
    <tr><td class="paramname">parameterNum</td><td>number of the custom shader parameter that controls the operation</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="rtss_indepth"></a>
The RTSS in Depth</h1>
<p>When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.</p>
<p>The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).</p>
<p>Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.</p>
<p>The following steps are executed in order to generate shaders for a given technique:</p>
<ul>
<li>For each pass in the technique the system builds a set of sub render states that describe the logic process of the rendering pipeline from the draw call submission until the final pixel color.</li>
<li>Each render state is translated into a set of logic shader programs (currently only pixel and vertex shader). The logic programs are then sent to specific shader language writers that produce source code for the respective shader language. The source code is used to create the GPU programs that are applied to the destination pass. Before rendering of an object that uses generated shaders the system allows each sub render state to update the GPU constants associated with it.</li>
</ul>
<h2>Initializing the system</h2>
<dl class="section note"><dt>Note</dt><dd>If you are using the <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>, the following steps will be taken automatically for you.</dd></dl>
<p>Initializing the system is composed of the following steps:</p><ul>
<li>Create the internal managers and structures via the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260" title="Initialize the Shader Generator System. ">Ogre::RTShader::ShaderGenerator::initialize()</a></code> method.</li>
<li>Set the target cache path. This is the place on your disk where the output shaders will be written to or will be read from in case they were generated by previous runs of your application.</li>
<li>Verify that the location of the shader libs needed by the system is added to the ResourceGroupManager via the <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d" title="Adds a location to the list of searchable locations for a Resource type. ">Ogre::ResourceGroupManager::addResourceLocation()</a></code> method.</li>
<li>Assign the target scene manager to the shader generator.</li>
<li>Add one or more specialized sub-render states that are to be shared among all materials (per pixel lighting, textured fog, etc...).</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260">Ogre::RTShader::ShaderGenerator::initialize</a>())</div><div class="line">{</div><div class="line">    <span class="comment">// Grab the shader generator pointer.</span></div><div class="line">    mShaderGenerator = <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">Ogre::RTShader::ShaderGenerator::getSingletonPtr</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Add the shader libs resource location. a sample shader lib can be found in Samples\Media\RTShaderLib</span></div><div class="line">    <a class="code" href="class_ogre_1_1_resource_group_manager.html#a45101333f0f9ff132fc381dd5c4a1d60">Ogre::ResourceGroupManager::getSingleton</a>().<a class="code" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d">addResourceLocation</a>(shaderLibPath, <span class="stringliteral">&quot;FileSystem&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Set shader cache path.</span></div><div class="line">    mShaderGenerator-&gt;setShaderCachePath(shaderCachePath);      </div><div class="line"></div><div class="line">    <span class="comment">// Set the scene manager.</span></div><div class="line">    mShaderGenerator-&gt;addSceneManager(sceneMgr);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><h2>Creating shader based technique</h2>
<p>This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.</p>
<p>To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.</p>
<p>Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// Create shader based technique from the default technique of the given material.</span></div><div class="line">mShaderGenerator-&gt;createShaderBasedTechnique(<span class="stringliteral">&quot;Examples/BeachStones&quot;</span>, <a class="code" href="class_ogre_1_1_material_manager.html#a290b828b5d44637ee4d247a09ea81bd6">Ogre::MaterialManager::DEFAULT_SCHEME_NAME</a>, <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line"><span class="comment">// Apply the shader generated based techniques.</span></div><div class="line">mViewport-&gt;setMaterialScheme(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div></div><!-- fragment --> <div class="image">
<object type="image/svg+xml" data="CreateShaderBasedTech.svg">CreateShaderBasedTech.svg</object>
</div>
<h2>Runtime shader generation</h2>
<p>During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.</p>
<div class="image">
<object type="image/svg+xml" data="RuntimeShaderGeneration.svg">RuntimeShaderGeneration.svg</object>
</div>
<h2><a class="anchor" id="rtss__components"></a>
Main components</h2>
<p>The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.</p>
<h3>ShaderGenerator</h3>
<p>The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.</p>
<h3>RenderState classes</h3>
<p>A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.</p>
<p>RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.</p>
<h3>SubRenderState classes</h3>
<p>Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.</p>
<p>There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_transform.html" title="Transform sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTransform</a> - responsible for adding code to the vertex shader which computes the position of the vertex in projection space</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_colour.html" title="Colour sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPColour</a> - responsible for adding code to the shaders that calculate the base diffuse and specular color of the object regardless of lights or textures. The color is calculated based on the ambient, diffuse, specular and emissive properties of the object and scene, color tracking and the specified hardware buffer color.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_lighting.html" title="Lighting sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPLighting</a> - responsible for adding code to the shaders that calculate the luminescence added to the object by light. Then add that value to the color calculated by the color SRS stage.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_texturing.html" title="Texturing sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTexturing</a> - responsible for adding code that modulates the color of the pixels based on textures assigned to the material.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_fog.html" title="Fog sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPFog</a> - responsible for adding code that modulates the color of a pixel based on the scene or object fog parameters.</li>
</ul>
<p>There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...</p>
<h3>SubRenderStateFactory</h3>
<p>As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.</p>
<p>These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.</p>
<h2><a class="anchor" id="creating-extensions"></a>
Creating custom shader extensions</h2>
<p>Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.</p>
<p>In order to extend the system with your own shader effects you'll have to follow these steps:</p><ul>
<li>Implement the SubRenderState interface - This is the main class that is responsible for the actual effect processing such as preparing the destination pass, updating the CPU shader programs, updating the GPU shader parameters etc.</li>
<li>Implement the SubRenderStateFactory interface: This class will allow the RTSS to create instances of the previous class via code or script as well as export it to material script file.</li>
<li>Register the factory to the RTSS using the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac266946244d79b2d4732607ae9479bd9" title="Add sub render state factory. ">Ogre::RTShader::ShaderGenerator::addSubRenderStateFactory</a> method.</li>
<li>Add shader files that will supply all the actual shader functions your SubRenderState needs. In order to support multiple shader languages you should supply code for your entire desired target shading languages (CG, HLSL, GLSL etc). These files should be placed in a way that the resource manager could access them. This can be done by placing them in a valid resource location or by dynamically adding resource location.</li>
</ul>
<p>Implementing the SubRenderState requires overriding the pure methods of the base class.</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#ae91b7b8f76848d67652b6e5832a27a49" title="Get the type of this sub render state. ">Ogre::RTShader::SubRenderState::getType()</a> should return unique string that identify the sub class implementation. That value is shared among all instances and can be stored in a static string variable. It uses to system to match between SubRenderState instance and the factory to should destroy it.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#acb48c34ee231f0220f68c967fb32f1e5" title="Get the execution order of this sub render state. ">Ogre::RTShader::SubRenderState::getExecutionOrder()</a> should return integer value that will use the system to sort all SubRenderState instances of the same render state before each one of them will create its part in the CPU shader programs. Note that:<ul>
<li>The execution order does not imply the order of the parameter definitions and function calls within the generated shader.</li>
<li>If an execution number is set to be the same as one of the basic fixed pipeline SRSs. Than that SRS will be built <b>instead</b> of the fixed pipeline SRS.</li>
</ul>
</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a5dfe9f03413e0fe99ea2640f06c1f13c" title="Copy details from a given sub render state to this one. ">Ogre::RTShader::SubRenderState::copyFrom()</a> a simple copy method that uses the system when coping one instance to another. <b>Note:</b> Only configuration data attributes should be copy here.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4b43c261946926ebbc6456deccc6697a" title="Create sub programs that represents this sub render state as part of a program set. ">Ogre::RTShader::SubRenderState::createCpuSubPrograms</a> - This is the heart of this interface. This method should update the CPU shader programs with the specific details of the overriding class.</li>
</ul>
<p>The SubRenderState supply default implementation for this method which break down this method into three stages:</p><ul>
<li>Resolving parameters: this stage should grab all the needed parameters for this SubRrenderState. In case of the FFPTransform it should resolve the world view projection matrix and vertex shader input and output position parameters.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Function* vsEntry = vsProgram-&gt;getEntryPointFunction();</div><div class="line">    </div><div class="line">    <span class="comment">// Resolve World View Projection Matrix.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#ae0e6b89f6ed3986b0a87e2472e3ff7f1">UniformParameterPtr</a> wvpMatrix = vsProgram-&gt;resolveAutoParameterInt(GpuProgramParameters::ACT_WORLDVIEWPROJ_MATRIX, 0);</div><div class="line">        </div><div class="line">    <span class="comment">// Resolve input position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionIn = vsEntry-&gt;resolveInputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_OBJECT_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>); </div><div class="line">    </div><div class="line">    <span class="comment">// Resolve output position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionOut = vsEntry-&gt;resolveOutputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_PROJECTIVE_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!wvpMatrix || !positionIn || !positionOut)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___general.html#gaf27f0d64dfeb225d37a513c253eaa1a0">OGRE_EXCEPT</a>( Exception::ERR_INTERNAL_ERROR, </div><div class="line">                <span class="stringliteral">&quot;Not all parameters could be constructed for the sub-render state.&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;FFPTransform::createCpuSubPrograms&quot;</span> );</div><div class="line">    }</div></div><!-- fragment --><ul>
<li>Resolving dependencies: this stage should provide the name of the external shader library files that contains the actual shader code needed by this SubRenderState. In case of the FFPTexturing it will add the common and texturing library for both vertex and pixel shader program.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Program* psProgram = programSet-&gt;getCpuFragmentProgram();</div><div class="line"></div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);    </div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);</div></div><!-- fragment --><ul>
<li>Adding function invocations: this stage creates the function calls within this SubRenderState requires. Each function call has two keys that are used by the system to sort it before generating the actual shader code as well as set of in/out parameters. A function invocation is added to either vertex shader program or fragment shader program. In case of the FFPFog it will add vertex depth calculation to the vertex shader program.</li>
</ul>
<div class="fragment"><div class="line">        curFuncInvocation = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> FunctionInvocation(<a class="code" href="group___r_t_shader.html#gabaab1e89270cd7f763f2f8e0258c400e">FFP_FUNC_PIXELFOG_DEPTH</a>, <a class="code" href="group___r_t_shader.html#gga7d20b2397c3eab2b52ec405863c6f274a8b4930a3fd90d5b7222960fc5727b8cf">FFP_VS_FOG</a>);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mWorldViewProjMatrix, Operand::OPS_IN);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSInPos, Operand::OPS_IN);  </div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSOutDepth, Operand::OPS_OUT);  </div><div class="line">        vsMain-&gt;addAtomInstance(curFuncInvocation);     </div></div><!-- fragment --><p> Note:</p><ul>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can add as many function invocations as it needs.</li>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can different function invocations in different ordering.</li>
<li>The ordering of the function invocation is crucial. Use the FFPVertexShaderStage and FFPFragmentShaderStage enumarations to place your invocations in the desired order.</li>
<li>Make sure the parameter semantic (in/out) in the SubRenderState code matches to your shader code implementation you supplied in the library file. GLSL will fail to link to libray functions if it won't be able to find a perfect function declaration match.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4c2acbc15e44c3fe42868abce1116ec2" title="Update GPU programs parameters before a rendering operation occurs. ">Ogre::RTShader::SubRenderState::updateGpuProgramsParams</a> - As the name suggest this method should be overridden only in case your SubRenderState should update some parameter it created before.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#afd08043cfad43a1ae470c3c1be341ba1" title="Called before adding this sub render state to the given render state. ">Ogre::RTShader::SubRenderState::preAddToRenderState()</a>: this method called before adding this SubRenderState to a parent RenderState instances. It allows this SubRenderState to exclude itself from the list in case the source pass is not matching. I.E in case of SubRenderState that perform lighting calculations it can return false when the given source pass specifies that lighting calculations disabled for it.</li>
</ul>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (!srcPass-&gt;getLightingEnabled())</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div></div><!-- fragment --><p> This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.</p>
<p>Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods</p><ul>
<li>Ogre::RTShader::SubRenderStateFactory::createInstanceImpl(): This method should return instance for the SubRenderState sub class.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#a954d30cb82307ae1ba785792b833b689" title="Create an instance of the SubRenderState sub class it suppose to create. ">Ogre::RTShader::SubRenderStateFactory::createInstance()</a>: This method should return instasnce for the SubRenderState sub class using the given script compiler parameters. Implemet this method if you want to be able to creat your custom shader extension from material script.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#ada31909080bae96784504be42d9bd77c" title="Write the given sub-render state instance using the material serializer. ">Ogre::RTShader::SubRenderStateFactory::writeInstance()</a>: This method should write down the parameters of a given SubRenderState instance to material script file. Implement this method if you want to be able to export a material that contains your custom shader extension.</li>
</ul>
<h2><a class="anchor" id="debugging"></a>
Tips for debugging shaders</h2>
<p>A couple of notes on debugging shaders coming from the RTSS:</p><ul>
<li>Call <a class="el" href="class_ogre_bites_1_1_application_context.html#aaad4c1d25a7a5f60dd5c5f3812f1096b" title="make the RTSS write out the generated shaders for caching and debugging ">OgreBites::ApplicationContext::setRTSSWriteShadersToDisk</a>. This will cache the generated shaders onto the disk under the directory <code>{<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> directory}\Samples\Media\RTShaderLib\cache</code>. This is important for 2 reasons:<ul>
<li>It will make compilation problems easier to detect.</li>
<li>Once a shader is written to the disk, as long as you don't change the code behind it, the same shader will be picked up in the next application run even if its content has changed. If you have compilation or visual problems with the shader you can try to manually tinker with it without compiling the code again and again.</li>
</ul>
</li>
<li>Find the file OgreShaderProgramManager.cpp and add a breakpoint at <code>pGpuProgram.setNull();</code> (in createGpuProgram). If a shader will fail to compile it will usually fail there. Once that happens you can find the shader name under the <code>programName</code> parameter, then look for it in the cache directory you created.</li>
<li>Other common problems with creating shaders in RTSS usually occur from defining vertex shader parameters and using them in the pixel shader and vice versa. so watch out for those.</li>
</ul>
<h1><a class="anchor" id="history"></a>
Historical background</h1>
<p>When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).</p>
<p>As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.</p>
<p>Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.</p>
<p>The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.</p>
<p>With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.</p>
<h1><a class="anchor" id="pros-cons"></a>
Pros and Cons</h1>
<p>Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders</p><ul>
<li>Hardware animation (a.k.a hardware skinning)</li>
<li>Soft shadows</li>
<li>Normal/Bump maps</li>
<li>Specular maps</li>
<li>Advanced multi-texturing effects</li>
</ul>
<p>Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.</p>
<p>So why use a runtime shader system anyway?</p>
<ul>
<li>Save development time e.g. when your target scene has dynamic lights and the number changes, fog changes, ... and the number of material attributes increases the total count of needed shaders dramatically. It can easily cross 100 and it becomes a time consuming development task.</li>
<li>Reusable code - once you've written the shader extension you can use it anywhere due to its independent nature.</li>
<li>Custom shaders extension library - enjoy the shared library of effects created by the community. Unlike hand written shader code, which may require many adjustments to be plugged into your own shader code, using the extensions library requires minimum changes. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: RTSS: Run Time Shader System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rtss.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">RTSS: Run Time Shader System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#core-feats">Core features of the system</a></li>
<li class="level1"><a href="#rtss_overview">System overview</a><ul><li class="level2"><a href="#rtss_custom_api">Customising via API</a></li>
<li class="level2"><a href="#rtss_custom_mat">Customizing via Material Script</a></li>
</ul>
</li>
<li class="level1"><a href="#rtss_indepth">The RTSS in Depth</a><ul><li class="level2"><a href="#rtss__components">Main components</a></li>
<li class="level2"><a href="#creating-extensions">Creating custom shader extensions</a></li>
<li class="level2"><a href="#debugging">Tips for debugging shaders</a></li>
</ul>
</li>
<li class="level1"><a href="#history">Historical background</a></li>
<li class="level1"><a href="#pros-cons">Pros and Cons</a></li>
</ul>
</div>
<div class="textblock"><p>This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.</p>
<h1><a class="anchor" id="core-feats"></a>
Core features of the system</h1>
<ul>
<li>Runtime shader generation synchronized with scene state. Each time scene settings change, a new set of shaders is generated.</li>
<li>Full Fixed Function Pipeline (FFP) emulation. This feature is most useful combined with render system that doesn't provide any FFP functionality (OpenGL ES 2.0, D3D11 etc).</li>
<li>Shader language independent interface: the logic representation of the shader programs is completely independent from the target shader language. You can generate code for different shader languages from the same program.</li>
<li>Pluggable interface allows extending the target shader languages set.</li>
<li>Pluggable interface allows adding new shader based effects to the system in a seamless way. Each effect code will be automatically combined with the rest of the shader code.</li>
<li>Smart program management: each shader program is created only once and may be used by multiple passes.</li>
<li>Automatic vertex shader compacting mechanism: no more compacting variables by hand. In case the amount of used vertex shader output registers exceeds the maximum allowed (12 to 32, depending on <a href="http://msdn.microsoft.com/en-us/library/bb172918%28v=VS.85%29.aspx">D3DPSHADERCAPS2_0.NumTemps</a>), a compacting algorithm packs the vertex shader outputs and adds unpack code in the fragment shader side.</li>
<li>Material script support, for both export and import.</li>
</ul>
<h1><a class="anchor" id="rtss_overview"></a>
System overview</h1>
<p>The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.</p>
<p>Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.</p>
<p>To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.</p>
<p>After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.</p>
<p>Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates</p>
<div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">uniform mat4    worldviewproj_matrix;</div><div class="line">uniform mat4    texture_matrix1;</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">in  vec4    vertex;</div><div class="line">in  vec4    uv0;</div><div class="line">out vec4    oTexcoord4_0;</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    FFP_Transform(worldviewproj_matrix, vertex, gl_Position);</div><div class="line">    FFP_TransformTexCoord(texture_matrix1, uv0.xy, oTexcoord4_0.xy);</div><div class="line">}</div></div><!-- fragment --><p>It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)</p>
<p>Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.</p>
<p>The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.</p>
<h2><a class="anchor" id="rtss_custom_api"></a>
Customising via API</h2>
<p>The first option is to globally enforce per-pixel lighting, you can do the following</p>
<div class="fragment"><div class="line">        <span class="comment">// Grab the scheme render state.</span></div><div class="line">        <a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">Ogre::RTShader::RenderState</a>* schemRenderState =</div><div class="line">            mShaderGenerator-&gt;getRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line">        <span class="comment">// Add per pixel lighting sub render state to the global scheme render state.</span></div><div class="line">        <span class="comment">// It will override the default FFP lighting sub render state.</span></div><div class="line">        <span class="keywordflow">if</span> (usePerPixelLighting) {</div><div class="line">            <a class="code" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">Ogre::RTShader::SubRenderState</a>* perPixelLightModel =</div><div class="line">                mShaderGenerator-&gt;createSubRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_per_pixel_lighting.html#ae766f76cad4b3a4339a0cd50abbddcc2">Ogre::RTShader::PerPixelLighting::Type</a>);</div><div class="line"></div><div class="line">            schemRenderState-&gt;<a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html#af66edaf33c654e03ef89f1eaec384a1f">addTemplateSubRenderState</a>(perPixelLightModel);</div><div class="line">        }</div></div><!-- fragment --><p> any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.</p>
<h2><a class="anchor" id="rtss_custom_mat"></a>
Customizing via Material Script</h2>
<p>Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following</p>
<div class="fragment"><div class="line">            <span class="comment">// RT Shader system section.</span></div><div class="line">            rtshader_system</div><div class="line">            {       </div><div class="line">                <span class="comment">// Override lighting stage with per pixel lighting.             </span></div><div class="line">                lighting_stage per_pixel                </div><div class="line">            }   </div></div><!-- fragment --><p> for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.</p>
<p>Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:</p>
<ul>
<li><a href="#lighting_stage">lighting_stage</a></li>
<li><a href="#light_count">light_count</a></li>
<li><a href="#triplanarTexturing">triplanarTexturing</a></li>
<li><a href="#integrated_pssm4">integrated_pssm4</a></li>
<li><a href="#layered_blend">layered_blend</a></li>
<li><a href="#source_modifier">source_modifier</a></li>
</ul>
<p><a class="anchor" id="lighting_stage"></a></p>
<h3>lighting_stage</h3>
<p>Force a specific lighting model.</p>
<p>Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code></p>
<p>Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code></p>
<p>Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_r_t_shader_1_1_normal_map_lighting.html#adc6b4bdd1ea31c2232336599d2b30b60" title="Normal map space definition. ">Ogre::RTShader::NormalMapLighting::NormalMapSpace</a> </dd>
<dd>
<a class="el" href="group___general.html#ga21a0186392e9c9ce16d29c5568a773c5" title="High-level filtering options providing shortcuts to settings the minification, magnification and mip ...">Ogre::TextureFilterOptions</a></dd></dl>
<p><a class="anchor" id="light_count"></a></p>
<h3>light_count</h3>
<p>Override dynamic light count. Allows to customize which lights the RTSS will consider.</p>
<p>Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code></p>
<p><a class="anchor" id="triplanarTexturing"></a></p>
<h3>triplanarTexturing</h3>
<p>Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a></p>
<p>Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code></p>
<p>Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureScale</td><td>texture coordinates are multiplied by this. </td></tr>
    <tr><td class="paramname">plateauSize</td><td>plateau on which small components of the normal have no influence. </td></tr>
    <tr><td class="paramname">transitionSpeed</td><td>transitions speed between the three textures Valid values are [0; 0.57] not bigger to avoid division by zero </td></tr>
    <tr><td class="paramname">textureFromX</td><td>Texture for the x-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromY</td><td>Texture for the y-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromZ</td><td>Texture for the z-direction planar mapping</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="integrated_pssm4"></a></p>
<h3>integrated_pssm4</h3>
<p>Integrated PSSM shadow receiver with 3 splits. Custom split points.</p>
<p>Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code></p>
<p><a class="anchor" id="layered_blend"></a></p>
<h3>layered_blend</h3>
<p>Apply photoshop-like blend effects to texture layers</p>
<p>Format: <code>layered_blend &lt;effect&gt;</code></p>
<p>Example: layered_blend luminosity</p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">effect</td><td>one of <code>default, normal, lighten, darken, multiply, average, add, subtract, difference, negation, exclusion, screen, overlay, hard_light, soft_light, color_dodge, color_burn, linear_dodge, linear_burn, linear_light, vivid_light, pin_light, hard_mix, reflect, glow, phoenix, saturation, color, luminosity</code></td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="source_modifier"></a></p>
<h3>source_modifier</h3>
<p>Apply custom modulate effect to texture layer</p>
<p>Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code></p>
<p>Example: <code>source_modifier src1_inverse_modulate custom 2</code></p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>one of <code>src1_modulate, src2_modulate, src1_inverse_modulate, src2_inverse_modulate</code> </td></tr>
    <tr><td class="paramname">parameterNum</td><td>number of the custom shader parameter that controls the operation</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="rtss_indepth"></a>
The RTSS in Depth</h1>
<p>When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.</p>
<p>The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).</p>
<p>Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.</p>
<p>The following steps are executed in order to generate shaders for a given technique:</p>
<ul>
<li>For each pass in the technique the system builds a set of sub render states that describe the logic process of the rendering pipeline from the draw call submission until the final pixel color.</li>
<li>Each render state is translated into a set of logic shader programs (currently only pixel and vertex shader). The logic programs are then sent to specific shader language writers that produce source code for the respective shader language. The source code is used to create the GPU programs that are applied to the destination pass. Before rendering of an object that uses generated shaders the system allows each sub render state to update the GPU constants associated with it.</li>
</ul>
<h2>Initializing the system</h2>
<dl class="section note"><dt>Note</dt><dd>If you are using the <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>, the following steps will be taken automatically for you.</dd></dl>
<p>Initializing the system is composed of the following steps:</p><ul>
<li>Create the internal managers and structures via the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260" title="Initialize the Shader Generator System. ">Ogre::RTShader::ShaderGenerator::initialize()</a></code> method.</li>
<li>Set the target cache path. This is the place on your disk where the output shaders will be written to or will be read from in case they were generated by previous runs of your application.</li>
<li>Verify that the location of the shader libs needed by the system is added to the ResourceGroupManager via the <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d" title="Adds a location to the list of searchable locations for a Resource type. ">Ogre::ResourceGroupManager::addResourceLocation()</a></code> method.</li>
<li>Assign the target scene manager to the shader generator.</li>
<li>Add one or more specialized sub-render states that are to be shared among all materials (per pixel lighting, textured fog, etc...).</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260">Ogre::RTShader::ShaderGenerator::initialize</a>())</div><div class="line">{</div><div class="line">    <span class="comment">// Grab the shader generator pointer.</span></div><div class="line">    mShaderGenerator = <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">Ogre::RTShader::ShaderGenerator::getSingletonPtr</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Add the shader libs resource location. a sample shader lib can be found in Samples\Media\RTShaderLib</span></div><div class="line">    <a class="code" href="class_ogre_1_1_resource_group_manager.html#a45101333f0f9ff132fc381dd5c4a1d60">Ogre::ResourceGroupManager::getSingleton</a>().<a class="code" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d">addResourceLocation</a>(shaderLibPath, <span class="stringliteral">&quot;FileSystem&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Set shader cache path.</span></div><div class="line">    mShaderGenerator-&gt;setShaderCachePath(shaderCachePath);      </div><div class="line"></div><div class="line">    <span class="comment">// Set the scene manager.</span></div><div class="line">    mShaderGenerator-&gt;addSceneManager(sceneMgr);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><h2>Creating shader based technique</h2>
<p>This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.</p>
<p>To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.</p>
<p>Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// Create shader based technique from the default technique of the given material.</span></div><div class="line">mShaderGenerator-&gt;createShaderBasedTechnique(<span class="stringliteral">&quot;Examples/BeachStones&quot;</span>, <a class="code" href="class_ogre_1_1_material_manager.html#a290b828b5d44637ee4d247a09ea81bd6">Ogre::MaterialManager::DEFAULT_SCHEME_NAME</a>, <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line"><span class="comment">// Apply the shader generated based techniques.</span></div><div class="line">mViewport-&gt;setMaterialScheme(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div></div><!-- fragment --> <div class="image">
<object type="image/svg+xml" data="CreateShaderBasedTech.svg">CreateShaderBasedTech.svg</object>
</div>
<h2>Runtime shader generation</h2>
<p>During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.</p>
<div class="image">
<object type="image/svg+xml" data="RuntimeShaderGeneration.svg">RuntimeShaderGeneration.svg</object>
</div>
<h2><a class="anchor" id="rtss__components"></a>
Main components</h2>
<p>The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.</p>
<h3>ShaderGenerator</h3>
<p>The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.</p>
<h3>RenderState classes</h3>
<p>A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.</p>
<p>RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.</p>
<h3>SubRenderState classes</h3>
<p>Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.</p>
<p>There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_transform.html" title="Transform sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTransform</a> - responsible for adding code to the vertex shader which computes the position of the vertex in projection space</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_colour.html" title="Colour sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPColour</a> - responsible for adding code to the shaders that calculate the base diffuse and specular color of the object regardless of lights or textures. The color is calculated based on the ambient, diffuse, specular and emissive properties of the object and scene, color tracking and the specified hardware buffer color.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_lighting.html" title="Lighting sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPLighting</a> - responsible for adding code to the shaders that calculate the luminescence added to the object by light. Then add that value to the color calculated by the color SRS stage.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_texturing.html" title="Texturing sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTexturing</a> - responsible for adding code that modulates the color of the pixels based on textures assigned to the material.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_fog.html" title="Fog sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPFog</a> - responsible for adding code that modulates the color of a pixel based on the scene or object fog parameters.</li>
</ul>
<p>There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...</p>
<h3>SubRenderStateFactory</h3>
<p>As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.</p>
<p>These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.</p>
<h2><a class="anchor" id="creating-extensions"></a>
Creating custom shader extensions</h2>
<p>Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.</p>
<p>In order to extend the system with your own shader effects you'll have to follow these steps:</p><ul>
<li>Implement the SubRenderState interface - This is the main class that is responsible for the actual effect processing such as preparing the destination pass, updating the CPU shader programs, updating the GPU shader parameters etc.</li>
<li>Implement the SubRenderStateFactory interface: This class will allow the RTSS to create instances of the previous class via code or script as well as export it to material script file.</li>
<li>Register the factory to the RTSS using the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac266946244d79b2d4732607ae9479bd9" title="Add sub render state factory. ">Ogre::RTShader::ShaderGenerator::addSubRenderStateFactory</a> method.</li>
<li>Add shader files that will supply all the actual shader functions your SubRenderState needs. In order to support multiple shader languages you should supply code for your entire desired target shading languages (CG, HLSL, GLSL etc). These files should be placed in a way that the resource manager could access them. This can be done by placing them in a valid resource location or by dynamically adding resource location.</li>
</ul>
<p>Implementing the SubRenderState requires overriding the pure methods of the base class.</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#ae91b7b8f76848d67652b6e5832a27a49" title="Get the type of this sub render state. ">Ogre::RTShader::SubRenderState::getType()</a> should return unique string that identify the sub class implementation. That value is shared among all instances and can be stored in a static string variable. It uses to system to match between SubRenderState instance and the factory to should destroy it.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#acb48c34ee231f0220f68c967fb32f1e5" title="Get the execution order of this sub render state. ">Ogre::RTShader::SubRenderState::getExecutionOrder()</a> should return integer value that will use the system to sort all SubRenderState instances of the same render state before each one of them will create its part in the CPU shader programs. Note that:<ul>
<li>The execution order does not imply the order of the parameter definitions and function calls within the generated shader.</li>
<li>If an execution number is set to be the same as one of the basic fixed pipeline SRSs. Than that SRS will be built <b>instead</b> of the fixed pipeline SRS.</li>
</ul>
</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a5dfe9f03413e0fe99ea2640f06c1f13c" title="Copy details from a given sub render state to this one. ">Ogre::RTShader::SubRenderState::copyFrom()</a> a simple copy method that uses the system when coping one instance to another. <b>Note:</b> Only configuration data attributes should be copy here.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4b43c261946926ebbc6456deccc6697a" title="Create sub programs that represents this sub render state as part of a program set. ">Ogre::RTShader::SubRenderState::createCpuSubPrograms</a> - This is the heart of this interface. This method should update the CPU shader programs with the specific details of the overriding class.</li>
</ul>
<p>The SubRenderState supply default implementation for this method which break down this method into three stages:</p><ul>
<li>Resolving parameters: this stage should grab all the needed parameters for this SubRrenderState. In case of the FFPTransform it should resolve the world view projection matrix and vertex shader input and output position parameters.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Function* vsEntry = vsProgram-&gt;getEntryPointFunction();</div><div class="line">    </div><div class="line">    <span class="comment">// Resolve World View Projection Matrix.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#ae0e6b89f6ed3986b0a87e2472e3ff7f1">UniformParameterPtr</a> wvpMatrix = vsProgram-&gt;resolveAutoParameterInt(GpuProgramParameters::ACT_WORLDVIEWPROJ_MATRIX, 0);</div><div class="line">        </div><div class="line">    <span class="comment">// Resolve input position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionIn = vsEntry-&gt;resolveInputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_OBJECT_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>); </div><div class="line">    </div><div class="line">    <span class="comment">// Resolve output position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionOut = vsEntry-&gt;resolveOutputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_PROJECTIVE_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!wvpMatrix || !positionIn || !positionOut)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___general.html#gaf27f0d64dfeb225d37a513c253eaa1a0">OGRE_EXCEPT</a>( Exception::ERR_INTERNAL_ERROR, </div><div class="line">                <span class="stringliteral">&quot;Not all parameters could be constructed for the sub-render state.&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;FFPTransform::createCpuSubPrograms&quot;</span> );</div><div class="line">    }</div></div><!-- fragment --><ul>
<li>Resolving dependencies: this stage should provide the name of the external shader library files that contains the actual shader code needed by this SubRenderState. In case of the FFPTexturing it will add the common and texturing library for both vertex and pixel shader program.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Program* psProgram = programSet-&gt;getCpuFragmentProgram();</div><div class="line"></div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);    </div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);</div></div><!-- fragment --><ul>
<li>Adding function invocations: this stage creates the function calls within this SubRenderState requires. Each function call has two keys that are used by the system to sort it before generating the actual shader code as well as set of in/out parameters. A function invocation is added to either vertex shader program or fragment shader program. In case of the FFPFog it will add vertex depth calculation to the vertex shader program.</li>
</ul>
<div class="fragment"><div class="line">        curFuncInvocation = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> FunctionInvocation(<a class="code" href="group___r_t_shader.html#gabaab1e89270cd7f763f2f8e0258c400e">FFP_FUNC_PIXELFOG_DEPTH</a>, <a class="code" href="group___r_t_shader.html#gga7d20b2397c3eab2b52ec405863c6f274a8b4930a3fd90d5b7222960fc5727b8cf">FFP_VS_FOG</a>);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mWorldViewProjMatrix, Operand::OPS_IN);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSInPos, Operand::OPS_IN);  </div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSOutDepth, Operand::OPS_OUT);  </div><div class="line">        vsMain-&gt;addAtomInstance(curFuncInvocation);     </div></div><!-- fragment --><p> Note:</p><ul>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can add as many function invocations as it needs.</li>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can different function invocations in different ordering.</li>
<li>The ordering of the function invocation is crucial. Use the FFPVertexShaderStage and FFPFragmentShaderStage enumarations to place your invocations in the desired order.</li>
<li>Make sure the parameter semantic (in/out) in the SubRenderState code matches to your shader code implementation you supplied in the library file. GLSL will fail to link to libray functions if it won't be able to find a perfect function declaration match.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4c2acbc15e44c3fe42868abce1116ec2" title="Update GPU programs parameters before a rendering operation occurs. ">Ogre::RTShader::SubRenderState::updateGpuProgramsParams</a> - As the name suggest this method should be overridden only in case your SubRenderState should update some parameter it created before.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#afd08043cfad43a1ae470c3c1be341ba1" title="Called before adding this sub render state to the given render state. ">Ogre::RTShader::SubRenderState::preAddToRenderState()</a>: this method called before adding this SubRenderState to a parent RenderState instances. It allows this SubRenderState to exclude itself from the list in case the source pass is not matching. I.E in case of SubRenderState that perform lighting calculations it can return false when the given source pass specifies that lighting calculations disabled for it.</li>
</ul>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (!srcPass-&gt;getLightingEnabled())</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div></div><!-- fragment --><p> This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.</p>
<p>Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods</p><ul>
<li>Ogre::RTShader::SubRenderStateFactory::createInstanceImpl(): This method should return instance for the SubRenderState sub class.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#a954d30cb82307ae1ba785792b833b689" title="Create an instance of the SubRenderState sub class it suppose to create. ">Ogre::RTShader::SubRenderStateFactory::createInstance()</a>: This method should return instasnce for the SubRenderState sub class using the given script compiler parameters. Implemet this method if you want to be able to creat your custom shader extension from material script.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#ada31909080bae96784504be42d9bd77c" title="Write the given sub-render state instance using the material serializer. ">Ogre::RTShader::SubRenderStateFactory::writeInstance()</a>: This method should write down the parameters of a given SubRenderState instance to material script file. Implement this method if you want to be able to export a material that contains your custom shader extension.</li>
</ul>
<h2><a class="anchor" id="debugging"></a>
Tips for debugging shaders</h2>
<p>A couple of notes on debugging shaders coming from the RTSS:</p><ul>
<li>Call <a class="el" href="class_ogre_bites_1_1_application_context.html#aaad4c1d25a7a5f60dd5c5f3812f1096b" title="make the RTSS write out the generated shaders for caching and debugging ">OgreBites::ApplicationContext::setRTSSWriteShadersToDisk</a>. This will cache the generated shaders onto the disk under the directory <code>{<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> directory}\Samples\Media\RTShaderLib\cache</code>. This is important for 2 reasons:<ul>
<li>It will make compilation problems easier to detect.</li>
<li>Once a shader is written to the disk, as long as you don't change the code behind it, the same shader will be picked up in the next application run even if its content has changed. If you have compilation or visual problems with the shader you can try to manually tinker with it without compiling the code again and again.</li>
</ul>
</li>
<li>Find the file OgreShaderProgramManager.cpp and add a breakpoint at <code>pGpuProgram.setNull();</code> (in createGpuProgram). If a shader will fail to compile it will usually fail there. Once that happens you can find the shader name under the <code>programName</code> parameter, then look for it in the cache directory you created.</li>
<li>Other common problems with creating shaders in RTSS usually occur from defining vertex shader parameters and using them in the pixel shader and vice versa. so watch out for those.</li>
</ul>
<h1><a class="anchor" id="history"></a>
Historical background</h1>
<p>When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).</p>
<p>As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.</p>
<p>Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.</p>
<p>The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.</p>
<p>With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.</p>
<h1><a class="anchor" id="pros-cons"></a>
Pros and Cons</h1>
<p>Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders</p><ul>
<li>Hardware animation (a.k.a hardware skinning)</li>
<li>Soft shadows</li>
<li>Normal/Bump maps</li>
<li>Specular maps</li>
<li>Advanced multi-texturing effects</li>
</ul>
<p>Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.</p>
<p>So why use a runtime shader system anyway?</p>
<ul>
<li>Save development time e.g. when your target scene has dynamic lights and the number changes, fog changes, ... and the number of material attributes increases the total count of needed shaders dramatically. It can easily cross 100 and it becomes a time consuming development task.</li>
<li>Reusable code - once you've written the shader extension you can use it anywhere due to its independent nature.</li>
<li>Custom shaders extension library - enjoy the shared library of effects created by the community. Unlike hand written shader code, which may require many adjustments to be plugged into your own shader code, using the extensions library requires minimum changes. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: RTSS: Run Time Shader System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rtss.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">RTSS: Run Time Shader System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#core-feats">Core features of the system</a></li>
<li class="level1"><a href="#rtss_overview">System overview</a><ul><li class="level2"><a href="#rtss_custom_api">Customising via API</a></li>
<li class="level2"><a href="#rtss_custom_mat">Customizing via Material Script</a></li>
</ul>
</li>
<li class="level1"><a href="#rtss_indepth">The RTSS in Depth</a><ul><li class="level2"><a href="#rtss__components">Main components</a></li>
<li class="level2"><a href="#creating-extensions">Creating custom shader extensions</a></li>
<li class="level2"><a href="#debugging">Tips for debugging shaders</a></li>
</ul>
</li>
<li class="level1"><a href="#history">Historical background</a></li>
<li class="level1"><a href="#pros-cons">Pros and Cons</a></li>
</ul>
</div>
<div class="textblock"><p>This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.</p>
<h1><a class="anchor" id="core-feats"></a>
Core features of the system</h1>
<ul>
<li>Runtime shader generation synchronized with scene state. Each time scene settings change, a new set of shaders is generated.</li>
<li>Full Fixed Function Pipeline (FFP) emulation. This feature is most useful combined with render system that doesn't provide any FFP functionality (OpenGL ES 2.0, D3D11 etc).</li>
<li>Shader language independent interface: the logic representation of the shader programs is completely independent from the target shader language. You can generate code for different shader languages from the same program.</li>
<li>Pluggable interface allows extending the target shader languages set.</li>
<li>Pluggable interface allows adding new shader based effects to the system in a seamless way. Each effect code will be automatically combined with the rest of the shader code.</li>
<li>Smart program management: each shader program is created only once and may be used by multiple passes.</li>
<li>Automatic vertex shader compacting mechanism: no more compacting variables by hand. In case the amount of used vertex shader output registers exceeds the maximum allowed (12 to 32, depending on <a href="http://msdn.microsoft.com/en-us/library/bb172918%28v=VS.85%29.aspx">D3DPSHADERCAPS2_0.NumTemps</a>), a compacting algorithm packs the vertex shader outputs and adds unpack code in the fragment shader side.</li>
<li>Material script support, for both export and import.</li>
</ul>
<h1><a class="anchor" id="rtss_overview"></a>
System overview</h1>
<p>The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.</p>
<p>Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.</p>
<p>To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.</p>
<p>After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.</p>
<p>Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates</p>
<div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">uniform mat4    worldviewproj_matrix;</div><div class="line">uniform mat4    texture_matrix1;</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">in  vec4    vertex;</div><div class="line">in  vec4    uv0;</div><div class="line">out vec4    oTexcoord4_0;</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    FFP_Transform(worldviewproj_matrix, vertex, gl_Position);</div><div class="line">    FFP_TransformTexCoord(texture_matrix1, uv0.xy, oTexcoord4_0.xy);</div><div class="line">}</div></div><!-- fragment --><p>It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)</p>
<p>Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.</p>
<p>The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.</p>
<h2><a class="anchor" id="rtss_custom_api"></a>
Customising via API</h2>
<p>The first option is to globally enforce per-pixel lighting, you can do the following</p>
<div class="fragment"><div class="line">        <span class="comment">// Grab the scheme render state.</span></div><div class="line">        <a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">Ogre::RTShader::RenderState</a>* schemRenderState =</div><div class="line">            mShaderGenerator-&gt;getRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line">        <span class="comment">// Add per pixel lighting sub render state to the global scheme render state.</span></div><div class="line">        <span class="comment">// It will override the default FFP lighting sub render state.</span></div><div class="line">        <span class="keywordflow">if</span> (usePerPixelLighting) {</div><div class="line">            <a class="code" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">Ogre::RTShader::SubRenderState</a>* perPixelLightModel =</div><div class="line">                mShaderGenerator-&gt;createSubRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_per_pixel_lighting.html#ae766f76cad4b3a4339a0cd50abbddcc2">Ogre::RTShader::PerPixelLighting::Type</a>);</div><div class="line"></div><div class="line">            schemRenderState-&gt;<a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html#af66edaf33c654e03ef89f1eaec384a1f">addTemplateSubRenderState</a>(perPixelLightModel);</div><div class="line">        }</div></div><!-- fragment --><p> any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.</p>
<h2><a class="anchor" id="rtss_custom_mat"></a>
Customizing via Material Script</h2>
<p>Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following</p>
<div class="fragment"><div class="line">            <span class="comment">// RT Shader system section.</span></div><div class="line">            rtshader_system</div><div class="line">            {       </div><div class="line">                <span class="comment">// Override lighting stage with per pixel lighting.             </span></div><div class="line">                lighting_stage per_pixel                </div><div class="line">            }   </div></div><!-- fragment --><p> for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.</p>
<p>Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:</p>
<ul>
<li><a href="#lighting_stage">lighting_stage</a></li>
<li><a href="#light_count">light_count</a></li>
<li><a href="#triplanarTexturing">triplanarTexturing</a></li>
<li><a href="#integrated_pssm4">integrated_pssm4</a></li>
<li><a href="#layered_blend">layered_blend</a></li>
<li><a href="#source_modifier">source_modifier</a></li>
</ul>
<p><a class="anchor" id="lighting_stage"></a></p>
<h3>lighting_stage</h3>
<p>Force a specific lighting model.</p>
<p>Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code></p>
<p>Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code></p>
<p>Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_r_t_shader_1_1_normal_map_lighting.html#adc6b4bdd1ea31c2232336599d2b30b60" title="Normal map space definition. ">Ogre::RTShader::NormalMapLighting::NormalMapSpace</a> </dd>
<dd>
<a class="el" href="group___general.html#ga21a0186392e9c9ce16d29c5568a773c5" title="High-level filtering options providing shortcuts to settings the minification, magnification and mip ...">Ogre::TextureFilterOptions</a></dd></dl>
<p><a class="anchor" id="light_count"></a></p>
<h3>light_count</h3>
<p>Override dynamic light count. Allows to customize which lights the RTSS will consider.</p>
<p>Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code></p>
<p><a class="anchor" id="triplanarTexturing"></a></p>
<h3>triplanarTexturing</h3>
<p>Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a></p>
<p>Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code></p>
<p>Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureScale</td><td>texture coordinates are multiplied by this. </td></tr>
    <tr><td class="paramname">plateauSize</td><td>plateau on which small components of the normal have no influence. </td></tr>
    <tr><td class="paramname">transitionSpeed</td><td>transitions speed between the three textures Valid values are [0; 0.57] not bigger to avoid division by zero </td></tr>
    <tr><td class="paramname">textureFromX</td><td>Texture for the x-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromY</td><td>Texture for the y-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromZ</td><td>Texture for the z-direction planar mapping</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="integrated_pssm4"></a></p>
<h3>integrated_pssm4</h3>
<p>Integrated PSSM shadow receiver with 3 splits. Custom split points.</p>
<p>Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code></p>
<p><a class="anchor" id="layered_blend"></a></p>
<h3>layered_blend</h3>
<p>Apply photoshop-like blend effects to texture layers</p>
<p>Format: <code>layered_blend &lt;effect&gt;</code></p>
<p>Example: layered_blend luminosity</p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">effect</td><td>one of <code>default, normal, lighten, darken, multiply, average, add, subtract, difference, negation, exclusion, screen, overlay, hard_light, soft_light, color_dodge, color_burn, linear_dodge, linear_burn, linear_light, vivid_light, pin_light, hard_mix, reflect, glow, phoenix, saturation, color, luminosity</code></td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="source_modifier"></a></p>
<h3>source_modifier</h3>
<p>Apply custom modulate effect to texture layer</p>
<p>Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code></p>
<p>Example: <code>source_modifier src1_inverse_modulate custom 2</code></p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>one of <code>src1_modulate, src2_modulate, src1_inverse_modulate, src2_inverse_modulate</code> </td></tr>
    <tr><td class="paramname">parameterNum</td><td>number of the custom shader parameter that controls the operation</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="rtss_indepth"></a>
The RTSS in Depth</h1>
<p>When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.</p>
<p>The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).</p>
<p>Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.</p>
<p>The following steps are executed in order to generate shaders for a given technique:</p>
<ul>
<li>For each pass in the technique the system builds a set of sub render states that describe the logic process of the rendering pipeline from the draw call submission until the final pixel color.</li>
<li>Each render state is translated into a set of logic shader programs (currently only pixel and vertex shader). The logic programs are then sent to specific shader language writers that produce source code for the respective shader language. The source code is used to create the GPU programs that are applied to the destination pass. Before rendering of an object that uses generated shaders the system allows each sub render state to update the GPU constants associated with it.</li>
</ul>
<h2>Initializing the system</h2>
<dl class="section note"><dt>Note</dt><dd>If you are using the <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>, the following steps will be taken automatically for you.</dd></dl>
<p>Initializing the system is composed of the following steps:</p><ul>
<li>Create the internal managers and structures via the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260" title="Initialize the Shader Generator System. ">Ogre::RTShader::ShaderGenerator::initialize()</a></code> method.</li>
<li>Set the target cache path. This is the place on your disk where the output shaders will be written to or will be read from in case they were generated by previous runs of your application.</li>
<li>Verify that the location of the shader libs needed by the system is added to the ResourceGroupManager via the <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d" title="Adds a location to the list of searchable locations for a Resource type. ">Ogre::ResourceGroupManager::addResourceLocation()</a></code> method.</li>
<li>Assign the target scene manager to the shader generator.</li>
<li>Add one or more specialized sub-render states that are to be shared among all materials (per pixel lighting, textured fog, etc...).</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260">Ogre::RTShader::ShaderGenerator::initialize</a>())</div><div class="line">{</div><div class="line">    <span class="comment">// Grab the shader generator pointer.</span></div><div class="line">    mShaderGenerator = <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">Ogre::RTShader::ShaderGenerator::getSingletonPtr</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Add the shader libs resource location. a sample shader lib can be found in Samples\Media\RTShaderLib</span></div><div class="line">    <a class="code" href="class_ogre_1_1_resource_group_manager.html#a45101333f0f9ff132fc381dd5c4a1d60">Ogre::ResourceGroupManager::getSingleton</a>().<a class="code" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d">addResourceLocation</a>(shaderLibPath, <span class="stringliteral">&quot;FileSystem&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Set shader cache path.</span></div><div class="line">    mShaderGenerator-&gt;setShaderCachePath(shaderCachePath);      </div><div class="line"></div><div class="line">    <span class="comment">// Set the scene manager.</span></div><div class="line">    mShaderGenerator-&gt;addSceneManager(sceneMgr);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><h2>Creating shader based technique</h2>
<p>This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.</p>
<p>To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.</p>
<p>Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// Create shader based technique from the default technique of the given material.</span></div><div class="line">mShaderGenerator-&gt;createShaderBasedTechnique(<span class="stringliteral">&quot;Examples/BeachStones&quot;</span>, <a class="code" href="class_ogre_1_1_material_manager.html#a290b828b5d44637ee4d247a09ea81bd6">Ogre::MaterialManager::DEFAULT_SCHEME_NAME</a>, <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line"><span class="comment">// Apply the shader generated based techniques.</span></div><div class="line">mViewport-&gt;setMaterialScheme(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div></div><!-- fragment --> <div class="image">
<object type="image/svg+xml" data="CreateShaderBasedTech.svg">CreateShaderBasedTech.svg</object>
</div>
<h2>Runtime shader generation</h2>
<p>During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.</p>
<div class="image">
<object type="image/svg+xml" data="RuntimeShaderGeneration.svg">RuntimeShaderGeneration.svg</object>
</div>
<h2><a class="anchor" id="rtss__components"></a>
Main components</h2>
<p>The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.</p>
<h3>ShaderGenerator</h3>
<p>The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.</p>
<h3>RenderState classes</h3>
<p>A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.</p>
<p>RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.</p>
<h3>SubRenderState classes</h3>
<p>Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.</p>
<p>There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_transform.html" title="Transform sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTransform</a> - responsible for adding code to the vertex shader which computes the position of the vertex in projection space</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_colour.html" title="Colour sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPColour</a> - responsible for adding code to the shaders that calculate the base diffuse and specular color of the object regardless of lights or textures. The color is calculated based on the ambient, diffuse, specular and emissive properties of the object and scene, color tracking and the specified hardware buffer color.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_lighting.html" title="Lighting sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPLighting</a> - responsible for adding code to the shaders that calculate the luminescence added to the object by light. Then add that value to the color calculated by the color SRS stage.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_texturing.html" title="Texturing sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTexturing</a> - responsible for adding code that modulates the color of the pixels based on textures assigned to the material.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_fog.html" title="Fog sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPFog</a> - responsible for adding code that modulates the color of a pixel based on the scene or object fog parameters.</li>
</ul>
<p>There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...</p>
<h3>SubRenderStateFactory</h3>
<p>As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.</p>
<p>These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.</p>
<h2><a class="anchor" id="creating-extensions"></a>
Creating custom shader extensions</h2>
<p>Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.</p>
<p>In order to extend the system with your own shader effects you'll have to follow these steps:</p><ul>
<li>Implement the SubRenderState interface - This is the main class that is responsible for the actual effect processing such as preparing the destination pass, updating the CPU shader programs, updating the GPU shader parameters etc.</li>
<li>Implement the SubRenderStateFactory interface: This class will allow the RTSS to create instances of the previous class via code or script as well as export it to material script file.</li>
<li>Register the factory to the RTSS using the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac266946244d79b2d4732607ae9479bd9" title="Add sub render state factory. ">Ogre::RTShader::ShaderGenerator::addSubRenderStateFactory</a> method.</li>
<li>Add shader files that will supply all the actual shader functions your SubRenderState needs. In order to support multiple shader languages you should supply code for your entire desired target shading languages (CG, HLSL, GLSL etc). These files should be placed in a way that the resource manager could access them. This can be done by placing them in a valid resource location or by dynamically adding resource location.</li>
</ul>
<p>Implementing the SubRenderState requires overriding the pure methods of the base class.</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#ae91b7b8f76848d67652b6e5832a27a49" title="Get the type of this sub render state. ">Ogre::RTShader::SubRenderState::getType()</a> should return unique string that identify the sub class implementation. That value is shared among all instances and can be stored in a static string variable. It uses to system to match between SubRenderState instance and the factory to should destroy it.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#acb48c34ee231f0220f68c967fb32f1e5" title="Get the execution order of this sub render state. ">Ogre::RTShader::SubRenderState::getExecutionOrder()</a> should return integer value that will use the system to sort all SubRenderState instances of the same render state before each one of them will create its part in the CPU shader programs. Note that:<ul>
<li>The execution order does not imply the order of the parameter definitions and function calls within the generated shader.</li>
<li>If an execution number is set to be the same as one of the basic fixed pipeline SRSs. Than that SRS will be built <b>instead</b> of the fixed pipeline SRS.</li>
</ul>
</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a5dfe9f03413e0fe99ea2640f06c1f13c" title="Copy details from a given sub render state to this one. ">Ogre::RTShader::SubRenderState::copyFrom()</a> a simple copy method that uses the system when coping one instance to another. <b>Note:</b> Only configuration data attributes should be copy here.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4b43c261946926ebbc6456deccc6697a" title="Create sub programs that represents this sub render state as part of a program set. ">Ogre::RTShader::SubRenderState::createCpuSubPrograms</a> - This is the heart of this interface. This method should update the CPU shader programs with the specific details of the overriding class.</li>
</ul>
<p>The SubRenderState supply default implementation for this method which break down this method into three stages:</p><ul>
<li>Resolving parameters: this stage should grab all the needed parameters for this SubRrenderState. In case of the FFPTransform it should resolve the world view projection matrix and vertex shader input and output position parameters.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Function* vsEntry = vsProgram-&gt;getEntryPointFunction();</div><div class="line">    </div><div class="line">    <span class="comment">// Resolve World View Projection Matrix.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#ae0e6b89f6ed3986b0a87e2472e3ff7f1">UniformParameterPtr</a> wvpMatrix = vsProgram-&gt;resolveAutoParameterInt(GpuProgramParameters::ACT_WORLDVIEWPROJ_MATRIX, 0);</div><div class="line">        </div><div class="line">    <span class="comment">// Resolve input position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionIn = vsEntry-&gt;resolveInputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_OBJECT_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>); </div><div class="line">    </div><div class="line">    <span class="comment">// Resolve output position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionOut = vsEntry-&gt;resolveOutputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_PROJECTIVE_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!wvpMatrix || !positionIn || !positionOut)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___general.html#gaf27f0d64dfeb225d37a513c253eaa1a0">OGRE_EXCEPT</a>( Exception::ERR_INTERNAL_ERROR, </div><div class="line">                <span class="stringliteral">&quot;Not all parameters could be constructed for the sub-render state.&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;FFPTransform::createCpuSubPrograms&quot;</span> );</div><div class="line">    }</div></div><!-- fragment --><ul>
<li>Resolving dependencies: this stage should provide the name of the external shader library files that contains the actual shader code needed by this SubRenderState. In case of the FFPTexturing it will add the common and texturing library for both vertex and pixel shader program.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Program* psProgram = programSet-&gt;getCpuFragmentProgram();</div><div class="line"></div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);    </div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);</div></div><!-- fragment --><ul>
<li>Adding function invocations: this stage creates the function calls within this SubRenderState requires. Each function call has two keys that are used by the system to sort it before generating the actual shader code as well as set of in/out parameters. A function invocation is added to either vertex shader program or fragment shader program. In case of the FFPFog it will add vertex depth calculation to the vertex shader program.</li>
</ul>
<div class="fragment"><div class="line">        curFuncInvocation = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> FunctionInvocation(<a class="code" href="group___r_t_shader.html#gabaab1e89270cd7f763f2f8e0258c400e">FFP_FUNC_PIXELFOG_DEPTH</a>, <a class="code" href="group___r_t_shader.html#gga7d20b2397c3eab2b52ec405863c6f274a8b4930a3fd90d5b7222960fc5727b8cf">FFP_VS_FOG</a>);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mWorldViewProjMatrix, Operand::OPS_IN);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSInPos, Operand::OPS_IN);  </div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSOutDepth, Operand::OPS_OUT);  </div><div class="line">        vsMain-&gt;addAtomInstance(curFuncInvocation);     </div></div><!-- fragment --><p> Note:</p><ul>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can add as many function invocations as it needs.</li>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can different function invocations in different ordering.</li>
<li>The ordering of the function invocation is crucial. Use the FFPVertexShaderStage and FFPFragmentShaderStage enumarations to place your invocations in the desired order.</li>
<li>Make sure the parameter semantic (in/out) in the SubRenderState code matches to your shader code implementation you supplied in the library file. GLSL will fail to link to libray functions if it won't be able to find a perfect function declaration match.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4c2acbc15e44c3fe42868abce1116ec2" title="Update GPU programs parameters before a rendering operation occurs. ">Ogre::RTShader::SubRenderState::updateGpuProgramsParams</a> - As the name suggest this method should be overridden only in case your SubRenderState should update some parameter it created before.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#afd08043cfad43a1ae470c3c1be341ba1" title="Called before adding this sub render state to the given render state. ">Ogre::RTShader::SubRenderState::preAddToRenderState()</a>: this method called before adding this SubRenderState to a parent RenderState instances. It allows this SubRenderState to exclude itself from the list in case the source pass is not matching. I.E in case of SubRenderState that perform lighting calculations it can return false when the given source pass specifies that lighting calculations disabled for it.</li>
</ul>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (!srcPass-&gt;getLightingEnabled())</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div></div><!-- fragment --><p> This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.</p>
<p>Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods</p><ul>
<li>Ogre::RTShader::SubRenderStateFactory::createInstanceImpl(): This method should return instance for the SubRenderState sub class.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#a954d30cb82307ae1ba785792b833b689" title="Create an instance of the SubRenderState sub class it suppose to create. ">Ogre::RTShader::SubRenderStateFactory::createInstance()</a>: This method should return instasnce for the SubRenderState sub class using the given script compiler parameters. Implemet this method if you want to be able to creat your custom shader extension from material script.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#ada31909080bae96784504be42d9bd77c" title="Write the given sub-render state instance using the material serializer. ">Ogre::RTShader::SubRenderStateFactory::writeInstance()</a>: This method should write down the parameters of a given SubRenderState instance to material script file. Implement this method if you want to be able to export a material that contains your custom shader extension.</li>
</ul>
<h2><a class="anchor" id="debugging"></a>
Tips for debugging shaders</h2>
<p>A couple of notes on debugging shaders coming from the RTSS:</p><ul>
<li>Call <a class="el" href="class_ogre_bites_1_1_application_context.html#aaad4c1d25a7a5f60dd5c5f3812f1096b" title="make the RTSS write out the generated shaders for caching and debugging ">OgreBites::ApplicationContext::setRTSSWriteShadersToDisk</a>. This will cache the generated shaders onto the disk under the directory <code>{<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> directory}\Samples\Media\RTShaderLib\cache</code>. This is important for 2 reasons:<ul>
<li>It will make compilation problems easier to detect.</li>
<li>Once a shader is written to the disk, as long as you don't change the code behind it, the same shader will be picked up in the next application run even if its content has changed. If you have compilation or visual problems with the shader you can try to manually tinker with it without compiling the code again and again.</li>
</ul>
</li>
<li>Find the file OgreShaderProgramManager.cpp and add a breakpoint at <code>pGpuProgram.setNull();</code> (in createGpuProgram). If a shader will fail to compile it will usually fail there. Once that happens you can find the shader name under the <code>programName</code> parameter, then look for it in the cache directory you created.</li>
<li>Other common problems with creating shaders in RTSS usually occur from defining vertex shader parameters and using them in the pixel shader and vice versa. so watch out for those.</li>
</ul>
<h1><a class="anchor" id="history"></a>
Historical background</h1>
<p>When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).</p>
<p>As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.</p>
<p>Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.</p>
<p>The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.</p>
<p>With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.</p>
<h1><a class="anchor" id="pros-cons"></a>
Pros and Cons</h1>
<p>Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders</p><ul>
<li>Hardware animation (a.k.a hardware skinning)</li>
<li>Soft shadows</li>
<li>Normal/Bump maps</li>
<li>Specular maps</li>
<li>Advanced multi-texturing effects</li>
</ul>
<p>Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.</p>
<p>So why use a runtime shader system anyway?</p>
<ul>
<li>Save development time e.g. when your target scene has dynamic lights and the number changes, fog changes, ... and the number of material attributes increases the total count of needed shaders dramatically. It can easily cross 100 and it becomes a time consuming development task.</li>
<li>Reusable code - once you've written the shader extension you can use it anywhere due to its independent nature.</li>
<li>Custom shaders extension library - enjoy the shared library of effects created by the community. Unlike hand written shader code, which may require many adjustments to be plugged into your own shader code, using the extensions library requires minimum changes. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: RTSS: Run Time Shader System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rtss.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">RTSS: Run Time Shader System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#core-feats">Core features of the system</a></li>
<li class="level1"><a href="#rtss_overview">System overview</a><ul><li class="level2"><a href="#rtss_custom_api">Customising via API</a></li>
<li class="level2"><a href="#rtss_custom_mat">Customizing via Material Script</a></li>
</ul>
</li>
<li class="level1"><a href="#rtss_indepth">The RTSS in Depth</a><ul><li class="level2"><a href="#rtss__components">Main components</a></li>
<li class="level2"><a href="#creating-extensions">Creating custom shader extensions</a></li>
<li class="level2"><a href="#debugging">Tips for debugging shaders</a></li>
</ul>
</li>
<li class="level1"><a href="#history">Historical background</a></li>
<li class="level1"><a href="#pros-cons">Pros and Cons</a></li>
</ul>
</div>
<div class="textblock"><p>This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.</p>
<h1><a class="anchor" id="core-feats"></a>
Core features of the system</h1>
<ul>
<li>Runtime shader generation synchronized with scene state. Each time scene settings change, a new set of shaders is generated.</li>
<li>Full Fixed Function Pipeline (FFP) emulation. This feature is most useful combined with render system that doesn't provide any FFP functionality (OpenGL ES 2.0, D3D11 etc).</li>
<li>Shader language independent interface: the logic representation of the shader programs is completely independent from the target shader language. You can generate code for different shader languages from the same program.</li>
<li>Pluggable interface allows extending the target shader languages set.</li>
<li>Pluggable interface allows adding new shader based effects to the system in a seamless way. Each effect code will be automatically combined with the rest of the shader code.</li>
<li>Smart program management: each shader program is created only once and may be used by multiple passes.</li>
<li>Automatic vertex shader compacting mechanism: no more compacting variables by hand. In case the amount of used vertex shader output registers exceeds the maximum allowed (12 to 32, depending on <a href="http://msdn.microsoft.com/en-us/library/bb172918%28v=VS.85%29.aspx">D3DPSHADERCAPS2_0.NumTemps</a>), a compacting algorithm packs the vertex shader outputs and adds unpack code in the fragment shader side.</li>
<li>Material script support, for both export and import.</li>
</ul>
<h1><a class="anchor" id="rtss_overview"></a>
System overview</h1>
<p>The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.</p>
<p>Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.</p>
<p>To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.</p>
<p>After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.</p>
<p>Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates</p>
<div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">uniform mat4    worldviewproj_matrix;</div><div class="line">uniform mat4    texture_matrix1;</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">in  vec4    vertex;</div><div class="line">in  vec4    uv0;</div><div class="line">out vec4    oTexcoord4_0;</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    FFP_Transform(worldviewproj_matrix, vertex, gl_Position);</div><div class="line">    FFP_TransformTexCoord(texture_matrix1, uv0.xy, oTexcoord4_0.xy);</div><div class="line">}</div></div><!-- fragment --><p>It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)</p>
<p>Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.</p>
<p>The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.</p>
<h2><a class="anchor" id="rtss_custom_api"></a>
Customising via API</h2>
<p>The first option is to globally enforce per-pixel lighting, you can do the following</p>
<div class="fragment"><div class="line">        <span class="comment">// Grab the scheme render state.</span></div><div class="line">        <a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">Ogre::RTShader::RenderState</a>* schemRenderState =</div><div class="line">            mShaderGenerator-&gt;getRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line">        <span class="comment">// Add per pixel lighting sub render state to the global scheme render state.</span></div><div class="line">        <span class="comment">// It will override the default FFP lighting sub render state.</span></div><div class="line">        <span class="keywordflow">if</span> (usePerPixelLighting) {</div><div class="line">            <a class="code" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">Ogre::RTShader::SubRenderState</a>* perPixelLightModel =</div><div class="line">                mShaderGenerator-&gt;createSubRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_per_pixel_lighting.html#ae766f76cad4b3a4339a0cd50abbddcc2">Ogre::RTShader::PerPixelLighting::Type</a>);</div><div class="line"></div><div class="line">            schemRenderState-&gt;<a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html#af66edaf33c654e03ef89f1eaec384a1f">addTemplateSubRenderState</a>(perPixelLightModel);</div><div class="line">        }</div></div><!-- fragment --><p> any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.</p>
<h2><a class="anchor" id="rtss_custom_mat"></a>
Customizing via Material Script</h2>
<p>Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following</p>
<div class="fragment"><div class="line">            <span class="comment">// RT Shader system section.</span></div><div class="line">            rtshader_system</div><div class="line">            {       </div><div class="line">                <span class="comment">// Override lighting stage with per pixel lighting.             </span></div><div class="line">                lighting_stage per_pixel                </div><div class="line">            }   </div></div><!-- fragment --><p> for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.</p>
<p>Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:</p>
<ul>
<li><a href="#lighting_stage">lighting_stage</a></li>
<li><a href="#light_count">light_count</a></li>
<li><a href="#triplanarTexturing">triplanarTexturing</a></li>
<li><a href="#integrated_pssm4">integrated_pssm4</a></li>
<li><a href="#layered_blend">layered_blend</a></li>
<li><a href="#source_modifier">source_modifier</a></li>
</ul>
<p><a class="anchor" id="lighting_stage"></a></p>
<h3>lighting_stage</h3>
<p>Force a specific lighting model.</p>
<p>Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code></p>
<p>Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code></p>
<p>Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_r_t_shader_1_1_normal_map_lighting.html#adc6b4bdd1ea31c2232336599d2b30b60" title="Normal map space definition. ">Ogre::RTShader::NormalMapLighting::NormalMapSpace</a> </dd>
<dd>
<a class="el" href="group___general.html#ga21a0186392e9c9ce16d29c5568a773c5" title="High-level filtering options providing shortcuts to settings the minification, magnification and mip ...">Ogre::TextureFilterOptions</a></dd></dl>
<p><a class="anchor" id="light_count"></a></p>
<h3>light_count</h3>
<p>Override dynamic light count. Allows to customize which lights the RTSS will consider.</p>
<p>Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code></p>
<p><a class="anchor" id="triplanarTexturing"></a></p>
<h3>triplanarTexturing</h3>
<p>Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a></p>
<p>Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code></p>
<p>Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureScale</td><td>texture coordinates are multiplied by this. </td></tr>
    <tr><td class="paramname">plateauSize</td><td>plateau on which small components of the normal have no influence. </td></tr>
    <tr><td class="paramname">transitionSpeed</td><td>transitions speed between the three textures Valid values are [0; 0.57] not bigger to avoid division by zero </td></tr>
    <tr><td class="paramname">textureFromX</td><td>Texture for the x-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromY</td><td>Texture for the y-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromZ</td><td>Texture for the z-direction planar mapping</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="integrated_pssm4"></a></p>
<h3>integrated_pssm4</h3>
<p>Integrated PSSM shadow receiver with 3 splits. Custom split points.</p>
<p>Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code></p>
<p><a class="anchor" id="layered_blend"></a></p>
<h3>layered_blend</h3>
<p>Apply photoshop-like blend effects to texture layers</p>
<p>Format: <code>layered_blend &lt;effect&gt;</code></p>
<p>Example: layered_blend luminosity</p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">effect</td><td>one of <code>default, normal, lighten, darken, multiply, average, add, subtract, difference, negation, exclusion, screen, overlay, hard_light, soft_light, color_dodge, color_burn, linear_dodge, linear_burn, linear_light, vivid_light, pin_light, hard_mix, reflect, glow, phoenix, saturation, color, luminosity</code></td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="source_modifier"></a></p>
<h3>source_modifier</h3>
<p>Apply custom modulate effect to texture layer</p>
<p>Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code></p>
<p>Example: <code>source_modifier src1_inverse_modulate custom 2</code></p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>one of <code>src1_modulate, src2_modulate, src1_inverse_modulate, src2_inverse_modulate</code> </td></tr>
    <tr><td class="paramname">parameterNum</td><td>number of the custom shader parameter that controls the operation</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="rtss_indepth"></a>
The RTSS in Depth</h1>
<p>When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.</p>
<p>The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).</p>
<p>Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.</p>
<p>The following steps are executed in order to generate shaders for a given technique:</p>
<ul>
<li>For each pass in the technique the system builds a set of sub render states that describe the logic process of the rendering pipeline from the draw call submission until the final pixel color.</li>
<li>Each render state is translated into a set of logic shader programs (currently only pixel and vertex shader). The logic programs are then sent to specific shader language writers that produce source code for the respective shader language. The source code is used to create the GPU programs that are applied to the destination pass. Before rendering of an object that uses generated shaders the system allows each sub render state to update the GPU constants associated with it.</li>
</ul>
<h2>Initializing the system</h2>
<dl class="section note"><dt>Note</dt><dd>If you are using the <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>, the following steps will be taken automatically for you.</dd></dl>
<p>Initializing the system is composed of the following steps:</p><ul>
<li>Create the internal managers and structures via the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260" title="Initialize the Shader Generator System. ">Ogre::RTShader::ShaderGenerator::initialize()</a></code> method.</li>
<li>Set the target cache path. This is the place on your disk where the output shaders will be written to or will be read from in case they were generated by previous runs of your application.</li>
<li>Verify that the location of the shader libs needed by the system is added to the ResourceGroupManager via the <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d" title="Adds a location to the list of searchable locations for a Resource type. ">Ogre::ResourceGroupManager::addResourceLocation()</a></code> method.</li>
<li>Assign the target scene manager to the shader generator.</li>
<li>Add one or more specialized sub-render states that are to be shared among all materials (per pixel lighting, textured fog, etc...).</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260">Ogre::RTShader::ShaderGenerator::initialize</a>())</div><div class="line">{</div><div class="line">    <span class="comment">// Grab the shader generator pointer.</span></div><div class="line">    mShaderGenerator = <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">Ogre::RTShader::ShaderGenerator::getSingletonPtr</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Add the shader libs resource location. a sample shader lib can be found in Samples\Media\RTShaderLib</span></div><div class="line">    <a class="code" href="class_ogre_1_1_resource_group_manager.html#a45101333f0f9ff132fc381dd5c4a1d60">Ogre::ResourceGroupManager::getSingleton</a>().<a class="code" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d">addResourceLocation</a>(shaderLibPath, <span class="stringliteral">&quot;FileSystem&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Set shader cache path.</span></div><div class="line">    mShaderGenerator-&gt;setShaderCachePath(shaderCachePath);      </div><div class="line"></div><div class="line">    <span class="comment">// Set the scene manager.</span></div><div class="line">    mShaderGenerator-&gt;addSceneManager(sceneMgr);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><h2>Creating shader based technique</h2>
<p>This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.</p>
<p>To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.</p>
<p>Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// Create shader based technique from the default technique of the given material.</span></div><div class="line">mShaderGenerator-&gt;createShaderBasedTechnique(<span class="stringliteral">&quot;Examples/BeachStones&quot;</span>, <a class="code" href="class_ogre_1_1_material_manager.html#a290b828b5d44637ee4d247a09ea81bd6">Ogre::MaterialManager::DEFAULT_SCHEME_NAME</a>, <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line"><span class="comment">// Apply the shader generated based techniques.</span></div><div class="line">mViewport-&gt;setMaterialScheme(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div></div><!-- fragment --> <div class="image">
<object type="image/svg+xml" data="CreateShaderBasedTech.svg">CreateShaderBasedTech.svg</object>
</div>
<h2>Runtime shader generation</h2>
<p>During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.</p>
<div class="image">
<object type="image/svg+xml" data="RuntimeShaderGeneration.svg">RuntimeShaderGeneration.svg</object>
</div>
<h2><a class="anchor" id="rtss__components"></a>
Main components</h2>
<p>The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.</p>
<h3>ShaderGenerator</h3>
<p>The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.</p>
<h3>RenderState classes</h3>
<p>A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.</p>
<p>RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.</p>
<h3>SubRenderState classes</h3>
<p>Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.</p>
<p>There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_transform.html" title="Transform sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTransform</a> - responsible for adding code to the vertex shader which computes the position of the vertex in projection space</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_colour.html" title="Colour sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPColour</a> - responsible for adding code to the shaders that calculate the base diffuse and specular color of the object regardless of lights or textures. The color is calculated based on the ambient, diffuse, specular and emissive properties of the object and scene, color tracking and the specified hardware buffer color.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_lighting.html" title="Lighting sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPLighting</a> - responsible for adding code to the shaders that calculate the luminescence added to the object by light. Then add that value to the color calculated by the color SRS stage.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_texturing.html" title="Texturing sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTexturing</a> - responsible for adding code that modulates the color of the pixels based on textures assigned to the material.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_fog.html" title="Fog sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPFog</a> - responsible for adding code that modulates the color of a pixel based on the scene or object fog parameters.</li>
</ul>
<p>There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...</p>
<h3>SubRenderStateFactory</h3>
<p>As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.</p>
<p>These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.</p>
<h2><a class="anchor" id="creating-extensions"></a>
Creating custom shader extensions</h2>
<p>Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.</p>
<p>In order to extend the system with your own shader effects you'll have to follow these steps:</p><ul>
<li>Implement the SubRenderState interface - This is the main class that is responsible for the actual effect processing such as preparing the destination pass, updating the CPU shader programs, updating the GPU shader parameters etc.</li>
<li>Implement the SubRenderStateFactory interface: This class will allow the RTSS to create instances of the previous class via code or script as well as export it to material script file.</li>
<li>Register the factory to the RTSS using the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac266946244d79b2d4732607ae9479bd9" title="Add sub render state factory. ">Ogre::RTShader::ShaderGenerator::addSubRenderStateFactory</a> method.</li>
<li>Add shader files that will supply all the actual shader functions your SubRenderState needs. In order to support multiple shader languages you should supply code for your entire desired target shading languages (CG, HLSL, GLSL etc). These files should be placed in a way that the resource manager could access them. This can be done by placing them in a valid resource location or by dynamically adding resource location.</li>
</ul>
<p>Implementing the SubRenderState requires overriding the pure methods of the base class.</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#ae91b7b8f76848d67652b6e5832a27a49" title="Get the type of this sub render state. ">Ogre::RTShader::SubRenderState::getType()</a> should return unique string that identify the sub class implementation. That value is shared among all instances and can be stored in a static string variable. It uses to system to match between SubRenderState instance and the factory to should destroy it.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#acb48c34ee231f0220f68c967fb32f1e5" title="Get the execution order of this sub render state. ">Ogre::RTShader::SubRenderState::getExecutionOrder()</a> should return integer value that will use the system to sort all SubRenderState instances of the same render state before each one of them will create its part in the CPU shader programs. Note that:<ul>
<li>The execution order does not imply the order of the parameter definitions and function calls within the generated shader.</li>
<li>If an execution number is set to be the same as one of the basic fixed pipeline SRSs. Than that SRS will be built <b>instead</b> of the fixed pipeline SRS.</li>
</ul>
</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a5dfe9f03413e0fe99ea2640f06c1f13c" title="Copy details from a given sub render state to this one. ">Ogre::RTShader::SubRenderState::copyFrom()</a> a simple copy method that uses the system when coping one instance to another. <b>Note:</b> Only configuration data attributes should be copy here.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4b43c261946926ebbc6456deccc6697a" title="Create sub programs that represents this sub render state as part of a program set. ">Ogre::RTShader::SubRenderState::createCpuSubPrograms</a> - This is the heart of this interface. This method should update the CPU shader programs with the specific details of the overriding class.</li>
</ul>
<p>The SubRenderState supply default implementation for this method which break down this method into three stages:</p><ul>
<li>Resolving parameters: this stage should grab all the needed parameters for this SubRrenderState. In case of the FFPTransform it should resolve the world view projection matrix and vertex shader input and output position parameters.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Function* vsEntry = vsProgram-&gt;getEntryPointFunction();</div><div class="line">    </div><div class="line">    <span class="comment">// Resolve World View Projection Matrix.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#ae0e6b89f6ed3986b0a87e2472e3ff7f1">UniformParameterPtr</a> wvpMatrix = vsProgram-&gt;resolveAutoParameterInt(GpuProgramParameters::ACT_WORLDVIEWPROJ_MATRIX, 0);</div><div class="line">        </div><div class="line">    <span class="comment">// Resolve input position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionIn = vsEntry-&gt;resolveInputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_OBJECT_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>); </div><div class="line">    </div><div class="line">    <span class="comment">// Resolve output position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionOut = vsEntry-&gt;resolveOutputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_PROJECTIVE_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!wvpMatrix || !positionIn || !positionOut)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___general.html#gaf27f0d64dfeb225d37a513c253eaa1a0">OGRE_EXCEPT</a>( Exception::ERR_INTERNAL_ERROR, </div><div class="line">                <span class="stringliteral">&quot;Not all parameters could be constructed for the sub-render state.&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;FFPTransform::createCpuSubPrograms&quot;</span> );</div><div class="line">    }</div></div><!-- fragment --><ul>
<li>Resolving dependencies: this stage should provide the name of the external shader library files that contains the actual shader code needed by this SubRenderState. In case of the FFPTexturing it will add the common and texturing library for both vertex and pixel shader program.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Program* psProgram = programSet-&gt;getCpuFragmentProgram();</div><div class="line"></div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);    </div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);</div></div><!-- fragment --><ul>
<li>Adding function invocations: this stage creates the function calls within this SubRenderState requires. Each function call has two keys that are used by the system to sort it before generating the actual shader code as well as set of in/out parameters. A function invocation is added to either vertex shader program or fragment shader program. In case of the FFPFog it will add vertex depth calculation to the vertex shader program.</li>
</ul>
<div class="fragment"><div class="line">        curFuncInvocation = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> FunctionInvocation(<a class="code" href="group___r_t_shader.html#gabaab1e89270cd7f763f2f8e0258c400e">FFP_FUNC_PIXELFOG_DEPTH</a>, <a class="code" href="group___r_t_shader.html#gga7d20b2397c3eab2b52ec405863c6f274a8b4930a3fd90d5b7222960fc5727b8cf">FFP_VS_FOG</a>);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mWorldViewProjMatrix, Operand::OPS_IN);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSInPos, Operand::OPS_IN);  </div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSOutDepth, Operand::OPS_OUT);  </div><div class="line">        vsMain-&gt;addAtomInstance(curFuncInvocation);     </div></div><!-- fragment --><p> Note:</p><ul>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can add as many function invocations as it needs.</li>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can different function invocations in different ordering.</li>
<li>The ordering of the function invocation is crucial. Use the FFPVertexShaderStage and FFPFragmentShaderStage enumarations to place your invocations in the desired order.</li>
<li>Make sure the parameter semantic (in/out) in the SubRenderState code matches to your shader code implementation you supplied in the library file. GLSL will fail to link to libray functions if it won't be able to find a perfect function declaration match.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4c2acbc15e44c3fe42868abce1116ec2" title="Update GPU programs parameters before a rendering operation occurs. ">Ogre::RTShader::SubRenderState::updateGpuProgramsParams</a> - As the name suggest this method should be overridden only in case your SubRenderState should update some parameter it created before.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#afd08043cfad43a1ae470c3c1be341ba1" title="Called before adding this sub render state to the given render state. ">Ogre::RTShader::SubRenderState::preAddToRenderState()</a>: this method called before adding this SubRenderState to a parent RenderState instances. It allows this SubRenderState to exclude itself from the list in case the source pass is not matching. I.E in case of SubRenderState that perform lighting calculations it can return false when the given source pass specifies that lighting calculations disabled for it.</li>
</ul>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (!srcPass-&gt;getLightingEnabled())</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div></div><!-- fragment --><p> This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.</p>
<p>Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods</p><ul>
<li>Ogre::RTShader::SubRenderStateFactory::createInstanceImpl(): This method should return instance for the SubRenderState sub class.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#a954d30cb82307ae1ba785792b833b689" title="Create an instance of the SubRenderState sub class it suppose to create. ">Ogre::RTShader::SubRenderStateFactory::createInstance()</a>: This method should return instasnce for the SubRenderState sub class using the given script compiler parameters. Implemet this method if you want to be able to creat your custom shader extension from material script.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#ada31909080bae96784504be42d9bd77c" title="Write the given sub-render state instance using the material serializer. ">Ogre::RTShader::SubRenderStateFactory::writeInstance()</a>: This method should write down the parameters of a given SubRenderState instance to material script file. Implement this method if you want to be able to export a material that contains your custom shader extension.</li>
</ul>
<h2><a class="anchor" id="debugging"></a>
Tips for debugging shaders</h2>
<p>A couple of notes on debugging shaders coming from the RTSS:</p><ul>
<li>Call <a class="el" href="class_ogre_bites_1_1_application_context.html#aaad4c1d25a7a5f60dd5c5f3812f1096b" title="make the RTSS write out the generated shaders for caching and debugging ">OgreBites::ApplicationContext::setRTSSWriteShadersToDisk</a>. This will cache the generated shaders onto the disk under the directory <code>{<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> directory}\Samples\Media\RTShaderLib\cache</code>. This is important for 2 reasons:<ul>
<li>It will make compilation problems easier to detect.</li>
<li>Once a shader is written to the disk, as long as you don't change the code behind it, the same shader will be picked up in the next application run even if its content has changed. If you have compilation or visual problems with the shader you can try to manually tinker with it without compiling the code again and again.</li>
</ul>
</li>
<li>Find the file OgreShaderProgramManager.cpp and add a breakpoint at <code>pGpuProgram.setNull();</code> (in createGpuProgram). If a shader will fail to compile it will usually fail there. Once that happens you can find the shader name under the <code>programName</code> parameter, then look for it in the cache directory you created.</li>
<li>Other common problems with creating shaders in RTSS usually occur from defining vertex shader parameters and using them in the pixel shader and vice versa. so watch out for those.</li>
</ul>
<h1><a class="anchor" id="history"></a>
Historical background</h1>
<p>When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).</p>
<p>As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.</p>
<p>Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.</p>
<p>The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.</p>
<p>With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.</p>
<h1><a class="anchor" id="pros-cons"></a>
Pros and Cons</h1>
<p>Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders</p><ul>
<li>Hardware animation (a.k.a hardware skinning)</li>
<li>Soft shadows</li>
<li>Normal/Bump maps</li>
<li>Specular maps</li>
<li>Advanced multi-texturing effects</li>
</ul>
<p>Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.</p>
<p>So why use a runtime shader system anyway?</p>
<ul>
<li>Save development time e.g. when your target scene has dynamic lights and the number changes, fog changes, ... and the number of material attributes increases the total count of needed shaders dramatically. It can easily cross 100 and it becomes a time consuming development task.</li>
<li>Reusable code - once you've written the shader extension you can use it anywhere due to its independent nature.</li>
<li>Custom shaders extension library - enjoy the shared library of effects created by the community. Unlike hand written shader code, which may require many adjustments to be plugged into your own shader code, using the extensions library requires minimum changes. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: HLMS: High Level Material System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hlms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HLMS: High Level Material System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#components">The three components</a></li>
<li class="level1"><a href="#materials">Compared to classical materials</a></li>
<li class="level1"><a href="#data">Material parameters are stored in “Blocks”</a><ul><li class="level2"><a href="#toc52">Datablocks</a></li>
</ul>
</li>
<li class="level1"><a href="#toc69">Hlms templates</a><ul><li class="level2"><a href="#preproc">The Hlms preprocessor</a></li>
<li class="level2"><a href="#syntax">Preprocessor syntax</a></li>
</ul>
</li>
<li class="level1"><a href="#shaders">Creation of shaders</a></li>
<li class="level1"><a href="#cpp">C++ interaction with shader templates</a></li>
<li class="level1"><a href="#customization">Customization</a></li>
</ul>
</div>
<div class="textblock"><p>This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.</p>
<p>Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.</p>
<p>Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.</p>
<p>But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.</p>
<p>Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.</p>
<h1><a class="anchor" id="components"></a>
The three components</h1>
<div class="image">
<object type="image/svg+xml" data="hlms_components.svg">hlms_components.svg</object>
</div>
<ol type="1">
<li>Scripts. To set the material properties (i.e. type of Hlms to use: PBS, Toon shading, GUI; what textures, diffuse colour, roughness, etc). <b>You currently have to do this from C++.</b> Everybody will be using this part.</li>
<li>Shader template. The Hlms takes a couple hand-written glsl/hlsl files as template and then adapts it to fit the needs on the fly (i.e. if the mesh doesn’t contain skeleton, the bit of code pertaining to skeletal animation is stripped from the vertex shader). The Hlms provides a simple preprocessor to deal with this entirely within from the template, but you’re not forced to use it. Here’s a simple example of the preprocessor. I won’t be explaining the main keywords today. Advanced users will probably want to modify these files (or write some of their own) to fit their custom needs.</li>
<li>C++ classes implementation. The C++ takes care of picking the shader templates and manipulating them before compiling; and most importantly it feeds the shaders with uniform/constans data and sets the textures that are being in use. It is extremely flexible, powerful, efficient and scalable, but it’s harder to use than good ol’ Materials because those used to be data-driven: there are no AutoParamsSource here. Want the view matrix? You better grab it from the camera when the scene pass is about to start, and then pass it yourself to the shader. This is very powerful, because in D3D11/GL3+ you can just set the uniform buffer with the view matrix just once for the entire frame, and thus have multiple uniforms buffers sorted by update frequency. Very advanced user will be using messing with this part.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Material scripts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.x do not yet support the HLMS - you must use the C++ API. e.g. <a class="el" href="class_ogre_1_1_pbs_material.html">Ogre::PbsMaterial</a>.</dd></dl>
<p>Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.</p>
<p>For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.</p>
<p>It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.</p>
<h1><a class="anchor" id="materials"></a>
Compared to classical materials</h1>
<p>Materials are still useful for:</p>
<ul>
<li>Quick iteration. You need to write a shader, just define the material and start coding. Why would you deal with the template’s syntax or a C++ module when you can just write a script and start coding?. The HLMS though comes with a Command line tool to know how your template translates into a final shader (which is very handy for iteration, it’s fast, and will check for syntax errors!), but it’s most useful when you want to write your own C++ module or change the template, not when you want to just experiment. Besides, old timers are used to writing materials.</li>
<li>Postprocessing effects. Materials are much better suited for this. Materials are data driven, easy to write. Postprocessing FXs don’t need an awful lot of permutations (i.e. having to deal with shadow mapping, instancing, skeleton animation, facial animation). And they’re at no performance disadvantage compared to HLMS: Each FX is a fullscreen pass that needs different shaders, different textures, its own uniforms. Basically, API overhead we can’t optimize. But it doesn’t matter much either, because it’s not like there are 100 fullscreen passes. Usually there’s less than 10.</li>
</ul>
<h1><a class="anchor" id="data"></a>
Material parameters are stored in “Blocks”</h1>
<p>You could be thinking the reason I came up with these two is to fit with D3D11′s grand scheme of things while being compatible with OpenGL. But that’s a half truth and an awesome side effect. I’ve been developing the Hlms using OpenGL this whole time.</p>
<p>An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and they’re right about that.</p>
<p>However, there are big advantages for using blocks:</p>
<ol type="1">
<li>Many materials in practice share the same Macro- &amp; Blendblock parameters. In an age where we want many 3D primitives with the same shader but slightly different parameters like texture, colour, or roughness (which equals, a different material) having these settings repeated per material wastes a lot of memory space… and a lot of bandwidth (and wastes cache space). <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 is bandwidth bound, so having all materials share the same pointer to the same Macroblock can potentially save a lot of bandwidth, and be friendlier to the cache at the same time.This stays true whether we use D3D11, D3D12, OpenGL, GL ES 2, or Mantle.</li>
<li>Sorting by Macroblock is a lot easier (and faster) than sorting by its individual parameters: when preparing the hash used for sorting, it’s much easier to just do (every frame, per object) <code>hash |= (macroblock-&gt;getId() &lt;&lt; bits) &amp; mask</code> than to do: <code>hash =| m-&gt;depth_check | m-&gt;depthWrite &lt;&lt; 1 | m-&gt;depthBias &lt;&lt; 2 | m-&gt;depth_slope_bias &lt;&lt; 3 | m-&gt;cullMode &lt;&lt; 18 | ... ;</code> We also need a lot more bits we can’t afford. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 imposes a limit on the amount of live Macroblocks you can have at the same time; as we run out of hashing space (by the way, D3D11 has its own limit). It operates around the idea that most setting combinations won’t be used in practice.</li>
</ol>
<p>Of course it’s not perfect, it can’t fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); you’ll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. We’re aiming the general use case.</p>
<p>These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since I’m not used to driver development. However from an engine perspective, blocks make sense.</p>
<h2><a class="anchor" id="toc52"></a>
Datablocks</h2>
<p>We’re introducing the concept of Datablocks. A Datablock is a “material” from the user’s perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.</p>
<div class="image">
<object type="image/svg+xml" data="hlms_blocks.svg">hlms_blocks.svg</object>
</div>
<p>The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.</p>
<dl class="section note"><dt>Note</dt><dd>Macroblocks and Blendblocks are not available in 1.x - use <a class="el" href="class_ogre_1_1_pass.html#ae454faee87f8cb0b8540810e48118788" title="Sets whether or not this pass renders with depth-buffer checking on or not. ">Ogre::Pass::setDepthCheckEnabled</a> etc. as usual, to change the respective properties</dd></dl>
<h1><a class="anchor" id="toc69"></a>
Hlms templates</h1>
<p>The Hlms will parse the template files from the template folder according to the following rules:</p>
<ol type="1">
<li>The files with the names "VertexShader_vs", "PixelShader_ps", "GeometryShader_gs", "HullShader_hs", "DomainShader_ds" will be fully parsed and compiled into the shader. If an implementation only provides "VertexShader_vs.glslt", "PixelShader_ps.glslt"; only the vertex and pixel shaders for OpenGL will be created. There will be no geometry or tesellation shaders.</li>
<li>The files that contain the string "_piece_vs" in their filenames will be parsed only for collecting pieces (more on pieces later). Likewise, the words "_piece_ps", "_piece_gs", "_piece_hs", "_piece_ds” correspond to the pieces for their respective shader stages. Note that you can concatenate, thus "MyUtilities_piece_vs_piece_ps.glslt” will be collected both in the vertex and pixel shader stages.</li>
</ol>
<p>The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.</p>
<h2><a class="anchor" id="preproc"></a>
The Hlms preprocessor</h2>
<p>The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.</p>
<p>For example </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can't evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can't check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable “IncludeLightingEquals2” and check whether it's non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can't see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you'll depend on the driver implementation having a good macro preprocessor.</p>
<h2><a class="anchor" id="syntax"></a>
Preprocessor syntax</h2>
<p>The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:</p>
<ul>
<li>@property</li>
<li>@foreach</li>
<li>@counter</li>
<li>@value</li>
<li>@set add sub mul div mod min max</li>
<li>@piece</li>
<li>@insertpiece</li>
<li>@pset padd psub pmul pdiv pmod pmin pmax</li>
</ul>
<h3>@property( expression )</h3>
<p>Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.</p>
<p>The logical operands &amp;&amp; || ! are valid.</p>
<p>Examples: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: </p><div class="fragment"><div class="line">hasLights != 0                              hasLights == 0</div><div class="line">diffuse = surfaceDiffuse * lightDiffuse;   diffuse = surfaceDiffuse ;</div></div><!-- fragment --><h3>@foreach( scopedVar, count, [start] )</h3>
<p>Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.</p>
<ul>
<li>scopedVar is a variable that can be used to print the current iteration of the loop while inside the block. i.e. “@scopedVar” will be converted into a number in the range [start; count)</li>
<li>count The number of times to repeat the loop (if start = 0). Count can read variables.</li>
<li>start Optional. Allows to start from a value different than 0. Start can read variables.</li>
</ul>
<p>Newlines are very important, as they will be printed with the loop.</p>
<p>Examples: </p><table class="doxtable">
<tr>
<th>Expression </th><th>Output  </th></tr>
<tr>
<td>@foreach( 4, n ) <br />
&emsp; @n@end </td><td><br />
0<br />
1<br />
2<br />
3 </td></tr>
<tr>
<td>@foreach( 4, n ) @n@end </td><td>0 1 2 3 </td></tr>
<tr>
<td>@foreach( 4, n )<br />
&emsp;@n<br />
@end </td><td><br />
0<br />
<br />
1<br />
<br />
2<br />
<br />
3<br />
 </td></tr>
<tr>
<td>@foreach( 4, n, 2 ) @n@end </td><td>2 3 </td></tr>
<tr>
<td>@pset( myStartVar, 1 )<br />
@pset( myCountVar, 3 )<br />
@foreach( myStartVar, n, myCountVar )<br />
&emsp;@n@end </td><td>1<br />
2 </td></tr>
<tr>
<td>@foreach( 2, n )<br />
&emsp;@insertpiece( pieceName@n )@end </td><td>@insertpiece( pieceName0 )<br />
 @insertpiece( pieceName1 ) </td></tr>
</table>
<blockquote class="doxtable">
<p><b>Attention #1!</b></p>
<p>Don't use the common letter i for the loop counter. It will conflict with other keywords.</p>
<p>i.e. “@foreach( 1, i )@insertpiece( pieceName )@end” will print “0nsertpiece( pieceName )” which is probably not what you intended.</p>
<p><b>Attention #2!</b></p>
<p>foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.</p>
<p>i.e. The following code will not work:</p>
<div class="fragment"><div class="line">@pset( myVar, 1 )</div><div class="line"></div><div class="line">@<span class="keywordflow">foreach</span>( 2, n )</div><div class="line"></div><div class="line"><span class="comment">//Code</span></div><div class="line"></div><div class="line">@psub( myVar, 1 ) <span class="comment">//Decrement myVar on each loop</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( myVar )</div><div class="line"></div><div class="line"><span class="comment">//Code that shouldn&#39;t be printed in the last iteration</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>Because psub will be evaluated before expanding the foreach. </p>
</blockquote>
<h3>@counter( variable )</h3>
<p>Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.</p>
<p>Examples: </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@counter( myVar )   1</div><div class="line"></div><div class="line">@counter( myVar )   2</div></div><!-- fragment --><h3>@value( variable )</h3>
<p>Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@value( myVar )     1</div><div class="line"></div><div class="line">@value( myVar )     1</div></div><!-- fragment --><h3>@set add sub mul div mod min max</h3>
<p>Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.</p>
<p>Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c</p>
<p>Useful in combination with @counter and @value</p>
<table class="doxtable">
<tr>
<th>Expression </th><th>Output </th><th>Math  </th></tr>
<tr>
<td>@set( myVar, 1 ) <br />
 @value( myVar ) </td><td>1 </td><td>myVar = 1 </td></tr>
<tr>
<td>@add( myVar, 5 )<br />
 @value( myVar ) </td><td>6 </td><td>myVar = 1 + 5 </td></tr>
<tr>
<td>@div( myVar, 2 ) <br />
 @value( myVar ) </td><td>3 </td><td>myVar = 6 / 2 </td></tr>
<tr>
<td>@mul( myVar, myVar )<br />
 @value( myVar ) </td><td>9 </td><td>myVar = 3 * 3 </td></tr>
<tr>
<td>@mod( myVar, 5 ) <br />
 @value( myVar ) </td><td>4 </td><td>myVar = 9 % 5 </td></tr>
<tr>
<td>@add( myVar, 1, 1 ) <br />
 @value( myVar ) </td><td>2 </td><td>myVar = 1 + 1 </td></tr>
</table>
<h3>@piece( nameOfPiece )</h3>
<p>Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won't be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                        Output</div><div class="line"></div><div class="line">@piece( VertexTransform )         </div><div class="line"></div><div class="line">outPos = worldViewProj * inPos   </div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><h3>@insertpiece( nameOfPiece )</h3>
<p>Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                                                     Output</div><div class="line"></div><div class="line">@piece( VertexTransform )outPos = worldViewProj * inPos@end   void main()</div><div class="line"></div><div class="line">void main()                                                    {</div><div class="line"></div><div class="line">{                                                              outPos = worldViewProj * inPos</div><div class="line"></div><div class="line">@insertpiece( VertexTransform )                                }</div><div class="line"></div><div class="line">@insertpiece( InexistentPiece )                                </div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h3>@pset padd psub pmul pdiv pmod pmin pmax</h3>
<p>Analogous to <a href="#toc304"><em>the family of math functions without the 'p' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.</p>
<p>i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )</p>
<p>One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.</p>
<p>If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.</p>
<h1><a class="anchor" id="shaders"></a>
Creation of shaders</h1>
<p>There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:</p>
<ol type="1">
<li>The Datablock/Material. Does it have Normal maps? Then include code to sample the normal map and affect the lighting calculations. Does it have a diffuse map? If not, avoid sampling the diffuse map and multiplying it against the diffuse colour, etc.</li>
<li>The Mesh. Is it skeletally animated? Then include skeletal animation code. How many blend weights? Modify the skeletal animation code appropiately. It doesn't have tangents? Then skip the normal map defined in the material. And so on.</li>
</ol>
<p>When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.</p>
<p>If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).</p>
<p>The following graph summarizes the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_hash.svg">hlms_hash.svg</object>
</div>
<p>Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a “<a href="#toc567"><em>pass hash</em></a>” instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).</p>
<p>While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_caching.svg">hlms_caching.svg</object>
</div>
<h1><a class="anchor" id="cpp"></a>
C++ interaction with shader templates</h1>
<p>Note: This section is relevant to those seeking to write their own Hlms implementation.</p>
<p>C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set “key” to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod</p>
<p>To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.</p>
<p>The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.</p>
<p>In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.</p>
<p>Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.</p>
<p>For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.</p>
<p>The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.</p>
<h2>Common conventions</h2>
<p>Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.</p>
<p>Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.</p>
<p>For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.</p>
<p>Properties in underscore_case are set from C++; propierties in camelCase are set from the template.</p>
<p>Propierties and pieces starting with 'custom_' are for user customizations of the template</p>
<p>TBD</p>
<h2>Disabling a stage</h2>
<p>By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.</p>
<p>Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.</p>
<h1><a class="anchor" id="customization"></a>
Customization</h1>
<p>In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.</p>
<p>Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.</p>
<p>Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.</p>
<p>There are different levels in which an Hlms implementation can be customized:</p>
<ol type="1">
<li>Using a library, see <a href="#toc574"><em>Hlms Initialization</em></a>. pass a set of piece files in a folder by pushing the folder to ArchiveVec. The files in that folder will be parsed first, in order (archiveVec[0] then archiveVec[1], … archiveVec[N-1]); which will let you define your own pieces to insert code into the default template (see the the table at the end). You can also do clever tricky things to avoid dealing with C++ code at all even if there are no 'custom_' pieces for it. For example, you can write the following code to override the BRDF declarations and provide a custom BRDF: <div class="fragment"><div class="line"><span class="comment">//Disable all known BRDFs that the implementation may enable</span></div><div class="line"></div><div class="line">@pset( BRDF_CookTorrance, 0 )</div><div class="line"></div><div class="line">@pset( BRDF_Default, 0 )</div><div class="line"></div><div class="line">@piece( DeclareBRDF )</div><div class="line"></div><div class="line"><span class="comment">// Your BRDF code declaration here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --></li>
</ol>
<ol type="1">
<li>Via listener, through HlmsListener. This allows you to have access to the buffer pass to fill extra information; or bind extra buffers to the shader.</li>
<li>Overload HlmsPbs. Useful for overriding only specific parts, or adding new functionality that requires storing extra information in a datablock (e.g. overload HlmsPbsDatablock to add more variables, and then overload HlmsPbs::createDatablockImpl to create these custom datablocks)</li>
<li>Directly modify HlmsPbs, HlmsPbsDatablock and the template. <table class="doxtable">
<tr>
<th>Variable </th><th>Description  </th></tr>
<tr>
<td>custom_passBuffer </td><td>Piece where users can add extra information for the pass buffer (only useful if the user is using HlmsListener or overloaded HlmsPbs. </td></tr>
<tr>
<td>custom_VStoPS </td><td>Piece where users can add more interpolants for passing data from the vertex to the pixel shader. </td></tr>
<tr>
<td>custom_vs_attributes </td><td>Custom vertex shader attributes in the Vertex Shader (i.e. a special texcoord, etc). </td></tr>
<tr>
<td>custom_vs_uniformDeclaration </td><td>Data declaration (textures, texture buffers, uniform buffers) in the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_posExecution </td><td>Executed after all code from the Vertex Shader has been performed. </td></tr>
<tr>
<td>custom_ps_uniformDeclaration </td><td>Same as custom_vs_uniformDeclaration, but for the Pixel Shader </td></tr>
<tr>
<td>custom_ps_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Pixel Shader. </td></tr>
<tr>
<td>custom_ps_posMaterialLoad </td><td>Executed right after loading material data; and before anything else. May not get executed if there is no relevant material data (i.e. doesn't have normals or QTangents for lighting calculation) </td></tr>
<tr>
<td>custom_ps_preLights </td><td>Executed right before any light (i.e. to perform your own ambient / global illumination pass). All relevant texture data should be loaded by now. </td></tr>
<tr>
<td>custom_ps_posExecution </td><td>Executed after all code from the Pixel Shader has been performed. </td></tr>
</table>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: HLMS: High Level Material System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hlms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HLMS: High Level Material System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#components">The three components</a></li>
<li class="level1"><a href="#materials">Compared to classical materials</a></li>
<li class="level1"><a href="#data">Material parameters are stored in “Blocks”</a><ul><li class="level2"><a href="#toc52">Datablocks</a></li>
</ul>
</li>
<li class="level1"><a href="#toc69">Hlms templates</a><ul><li class="level2"><a href="#preproc">The Hlms preprocessor</a></li>
<li class="level2"><a href="#syntax">Preprocessor syntax</a></li>
</ul>
</li>
<li class="level1"><a href="#shaders">Creation of shaders</a></li>
<li class="level1"><a href="#cpp">C++ interaction with shader templates</a></li>
<li class="level1"><a href="#customization">Customization</a></li>
</ul>
</div>
<div class="textblock"><p>This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.</p>
<p>Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.</p>
<p>Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.</p>
<p>But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.</p>
<p>Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.</p>
<h1><a class="anchor" id="components"></a>
The three components</h1>
<div class="image">
<object type="image/svg+xml" data="hlms_components.svg">hlms_components.svg</object>
</div>
<ol type="1">
<li>Scripts. To set the material properties (i.e. type of Hlms to use: PBS, Toon shading, GUI; what textures, diffuse colour, roughness, etc). <b>You currently have to do this from C++.</b> Everybody will be using this part.</li>
<li>Shader template. The Hlms takes a couple hand-written glsl/hlsl files as template and then adapts it to fit the needs on the fly (i.e. if the mesh doesn’t contain skeleton, the bit of code pertaining to skeletal animation is stripped from the vertex shader). The Hlms provides a simple preprocessor to deal with this entirely within from the template, but you’re not forced to use it. Here’s a simple example of the preprocessor. I won’t be explaining the main keywords today. Advanced users will probably want to modify these files (or write some of their own) to fit their custom needs.</li>
<li>C++ classes implementation. The C++ takes care of picking the shader templates and manipulating them before compiling; and most importantly it feeds the shaders with uniform/constans data and sets the textures that are being in use. It is extremely flexible, powerful, efficient and scalable, but it’s harder to use than good ol’ Materials because those used to be data-driven: there are no AutoParamsSource here. Want the view matrix? You better grab it from the camera when the scene pass is about to start, and then pass it yourself to the shader. This is very powerful, because in D3D11/GL3+ you can just set the uniform buffer with the view matrix just once for the entire frame, and thus have multiple uniforms buffers sorted by update frequency. Very advanced user will be using messing with this part.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Material scripts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.x do not yet support the HLMS - you must use the C++ API. e.g. <a class="el" href="class_ogre_1_1_pbs_material.html">Ogre::PbsMaterial</a>.</dd></dl>
<p>Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.</p>
<p>For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.</p>
<p>It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.</p>
<h1><a class="anchor" id="materials"></a>
Compared to classical materials</h1>
<p>Materials are still useful for:</p>
<ul>
<li>Quick iteration. You need to write a shader, just define the material and start coding. Why would you deal with the template’s syntax or a C++ module when you can just write a script and start coding?. The HLMS though comes with a Command line tool to know how your template translates into a final shader (which is very handy for iteration, it’s fast, and will check for syntax errors!), but it’s most useful when you want to write your own C++ module or change the template, not when you want to just experiment. Besides, old timers are used to writing materials.</li>
<li>Postprocessing effects. Materials are much better suited for this. Materials are data driven, easy to write. Postprocessing FXs don’t need an awful lot of permutations (i.e. having to deal with shadow mapping, instancing, skeleton animation, facial animation). And they’re at no performance disadvantage compared to HLMS: Each FX is a fullscreen pass that needs different shaders, different textures, its own uniforms. Basically, API overhead we can’t optimize. But it doesn’t matter much either, because it’s not like there are 100 fullscreen passes. Usually there’s less than 10.</li>
</ul>
<h1><a class="anchor" id="data"></a>
Material parameters are stored in “Blocks”</h1>
<p>You could be thinking the reason I came up with these two is to fit with D3D11′s grand scheme of things while being compatible with OpenGL. But that’s a half truth and an awesome side effect. I’ve been developing the Hlms using OpenGL this whole time.</p>
<p>An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and they’re right about that.</p>
<p>However, there are big advantages for using blocks:</p>
<ol type="1">
<li>Many materials in practice share the same Macro- &amp; Blendblock parameters. In an age where we want many 3D primitives with the same shader but slightly different parameters like texture, colour, or roughness (which equals, a different material) having these settings repeated per material wastes a lot of memory space… and a lot of bandwidth (and wastes cache space). <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 is bandwidth bound, so having all materials share the same pointer to the same Macroblock can potentially save a lot of bandwidth, and be friendlier to the cache at the same time.This stays true whether we use D3D11, D3D12, OpenGL, GL ES 2, or Mantle.</li>
<li>Sorting by Macroblock is a lot easier (and faster) than sorting by its individual parameters: when preparing the hash used for sorting, it’s much easier to just do (every frame, per object) <code>hash |= (macroblock-&gt;getId() &lt;&lt; bits) &amp; mask</code> than to do: <code>hash =| m-&gt;depth_check | m-&gt;depthWrite &lt;&lt; 1 | m-&gt;depthBias &lt;&lt; 2 | m-&gt;depth_slope_bias &lt;&lt; 3 | m-&gt;cullMode &lt;&lt; 18 | ... ;</code> We also need a lot more bits we can’t afford. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 imposes a limit on the amount of live Macroblocks you can have at the same time; as we run out of hashing space (by the way, D3D11 has its own limit). It operates around the idea that most setting combinations won’t be used in practice.</li>
</ol>
<p>Of course it’s not perfect, it can’t fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); you’ll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. We’re aiming the general use case.</p>
<p>These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since I’m not used to driver development. However from an engine perspective, blocks make sense.</p>
<h2><a class="anchor" id="toc52"></a>
Datablocks</h2>
<p>We’re introducing the concept of Datablocks. A Datablock is a “material” from the user’s perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.</p>
<div class="image">
<object type="image/svg+xml" data="hlms_blocks.svg">hlms_blocks.svg</object>
</div>
<p>The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.</p>
<dl class="section note"><dt>Note</dt><dd>Macroblocks and Blendblocks are not available in 1.x - use <a class="el" href="class_ogre_1_1_pass.html#ae454faee87f8cb0b8540810e48118788" title="Sets whether or not this pass renders with depth-buffer checking on or not. ">Ogre::Pass::setDepthCheckEnabled</a> etc. as usual, to change the respective properties</dd></dl>
<h1><a class="anchor" id="toc69"></a>
Hlms templates</h1>
<p>The Hlms will parse the template files from the template folder according to the following rules:</p>
<ol type="1">
<li>The files with the names "VertexShader_vs", "PixelShader_ps", "GeometryShader_gs", "HullShader_hs", "DomainShader_ds" will be fully parsed and compiled into the shader. If an implementation only provides "VertexShader_vs.glslt", "PixelShader_ps.glslt"; only the vertex and pixel shaders for OpenGL will be created. There will be no geometry or tesellation shaders.</li>
<li>The files that contain the string "_piece_vs" in their filenames will be parsed only for collecting pieces (more on pieces later). Likewise, the words "_piece_ps", "_piece_gs", "_piece_hs", "_piece_ds” correspond to the pieces for their respective shader stages. Note that you can concatenate, thus "MyUtilities_piece_vs_piece_ps.glslt” will be collected both in the vertex and pixel shader stages.</li>
</ol>
<p>The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.</p>
<h2><a class="anchor" id="preproc"></a>
The Hlms preprocessor</h2>
<p>The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.</p>
<p>For example </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can't evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can't check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable “IncludeLightingEquals2” and check whether it's non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can't see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you'll depend on the driver implementation having a good macro preprocessor.</p>
<h2><a class="anchor" id="syntax"></a>
Preprocessor syntax</h2>
<p>The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:</p>
<ul>
<li>@property</li>
<li>@foreach</li>
<li>@counter</li>
<li>@value</li>
<li>@set add sub mul div mod min max</li>
<li>@piece</li>
<li>@insertpiece</li>
<li>@pset padd psub pmul pdiv pmod pmin pmax</li>
</ul>
<h3>@property( expression )</h3>
<p>Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.</p>
<p>The logical operands &amp;&amp; || ! are valid.</p>
<p>Examples: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: </p><div class="fragment"><div class="line">hasLights != 0                              hasLights == 0</div><div class="line">diffuse = surfaceDiffuse * lightDiffuse;   diffuse = surfaceDiffuse ;</div></div><!-- fragment --><h3>@foreach( scopedVar, count, [start] )</h3>
<p>Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.</p>
<ul>
<li>scopedVar is a variable that can be used to print the current iteration of the loop while inside the block. i.e. “@scopedVar” will be converted into a number in the range [start; count)</li>
<li>count The number of times to repeat the loop (if start = 0). Count can read variables.</li>
<li>start Optional. Allows to start from a value different than 0. Start can read variables.</li>
</ul>
<p>Newlines are very important, as they will be printed with the loop.</p>
<p>Examples: </p><table class="doxtable">
<tr>
<th>Expression </th><th>Output  </th></tr>
<tr>
<td>@foreach( 4, n ) <br />
&emsp; @n@end </td><td><br />
0<br />
1<br />
2<br />
3 </td></tr>
<tr>
<td>@foreach( 4, n ) @n@end </td><td>0 1 2 3 </td></tr>
<tr>
<td>@foreach( 4, n )<br />
&emsp;@n<br />
@end </td><td><br />
0<br />
<br />
1<br />
<br />
2<br />
<br />
3<br />
 </td></tr>
<tr>
<td>@foreach( 4, n, 2 ) @n@end </td><td>2 3 </td></tr>
<tr>
<td>@pset( myStartVar, 1 )<br />
@pset( myCountVar, 3 )<br />
@foreach( myStartVar, n, myCountVar )<br />
&emsp;@n@end </td><td>1<br />
2 </td></tr>
<tr>
<td>@foreach( 2, n )<br />
&emsp;@insertpiece( pieceName@n )@end </td><td>@insertpiece( pieceName0 )<br />
 @insertpiece( pieceName1 ) </td></tr>
</table>
<blockquote class="doxtable">
<p><b>Attention #1!</b></p>
<p>Don't use the common letter i for the loop counter. It will conflict with other keywords.</p>
<p>i.e. “@foreach( 1, i )@insertpiece( pieceName )@end” will print “0nsertpiece( pieceName )” which is probably not what you intended.</p>
<p><b>Attention #2!</b></p>
<p>foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.</p>
<p>i.e. The following code will not work:</p>
<div class="fragment"><div class="line">@pset( myVar, 1 )</div><div class="line"></div><div class="line">@<span class="keywordflow">foreach</span>( 2, n )</div><div class="line"></div><div class="line"><span class="comment">//Code</span></div><div class="line"></div><div class="line">@psub( myVar, 1 ) <span class="comment">//Decrement myVar on each loop</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( myVar )</div><div class="line"></div><div class="line"><span class="comment">//Code that shouldn&#39;t be printed in the last iteration</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>Because psub will be evaluated before expanding the foreach. </p>
</blockquote>
<h3>@counter( variable )</h3>
<p>Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.</p>
<p>Examples: </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@counter( myVar )   1</div><div class="line"></div><div class="line">@counter( myVar )   2</div></div><!-- fragment --><h3>@value( variable )</h3>
<p>Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@value( myVar )     1</div><div class="line"></div><div class="line">@value( myVar )     1</div></div><!-- fragment --><h3>@set add sub mul div mod min max</h3>
<p>Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.</p>
<p>Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c</p>
<p>Useful in combination with @counter and @value</p>
<table class="doxtable">
<tr>
<th>Expression </th><th>Output </th><th>Math  </th></tr>
<tr>
<td>@set( myVar, 1 ) <br />
 @value( myVar ) </td><td>1 </td><td>myVar = 1 </td></tr>
<tr>
<td>@add( myVar, 5 )<br />
 @value( myVar ) </td><td>6 </td><td>myVar = 1 + 5 </td></tr>
<tr>
<td>@div( myVar, 2 ) <br />
 @value( myVar ) </td><td>3 </td><td>myVar = 6 / 2 </td></tr>
<tr>
<td>@mul( myVar, myVar )<br />
 @value( myVar ) </td><td>9 </td><td>myVar = 3 * 3 </td></tr>
<tr>
<td>@mod( myVar, 5 ) <br />
 @value( myVar ) </td><td>4 </td><td>myVar = 9 % 5 </td></tr>
<tr>
<td>@add( myVar, 1, 1 ) <br />
 @value( myVar ) </td><td>2 </td><td>myVar = 1 + 1 </td></tr>
</table>
<h3>@piece( nameOfPiece )</h3>
<p>Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won't be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                        Output</div><div class="line"></div><div class="line">@piece( VertexTransform )         </div><div class="line"></div><div class="line">outPos = worldViewProj * inPos   </div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><h3>@insertpiece( nameOfPiece )</h3>
<p>Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                                                     Output</div><div class="line"></div><div class="line">@piece( VertexTransform )outPos = worldViewProj * inPos@end   void main()</div><div class="line"></div><div class="line">void main()                                                    {</div><div class="line"></div><div class="line">{                                                              outPos = worldViewProj * inPos</div><div class="line"></div><div class="line">@insertpiece( VertexTransform )                                }</div><div class="line"></div><div class="line">@insertpiece( InexistentPiece )                                </div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h3>@pset padd psub pmul pdiv pmod pmin pmax</h3>
<p>Analogous to <a href="#toc304"><em>the family of math functions without the 'p' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.</p>
<p>i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )</p>
<p>One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.</p>
<p>If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.</p>
<h1><a class="anchor" id="shaders"></a>
Creation of shaders</h1>
<p>There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:</p>
<ol type="1">
<li>The Datablock/Material. Does it have Normal maps? Then include code to sample the normal map and affect the lighting calculations. Does it have a diffuse map? If not, avoid sampling the diffuse map and multiplying it against the diffuse colour, etc.</li>
<li>The Mesh. Is it skeletally animated? Then include skeletal animation code. How many blend weights? Modify the skeletal animation code appropiately. It doesn't have tangents? Then skip the normal map defined in the material. And so on.</li>
</ol>
<p>When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.</p>
<p>If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).</p>
<p>The following graph summarizes the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_hash.svg">hlms_hash.svg</object>
</div>
<p>Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a “<a href="#toc567"><em>pass hash</em></a>” instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).</p>
<p>While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_caching.svg">hlms_caching.svg</object>
</div>
<h1><a class="anchor" id="cpp"></a>
C++ interaction with shader templates</h1>
<p>Note: This section is relevant to those seeking to write their own Hlms implementation.</p>
<p>C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set “key” to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod</p>
<p>To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.</p>
<p>The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.</p>
<p>In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.</p>
<p>Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.</p>
<p>For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.</p>
<p>The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.</p>
<h2>Common conventions</h2>
<p>Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.</p>
<p>Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.</p>
<p>For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.</p>
<p>Properties in underscore_case are set from C++; propierties in camelCase are set from the template.</p>
<p>Propierties and pieces starting with 'custom_' are for user customizations of the template</p>
<p>TBD</p>
<h2>Disabling a stage</h2>
<p>By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.</p>
<p>Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.</p>
<h1><a class="anchor" id="customization"></a>
Customization</h1>
<p>In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.</p>
<p>Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.</p>
<p>Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.</p>
<p>There are different levels in which an Hlms implementation can be customized:</p>
<ol type="1">
<li>Using a library, see <a href="#toc574"><em>Hlms Initialization</em></a>. pass a set of piece files in a folder by pushing the folder to ArchiveVec. The files in that folder will be parsed first, in order (archiveVec[0] then archiveVec[1], … archiveVec[N-1]); which will let you define your own pieces to insert code into the default template (see the the table at the end). You can also do clever tricky things to avoid dealing with C++ code at all even if there are no 'custom_' pieces for it. For example, you can write the following code to override the BRDF declarations and provide a custom BRDF: <div class="fragment"><div class="line"><span class="comment">//Disable all known BRDFs that the implementation may enable</span></div><div class="line"></div><div class="line">@pset( BRDF_CookTorrance, 0 )</div><div class="line"></div><div class="line">@pset( BRDF_Default, 0 )</div><div class="line"></div><div class="line">@piece( DeclareBRDF )</div><div class="line"></div><div class="line"><span class="comment">// Your BRDF code declaration here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --></li>
</ol>
<ol type="1">
<li>Via listener, through HlmsListener. This allows you to have access to the buffer pass to fill extra information; or bind extra buffers to the shader.</li>
<li>Overload HlmsPbs. Useful for overriding only specific parts, or adding new functionality that requires storing extra information in a datablock (e.g. overload HlmsPbsDatablock to add more variables, and then overload HlmsPbs::createDatablockImpl to create these custom datablocks)</li>
<li>Directly modify HlmsPbs, HlmsPbsDatablock and the template. <table class="doxtable">
<tr>
<th>Variable </th><th>Description  </th></tr>
<tr>
<td>custom_passBuffer </td><td>Piece where users can add extra information for the pass buffer (only useful if the user is using HlmsListener or overloaded HlmsPbs. </td></tr>
<tr>
<td>custom_VStoPS </td><td>Piece where users can add more interpolants for passing data from the vertex to the pixel shader. </td></tr>
<tr>
<td>custom_vs_attributes </td><td>Custom vertex shader attributes in the Vertex Shader (i.e. a special texcoord, etc). </td></tr>
<tr>
<td>custom_vs_uniformDeclaration </td><td>Data declaration (textures, texture buffers, uniform buffers) in the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_posExecution </td><td>Executed after all code from the Vertex Shader has been performed. </td></tr>
<tr>
<td>custom_ps_uniformDeclaration </td><td>Same as custom_vs_uniformDeclaration, but for the Pixel Shader </td></tr>
<tr>
<td>custom_ps_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Pixel Shader. </td></tr>
<tr>
<td>custom_ps_posMaterialLoad </td><td>Executed right after loading material data; and before anything else. May not get executed if there is no relevant material data (i.e. doesn't have normals or QTangents for lighting calculation) </td></tr>
<tr>
<td>custom_ps_preLights </td><td>Executed right before any light (i.e. to perform your own ambient / global illumination pass). All relevant texture data should be loaded by now. </td></tr>
<tr>
<td>custom_ps_posExecution </td><td>Executed after all code from the Pixel Shader has been performed. </td></tr>
</table>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: RTSS: Run Time Shader System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rtss.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">RTSS: Run Time Shader System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#core-feats">Core features of the system</a></li>
<li class="level1"><a href="#rtss_overview">System overview</a><ul><li class="level2"><a href="#rtss_custom_api">Customising via API</a></li>
<li class="level2"><a href="#rtss_custom_mat">Customizing via Material Script</a></li>
</ul>
</li>
<li class="level1"><a href="#rtss_indepth">The RTSS in Depth</a><ul><li class="level2"><a href="#rtss__components">Main components</a></li>
<li class="level2"><a href="#creating-extensions">Creating custom shader extensions</a></li>
<li class="level2"><a href="#debugging">Tips for debugging shaders</a></li>
</ul>
</li>
<li class="level1"><a href="#history">Historical background</a></li>
<li class="level1"><a href="#pros-cons">Pros and Cons</a></li>
</ul>
</div>
<div class="textblock"><p>This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.</p>
<h1><a class="anchor" id="core-feats"></a>
Core features of the system</h1>
<ul>
<li>Runtime shader generation synchronized with scene state. Each time scene settings change, a new set of shaders is generated.</li>
<li>Full Fixed Function Pipeline (FFP) emulation. This feature is most useful combined with render system that doesn't provide any FFP functionality (OpenGL ES 2.0, D3D11 etc).</li>
<li>Shader language independent interface: the logic representation of the shader programs is completely independent from the target shader language. You can generate code for different shader languages from the same program.</li>
<li>Pluggable interface allows extending the target shader languages set.</li>
<li>Pluggable interface allows adding new shader based effects to the system in a seamless way. Each effect code will be automatically combined with the rest of the shader code.</li>
<li>Smart program management: each shader program is created only once and may be used by multiple passes.</li>
<li>Automatic vertex shader compacting mechanism: no more compacting variables by hand. In case the amount of used vertex shader output registers exceeds the maximum allowed (12 to 32, depending on <a href="http://msdn.microsoft.com/en-us/library/bb172918%28v=VS.85%29.aspx">D3DPSHADERCAPS2_0.NumTemps</a>), a compacting algorithm packs the vertex shader outputs and adds unpack code in the fragment shader side.</li>
<li>Material script support, for both export and import.</li>
</ul>
<h1><a class="anchor" id="rtss_overview"></a>
System overview</h1>
<p>The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.</p>
<p>Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.</p>
<p>To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.</p>
<p>After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.</p>
<p>Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates</p>
<div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">uniform mat4    worldviewproj_matrix;</div><div class="line">uniform mat4    texture_matrix1;</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">in  vec4    vertex;</div><div class="line">in  vec4    uv0;</div><div class="line">out vec4    oTexcoord4_0;</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    FFP_Transform(worldviewproj_matrix, vertex, gl_Position);</div><div class="line">    FFP_TransformTexCoord(texture_matrix1, uv0.xy, oTexcoord4_0.xy);</div><div class="line">}</div></div><!-- fragment --><p>It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)</p>
<p>Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.</p>
<p>The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.</p>
<h2><a class="anchor" id="rtss_custom_api"></a>
Customising via API</h2>
<p>The first option is to globally enforce per-pixel lighting, you can do the following</p>
<div class="fragment"><div class="line">        <span class="comment">// Grab the scheme render state.</span></div><div class="line">        <a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">Ogre::RTShader::RenderState</a>* schemRenderState =</div><div class="line">            mShaderGenerator-&gt;getRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line">        <span class="comment">// Add per pixel lighting sub render state to the global scheme render state.</span></div><div class="line">        <span class="comment">// It will override the default FFP lighting sub render state.</span></div><div class="line">        <span class="keywordflow">if</span> (usePerPixelLighting) {</div><div class="line">            <a class="code" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">Ogre::RTShader::SubRenderState</a>* perPixelLightModel =</div><div class="line">                mShaderGenerator-&gt;createSubRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_per_pixel_lighting.html#ae766f76cad4b3a4339a0cd50abbddcc2">Ogre::RTShader::PerPixelLighting::Type</a>);</div><div class="line"></div><div class="line">            schemRenderState-&gt;<a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html#af66edaf33c654e03ef89f1eaec384a1f">addTemplateSubRenderState</a>(perPixelLightModel);</div><div class="line">        }</div></div><!-- fragment --><p> any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.</p>
<h2><a class="anchor" id="rtss_custom_mat"></a>
Customizing via Material Script</h2>
<p>Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following</p>
<div class="fragment"><div class="line">            <span class="comment">// RT Shader system section.</span></div><div class="line">            rtshader_system</div><div class="line">            {       </div><div class="line">                <span class="comment">// Override lighting stage with per pixel lighting.             </span></div><div class="line">                lighting_stage per_pixel                </div><div class="line">            }   </div></div><!-- fragment --><p> for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.</p>
<p>Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:</p>
<ul>
<li><a href="#lighting_stage">lighting_stage</a></li>
<li><a href="#light_count">light_count</a></li>
<li><a href="#triplanarTexturing">triplanarTexturing</a></li>
<li><a href="#integrated_pssm4">integrated_pssm4</a></li>
<li><a href="#layered_blend">layered_blend</a></li>
<li><a href="#source_modifier">source_modifier</a></li>
</ul>
<p><a class="anchor" id="lighting_stage"></a></p>
<h3>lighting_stage</h3>
<p>Force a specific lighting model.</p>
<p>Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code></p>
<p>Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code></p>
<p>Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_r_t_shader_1_1_normal_map_lighting.html#adc6b4bdd1ea31c2232336599d2b30b60" title="Normal map space definition. ">Ogre::RTShader::NormalMapLighting::NormalMapSpace</a> </dd>
<dd>
<a class="el" href="group___general.html#ga21a0186392e9c9ce16d29c5568a773c5" title="High-level filtering options providing shortcuts to settings the minification, magnification and mip ...">Ogre::TextureFilterOptions</a></dd></dl>
<p><a class="anchor" id="light_count"></a></p>
<h3>light_count</h3>
<p>Override dynamic light count. Allows to customize which lights the RTSS will consider.</p>
<p>Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code></p>
<p><a class="anchor" id="triplanarTexturing"></a></p>
<h3>triplanarTexturing</h3>
<p>Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a></p>
<p>Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code></p>
<p>Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureScale</td><td>texture coordinates are multiplied by this. </td></tr>
    <tr><td class="paramname">plateauSize</td><td>plateau on which small components of the normal have no influence. </td></tr>
    <tr><td class="paramname">transitionSpeed</td><td>transitions speed between the three textures Valid values are [0; 0.57] not bigger to avoid division by zero </td></tr>
    <tr><td class="paramname">textureFromX</td><td>Texture for the x-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromY</td><td>Texture for the y-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromZ</td><td>Texture for the z-direction planar mapping</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="integrated_pssm4"></a></p>
<h3>integrated_pssm4</h3>
<p>Integrated PSSM shadow receiver with 3 splits. Custom split points.</p>
<p>Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code></p>
<p><a class="anchor" id="layered_blend"></a></p>
<h3>layered_blend</h3>
<p>Apply photoshop-like blend effects to texture layers</p>
<p>Format: <code>layered_blend &lt;effect&gt;</code></p>
<p>Example: layered_blend luminosity</p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">effect</td><td>one of <code>default, normal, lighten, darken, multiply, average, add, subtract, difference, negation, exclusion, screen, overlay, hard_light, soft_light, color_dodge, color_burn, linear_dodge, linear_burn, linear_light, vivid_light, pin_light, hard_mix, reflect, glow, phoenix, saturation, color, luminosity</code></td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="source_modifier"></a></p>
<h3>source_modifier</h3>
<p>Apply custom modulate effect to texture layer</p>
<p>Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code></p>
<p>Example: <code>source_modifier src1_inverse_modulate custom 2</code></p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>one of <code>src1_modulate, src2_modulate, src1_inverse_modulate, src2_inverse_modulate</code> </td></tr>
    <tr><td class="paramname">parameterNum</td><td>number of the custom shader parameter that controls the operation</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="rtss_indepth"></a>
The RTSS in Depth</h1>
<p>When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.</p>
<p>The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).</p>
<p>Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.</p>
<p>The following steps are executed in order to generate shaders for a given technique:</p>
<ul>
<li>For each pass in the technique the system builds a set of sub render states that describe the logic process of the rendering pipeline from the draw call submission until the final pixel color.</li>
<li>Each render state is translated into a set of logic shader programs (currently only pixel and vertex shader). The logic programs are then sent to specific shader language writers that produce source code for the respective shader language. The source code is used to create the GPU programs that are applied to the destination pass. Before rendering of an object that uses generated shaders the system allows each sub render state to update the GPU constants associated with it.</li>
</ul>
<h2>Initializing the system</h2>
<dl class="section note"><dt>Note</dt><dd>If you are using the <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>, the following steps will be taken automatically for you.</dd></dl>
<p>Initializing the system is composed of the following steps:</p><ul>
<li>Create the internal managers and structures via the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260" title="Initialize the Shader Generator System. ">Ogre::RTShader::ShaderGenerator::initialize()</a></code> method.</li>
<li>Set the target cache path. This is the place on your disk where the output shaders will be written to or will be read from in case they were generated by previous runs of your application.</li>
<li>Verify that the location of the shader libs needed by the system is added to the ResourceGroupManager via the <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d" title="Adds a location to the list of searchable locations for a Resource type. ">Ogre::ResourceGroupManager::addResourceLocation()</a></code> method.</li>
<li>Assign the target scene manager to the shader generator.</li>
<li>Add one or more specialized sub-render states that are to be shared among all materials (per pixel lighting, textured fog, etc...).</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260">Ogre::RTShader::ShaderGenerator::initialize</a>())</div><div class="line">{</div><div class="line">    <span class="comment">// Grab the shader generator pointer.</span></div><div class="line">    mShaderGenerator = <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">Ogre::RTShader::ShaderGenerator::getSingletonPtr</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Add the shader libs resource location. a sample shader lib can be found in Samples\Media\RTShaderLib</span></div><div class="line">    <a class="code" href="class_ogre_1_1_resource_group_manager.html#a45101333f0f9ff132fc381dd5c4a1d60">Ogre::ResourceGroupManager::getSingleton</a>().<a class="code" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d">addResourceLocation</a>(shaderLibPath, <span class="stringliteral">&quot;FileSystem&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Set shader cache path.</span></div><div class="line">    mShaderGenerator-&gt;setShaderCachePath(shaderCachePath);      </div><div class="line"></div><div class="line">    <span class="comment">// Set the scene manager.</span></div><div class="line">    mShaderGenerator-&gt;addSceneManager(sceneMgr);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><h2>Creating shader based technique</h2>
<p>This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.</p>
<p>To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.</p>
<p>Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// Create shader based technique from the default technique of the given material.</span></div><div class="line">mShaderGenerator-&gt;createShaderBasedTechnique(<span class="stringliteral">&quot;Examples/BeachStones&quot;</span>, <a class="code" href="class_ogre_1_1_material_manager.html#a290b828b5d44637ee4d247a09ea81bd6">Ogre::MaterialManager::DEFAULT_SCHEME_NAME</a>, <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line"><span class="comment">// Apply the shader generated based techniques.</span></div><div class="line">mViewport-&gt;setMaterialScheme(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div></div><!-- fragment --> <div class="image">
<object type="image/svg+xml" data="CreateShaderBasedTech.svg">CreateShaderBasedTech.svg</object>
</div>
<h2>Runtime shader generation</h2>
<p>During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.</p>
<div class="image">
<object type="image/svg+xml" data="RuntimeShaderGeneration.svg">RuntimeShaderGeneration.svg</object>
</div>
<h2><a class="anchor" id="rtss__components"></a>
Main components</h2>
<p>The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.</p>
<h3>ShaderGenerator</h3>
<p>The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.</p>
<h3>RenderState classes</h3>
<p>A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.</p>
<p>RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.</p>
<h3>SubRenderState classes</h3>
<p>Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.</p>
<p>There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_transform.html" title="Transform sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTransform</a> - responsible for adding code to the vertex shader which computes the position of the vertex in projection space</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_colour.html" title="Colour sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPColour</a> - responsible for adding code to the shaders that calculate the base diffuse and specular color of the object regardless of lights or textures. The color is calculated based on the ambient, diffuse, specular and emissive properties of the object and scene, color tracking and the specified hardware buffer color.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_lighting.html" title="Lighting sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPLighting</a> - responsible for adding code to the shaders that calculate the luminescence added to the object by light. Then add that value to the color calculated by the color SRS stage.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_texturing.html" title="Texturing sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTexturing</a> - responsible for adding code that modulates the color of the pixels based on textures assigned to the material.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_fog.html" title="Fog sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPFog</a> - responsible for adding code that modulates the color of a pixel based on the scene or object fog parameters.</li>
</ul>
<p>There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...</p>
<h3>SubRenderStateFactory</h3>
<p>As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.</p>
<p>These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.</p>
<h2><a class="anchor" id="creating-extensions"></a>
Creating custom shader extensions</h2>
<p>Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.</p>
<p>In order to extend the system with your own shader effects you'll have to follow these steps:</p><ul>
<li>Implement the SubRenderState interface - This is the main class that is responsible for the actual effect processing such as preparing the destination pass, updating the CPU shader programs, updating the GPU shader parameters etc.</li>
<li>Implement the SubRenderStateFactory interface: This class will allow the RTSS to create instances of the previous class via code or script as well as export it to material script file.</li>
<li>Register the factory to the RTSS using the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac266946244d79b2d4732607ae9479bd9" title="Add sub render state factory. ">Ogre::RTShader::ShaderGenerator::addSubRenderStateFactory</a> method.</li>
<li>Add shader files that will supply all the actual shader functions your SubRenderState needs. In order to support multiple shader languages you should supply code for your entire desired target shading languages (CG, HLSL, GLSL etc). These files should be placed in a way that the resource manager could access them. This can be done by placing them in a valid resource location or by dynamically adding resource location.</li>
</ul>
<p>Implementing the SubRenderState requires overriding the pure methods of the base class.</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#ae91b7b8f76848d67652b6e5832a27a49" title="Get the type of this sub render state. ">Ogre::RTShader::SubRenderState::getType()</a> should return unique string that identify the sub class implementation. That value is shared among all instances and can be stored in a static string variable. It uses to system to match between SubRenderState instance and the factory to should destroy it.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#acb48c34ee231f0220f68c967fb32f1e5" title="Get the execution order of this sub render state. ">Ogre::RTShader::SubRenderState::getExecutionOrder()</a> should return integer value that will use the system to sort all SubRenderState instances of the same render state before each one of them will create its part in the CPU shader programs. Note that:<ul>
<li>The execution order does not imply the order of the parameter definitions and function calls within the generated shader.</li>
<li>If an execution number is set to be the same as one of the basic fixed pipeline SRSs. Than that SRS will be built <b>instead</b> of the fixed pipeline SRS.</li>
</ul>
</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a5dfe9f03413e0fe99ea2640f06c1f13c" title="Copy details from a given sub render state to this one. ">Ogre::RTShader::SubRenderState::copyFrom()</a> a simple copy method that uses the system when coping one instance to another. <b>Note:</b> Only configuration data attributes should be copy here.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4b43c261946926ebbc6456deccc6697a" title="Create sub programs that represents this sub render state as part of a program set. ">Ogre::RTShader::SubRenderState::createCpuSubPrograms</a> - This is the heart of this interface. This method should update the CPU shader programs with the specific details of the overriding class.</li>
</ul>
<p>The SubRenderState supply default implementation for this method which break down this method into three stages:</p><ul>
<li>Resolving parameters: this stage should grab all the needed parameters for this SubRrenderState. In case of the FFPTransform it should resolve the world view projection matrix and vertex shader input and output position parameters.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Function* vsEntry = vsProgram-&gt;getEntryPointFunction();</div><div class="line">    </div><div class="line">    <span class="comment">// Resolve World View Projection Matrix.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#ae0e6b89f6ed3986b0a87e2472e3ff7f1">UniformParameterPtr</a> wvpMatrix = vsProgram-&gt;resolveAutoParameterInt(GpuProgramParameters::ACT_WORLDVIEWPROJ_MATRIX, 0);</div><div class="line">        </div><div class="line">    <span class="comment">// Resolve input position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionIn = vsEntry-&gt;resolveInputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_OBJECT_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>); </div><div class="line">    </div><div class="line">    <span class="comment">// Resolve output position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionOut = vsEntry-&gt;resolveOutputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_PROJECTIVE_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!wvpMatrix || !positionIn || !positionOut)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___general.html#gaf27f0d64dfeb225d37a513c253eaa1a0">OGRE_EXCEPT</a>( Exception::ERR_INTERNAL_ERROR, </div><div class="line">                <span class="stringliteral">&quot;Not all parameters could be constructed for the sub-render state.&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;FFPTransform::createCpuSubPrograms&quot;</span> );</div><div class="line">    }</div></div><!-- fragment --><ul>
<li>Resolving dependencies: this stage should provide the name of the external shader library files that contains the actual shader code needed by this SubRenderState. In case of the FFPTexturing it will add the common and texturing library for both vertex and pixel shader program.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Program* psProgram = programSet-&gt;getCpuFragmentProgram();</div><div class="line"></div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);    </div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);</div></div><!-- fragment --><ul>
<li>Adding function invocations: this stage creates the function calls within this SubRenderState requires. Each function call has two keys that are used by the system to sort it before generating the actual shader code as well as set of in/out parameters. A function invocation is added to either vertex shader program or fragment shader program. In case of the FFPFog it will add vertex depth calculation to the vertex shader program.</li>
</ul>
<div class="fragment"><div class="line">        curFuncInvocation = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> FunctionInvocation(<a class="code" href="group___r_t_shader.html#gabaab1e89270cd7f763f2f8e0258c400e">FFP_FUNC_PIXELFOG_DEPTH</a>, <a class="code" href="group___r_t_shader.html#gga7d20b2397c3eab2b52ec405863c6f274a8b4930a3fd90d5b7222960fc5727b8cf">FFP_VS_FOG</a>);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mWorldViewProjMatrix, Operand::OPS_IN);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSInPos, Operand::OPS_IN);  </div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSOutDepth, Operand::OPS_OUT);  </div><div class="line">        vsMain-&gt;addAtomInstance(curFuncInvocation);     </div></div><!-- fragment --><p> Note:</p><ul>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can add as many function invocations as it needs.</li>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can different function invocations in different ordering.</li>
<li>The ordering of the function invocation is crucial. Use the FFPVertexShaderStage and FFPFragmentShaderStage enumarations to place your invocations in the desired order.</li>
<li>Make sure the parameter semantic (in/out) in the SubRenderState code matches to your shader code implementation you supplied in the library file. GLSL will fail to link to libray functions if it won't be able to find a perfect function declaration match.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4c2acbc15e44c3fe42868abce1116ec2" title="Update GPU programs parameters before a rendering operation occurs. ">Ogre::RTShader::SubRenderState::updateGpuProgramsParams</a> - As the name suggest this method should be overridden only in case your SubRenderState should update some parameter it created before.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#afd08043cfad43a1ae470c3c1be341ba1" title="Called before adding this sub render state to the given render state. ">Ogre::RTShader::SubRenderState::preAddToRenderState()</a>: this method called before adding this SubRenderState to a parent RenderState instances. It allows this SubRenderState to exclude itself from the list in case the source pass is not matching. I.E in case of SubRenderState that perform lighting calculations it can return false when the given source pass specifies that lighting calculations disabled for it.</li>
</ul>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (!srcPass-&gt;getLightingEnabled())</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div></div><!-- fragment --><p> This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.</p>
<p>Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods</p><ul>
<li>Ogre::RTShader::SubRenderStateFactory::createInstanceImpl(): This method should return instance for the SubRenderState sub class.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#a954d30cb82307ae1ba785792b833b689" title="Create an instance of the SubRenderState sub class it suppose to create. ">Ogre::RTShader::SubRenderStateFactory::createInstance()</a>: This method should return instasnce for the SubRenderState sub class using the given script compiler parameters. Implemet this method if you want to be able to creat your custom shader extension from material script.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#ada31909080bae96784504be42d9bd77c" title="Write the given sub-render state instance using the material serializer. ">Ogre::RTShader::SubRenderStateFactory::writeInstance()</a>: This method should write down the parameters of a given SubRenderState instance to material script file. Implement this method if you want to be able to export a material that contains your custom shader extension.</li>
</ul>
<h2><a class="anchor" id="debugging"></a>
Tips for debugging shaders</h2>
<p>A couple of notes on debugging shaders coming from the RTSS:</p><ul>
<li>Call <a class="el" href="class_ogre_bites_1_1_application_context.html#aaad4c1d25a7a5f60dd5c5f3812f1096b" title="make the RTSS write out the generated shaders for caching and debugging ">OgreBites::ApplicationContext::setRTSSWriteShadersToDisk</a>. This will cache the generated shaders onto the disk under the directory <code>{<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> directory}\Samples\Media\RTShaderLib\cache</code>. This is important for 2 reasons:<ul>
<li>It will make compilation problems easier to detect.</li>
<li>Once a shader is written to the disk, as long as you don't change the code behind it, the same shader will be picked up in the next application run even if its content has changed. If you have compilation or visual problems with the shader you can try to manually tinker with it without compiling the code again and again.</li>
</ul>
</li>
<li>Find the file OgreShaderProgramManager.cpp and add a breakpoint at <code>pGpuProgram.setNull();</code> (in createGpuProgram). If a shader will fail to compile it will usually fail there. Once that happens you can find the shader name under the <code>programName</code> parameter, then look for it in the cache directory you created.</li>
<li>Other common problems with creating shaders in RTSS usually occur from defining vertex shader parameters and using them in the pixel shader and vice versa. so watch out for those.</li>
</ul>
<h1><a class="anchor" id="history"></a>
Historical background</h1>
<p>When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).</p>
<p>As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.</p>
<p>Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.</p>
<p>The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.</p>
<p>With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.</p>
<h1><a class="anchor" id="pros-cons"></a>
Pros and Cons</h1>
<p>Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders</p><ul>
<li>Hardware animation (a.k.a hardware skinning)</li>
<li>Soft shadows</li>
<li>Normal/Bump maps</li>
<li>Specular maps</li>
<li>Advanced multi-texturing effects</li>
</ul>
<p>Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.</p>
<p>So why use a runtime shader system anyway?</p>
<ul>
<li>Save development time e.g. when your target scene has dynamic lights and the number changes, fog changes, ... and the number of material attributes increases the total count of needed shaders dramatically. It can easily cross 100 and it becomes a time consuming development task.</li>
<li>Reusable code - once you've written the shader extension you can use it anywhere due to its independent nature.</li>
<li>Custom shaders extension library - enjoy the shared library of effects created by the community. Unlike hand written shader code, which may require many adjustments to be plugged into your own shader code, using the extensions library requires minimum changes. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: HLMS: High Level Material System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hlms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HLMS: High Level Material System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#components">The three components</a></li>
<li class="level1"><a href="#materials">Compared to classical materials</a></li>
<li class="level1"><a href="#data">Material parameters are stored in “Blocks”</a><ul><li class="level2"><a href="#toc52">Datablocks</a></li>
</ul>
</li>
<li class="level1"><a href="#toc69">Hlms templates</a><ul><li class="level2"><a href="#preproc">The Hlms preprocessor</a></li>
<li class="level2"><a href="#syntax">Preprocessor syntax</a></li>
</ul>
</li>
<li class="level1"><a href="#shaders">Creation of shaders</a></li>
<li class="level1"><a href="#cpp">C++ interaction with shader templates</a></li>
<li class="level1"><a href="#customization">Customization</a></li>
</ul>
</div>
<div class="textblock"><p>This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.</p>
<p>Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.</p>
<p>Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.</p>
<p>But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.</p>
<p>Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.</p>
<h1><a class="anchor" id="components"></a>
The three components</h1>
<div class="image">
<object type="image/svg+xml" data="hlms_components.svg">hlms_components.svg</object>
</div>
<ol type="1">
<li>Scripts. To set the material properties (i.e. type of Hlms to use: PBS, Toon shading, GUI; what textures, diffuse colour, roughness, etc). <b>You currently have to do this from C++.</b> Everybody will be using this part.</li>
<li>Shader template. The Hlms takes a couple hand-written glsl/hlsl files as template and then adapts it to fit the needs on the fly (i.e. if the mesh doesn’t contain skeleton, the bit of code pertaining to skeletal animation is stripped from the vertex shader). The Hlms provides a simple preprocessor to deal with this entirely within from the template, but you’re not forced to use it. Here’s a simple example of the preprocessor. I won’t be explaining the main keywords today. Advanced users will probably want to modify these files (or write some of their own) to fit their custom needs.</li>
<li>C++ classes implementation. The C++ takes care of picking the shader templates and manipulating them before compiling; and most importantly it feeds the shaders with uniform/constans data and sets the textures that are being in use. It is extremely flexible, powerful, efficient and scalable, but it’s harder to use than good ol’ Materials because those used to be data-driven: there are no AutoParamsSource here. Want the view matrix? You better grab it from the camera when the scene pass is about to start, and then pass it yourself to the shader. This is very powerful, because in D3D11/GL3+ you can just set the uniform buffer with the view matrix just once for the entire frame, and thus have multiple uniforms buffers sorted by update frequency. Very advanced user will be using messing with this part.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Material scripts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.x do not yet support the HLMS - you must use the C++ API. e.g. <a class="el" href="class_ogre_1_1_pbs_material.html">Ogre::PbsMaterial</a>.</dd></dl>
<p>Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.</p>
<p>For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.</p>
<p>It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.</p>
<h1><a class="anchor" id="materials"></a>
Compared to classical materials</h1>
<p>Materials are still useful for:</p>
<ul>
<li>Quick iteration. You need to write a shader, just define the material and start coding. Why would you deal with the template’s syntax or a C++ module when you can just write a script and start coding?. The HLMS though comes with a Command line tool to know how your template translates into a final shader (which is very handy for iteration, it’s fast, and will check for syntax errors!), but it’s most useful when you want to write your own C++ module or change the template, not when you want to just experiment. Besides, old timers are used to writing materials.</li>
<li>Postprocessing effects. Materials are much better suited for this. Materials are data driven, easy to write. Postprocessing FXs don’t need an awful lot of permutations (i.e. having to deal with shadow mapping, instancing, skeleton animation, facial animation). And they’re at no performance disadvantage compared to HLMS: Each FX is a fullscreen pass that needs different shaders, different textures, its own uniforms. Basically, API overhead we can’t optimize. But it doesn’t matter much either, because it’s not like there are 100 fullscreen passes. Usually there’s less than 10.</li>
</ul>
<h1><a class="anchor" id="data"></a>
Material parameters are stored in “Blocks”</h1>
<p>You could be thinking the reason I came up with these two is to fit with D3D11′s grand scheme of things while being compatible with OpenGL. But that’s a half truth and an awesome side effect. I’ve been developing the Hlms using OpenGL this whole time.</p>
<p>An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and they’re right about that.</p>
<p>However, there are big advantages for using blocks:</p>
<ol type="1">
<li>Many materials in practice share the same Macro- &amp; Blendblock parameters. In an age where we want many 3D primitives with the same shader but slightly different parameters like texture, colour, or roughness (which equals, a different material) having these settings repeated per material wastes a lot of memory space… and a lot of bandwidth (and wastes cache space). <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 is bandwidth bound, so having all materials share the same pointer to the same Macroblock can potentially save a lot of bandwidth, and be friendlier to the cache at the same time.This stays true whether we use D3D11, D3D12, OpenGL, GL ES 2, or Mantle.</li>
<li>Sorting by Macroblock is a lot easier (and faster) than sorting by its individual parameters: when preparing the hash used for sorting, it’s much easier to just do (every frame, per object) <code>hash |= (macroblock-&gt;getId() &lt;&lt; bits) &amp; mask</code> than to do: <code>hash =| m-&gt;depth_check | m-&gt;depthWrite &lt;&lt; 1 | m-&gt;depthBias &lt;&lt; 2 | m-&gt;depth_slope_bias &lt;&lt; 3 | m-&gt;cullMode &lt;&lt; 18 | ... ;</code> We also need a lot more bits we can’t afford. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 imposes a limit on the amount of live Macroblocks you can have at the same time; as we run out of hashing space (by the way, D3D11 has its own limit). It operates around the idea that most setting combinations won’t be used in practice.</li>
</ol>
<p>Of course it’s not perfect, it can’t fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); you’ll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. We’re aiming the general use case.</p>
<p>These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since I’m not used to driver development. However from an engine perspective, blocks make sense.</p>
<h2><a class="anchor" id="toc52"></a>
Datablocks</h2>
<p>We’re introducing the concept of Datablocks. A Datablock is a “material” from the user’s perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.</p>
<div class="image">
<object type="image/svg+xml" data="hlms_blocks.svg">hlms_blocks.svg</object>
</div>
<p>The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.</p>
<dl class="section note"><dt>Note</dt><dd>Macroblocks and Blendblocks are not available in 1.x - use <a class="el" href="class_ogre_1_1_pass.html#ae454faee87f8cb0b8540810e48118788" title="Sets whether or not this pass renders with depth-buffer checking on or not. ">Ogre::Pass::setDepthCheckEnabled</a> etc. as usual, to change the respective properties</dd></dl>
<h1><a class="anchor" id="toc69"></a>
Hlms templates</h1>
<p>The Hlms will parse the template files from the template folder according to the following rules:</p>
<ol type="1">
<li>The files with the names "VertexShader_vs", "PixelShader_ps", "GeometryShader_gs", "HullShader_hs", "DomainShader_ds" will be fully parsed and compiled into the shader. If an implementation only provides "VertexShader_vs.glslt", "PixelShader_ps.glslt"; only the vertex and pixel shaders for OpenGL will be created. There will be no geometry or tesellation shaders.</li>
<li>The files that contain the string "_piece_vs" in their filenames will be parsed only for collecting pieces (more on pieces later). Likewise, the words "_piece_ps", "_piece_gs", "_piece_hs", "_piece_ds” correspond to the pieces for their respective shader stages. Note that you can concatenate, thus "MyUtilities_piece_vs_piece_ps.glslt” will be collected both in the vertex and pixel shader stages.</li>
</ol>
<p>The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.</p>
<h2><a class="anchor" id="preproc"></a>
The Hlms preprocessor</h2>
<p>The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.</p>
<p>For example </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can't evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can't check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable “IncludeLightingEquals2” and check whether it's non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can't see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you'll depend on the driver implementation having a good macro preprocessor.</p>
<h2><a class="anchor" id="syntax"></a>
Preprocessor syntax</h2>
<p>The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:</p>
<ul>
<li>@property</li>
<li>@foreach</li>
<li>@counter</li>
<li>@value</li>
<li>@set add sub mul div mod min max</li>
<li>@piece</li>
<li>@insertpiece</li>
<li>@pset padd psub pmul pdiv pmod pmin pmax</li>
</ul>
<h3>@property( expression )</h3>
<p>Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.</p>
<p>The logical operands &amp;&amp; || ! are valid.</p>
<p>Examples: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: </p><div class="fragment"><div class="line">hasLights != 0                              hasLights == 0</div><div class="line">diffuse = surfaceDiffuse * lightDiffuse;   diffuse = surfaceDiffuse ;</div></div><!-- fragment --><h3>@foreach( scopedVar, count, [start] )</h3>
<p>Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.</p>
<ul>
<li>scopedVar is a variable that can be used to print the current iteration of the loop while inside the block. i.e. “@scopedVar” will be converted into a number in the range [start; count)</li>
<li>count The number of times to repeat the loop (if start = 0). Count can read variables.</li>
<li>start Optional. Allows to start from a value different than 0. Start can read variables.</li>
</ul>
<p>Newlines are very important, as they will be printed with the loop.</p>
<p>Examples: </p><table class="doxtable">
<tr>
<th>Expression </th><th>Output  </th></tr>
<tr>
<td>@foreach( 4, n ) <br />
&emsp; @n@end </td><td><br />
0<br />
1<br />
2<br />
3 </td></tr>
<tr>
<td>@foreach( 4, n ) @n@end </td><td>0 1 2 3 </td></tr>
<tr>
<td>@foreach( 4, n )<br />
&emsp;@n<br />
@end </td><td><br />
0<br />
<br />
1<br />
<br />
2<br />
<br />
3<br />
 </td></tr>
<tr>
<td>@foreach( 4, n, 2 ) @n@end </td><td>2 3 </td></tr>
<tr>
<td>@pset( myStartVar, 1 )<br />
@pset( myCountVar, 3 )<br />
@foreach( myStartVar, n, myCountVar )<br />
&emsp;@n@end </td><td>1<br />
2 </td></tr>
<tr>
<td>@foreach( 2, n )<br />
&emsp;@insertpiece( pieceName@n )@end </td><td>@insertpiece( pieceName0 )<br />
 @insertpiece( pieceName1 ) </td></tr>
</table>
<blockquote class="doxtable">
<p><b>Attention #1!</b></p>
<p>Don't use the common letter i for the loop counter. It will conflict with other keywords.</p>
<p>i.e. “@foreach( 1, i )@insertpiece( pieceName )@end” will print “0nsertpiece( pieceName )” which is probably not what you intended.</p>
<p><b>Attention #2!</b></p>
<p>foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.</p>
<p>i.e. The following code will not work:</p>
<div class="fragment"><div class="line">@pset( myVar, 1 )</div><div class="line"></div><div class="line">@<span class="keywordflow">foreach</span>( 2, n )</div><div class="line"></div><div class="line"><span class="comment">//Code</span></div><div class="line"></div><div class="line">@psub( myVar, 1 ) <span class="comment">//Decrement myVar on each loop</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( myVar )</div><div class="line"></div><div class="line"><span class="comment">//Code that shouldn&#39;t be printed in the last iteration</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>Because psub will be evaluated before expanding the foreach. </p>
</blockquote>
<h3>@counter( variable )</h3>
<p>Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.</p>
<p>Examples: </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@counter( myVar )   1</div><div class="line"></div><div class="line">@counter( myVar )   2</div></div><!-- fragment --><h3>@value( variable )</h3>
<p>Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@value( myVar )     1</div><div class="line"></div><div class="line">@value( myVar )     1</div></div><!-- fragment --><h3>@set add sub mul div mod min max</h3>
<p>Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.</p>
<p>Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c</p>
<p>Useful in combination with @counter and @value</p>
<table class="doxtable">
<tr>
<th>Expression </th><th>Output </th><th>Math  </th></tr>
<tr>
<td>@set( myVar, 1 ) <br />
 @value( myVar ) </td><td>1 </td><td>myVar = 1 </td></tr>
<tr>
<td>@add( myVar, 5 )<br />
 @value( myVar ) </td><td>6 </td><td>myVar = 1 + 5 </td></tr>
<tr>
<td>@div( myVar, 2 ) <br />
 @value( myVar ) </td><td>3 </td><td>myVar = 6 / 2 </td></tr>
<tr>
<td>@mul( myVar, myVar )<br />
 @value( myVar ) </td><td>9 </td><td>myVar = 3 * 3 </td></tr>
<tr>
<td>@mod( myVar, 5 ) <br />
 @value( myVar ) </td><td>4 </td><td>myVar = 9 % 5 </td></tr>
<tr>
<td>@add( myVar, 1, 1 ) <br />
 @value( myVar ) </td><td>2 </td><td>myVar = 1 + 1 </td></tr>
</table>
<h3>@piece( nameOfPiece )</h3>
<p>Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won't be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                        Output</div><div class="line"></div><div class="line">@piece( VertexTransform )         </div><div class="line"></div><div class="line">outPos = worldViewProj * inPos   </div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><h3>@insertpiece( nameOfPiece )</h3>
<p>Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                                                     Output</div><div class="line"></div><div class="line">@piece( VertexTransform )outPos = worldViewProj * inPos@end   void main()</div><div class="line"></div><div class="line">void main()                                                    {</div><div class="line"></div><div class="line">{                                                              outPos = worldViewProj * inPos</div><div class="line"></div><div class="line">@insertpiece( VertexTransform )                                }</div><div class="line"></div><div class="line">@insertpiece( InexistentPiece )                                </div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h3>@pset padd psub pmul pdiv pmod pmin pmax</h3>
<p>Analogous to <a href="#toc304"><em>the family of math functions without the 'p' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.</p>
<p>i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )</p>
<p>One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.</p>
<p>If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.</p>
<h1><a class="anchor" id="shaders"></a>
Creation of shaders</h1>
<p>There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:</p>
<ol type="1">
<li>The Datablock/Material. Does it have Normal maps? Then include code to sample the normal map and affect the lighting calculations. Does it have a diffuse map? If not, avoid sampling the diffuse map and multiplying it against the diffuse colour, etc.</li>
<li>The Mesh. Is it skeletally animated? Then include skeletal animation code. How many blend weights? Modify the skeletal animation code appropiately. It doesn't have tangents? Then skip the normal map defined in the material. And so on.</li>
</ol>
<p>When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.</p>
<p>If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).</p>
<p>The following graph summarizes the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_hash.svg">hlms_hash.svg</object>
</div>
<p>Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a “<a href="#toc567"><em>pass hash</em></a>” instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).</p>
<p>While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_caching.svg">hlms_caching.svg</object>
</div>
<h1><a class="anchor" id="cpp"></a>
C++ interaction with shader templates</h1>
<p>Note: This section is relevant to those seeking to write their own Hlms implementation.</p>
<p>C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set “key” to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod</p>
<p>To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.</p>
<p>The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.</p>
<p>In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.</p>
<p>Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.</p>
<p>For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.</p>
<p>The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.</p>
<h2>Common conventions</h2>
<p>Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.</p>
<p>Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.</p>
<p>For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.</p>
<p>Properties in underscore_case are set from C++; propierties in camelCase are set from the template.</p>
<p>Propierties and pieces starting with 'custom_' are for user customizations of the template</p>
<p>TBD</p>
<h2>Disabling a stage</h2>
<p>By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.</p>
<p>Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.</p>
<h1><a class="anchor" id="customization"></a>
Customization</h1>
<p>In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.</p>
<p>Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.</p>
<p>Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.</p>
<p>There are different levels in which an Hlms implementation can be customized:</p>
<ol type="1">
<li>Using a library, see <a href="#toc574"><em>Hlms Initialization</em></a>. pass a set of piece files in a folder by pushing the folder to ArchiveVec. The files in that folder will be parsed first, in order (archiveVec[0] then archiveVec[1], … archiveVec[N-1]); which will let you define your own pieces to insert code into the default template (see the the table at the end). You can also do clever tricky things to avoid dealing with C++ code at all even if there are no 'custom_' pieces for it. For example, you can write the following code to override the BRDF declarations and provide a custom BRDF: <div class="fragment"><div class="line"><span class="comment">//Disable all known BRDFs that the implementation may enable</span></div><div class="line"></div><div class="line">@pset( BRDF_CookTorrance, 0 )</div><div class="line"></div><div class="line">@pset( BRDF_Default, 0 )</div><div class="line"></div><div class="line">@piece( DeclareBRDF )</div><div class="line"></div><div class="line"><span class="comment">// Your BRDF code declaration here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --></li>
</ol>
<ol type="1">
<li>Via listener, through HlmsListener. This allows you to have access to the buffer pass to fill extra information; or bind extra buffers to the shader.</li>
<li>Overload HlmsPbs. Useful for overriding only specific parts, or adding new functionality that requires storing extra information in a datablock (e.g. overload HlmsPbsDatablock to add more variables, and then overload HlmsPbs::createDatablockImpl to create these custom datablocks)</li>
<li>Directly modify HlmsPbs, HlmsPbsDatablock and the template. <table class="doxtable">
<tr>
<th>Variable </th><th>Description  </th></tr>
<tr>
<td>custom_passBuffer </td><td>Piece where users can add extra information for the pass buffer (only useful if the user is using HlmsListener or overloaded HlmsPbs. </td></tr>
<tr>
<td>custom_VStoPS </td><td>Piece where users can add more interpolants for passing data from the vertex to the pixel shader. </td></tr>
<tr>
<td>custom_vs_attributes </td><td>Custom vertex shader attributes in the Vertex Shader (i.e. a special texcoord, etc). </td></tr>
<tr>
<td>custom_vs_uniformDeclaration </td><td>Data declaration (textures, texture buffers, uniform buffers) in the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_posExecution </td><td>Executed after all code from the Vertex Shader has been performed. </td></tr>
<tr>
<td>custom_ps_uniformDeclaration </td><td>Same as custom_vs_uniformDeclaration, but for the Pixel Shader </td></tr>
<tr>
<td>custom_ps_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Pixel Shader. </td></tr>
<tr>
<td>custom_ps_posMaterialLoad </td><td>Executed right after loading material data; and before anything else. May not get executed if there is no relevant material data (i.e. doesn't have normals or QTangents for lighting calculation) </td></tr>
<tr>
<td>custom_ps_preLights </td><td>Executed right before any light (i.e. to perform your own ambient / global illumination pass). All relevant texture data should be loaded by now. </td></tr>
<tr>
<td>custom_ps_posExecution </td><td>Executed after all code from the Pixel Shader has been performed. </td></tr>
</table>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: RTSS: Run Time Shader System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rtss.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">RTSS: Run Time Shader System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#core-feats">Core features of the system</a></li>
<li class="level1"><a href="#rtss_overview">System overview</a><ul><li class="level2"><a href="#rtss_custom_api">Customising via API</a></li>
<li class="level2"><a href="#rtss_custom_mat">Customizing via Material Script</a></li>
</ul>
</li>
<li class="level1"><a href="#rtss_indepth">The RTSS in Depth</a><ul><li class="level2"><a href="#rtss__components">Main components</a></li>
<li class="level2"><a href="#creating-extensions">Creating custom shader extensions</a></li>
<li class="level2"><a href="#debugging">Tips for debugging shaders</a></li>
</ul>
</li>
<li class="level1"><a href="#history">Historical background</a></li>
<li class="level1"><a href="#pros-cons">Pros and Cons</a></li>
</ul>
</div>
<div class="textblock"><p>This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.</p>
<h1><a class="anchor" id="core-feats"></a>
Core features of the system</h1>
<ul>
<li>Runtime shader generation synchronized with scene state. Each time scene settings change, a new set of shaders is generated.</li>
<li>Full Fixed Function Pipeline (FFP) emulation. This feature is most useful combined with render system that doesn't provide any FFP functionality (OpenGL ES 2.0, D3D11 etc).</li>
<li>Shader language independent interface: the logic representation of the shader programs is completely independent from the target shader language. You can generate code for different shader languages from the same program.</li>
<li>Pluggable interface allows extending the target shader languages set.</li>
<li>Pluggable interface allows adding new shader based effects to the system in a seamless way. Each effect code will be automatically combined with the rest of the shader code.</li>
<li>Smart program management: each shader program is created only once and may be used by multiple passes.</li>
<li>Automatic vertex shader compacting mechanism: no more compacting variables by hand. In case the amount of used vertex shader output registers exceeds the maximum allowed (12 to 32, depending on <a href="http://msdn.microsoft.com/en-us/library/bb172918%28v=VS.85%29.aspx">D3DPSHADERCAPS2_0.NumTemps</a>), a compacting algorithm packs the vertex shader outputs and adds unpack code in the fragment shader side.</li>
<li>Material script support, for both export and import.</li>
</ul>
<h1><a class="anchor" id="rtss_overview"></a>
System overview</h1>
<p>The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.</p>
<p>Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.</p>
<p>To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.</p>
<p>After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.</p>
<p>Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates</p>
<div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">uniform mat4    worldviewproj_matrix;</div><div class="line">uniform mat4    texture_matrix1;</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">in  vec4    vertex;</div><div class="line">in  vec4    uv0;</div><div class="line">out vec4    oTexcoord4_0;</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    FFP_Transform(worldviewproj_matrix, vertex, gl_Position);</div><div class="line">    FFP_TransformTexCoord(texture_matrix1, uv0.xy, oTexcoord4_0.xy);</div><div class="line">}</div></div><!-- fragment --><p>It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)</p>
<p>Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.</p>
<p>The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.</p>
<h2><a class="anchor" id="rtss_custom_api"></a>
Customising via API</h2>
<p>The first option is to globally enforce per-pixel lighting, you can do the following</p>
<div class="fragment"><div class="line">        <span class="comment">// Grab the scheme render state.</span></div><div class="line">        <a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">Ogre::RTShader::RenderState</a>* schemRenderState =</div><div class="line">            mShaderGenerator-&gt;getRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line">        <span class="comment">// Add per pixel lighting sub render state to the global scheme render state.</span></div><div class="line">        <span class="comment">// It will override the default FFP lighting sub render state.</span></div><div class="line">        <span class="keywordflow">if</span> (usePerPixelLighting) {</div><div class="line">            <a class="code" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">Ogre::RTShader::SubRenderState</a>* perPixelLightModel =</div><div class="line">                mShaderGenerator-&gt;createSubRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_per_pixel_lighting.html#ae766f76cad4b3a4339a0cd50abbddcc2">Ogre::RTShader::PerPixelLighting::Type</a>);</div><div class="line"></div><div class="line">            schemRenderState-&gt;<a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html#af66edaf33c654e03ef89f1eaec384a1f">addTemplateSubRenderState</a>(perPixelLightModel);</div><div class="line">        }</div></div><!-- fragment --><p> any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.</p>
<h2><a class="anchor" id="rtss_custom_mat"></a>
Customizing via Material Script</h2>
<p>Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following</p>
<div class="fragment"><div class="line">            <span class="comment">// RT Shader system section.</span></div><div class="line">            rtshader_system</div><div class="line">            {       </div><div class="line">                <span class="comment">// Override lighting stage with per pixel lighting.             </span></div><div class="line">                lighting_stage per_pixel                </div><div class="line">            }   </div></div><!-- fragment --><p> for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.</p>
<p>Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:</p>
<ul>
<li><a href="#lighting_stage">lighting_stage</a></li>
<li><a href="#light_count">light_count</a></li>
<li><a href="#triplanarTexturing">triplanarTexturing</a></li>
<li><a href="#integrated_pssm4">integrated_pssm4</a></li>
<li><a href="#layered_blend">layered_blend</a></li>
<li><a href="#source_modifier">source_modifier</a></li>
</ul>
<p><a class="anchor" id="lighting_stage"></a></p>
<h3>lighting_stage</h3>
<p>Force a specific lighting model.</p>
<p>Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code></p>
<p>Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code></p>
<p>Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_r_t_shader_1_1_normal_map_lighting.html#adc6b4bdd1ea31c2232336599d2b30b60" title="Normal map space definition. ">Ogre::RTShader::NormalMapLighting::NormalMapSpace</a> </dd>
<dd>
<a class="el" href="group___general.html#ga21a0186392e9c9ce16d29c5568a773c5" title="High-level filtering options providing shortcuts to settings the minification, magnification and mip ...">Ogre::TextureFilterOptions</a></dd></dl>
<p><a class="anchor" id="light_count"></a></p>
<h3>light_count</h3>
<p>Override dynamic light count. Allows to customize which lights the RTSS will consider.</p>
<p>Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code></p>
<p><a class="anchor" id="triplanarTexturing"></a></p>
<h3>triplanarTexturing</h3>
<p>Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a></p>
<p>Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code></p>
<p>Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureScale</td><td>texture coordinates are multiplied by this. </td></tr>
    <tr><td class="paramname">plateauSize</td><td>plateau on which small components of the normal have no influence. </td></tr>
    <tr><td class="paramname">transitionSpeed</td><td>transitions speed between the three textures Valid values are [0; 0.57] not bigger to avoid division by zero </td></tr>
    <tr><td class="paramname">textureFromX</td><td>Texture for the x-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromY</td><td>Texture for the y-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromZ</td><td>Texture for the z-direction planar mapping</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="integrated_pssm4"></a></p>
<h3>integrated_pssm4</h3>
<p>Integrated PSSM shadow receiver with 3 splits. Custom split points.</p>
<p>Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code></p>
<p><a class="anchor" id="layered_blend"></a></p>
<h3>layered_blend</h3>
<p>Apply photoshop-like blend effects to texture layers</p>
<p>Format: <code>layered_blend &lt;effect&gt;</code></p>
<p>Example: layered_blend luminosity</p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">effect</td><td>one of <code>default, normal, lighten, darken, multiply, average, add, subtract, difference, negation, exclusion, screen, overlay, hard_light, soft_light, color_dodge, color_burn, linear_dodge, linear_burn, linear_light, vivid_light, pin_light, hard_mix, reflect, glow, phoenix, saturation, color, luminosity</code></td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="source_modifier"></a></p>
<h3>source_modifier</h3>
<p>Apply custom modulate effect to texture layer</p>
<p>Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code></p>
<p>Example: <code>source_modifier src1_inverse_modulate custom 2</code></p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>one of <code>src1_modulate, src2_modulate, src1_inverse_modulate, src2_inverse_modulate</code> </td></tr>
    <tr><td class="paramname">parameterNum</td><td>number of the custom shader parameter that controls the operation</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="rtss_indepth"></a>
The RTSS in Depth</h1>
<p>When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.</p>
<p>The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).</p>
<p>Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.</p>
<p>The following steps are executed in order to generate shaders for a given technique:</p>
<ul>
<li>For each pass in the technique the system builds a set of sub render states that describe the logic process of the rendering pipeline from the draw call submission until the final pixel color.</li>
<li>Each render state is translated into a set of logic shader programs (currently only pixel and vertex shader). The logic programs are then sent to specific shader language writers that produce source code for the respective shader language. The source code is used to create the GPU programs that are applied to the destination pass. Before rendering of an object that uses generated shaders the system allows each sub render state to update the GPU constants associated with it.</li>
</ul>
<h2>Initializing the system</h2>
<dl class="section note"><dt>Note</dt><dd>If you are using the <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>, the following steps will be taken automatically for you.</dd></dl>
<p>Initializing the system is composed of the following steps:</p><ul>
<li>Create the internal managers and structures via the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260" title="Initialize the Shader Generator System. ">Ogre::RTShader::ShaderGenerator::initialize()</a></code> method.</li>
<li>Set the target cache path. This is the place on your disk where the output shaders will be written to or will be read from in case they were generated by previous runs of your application.</li>
<li>Verify that the location of the shader libs needed by the system is added to the ResourceGroupManager via the <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d" title="Adds a location to the list of searchable locations for a Resource type. ">Ogre::ResourceGroupManager::addResourceLocation()</a></code> method.</li>
<li>Assign the target scene manager to the shader generator.</li>
<li>Add one or more specialized sub-render states that are to be shared among all materials (per pixel lighting, textured fog, etc...).</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260">Ogre::RTShader::ShaderGenerator::initialize</a>())</div><div class="line">{</div><div class="line">    <span class="comment">// Grab the shader generator pointer.</span></div><div class="line">    mShaderGenerator = <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">Ogre::RTShader::ShaderGenerator::getSingletonPtr</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Add the shader libs resource location. a sample shader lib can be found in Samples\Media\RTShaderLib</span></div><div class="line">    <a class="code" href="class_ogre_1_1_resource_group_manager.html#a45101333f0f9ff132fc381dd5c4a1d60">Ogre::ResourceGroupManager::getSingleton</a>().<a class="code" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d">addResourceLocation</a>(shaderLibPath, <span class="stringliteral">&quot;FileSystem&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Set shader cache path.</span></div><div class="line">    mShaderGenerator-&gt;setShaderCachePath(shaderCachePath);      </div><div class="line"></div><div class="line">    <span class="comment">// Set the scene manager.</span></div><div class="line">    mShaderGenerator-&gt;addSceneManager(sceneMgr);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><h2>Creating shader based technique</h2>
<p>This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.</p>
<p>To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.</p>
<p>Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// Create shader based technique from the default technique of the given material.</span></div><div class="line">mShaderGenerator-&gt;createShaderBasedTechnique(<span class="stringliteral">&quot;Examples/BeachStones&quot;</span>, <a class="code" href="class_ogre_1_1_material_manager.html#a290b828b5d44637ee4d247a09ea81bd6">Ogre::MaterialManager::DEFAULT_SCHEME_NAME</a>, <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line"><span class="comment">// Apply the shader generated based techniques.</span></div><div class="line">mViewport-&gt;setMaterialScheme(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div></div><!-- fragment --> <div class="image">
<object type="image/svg+xml" data="CreateShaderBasedTech.svg">CreateShaderBasedTech.svg</object>
</div>
<h2>Runtime shader generation</h2>
<p>During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.</p>
<div class="image">
<object type="image/svg+xml" data="RuntimeShaderGeneration.svg">RuntimeShaderGeneration.svg</object>
</div>
<h2><a class="anchor" id="rtss__components"></a>
Main components</h2>
<p>The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.</p>
<h3>ShaderGenerator</h3>
<p>The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.</p>
<h3>RenderState classes</h3>
<p>A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.</p>
<p>RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.</p>
<h3>SubRenderState classes</h3>
<p>Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.</p>
<p>There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_transform.html" title="Transform sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTransform</a> - responsible for adding code to the vertex shader which computes the position of the vertex in projection space</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_colour.html" title="Colour sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPColour</a> - responsible for adding code to the shaders that calculate the base diffuse and specular color of the object regardless of lights or textures. The color is calculated based on the ambient, diffuse, specular and emissive properties of the object and scene, color tracking and the specified hardware buffer color.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_lighting.html" title="Lighting sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPLighting</a> - responsible for adding code to the shaders that calculate the luminescence added to the object by light. Then add that value to the color calculated by the color SRS stage.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_texturing.html" title="Texturing sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTexturing</a> - responsible for adding code that modulates the color of the pixels based on textures assigned to the material.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_fog.html" title="Fog sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPFog</a> - responsible for adding code that modulates the color of a pixel based on the scene or object fog parameters.</li>
</ul>
<p>There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...</p>
<h3>SubRenderStateFactory</h3>
<p>As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.</p>
<p>These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.</p>
<h2><a class="anchor" id="creating-extensions"></a>
Creating custom shader extensions</h2>
<p>Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.</p>
<p>In order to extend the system with your own shader effects you'll have to follow these steps:</p><ul>
<li>Implement the SubRenderState interface - This is the main class that is responsible for the actual effect processing such as preparing the destination pass, updating the CPU shader programs, updating the GPU shader parameters etc.</li>
<li>Implement the SubRenderStateFactory interface: This class will allow the RTSS to create instances of the previous class via code or script as well as export it to material script file.</li>
<li>Register the factory to the RTSS using the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac266946244d79b2d4732607ae9479bd9" title="Add sub render state factory. ">Ogre::RTShader::ShaderGenerator::addSubRenderStateFactory</a> method.</li>
<li>Add shader files that will supply all the actual shader functions your SubRenderState needs. In order to support multiple shader languages you should supply code for your entire desired target shading languages (CG, HLSL, GLSL etc). These files should be placed in a way that the resource manager could access them. This can be done by placing them in a valid resource location or by dynamically adding resource location.</li>
</ul>
<p>Implementing the SubRenderState requires overriding the pure methods of the base class.</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#ae91b7b8f76848d67652b6e5832a27a49" title="Get the type of this sub render state. ">Ogre::RTShader::SubRenderState::getType()</a> should return unique string that identify the sub class implementation. That value is shared among all instances and can be stored in a static string variable. It uses to system to match between SubRenderState instance and the factory to should destroy it.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#acb48c34ee231f0220f68c967fb32f1e5" title="Get the execution order of this sub render state. ">Ogre::RTShader::SubRenderState::getExecutionOrder()</a> should return integer value that will use the system to sort all SubRenderState instances of the same render state before each one of them will create its part in the CPU shader programs. Note that:<ul>
<li>The execution order does not imply the order of the parameter definitions and function calls within the generated shader.</li>
<li>If an execution number is set to be the same as one of the basic fixed pipeline SRSs. Than that SRS will be built <b>instead</b> of the fixed pipeline SRS.</li>
</ul>
</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a5dfe9f03413e0fe99ea2640f06c1f13c" title="Copy details from a given sub render state to this one. ">Ogre::RTShader::SubRenderState::copyFrom()</a> a simple copy method that uses the system when coping one instance to another. <b>Note:</b> Only configuration data attributes should be copy here.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4b43c261946926ebbc6456deccc6697a" title="Create sub programs that represents this sub render state as part of a program set. ">Ogre::RTShader::SubRenderState::createCpuSubPrograms</a> - This is the heart of this interface. This method should update the CPU shader programs with the specific details of the overriding class.</li>
</ul>
<p>The SubRenderState supply default implementation for this method which break down this method into three stages:</p><ul>
<li>Resolving parameters: this stage should grab all the needed parameters for this SubRrenderState. In case of the FFPTransform it should resolve the world view projection matrix and vertex shader input and output position parameters.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Function* vsEntry = vsProgram-&gt;getEntryPointFunction();</div><div class="line">    </div><div class="line">    <span class="comment">// Resolve World View Projection Matrix.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#ae0e6b89f6ed3986b0a87e2472e3ff7f1">UniformParameterPtr</a> wvpMatrix = vsProgram-&gt;resolveAutoParameterInt(GpuProgramParameters::ACT_WORLDVIEWPROJ_MATRIX, 0);</div><div class="line">        </div><div class="line">    <span class="comment">// Resolve input position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionIn = vsEntry-&gt;resolveInputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_OBJECT_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>); </div><div class="line">    </div><div class="line">    <span class="comment">// Resolve output position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionOut = vsEntry-&gt;resolveOutputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_PROJECTIVE_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!wvpMatrix || !positionIn || !positionOut)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___general.html#gaf27f0d64dfeb225d37a513c253eaa1a0">OGRE_EXCEPT</a>( Exception::ERR_INTERNAL_ERROR, </div><div class="line">                <span class="stringliteral">&quot;Not all parameters could be constructed for the sub-render state.&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;FFPTransform::createCpuSubPrograms&quot;</span> );</div><div class="line">    }</div></div><!-- fragment --><ul>
<li>Resolving dependencies: this stage should provide the name of the external shader library files that contains the actual shader code needed by this SubRenderState. In case of the FFPTexturing it will add the common and texturing library for both vertex and pixel shader program.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Program* psProgram = programSet-&gt;getCpuFragmentProgram();</div><div class="line"></div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);    </div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);</div></div><!-- fragment --><ul>
<li>Adding function invocations: this stage creates the function calls within this SubRenderState requires. Each function call has two keys that are used by the system to sort it before generating the actual shader code as well as set of in/out parameters. A function invocation is added to either vertex shader program or fragment shader program. In case of the FFPFog it will add vertex depth calculation to the vertex shader program.</li>
</ul>
<div class="fragment"><div class="line">        curFuncInvocation = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> FunctionInvocation(<a class="code" href="group___r_t_shader.html#gabaab1e89270cd7f763f2f8e0258c400e">FFP_FUNC_PIXELFOG_DEPTH</a>, <a class="code" href="group___r_t_shader.html#gga7d20b2397c3eab2b52ec405863c6f274a8b4930a3fd90d5b7222960fc5727b8cf">FFP_VS_FOG</a>);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mWorldViewProjMatrix, Operand::OPS_IN);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSInPos, Operand::OPS_IN);  </div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSOutDepth, Operand::OPS_OUT);  </div><div class="line">        vsMain-&gt;addAtomInstance(curFuncInvocation);     </div></div><!-- fragment --><p> Note:</p><ul>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can add as many function invocations as it needs.</li>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can different function invocations in different ordering.</li>
<li>The ordering of the function invocation is crucial. Use the FFPVertexShaderStage and FFPFragmentShaderStage enumarations to place your invocations in the desired order.</li>
<li>Make sure the parameter semantic (in/out) in the SubRenderState code matches to your shader code implementation you supplied in the library file. GLSL will fail to link to libray functions if it won't be able to find a perfect function declaration match.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4c2acbc15e44c3fe42868abce1116ec2" title="Update GPU programs parameters before a rendering operation occurs. ">Ogre::RTShader::SubRenderState::updateGpuProgramsParams</a> - As the name suggest this method should be overridden only in case your SubRenderState should update some parameter it created before.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#afd08043cfad43a1ae470c3c1be341ba1" title="Called before adding this sub render state to the given render state. ">Ogre::RTShader::SubRenderState::preAddToRenderState()</a>: this method called before adding this SubRenderState to a parent RenderState instances. It allows this SubRenderState to exclude itself from the list in case the source pass is not matching. I.E in case of SubRenderState that perform lighting calculations it can return false when the given source pass specifies that lighting calculations disabled for it.</li>
</ul>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (!srcPass-&gt;getLightingEnabled())</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div></div><!-- fragment --><p> This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.</p>
<p>Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods</p><ul>
<li>Ogre::RTShader::SubRenderStateFactory::createInstanceImpl(): This method should return instance for the SubRenderState sub class.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#a954d30cb82307ae1ba785792b833b689" title="Create an instance of the SubRenderState sub class it suppose to create. ">Ogre::RTShader::SubRenderStateFactory::createInstance()</a>: This method should return instasnce for the SubRenderState sub class using the given script compiler parameters. Implemet this method if you want to be able to creat your custom shader extension from material script.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#ada31909080bae96784504be42d9bd77c" title="Write the given sub-render state instance using the material serializer. ">Ogre::RTShader::SubRenderStateFactory::writeInstance()</a>: This method should write down the parameters of a given SubRenderState instance to material script file. Implement this method if you want to be able to export a material that contains your custom shader extension.</li>
</ul>
<h2><a class="anchor" id="debugging"></a>
Tips for debugging shaders</h2>
<p>A couple of notes on debugging shaders coming from the RTSS:</p><ul>
<li>Call <a class="el" href="class_ogre_bites_1_1_application_context.html#aaad4c1d25a7a5f60dd5c5f3812f1096b" title="make the RTSS write out the generated shaders for caching and debugging ">OgreBites::ApplicationContext::setRTSSWriteShadersToDisk</a>. This will cache the generated shaders onto the disk under the directory <code>{<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> directory}\Samples\Media\RTShaderLib\cache</code>. This is important for 2 reasons:<ul>
<li>It will make compilation problems easier to detect.</li>
<li>Once a shader is written to the disk, as long as you don't change the code behind it, the same shader will be picked up in the next application run even if its content has changed. If you have compilation or visual problems with the shader you can try to manually tinker with it without compiling the code again and again.</li>
</ul>
</li>
<li>Find the file OgreShaderProgramManager.cpp and add a breakpoint at <code>pGpuProgram.setNull();</code> (in createGpuProgram). If a shader will fail to compile it will usually fail there. Once that happens you can find the shader name under the <code>programName</code> parameter, then look for it in the cache directory you created.</li>
<li>Other common problems with creating shaders in RTSS usually occur from defining vertex shader parameters and using them in the pixel shader and vice versa. so watch out for those.</li>
</ul>
<h1><a class="anchor" id="history"></a>
Historical background</h1>
<p>When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).</p>
<p>As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.</p>
<p>Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.</p>
<p>The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.</p>
<p>With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.</p>
<h1><a class="anchor" id="pros-cons"></a>
Pros and Cons</h1>
<p>Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders</p><ul>
<li>Hardware animation (a.k.a hardware skinning)</li>
<li>Soft shadows</li>
<li>Normal/Bump maps</li>
<li>Specular maps</li>
<li>Advanced multi-texturing effects</li>
</ul>
<p>Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.</p>
<p>So why use a runtime shader system anyway?</p>
<ul>
<li>Save development time e.g. when your target scene has dynamic lights and the number changes, fog changes, ... and the number of material attributes increases the total count of needed shaders dramatically. It can easily cross 100 and it becomes a time consuming development task.</li>
<li>Reusable code - once you've written the shader extension you can use it anywhere due to its independent nature.</li>
<li>Custom shaders extension library - enjoy the shared library of effects created by the community. Unlike hand written shader code, which may require many adjustments to be plugged into your own shader code, using the extensions library requires minimum changes. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: HLMS: High Level Material System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hlms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HLMS: High Level Material System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#components">The three components</a></li>
<li class="level1"><a href="#materials">Compared to classical materials</a></li>
<li class="level1"><a href="#data">Material parameters are stored in “Blocks”</a><ul><li class="level2"><a href="#toc52">Datablocks</a></li>
</ul>
</li>
<li class="level1"><a href="#toc69">Hlms templates</a><ul><li class="level2"><a href="#preproc">The Hlms preprocessor</a></li>
<li class="level2"><a href="#syntax">Preprocessor syntax</a></li>
</ul>
</li>
<li class="level1"><a href="#shaders">Creation of shaders</a></li>
<li class="level1"><a href="#cpp">C++ interaction with shader templates</a></li>
<li class="level1"><a href="#customization">Customization</a></li>
</ul>
</div>
<div class="textblock"><p>This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.</p>
<p>Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.</p>
<p>Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.</p>
<p>But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.</p>
<p>Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.</p>
<h1><a class="anchor" id="components"></a>
The three components</h1>
<div class="image">
<object type="image/svg+xml" data="hlms_components.svg">hlms_components.svg</object>
</div>
<ol type="1">
<li>Scripts. To set the material properties (i.e. type of Hlms to use: PBS, Toon shading, GUI; what textures, diffuse colour, roughness, etc). <b>You currently have to do this from C++.</b> Everybody will be using this part.</li>
<li>Shader template. The Hlms takes a couple hand-written glsl/hlsl files as template and then adapts it to fit the needs on the fly (i.e. if the mesh doesn’t contain skeleton, the bit of code pertaining to skeletal animation is stripped from the vertex shader). The Hlms provides a simple preprocessor to deal with this entirely within from the template, but you’re not forced to use it. Here’s a simple example of the preprocessor. I won’t be explaining the main keywords today. Advanced users will probably want to modify these files (or write some of their own) to fit their custom needs.</li>
<li>C++ classes implementation. The C++ takes care of picking the shader templates and manipulating them before compiling; and most importantly it feeds the shaders with uniform/constans data and sets the textures that are being in use. It is extremely flexible, powerful, efficient and scalable, but it’s harder to use than good ol’ Materials because those used to be data-driven: there are no AutoParamsSource here. Want the view matrix? You better grab it from the camera when the scene pass is about to start, and then pass it yourself to the shader. This is very powerful, because in D3D11/GL3+ you can just set the uniform buffer with the view matrix just once for the entire frame, and thus have multiple uniforms buffers sorted by update frequency. Very advanced user will be using messing with this part.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Material scripts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.x do not yet support the HLMS - you must use the C++ API. e.g. <a class="el" href="class_ogre_1_1_pbs_material.html">Ogre::PbsMaterial</a>.</dd></dl>
<p>Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.</p>
<p>For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.</p>
<p>It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.</p>
<h1><a class="anchor" id="materials"></a>
Compared to classical materials</h1>
<p>Materials are still useful for:</p>
<ul>
<li>Quick iteration. You need to write a shader, just define the material and start coding. Why would you deal with the template’s syntax or a C++ module when you can just write a script and start coding?. The HLMS though comes with a Command line tool to know how your template translates into a final shader (which is very handy for iteration, it’s fast, and will check for syntax errors!), but it’s most useful when you want to write your own C++ module or change the template, not when you want to just experiment. Besides, old timers are used to writing materials.</li>
<li>Postprocessing effects. Materials are much better suited for this. Materials are data driven, easy to write. Postprocessing FXs don’t need an awful lot of permutations (i.e. having to deal with shadow mapping, instancing, skeleton animation, facial animation). And they’re at no performance disadvantage compared to HLMS: Each FX is a fullscreen pass that needs different shaders, different textures, its own uniforms. Basically, API overhead we can’t optimize. But it doesn’t matter much either, because it’s not like there are 100 fullscreen passes. Usually there’s less than 10.</li>
</ul>
<h1><a class="anchor" id="data"></a>
Material parameters are stored in “Blocks”</h1>
<p>You could be thinking the reason I came up with these two is to fit with D3D11′s grand scheme of things while being compatible with OpenGL. But that’s a half truth and an awesome side effect. I’ve been developing the Hlms using OpenGL this whole time.</p>
<p>An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and they’re right about that.</p>
<p>However, there are big advantages for using blocks:</p>
<ol type="1">
<li>Many materials in practice share the same Macro- &amp; Blendblock parameters. In an age where we want many 3D primitives with the same shader but slightly different parameters like texture, colour, or roughness (which equals, a different material) having these settings repeated per material wastes a lot of memory space… and a lot of bandwidth (and wastes cache space). <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 is bandwidth bound, so having all materials share the same pointer to the same Macroblock can potentially save a lot of bandwidth, and be friendlier to the cache at the same time.This stays true whether we use D3D11, D3D12, OpenGL, GL ES 2, or Mantle.</li>
<li>Sorting by Macroblock is a lot easier (and faster) than sorting by its individual parameters: when preparing the hash used for sorting, it’s much easier to just do (every frame, per object) <code>hash |= (macroblock-&gt;getId() &lt;&lt; bits) &amp; mask</code> than to do: <code>hash =| m-&gt;depth_check | m-&gt;depthWrite &lt;&lt; 1 | m-&gt;depthBias &lt;&lt; 2 | m-&gt;depth_slope_bias &lt;&lt; 3 | m-&gt;cullMode &lt;&lt; 18 | ... ;</code> We also need a lot more bits we can’t afford. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 imposes a limit on the amount of live Macroblocks you can have at the same time; as we run out of hashing space (by the way, D3D11 has its own limit). It operates around the idea that most setting combinations won’t be used in practice.</li>
</ol>
<p>Of course it’s not perfect, it can’t fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); you’ll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. We’re aiming the general use case.</p>
<p>These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since I’m not used to driver development. However from an engine perspective, blocks make sense.</p>
<h2><a class="anchor" id="toc52"></a>
Datablocks</h2>
<p>We’re introducing the concept of Datablocks. A Datablock is a “material” from the user’s perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.</p>
<div class="image">
<object type="image/svg+xml" data="hlms_blocks.svg">hlms_blocks.svg</object>
</div>
<p>The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.</p>
<dl class="section note"><dt>Note</dt><dd>Macroblocks and Blendblocks are not available in 1.x - use <a class="el" href="class_ogre_1_1_pass.html#ae454faee87f8cb0b8540810e48118788" title="Sets whether or not this pass renders with depth-buffer checking on or not. ">Ogre::Pass::setDepthCheckEnabled</a> etc. as usual, to change the respective properties</dd></dl>
<h1><a class="anchor" id="toc69"></a>
Hlms templates</h1>
<p>The Hlms will parse the template files from the template folder according to the following rules:</p>
<ol type="1">
<li>The files with the names "VertexShader_vs", "PixelShader_ps", "GeometryShader_gs", "HullShader_hs", "DomainShader_ds" will be fully parsed and compiled into the shader. If an implementation only provides "VertexShader_vs.glslt", "PixelShader_ps.glslt"; only the vertex and pixel shaders for OpenGL will be created. There will be no geometry or tesellation shaders.</li>
<li>The files that contain the string "_piece_vs" in their filenames will be parsed only for collecting pieces (more on pieces later). Likewise, the words "_piece_ps", "_piece_gs", "_piece_hs", "_piece_ds” correspond to the pieces for their respective shader stages. Note that you can concatenate, thus "MyUtilities_piece_vs_piece_ps.glslt” will be collected both in the vertex and pixel shader stages.</li>
</ol>
<p>The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.</p>
<h2><a class="anchor" id="preproc"></a>
The Hlms preprocessor</h2>
<p>The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.</p>
<p>For example </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can't evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can't check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable “IncludeLightingEquals2” and check whether it's non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can't see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you'll depend on the driver implementation having a good macro preprocessor.</p>
<h2><a class="anchor" id="syntax"></a>
Preprocessor syntax</h2>
<p>The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:</p>
<ul>
<li>@property</li>
<li>@foreach</li>
<li>@counter</li>
<li>@value</li>
<li>@set add sub mul div mod min max</li>
<li>@piece</li>
<li>@insertpiece</li>
<li>@pset padd psub pmul pdiv pmod pmin pmax</li>
</ul>
<h3>@property( expression )</h3>
<p>Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.</p>
<p>The logical operands &amp;&amp; || ! are valid.</p>
<p>Examples: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: </p><div class="fragment"><div class="line">hasLights != 0                              hasLights == 0</div><div class="line">diffuse = surfaceDiffuse * lightDiffuse;   diffuse = surfaceDiffuse ;</div></div><!-- fragment --><h3>@foreach( scopedVar, count, [start] )</h3>
<p>Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.</p>
<ul>
<li>scopedVar is a variable that can be used to print the current iteration of the loop while inside the block. i.e. “@scopedVar” will be converted into a number in the range [start; count)</li>
<li>count The number of times to repeat the loop (if start = 0). Count can read variables.</li>
<li>start Optional. Allows to start from a value different than 0. Start can read variables.</li>
</ul>
<p>Newlines are very important, as they will be printed with the loop.</p>
<p>Examples: </p><table class="doxtable">
<tr>
<th>Expression </th><th>Output  </th></tr>
<tr>
<td>@foreach( 4, n ) <br />
&emsp; @n@end </td><td><br />
0<br />
1<br />
2<br />
3 </td></tr>
<tr>
<td>@foreach( 4, n ) @n@end </td><td>0 1 2 3 </td></tr>
<tr>
<td>@foreach( 4, n )<br />
&emsp;@n<br />
@end </td><td><br />
0<br />
<br />
1<br />
<br />
2<br />
<br />
3<br />
 </td></tr>
<tr>
<td>@foreach( 4, n, 2 ) @n@end </td><td>2 3 </td></tr>
<tr>
<td>@pset( myStartVar, 1 )<br />
@pset( myCountVar, 3 )<br />
@foreach( myStartVar, n, myCountVar )<br />
&emsp;@n@end </td><td>1<br />
2 </td></tr>
<tr>
<td>@foreach( 2, n )<br />
&emsp;@insertpiece( pieceName@n )@end </td><td>@insertpiece( pieceName0 )<br />
 @insertpiece( pieceName1 ) </td></tr>
</table>
<blockquote class="doxtable">
<p><b>Attention #1!</b></p>
<p>Don't use the common letter i for the loop counter. It will conflict with other keywords.</p>
<p>i.e. “@foreach( 1, i )@insertpiece( pieceName )@end” will print “0nsertpiece( pieceName )” which is probably not what you intended.</p>
<p><b>Attention #2!</b></p>
<p>foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.</p>
<p>i.e. The following code will not work:</p>
<div class="fragment"><div class="line">@pset( myVar, 1 )</div><div class="line"></div><div class="line">@<span class="keywordflow">foreach</span>( 2, n )</div><div class="line"></div><div class="line"><span class="comment">//Code</span></div><div class="line"></div><div class="line">@psub( myVar, 1 ) <span class="comment">//Decrement myVar on each loop</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( myVar )</div><div class="line"></div><div class="line"><span class="comment">//Code that shouldn&#39;t be printed in the last iteration</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>Because psub will be evaluated before expanding the foreach. </p>
</blockquote>
<h3>@counter( variable )</h3>
<p>Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.</p>
<p>Examples: </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@counter( myVar )   1</div><div class="line"></div><div class="line">@counter( myVar )   2</div></div><!-- fragment --><h3>@value( variable )</h3>
<p>Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@value( myVar )     1</div><div class="line"></div><div class="line">@value( myVar )     1</div></div><!-- fragment --><h3>@set add sub mul div mod min max</h3>
<p>Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.</p>
<p>Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c</p>
<p>Useful in combination with @counter and @value</p>
<table class="doxtable">
<tr>
<th>Expression </th><th>Output </th><th>Math  </th></tr>
<tr>
<td>@set( myVar, 1 ) <br />
 @value( myVar ) </td><td>1 </td><td>myVar = 1 </td></tr>
<tr>
<td>@add( myVar, 5 )<br />
 @value( myVar ) </td><td>6 </td><td>myVar = 1 + 5 </td></tr>
<tr>
<td>@div( myVar, 2 ) <br />
 @value( myVar ) </td><td>3 </td><td>myVar = 6 / 2 </td></tr>
<tr>
<td>@mul( myVar, myVar )<br />
 @value( myVar ) </td><td>9 </td><td>myVar = 3 * 3 </td></tr>
<tr>
<td>@mod( myVar, 5 ) <br />
 @value( myVar ) </td><td>4 </td><td>myVar = 9 % 5 </td></tr>
<tr>
<td>@add( myVar, 1, 1 ) <br />
 @value( myVar ) </td><td>2 </td><td>myVar = 1 + 1 </td></tr>
</table>
<h3>@piece( nameOfPiece )</h3>
<p>Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won't be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                        Output</div><div class="line"></div><div class="line">@piece( VertexTransform )         </div><div class="line"></div><div class="line">outPos = worldViewProj * inPos   </div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><h3>@insertpiece( nameOfPiece )</h3>
<p>Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                                                     Output</div><div class="line"></div><div class="line">@piece( VertexTransform )outPos = worldViewProj * inPos@end   void main()</div><div class="line"></div><div class="line">void main()                                                    {</div><div class="line"></div><div class="line">{                                                              outPos = worldViewProj * inPos</div><div class="line"></div><div class="line">@insertpiece( VertexTransform )                                }</div><div class="line"></div><div class="line">@insertpiece( InexistentPiece )                                </div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h3>@pset padd psub pmul pdiv pmod pmin pmax</h3>
<p>Analogous to <a href="#toc304"><em>the family of math functions without the 'p' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.</p>
<p>i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )</p>
<p>One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.</p>
<p>If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.</p>
<h1><a class="anchor" id="shaders"></a>
Creation of shaders</h1>
<p>There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:</p>
<ol type="1">
<li>The Datablock/Material. Does it have Normal maps? Then include code to sample the normal map and affect the lighting calculations. Does it have a diffuse map? If not, avoid sampling the diffuse map and multiplying it against the diffuse colour, etc.</li>
<li>The Mesh. Is it skeletally animated? Then include skeletal animation code. How many blend weights? Modify the skeletal animation code appropiately. It doesn't have tangents? Then skip the normal map defined in the material. And so on.</li>
</ol>
<p>When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.</p>
<p>If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).</p>
<p>The following graph summarizes the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_hash.svg">hlms_hash.svg</object>
</div>
<p>Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a “<a href="#toc567"><em>pass hash</em></a>” instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).</p>
<p>While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_caching.svg">hlms_caching.svg</object>
</div>
<h1><a class="anchor" id="cpp"></a>
C++ interaction with shader templates</h1>
<p>Note: This section is relevant to those seeking to write their own Hlms implementation.</p>
<p>C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set “key” to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod</p>
<p>To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.</p>
<p>The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.</p>
<p>In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.</p>
<p>Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.</p>
<p>For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.</p>
<p>The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.</p>
<h2>Common conventions</h2>
<p>Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.</p>
<p>Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.</p>
<p>For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.</p>
<p>Properties in underscore_case are set from C++; propierties in camelCase are set from the template.</p>
<p>Propierties and pieces starting with 'custom_' are for user customizations of the template</p>
<p>TBD</p>
<h2>Disabling a stage</h2>
<p>By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.</p>
<p>Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.</p>
<h1><a class="anchor" id="customization"></a>
Customization</h1>
<p>In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.</p>
<p>Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.</p>
<p>Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.</p>
<p>There are different levels in which an Hlms implementation can be customized:</p>
<ol type="1">
<li>Using a library, see <a href="#toc574"><em>Hlms Initialization</em></a>. pass a set of piece files in a folder by pushing the folder to ArchiveVec. The files in that folder will be parsed first, in order (archiveVec[0] then archiveVec[1], … archiveVec[N-1]); which will let you define your own pieces to insert code into the default template (see the the table at the end). You can also do clever tricky things to avoid dealing with C++ code at all even if there are no 'custom_' pieces for it. For example, you can write the following code to override the BRDF declarations and provide a custom BRDF: <div class="fragment"><div class="line"><span class="comment">//Disable all known BRDFs that the implementation may enable</span></div><div class="line"></div><div class="line">@pset( BRDF_CookTorrance, 0 )</div><div class="line"></div><div class="line">@pset( BRDF_Default, 0 )</div><div class="line"></div><div class="line">@piece( DeclareBRDF )</div><div class="line"></div><div class="line"><span class="comment">// Your BRDF code declaration here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --></li>
</ol>
<ol type="1">
<li>Via listener, through HlmsListener. This allows you to have access to the buffer pass to fill extra information; or bind extra buffers to the shader.</li>
<li>Overload HlmsPbs. Useful for overriding only specific parts, or adding new functionality that requires storing extra information in a datablock (e.g. overload HlmsPbsDatablock to add more variables, and then overload HlmsPbs::createDatablockImpl to create these custom datablocks)</li>
<li>Directly modify HlmsPbs, HlmsPbsDatablock and the template. <table class="doxtable">
<tr>
<th>Variable </th><th>Description  </th></tr>
<tr>
<td>custom_passBuffer </td><td>Piece where users can add extra information for the pass buffer (only useful if the user is using HlmsListener or overloaded HlmsPbs. </td></tr>
<tr>
<td>custom_VStoPS </td><td>Piece where users can add more interpolants for passing data from the vertex to the pixel shader. </td></tr>
<tr>
<td>custom_vs_attributes </td><td>Custom vertex shader attributes in the Vertex Shader (i.e. a special texcoord, etc). </td></tr>
<tr>
<td>custom_vs_uniformDeclaration </td><td>Data declaration (textures, texture buffers, uniform buffers) in the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_posExecution </td><td>Executed after all code from the Vertex Shader has been performed. </td></tr>
<tr>
<td>custom_ps_uniformDeclaration </td><td>Same as custom_vs_uniformDeclaration, but for the Pixel Shader </td></tr>
<tr>
<td>custom_ps_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Pixel Shader. </td></tr>
<tr>
<td>custom_ps_posMaterialLoad </td><td>Executed right after loading material data; and before anything else. May not get executed if there is no relevant material data (i.e. doesn't have normals or QTangents for lighting calculation) </td></tr>
<tr>
<td>custom_ps_preLights </td><td>Executed right before any light (i.e. to perform your own ambient / global illumination pass). All relevant texture data should be loaded by now. </td></tr>
<tr>
<td>custom_ps_posExecution </td><td>Executed after all code from the Pixel Shader has been performed. </td></tr>
</table>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: RTSS: Run Time Shader System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rtss.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">RTSS: Run Time Shader System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#core-feats">Core features of the system</a></li>
<li class="level1"><a href="#rtss_overview">System overview</a><ul><li class="level2"><a href="#rtss_custom_api">Customising via API</a></li>
<li class="level2"><a href="#rtss_custom_mat">Customizing via Material Script</a></li>
</ul>
</li>
<li class="level1"><a href="#rtss_indepth">The RTSS in Depth</a><ul><li class="level2"><a href="#rtss__components">Main components</a></li>
<li class="level2"><a href="#creating-extensions">Creating custom shader extensions</a></li>
<li class="level2"><a href="#debugging">Tips for debugging shaders</a></li>
</ul>
</li>
<li class="level1"><a href="#history">Historical background</a></li>
<li class="level1"><a href="#pros-cons">Pros and Cons</a></li>
</ul>
</div>
<div class="textblock"><p>This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.</p>
<h1><a class="anchor" id="core-feats"></a>
Core features of the system</h1>
<ul>
<li>Runtime shader generation synchronized with scene state. Each time scene settings change, a new set of shaders is generated.</li>
<li>Full Fixed Function Pipeline (FFP) emulation. This feature is most useful combined with render system that doesn't provide any FFP functionality (OpenGL ES 2.0, D3D11 etc).</li>
<li>Shader language independent interface: the logic representation of the shader programs is completely independent from the target shader language. You can generate code for different shader languages from the same program.</li>
<li>Pluggable interface allows extending the target shader languages set.</li>
<li>Pluggable interface allows adding new shader based effects to the system in a seamless way. Each effect code will be automatically combined with the rest of the shader code.</li>
<li>Smart program management: each shader program is created only once and may be used by multiple passes.</li>
<li>Automatic vertex shader compacting mechanism: no more compacting variables by hand. In case the amount of used vertex shader output registers exceeds the maximum allowed (12 to 32, depending on <a href="http://msdn.microsoft.com/en-us/library/bb172918%28v=VS.85%29.aspx">D3DPSHADERCAPS2_0.NumTemps</a>), a compacting algorithm packs the vertex shader outputs and adds unpack code in the fragment shader side.</li>
<li>Material script support, for both export and import.</li>
</ul>
<h1><a class="anchor" id="rtss_overview"></a>
System overview</h1>
<p>The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.</p>
<p>Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.</p>
<p>To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.</p>
<p>After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.</p>
<p>Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates</p>
<div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">uniform mat4    worldviewproj_matrix;</div><div class="line">uniform mat4    texture_matrix1;</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">in  vec4    vertex;</div><div class="line">in  vec4    uv0;</div><div class="line">out vec4    oTexcoord4_0;</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    FFP_Transform(worldviewproj_matrix, vertex, gl_Position);</div><div class="line">    FFP_TransformTexCoord(texture_matrix1, uv0.xy, oTexcoord4_0.xy);</div><div class="line">}</div></div><!-- fragment --><p>It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)</p>
<p>Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.</p>
<p>The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.</p>
<h2><a class="anchor" id="rtss_custom_api"></a>
Customising via API</h2>
<p>The first option is to globally enforce per-pixel lighting, you can do the following</p>
<div class="fragment"><div class="line">        <span class="comment">// Grab the scheme render state.</span></div><div class="line">        <a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">Ogre::RTShader::RenderState</a>* schemRenderState =</div><div class="line">            mShaderGenerator-&gt;getRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line">        <span class="comment">// Add per pixel lighting sub render state to the global scheme render state.</span></div><div class="line">        <span class="comment">// It will override the default FFP lighting sub render state.</span></div><div class="line">        <span class="keywordflow">if</span> (usePerPixelLighting) {</div><div class="line">            <a class="code" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">Ogre::RTShader::SubRenderState</a>* perPixelLightModel =</div><div class="line">                mShaderGenerator-&gt;createSubRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_per_pixel_lighting.html#ae766f76cad4b3a4339a0cd50abbddcc2">Ogre::RTShader::PerPixelLighting::Type</a>);</div><div class="line"></div><div class="line">            schemRenderState-&gt;<a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html#af66edaf33c654e03ef89f1eaec384a1f">addTemplateSubRenderState</a>(perPixelLightModel);</div><div class="line">        }</div></div><!-- fragment --><p> any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.</p>
<h2><a class="anchor" id="rtss_custom_mat"></a>
Customizing via Material Script</h2>
<p>Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following</p>
<div class="fragment"><div class="line">            <span class="comment">// RT Shader system section.</span></div><div class="line">            rtshader_system</div><div class="line">            {       </div><div class="line">                <span class="comment">// Override lighting stage with per pixel lighting.             </span></div><div class="line">                lighting_stage per_pixel                </div><div class="line">            }   </div></div><!-- fragment --><p> for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.</p>
<p>Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:</p>
<ul>
<li><a href="#lighting_stage">lighting_stage</a></li>
<li><a href="#light_count">light_count</a></li>
<li><a href="#triplanarTexturing">triplanarTexturing</a></li>
<li><a href="#integrated_pssm4">integrated_pssm4</a></li>
<li><a href="#layered_blend">layered_blend</a></li>
<li><a href="#source_modifier">source_modifier</a></li>
</ul>
<p><a class="anchor" id="lighting_stage"></a></p>
<h3>lighting_stage</h3>
<p>Force a specific lighting model.</p>
<p>Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code></p>
<p>Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code></p>
<p>Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_r_t_shader_1_1_normal_map_lighting.html#adc6b4bdd1ea31c2232336599d2b30b60" title="Normal map space definition. ">Ogre::RTShader::NormalMapLighting::NormalMapSpace</a> </dd>
<dd>
<a class="el" href="group___general.html#ga21a0186392e9c9ce16d29c5568a773c5" title="High-level filtering options providing shortcuts to settings the minification, magnification and mip ...">Ogre::TextureFilterOptions</a></dd></dl>
<p><a class="anchor" id="light_count"></a></p>
<h3>light_count</h3>
<p>Override dynamic light count. Allows to customize which lights the RTSS will consider.</p>
<p>Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code></p>
<p><a class="anchor" id="triplanarTexturing"></a></p>
<h3>triplanarTexturing</h3>
<p>Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a></p>
<p>Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code></p>
<p>Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureScale</td><td>texture coordinates are multiplied by this. </td></tr>
    <tr><td class="paramname">plateauSize</td><td>plateau on which small components of the normal have no influence. </td></tr>
    <tr><td class="paramname">transitionSpeed</td><td>transitions speed between the three textures Valid values are [0; 0.57] not bigger to avoid division by zero </td></tr>
    <tr><td class="paramname">textureFromX</td><td>Texture for the x-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromY</td><td>Texture for the y-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromZ</td><td>Texture for the z-direction planar mapping</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="integrated_pssm4"></a></p>
<h3>integrated_pssm4</h3>
<p>Integrated PSSM shadow receiver with 3 splits. Custom split points.</p>
<p>Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code></p>
<p><a class="anchor" id="layered_blend"></a></p>
<h3>layered_blend</h3>
<p>Apply photoshop-like blend effects to texture layers</p>
<p>Format: <code>layered_blend &lt;effect&gt;</code></p>
<p>Example: layered_blend luminosity</p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">effect</td><td>one of <code>default, normal, lighten, darken, multiply, average, add, subtract, difference, negation, exclusion, screen, overlay, hard_light, soft_light, color_dodge, color_burn, linear_dodge, linear_burn, linear_light, vivid_light, pin_light, hard_mix, reflect, glow, phoenix, saturation, color, luminosity</code></td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="source_modifier"></a></p>
<h3>source_modifier</h3>
<p>Apply custom modulate effect to texture layer</p>
<p>Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code></p>
<p>Example: <code>source_modifier src1_inverse_modulate custom 2</code></p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>one of <code>src1_modulate, src2_modulate, src1_inverse_modulate, src2_inverse_modulate</code> </td></tr>
    <tr><td class="paramname">parameterNum</td><td>number of the custom shader parameter that controls the operation</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="rtss_indepth"></a>
The RTSS in Depth</h1>
<p>When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.</p>
<p>The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).</p>
<p>Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.</p>
<p>The following steps are executed in order to generate shaders for a given technique:</p>
<ul>
<li>For each pass in the technique the system builds a set of sub render states that describe the logic process of the rendering pipeline from the draw call submission until the final pixel color.</li>
<li>Each render state is translated into a set of logic shader programs (currently only pixel and vertex shader). The logic programs are then sent to specific shader language writers that produce source code for the respective shader language. The source code is used to create the GPU programs that are applied to the destination pass. Before rendering of an object that uses generated shaders the system allows each sub render state to update the GPU constants associated with it.</li>
</ul>
<h2>Initializing the system</h2>
<dl class="section note"><dt>Note</dt><dd>If you are using the <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>, the following steps will be taken automatically for you.</dd></dl>
<p>Initializing the system is composed of the following steps:</p><ul>
<li>Create the internal managers and structures via the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260" title="Initialize the Shader Generator System. ">Ogre::RTShader::ShaderGenerator::initialize()</a></code> method.</li>
<li>Set the target cache path. This is the place on your disk where the output shaders will be written to or will be read from in case they were generated by previous runs of your application.</li>
<li>Verify that the location of the shader libs needed by the system is added to the ResourceGroupManager via the <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d" title="Adds a location to the list of searchable locations for a Resource type. ">Ogre::ResourceGroupManager::addResourceLocation()</a></code> method.</li>
<li>Assign the target scene manager to the shader generator.</li>
<li>Add one or more specialized sub-render states that are to be shared among all materials (per pixel lighting, textured fog, etc...).</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260">Ogre::RTShader::ShaderGenerator::initialize</a>())</div><div class="line">{</div><div class="line">    <span class="comment">// Grab the shader generator pointer.</span></div><div class="line">    mShaderGenerator = <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">Ogre::RTShader::ShaderGenerator::getSingletonPtr</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Add the shader libs resource location. a sample shader lib can be found in Samples\Media\RTShaderLib</span></div><div class="line">    <a class="code" href="class_ogre_1_1_resource_group_manager.html#a45101333f0f9ff132fc381dd5c4a1d60">Ogre::ResourceGroupManager::getSingleton</a>().<a class="code" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d">addResourceLocation</a>(shaderLibPath, <span class="stringliteral">&quot;FileSystem&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Set shader cache path.</span></div><div class="line">    mShaderGenerator-&gt;setShaderCachePath(shaderCachePath);      </div><div class="line"></div><div class="line">    <span class="comment">// Set the scene manager.</span></div><div class="line">    mShaderGenerator-&gt;addSceneManager(sceneMgr);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><h2>Creating shader based technique</h2>
<p>This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.</p>
<p>To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.</p>
<p>Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// Create shader based technique from the default technique of the given material.</span></div><div class="line">mShaderGenerator-&gt;createShaderBasedTechnique(<span class="stringliteral">&quot;Examples/BeachStones&quot;</span>, <a class="code" href="class_ogre_1_1_material_manager.html#a290b828b5d44637ee4d247a09ea81bd6">Ogre::MaterialManager::DEFAULT_SCHEME_NAME</a>, <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line"><span class="comment">// Apply the shader generated based techniques.</span></div><div class="line">mViewport-&gt;setMaterialScheme(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div></div><!-- fragment --> <div class="image">
<object type="image/svg+xml" data="CreateShaderBasedTech.svg">CreateShaderBasedTech.svg</object>
</div>
<h2>Runtime shader generation</h2>
<p>During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.</p>
<div class="image">
<object type="image/svg+xml" data="RuntimeShaderGeneration.svg">RuntimeShaderGeneration.svg</object>
</div>
<h2><a class="anchor" id="rtss__components"></a>
Main components</h2>
<p>The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.</p>
<h3>ShaderGenerator</h3>
<p>The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.</p>
<h3>RenderState classes</h3>
<p>A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.</p>
<p>RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.</p>
<h3>SubRenderState classes</h3>
<p>Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.</p>
<p>There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_transform.html" title="Transform sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTransform</a> - responsible for adding code to the vertex shader which computes the position of the vertex in projection space</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_colour.html" title="Colour sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPColour</a> - responsible for adding code to the shaders that calculate the base diffuse and specular color of the object regardless of lights or textures. The color is calculated based on the ambient, diffuse, specular and emissive properties of the object and scene, color tracking and the specified hardware buffer color.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_lighting.html" title="Lighting sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPLighting</a> - responsible for adding code to the shaders that calculate the luminescence added to the object by light. Then add that value to the color calculated by the color SRS stage.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_texturing.html" title="Texturing sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTexturing</a> - responsible for adding code that modulates the color of the pixels based on textures assigned to the material.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_fog.html" title="Fog sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPFog</a> - responsible for adding code that modulates the color of a pixel based on the scene or object fog parameters.</li>
</ul>
<p>There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...</p>
<h3>SubRenderStateFactory</h3>
<p>As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.</p>
<p>These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.</p>
<h2><a class="anchor" id="creating-extensions"></a>
Creating custom shader extensions</h2>
<p>Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.</p>
<p>In order to extend the system with your own shader effects you'll have to follow these steps:</p><ul>
<li>Implement the SubRenderState interface - This is the main class that is responsible for the actual effect processing such as preparing the destination pass, updating the CPU shader programs, updating the GPU shader parameters etc.</li>
<li>Implement the SubRenderStateFactory interface: This class will allow the RTSS to create instances of the previous class via code or script as well as export it to material script file.</li>
<li>Register the factory to the RTSS using the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac266946244d79b2d4732607ae9479bd9" title="Add sub render state factory. ">Ogre::RTShader::ShaderGenerator::addSubRenderStateFactory</a> method.</li>
<li>Add shader files that will supply all the actual shader functions your SubRenderState needs. In order to support multiple shader languages you should supply code for your entire desired target shading languages (CG, HLSL, GLSL etc). These files should be placed in a way that the resource manager could access them. This can be done by placing them in a valid resource location or by dynamically adding resource location.</li>
</ul>
<p>Implementing the SubRenderState requires overriding the pure methods of the base class.</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#ae91b7b8f76848d67652b6e5832a27a49" title="Get the type of this sub render state. ">Ogre::RTShader::SubRenderState::getType()</a> should return unique string that identify the sub class implementation. That value is shared among all instances and can be stored in a static string variable. It uses to system to match between SubRenderState instance and the factory to should destroy it.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#acb48c34ee231f0220f68c967fb32f1e5" title="Get the execution order of this sub render state. ">Ogre::RTShader::SubRenderState::getExecutionOrder()</a> should return integer value that will use the system to sort all SubRenderState instances of the same render state before each one of them will create its part in the CPU shader programs. Note that:<ul>
<li>The execution order does not imply the order of the parameter definitions and function calls within the generated shader.</li>
<li>If an execution number is set to be the same as one of the basic fixed pipeline SRSs. Than that SRS will be built <b>instead</b> of the fixed pipeline SRS.</li>
</ul>
</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a5dfe9f03413e0fe99ea2640f06c1f13c" title="Copy details from a given sub render state to this one. ">Ogre::RTShader::SubRenderState::copyFrom()</a> a simple copy method that uses the system when coping one instance to another. <b>Note:</b> Only configuration data attributes should be copy here.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4b43c261946926ebbc6456deccc6697a" title="Create sub programs that represents this sub render state as part of a program set. ">Ogre::RTShader::SubRenderState::createCpuSubPrograms</a> - This is the heart of this interface. This method should update the CPU shader programs with the specific details of the overriding class.</li>
</ul>
<p>The SubRenderState supply default implementation for this method which break down this method into three stages:</p><ul>
<li>Resolving parameters: this stage should grab all the needed parameters for this SubRrenderState. In case of the FFPTransform it should resolve the world view projection matrix and vertex shader input and output position parameters.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Function* vsEntry = vsProgram-&gt;getEntryPointFunction();</div><div class="line">    </div><div class="line">    <span class="comment">// Resolve World View Projection Matrix.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#ae0e6b89f6ed3986b0a87e2472e3ff7f1">UniformParameterPtr</a> wvpMatrix = vsProgram-&gt;resolveAutoParameterInt(GpuProgramParameters::ACT_WORLDVIEWPROJ_MATRIX, 0);</div><div class="line">        </div><div class="line">    <span class="comment">// Resolve input position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionIn = vsEntry-&gt;resolveInputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_OBJECT_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>); </div><div class="line">    </div><div class="line">    <span class="comment">// Resolve output position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionOut = vsEntry-&gt;resolveOutputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_PROJECTIVE_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!wvpMatrix || !positionIn || !positionOut)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___general.html#gaf27f0d64dfeb225d37a513c253eaa1a0">OGRE_EXCEPT</a>( Exception::ERR_INTERNAL_ERROR, </div><div class="line">                <span class="stringliteral">&quot;Not all parameters could be constructed for the sub-render state.&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;FFPTransform::createCpuSubPrograms&quot;</span> );</div><div class="line">    }</div></div><!-- fragment --><ul>
<li>Resolving dependencies: this stage should provide the name of the external shader library files that contains the actual shader code needed by this SubRenderState. In case of the FFPTexturing it will add the common and texturing library for both vertex and pixel shader program.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Program* psProgram = programSet-&gt;getCpuFragmentProgram();</div><div class="line"></div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);    </div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);</div></div><!-- fragment --><ul>
<li>Adding function invocations: this stage creates the function calls within this SubRenderState requires. Each function call has two keys that are used by the system to sort it before generating the actual shader code as well as set of in/out parameters. A function invocation is added to either vertex shader program or fragment shader program. In case of the FFPFog it will add vertex depth calculation to the vertex shader program.</li>
</ul>
<div class="fragment"><div class="line">        curFuncInvocation = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> FunctionInvocation(<a class="code" href="group___r_t_shader.html#gabaab1e89270cd7f763f2f8e0258c400e">FFP_FUNC_PIXELFOG_DEPTH</a>, <a class="code" href="group___r_t_shader.html#gga7d20b2397c3eab2b52ec405863c6f274a8b4930a3fd90d5b7222960fc5727b8cf">FFP_VS_FOG</a>);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mWorldViewProjMatrix, Operand::OPS_IN);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSInPos, Operand::OPS_IN);  </div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSOutDepth, Operand::OPS_OUT);  </div><div class="line">        vsMain-&gt;addAtomInstance(curFuncInvocation);     </div></div><!-- fragment --><p> Note:</p><ul>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can add as many function invocations as it needs.</li>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can different function invocations in different ordering.</li>
<li>The ordering of the function invocation is crucial. Use the FFPVertexShaderStage and FFPFragmentShaderStage enumarations to place your invocations in the desired order.</li>
<li>Make sure the parameter semantic (in/out) in the SubRenderState code matches to your shader code implementation you supplied in the library file. GLSL will fail to link to libray functions if it won't be able to find a perfect function declaration match.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4c2acbc15e44c3fe42868abce1116ec2" title="Update GPU programs parameters before a rendering operation occurs. ">Ogre::RTShader::SubRenderState::updateGpuProgramsParams</a> - As the name suggest this method should be overridden only in case your SubRenderState should update some parameter it created before.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#afd08043cfad43a1ae470c3c1be341ba1" title="Called before adding this sub render state to the given render state. ">Ogre::RTShader::SubRenderState::preAddToRenderState()</a>: this method called before adding this SubRenderState to a parent RenderState instances. It allows this SubRenderState to exclude itself from the list in case the source pass is not matching. I.E in case of SubRenderState that perform lighting calculations it can return false when the given source pass specifies that lighting calculations disabled for it.</li>
</ul>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (!srcPass-&gt;getLightingEnabled())</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div></div><!-- fragment --><p> This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.</p>
<p>Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods</p><ul>
<li>Ogre::RTShader::SubRenderStateFactory::createInstanceImpl(): This method should return instance for the SubRenderState sub class.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#a954d30cb82307ae1ba785792b833b689" title="Create an instance of the SubRenderState sub class it suppose to create. ">Ogre::RTShader::SubRenderStateFactory::createInstance()</a>: This method should return instasnce for the SubRenderState sub class using the given script compiler parameters. Implemet this method if you want to be able to creat your custom shader extension from material script.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#ada31909080bae96784504be42d9bd77c" title="Write the given sub-render state instance using the material serializer. ">Ogre::RTShader::SubRenderStateFactory::writeInstance()</a>: This method should write down the parameters of a given SubRenderState instance to material script file. Implement this method if you want to be able to export a material that contains your custom shader extension.</li>
</ul>
<h2><a class="anchor" id="debugging"></a>
Tips for debugging shaders</h2>
<p>A couple of notes on debugging shaders coming from the RTSS:</p><ul>
<li>Call <a class="el" href="class_ogre_bites_1_1_application_context.html#aaad4c1d25a7a5f60dd5c5f3812f1096b" title="make the RTSS write out the generated shaders for caching and debugging ">OgreBites::ApplicationContext::setRTSSWriteShadersToDisk</a>. This will cache the generated shaders onto the disk under the directory <code>{<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> directory}\Samples\Media\RTShaderLib\cache</code>. This is important for 2 reasons:<ul>
<li>It will make compilation problems easier to detect.</li>
<li>Once a shader is written to the disk, as long as you don't change the code behind it, the same shader will be picked up in the next application run even if its content has changed. If you have compilation or visual problems with the shader you can try to manually tinker with it without compiling the code again and again.</li>
</ul>
</li>
<li>Find the file OgreShaderProgramManager.cpp and add a breakpoint at <code>pGpuProgram.setNull();</code> (in createGpuProgram). If a shader will fail to compile it will usually fail there. Once that happens you can find the shader name under the <code>programName</code> parameter, then look for it in the cache directory you created.</li>
<li>Other common problems with creating shaders in RTSS usually occur from defining vertex shader parameters and using them in the pixel shader and vice versa. so watch out for those.</li>
</ul>
<h1><a class="anchor" id="history"></a>
Historical background</h1>
<p>When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).</p>
<p>As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.</p>
<p>Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.</p>
<p>The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.</p>
<p>With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.</p>
<h1><a class="anchor" id="pros-cons"></a>
Pros and Cons</h1>
<p>Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders</p><ul>
<li>Hardware animation (a.k.a hardware skinning)</li>
<li>Soft shadows</li>
<li>Normal/Bump maps</li>
<li>Specular maps</li>
<li>Advanced multi-texturing effects</li>
</ul>
<p>Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.</p>
<p>So why use a runtime shader system anyway?</p>
<ul>
<li>Save development time e.g. when your target scene has dynamic lights and the number changes, fog changes, ... and the number of material attributes increases the total count of needed shaders dramatically. It can easily cross 100 and it becomes a time consuming development task.</li>
<li>Reusable code - once you've written the shader extension you can use it anywhere due to its independent nature.</li>
<li>Custom shaders extension library - enjoy the shared library of effects created by the community. Unlike hand written shader code, which may require many adjustments to be plugged into your own shader code, using the extensions library requires minimum changes. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: HLMS: High Level Material System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hlms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HLMS: High Level Material System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#components">The three components</a></li>
<li class="level1"><a href="#materials">Compared to classical materials</a></li>
<li class="level1"><a href="#data">Material parameters are stored in “Blocks”</a><ul><li class="level2"><a href="#toc52">Datablocks</a></li>
</ul>
</li>
<li class="level1"><a href="#toc69">Hlms templates</a><ul><li class="level2"><a href="#preproc">The Hlms preprocessor</a></li>
<li class="level2"><a href="#syntax">Preprocessor syntax</a></li>
</ul>
</li>
<li class="level1"><a href="#shaders">Creation of shaders</a></li>
<li class="level1"><a href="#cpp">C++ interaction with shader templates</a></li>
<li class="level1"><a href="#customization">Customization</a></li>
</ul>
</div>
<div class="textblock"><p>This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.</p>
<p>Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.</p>
<p>Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.</p>
<p>But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.</p>
<p>Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.</p>
<h1><a class="anchor" id="components"></a>
The three components</h1>
<div class="image">
<object type="image/svg+xml" data="hlms_components.svg">hlms_components.svg</object>
</div>
<ol type="1">
<li>Scripts. To set the material properties (i.e. type of Hlms to use: PBS, Toon shading, GUI; what textures, diffuse colour, roughness, etc). <b>You currently have to do this from C++.</b> Everybody will be using this part.</li>
<li>Shader template. The Hlms takes a couple hand-written glsl/hlsl files as template and then adapts it to fit the needs on the fly (i.e. if the mesh doesn’t contain skeleton, the bit of code pertaining to skeletal animation is stripped from the vertex shader). The Hlms provides a simple preprocessor to deal with this entirely within from the template, but you’re not forced to use it. Here’s a simple example of the preprocessor. I won’t be explaining the main keywords today. Advanced users will probably want to modify these files (or write some of their own) to fit their custom needs.</li>
<li>C++ classes implementation. The C++ takes care of picking the shader templates and manipulating them before compiling; and most importantly it feeds the shaders with uniform/constans data and sets the textures that are being in use. It is extremely flexible, powerful, efficient and scalable, but it’s harder to use than good ol’ Materials because those used to be data-driven: there are no AutoParamsSource here. Want the view matrix? You better grab it from the camera when the scene pass is about to start, and then pass it yourself to the shader. This is very powerful, because in D3D11/GL3+ you can just set the uniform buffer with the view matrix just once for the entire frame, and thus have multiple uniforms buffers sorted by update frequency. Very advanced user will be using messing with this part.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Material scripts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.x do not yet support the HLMS - you must use the C++ API. e.g. <a class="el" href="class_ogre_1_1_pbs_material.html">Ogre::PbsMaterial</a>.</dd></dl>
<p>Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.</p>
<p>For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.</p>
<p>It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.</p>
<h1><a class="anchor" id="materials"></a>
Compared to classical materials</h1>
<p>Materials are still useful for:</p>
<ul>
<li>Quick iteration. You need to write a shader, just define the material and start coding. Why would you deal with the template’s syntax or a C++ module when you can just write a script and start coding?. The HLMS though comes with a Command line tool to know how your template translates into a final shader (which is very handy for iteration, it’s fast, and will check for syntax errors!), but it’s most useful when you want to write your own C++ module or change the template, not when you want to just experiment. Besides, old timers are used to writing materials.</li>
<li>Postprocessing effects. Materials are much better suited for this. Materials are data driven, easy to write. Postprocessing FXs don’t need an awful lot of permutations (i.e. having to deal with shadow mapping, instancing, skeleton animation, facial animation). And they’re at no performance disadvantage compared to HLMS: Each FX is a fullscreen pass that needs different shaders, different textures, its own uniforms. Basically, API overhead we can’t optimize. But it doesn’t matter much either, because it’s not like there are 100 fullscreen passes. Usually there’s less than 10.</li>
</ul>
<h1><a class="anchor" id="data"></a>
Material parameters are stored in “Blocks”</h1>
<p>You could be thinking the reason I came up with these two is to fit with D3D11′s grand scheme of things while being compatible with OpenGL. But that’s a half truth and an awesome side effect. I’ve been developing the Hlms using OpenGL this whole time.</p>
<p>An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and they’re right about that.</p>
<p>However, there are big advantages for using blocks:</p>
<ol type="1">
<li>Many materials in practice share the same Macro- &amp; Blendblock parameters. In an age where we want many 3D primitives with the same shader but slightly different parameters like texture, colour, or roughness (which equals, a different material) having these settings repeated per material wastes a lot of memory space… and a lot of bandwidth (and wastes cache space). <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 is bandwidth bound, so having all materials share the same pointer to the same Macroblock can potentially save a lot of bandwidth, and be friendlier to the cache at the same time.This stays true whether we use D3D11, D3D12, OpenGL, GL ES 2, or Mantle.</li>
<li>Sorting by Macroblock is a lot easier (and faster) than sorting by its individual parameters: when preparing the hash used for sorting, it’s much easier to just do (every frame, per object) <code>hash |= (macroblock-&gt;getId() &lt;&lt; bits) &amp; mask</code> than to do: <code>hash =| m-&gt;depth_check | m-&gt;depthWrite &lt;&lt; 1 | m-&gt;depthBias &lt;&lt; 2 | m-&gt;depth_slope_bias &lt;&lt; 3 | m-&gt;cullMode &lt;&lt; 18 | ... ;</code> We also need a lot more bits we can’t afford. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 imposes a limit on the amount of live Macroblocks you can have at the same time; as we run out of hashing space (by the way, D3D11 has its own limit). It operates around the idea that most setting combinations won’t be used in practice.</li>
</ol>
<p>Of course it’s not perfect, it can’t fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); you’ll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. We’re aiming the general use case.</p>
<p>These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since I’m not used to driver development. However from an engine perspective, blocks make sense.</p>
<h2><a class="anchor" id="toc52"></a>
Datablocks</h2>
<p>We’re introducing the concept of Datablocks. A Datablock is a “material” from the user’s perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.</p>
<div class="image">
<object type="image/svg+xml" data="hlms_blocks.svg">hlms_blocks.svg</object>
</div>
<p>The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.</p>
<dl class="section note"><dt>Note</dt><dd>Macroblocks and Blendblocks are not available in 1.x - use <a class="el" href="class_ogre_1_1_pass.html#ae454faee87f8cb0b8540810e48118788" title="Sets whether or not this pass renders with depth-buffer checking on or not. ">Ogre::Pass::setDepthCheckEnabled</a> etc. as usual, to change the respective properties</dd></dl>
<h1><a class="anchor" id="toc69"></a>
Hlms templates</h1>
<p>The Hlms will parse the template files from the template folder according to the following rules:</p>
<ol type="1">
<li>The files with the names "VertexShader_vs", "PixelShader_ps", "GeometryShader_gs", "HullShader_hs", "DomainShader_ds" will be fully parsed and compiled into the shader. If an implementation only provides "VertexShader_vs.glslt", "PixelShader_ps.glslt"; only the vertex and pixel shaders for OpenGL will be created. There will be no geometry or tesellation shaders.</li>
<li>The files that contain the string "_piece_vs" in their filenames will be parsed only for collecting pieces (more on pieces later). Likewise, the words "_piece_ps", "_piece_gs", "_piece_hs", "_piece_ds” correspond to the pieces for their respective shader stages. Note that you can concatenate, thus "MyUtilities_piece_vs_piece_ps.glslt” will be collected both in the vertex and pixel shader stages.</li>
</ol>
<p>The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.</p>
<h2><a class="anchor" id="preproc"></a>
The Hlms preprocessor</h2>
<p>The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.</p>
<p>For example </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can't evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can't check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable “IncludeLightingEquals2” and check whether it's non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can't see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you'll depend on the driver implementation having a good macro preprocessor.</p>
<h2><a class="anchor" id="syntax"></a>
Preprocessor syntax</h2>
<p>The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:</p>
<ul>
<li>@property</li>
<li>@foreach</li>
<li>@counter</li>
<li>@value</li>
<li>@set add sub mul div mod min max</li>
<li>@piece</li>
<li>@insertpiece</li>
<li>@pset padd psub pmul pdiv pmod pmin pmax</li>
</ul>
<h3>@property( expression )</h3>
<p>Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.</p>
<p>The logical operands &amp;&amp; || ! are valid.</p>
<p>Examples: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: </p><div class="fragment"><div class="line">hasLights != 0                              hasLights == 0</div><div class="line">diffuse = surfaceDiffuse * lightDiffuse;   diffuse = surfaceDiffuse ;</div></div><!-- fragment --><h3>@foreach( scopedVar, count, [start] )</h3>
<p>Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.</p>
<ul>
<li>scopedVar is a variable that can be used to print the current iteration of the loop while inside the block. i.e. “@scopedVar” will be converted into a number in the range [start; count)</li>
<li>count The number of times to repeat the loop (if start = 0). Count can read variables.</li>
<li>start Optional. Allows to start from a value different than 0. Start can read variables.</li>
</ul>
<p>Newlines are very important, as they will be printed with the loop.</p>
<p>Examples: </p><table class="doxtable">
<tr>
<th>Expression </th><th>Output  </th></tr>
<tr>
<td>@foreach( 4, n ) <br />
&emsp; @n@end </td><td><br />
0<br />
1<br />
2<br />
3 </td></tr>
<tr>
<td>@foreach( 4, n ) @n@end </td><td>0 1 2 3 </td></tr>
<tr>
<td>@foreach( 4, n )<br />
&emsp;@n<br />
@end </td><td><br />
0<br />
<br />
1<br />
<br />
2<br />
<br />
3<br />
 </td></tr>
<tr>
<td>@foreach( 4, n, 2 ) @n@end </td><td>2 3 </td></tr>
<tr>
<td>@pset( myStartVar, 1 )<br />
@pset( myCountVar, 3 )<br />
@foreach( myStartVar, n, myCountVar )<br />
&emsp;@n@end </td><td>1<br />
2 </td></tr>
<tr>
<td>@foreach( 2, n )<br />
&emsp;@insertpiece( pieceName@n )@end </td><td>@insertpiece( pieceName0 )<br />
 @insertpiece( pieceName1 ) </td></tr>
</table>
<blockquote class="doxtable">
<p><b>Attention #1!</b></p>
<p>Don't use the common letter i for the loop counter. It will conflict with other keywords.</p>
<p>i.e. “@foreach( 1, i )@insertpiece( pieceName )@end” will print “0nsertpiece( pieceName )” which is probably not what you intended.</p>
<p><b>Attention #2!</b></p>
<p>foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.</p>
<p>i.e. The following code will not work:</p>
<div class="fragment"><div class="line">@pset( myVar, 1 )</div><div class="line"></div><div class="line">@<span class="keywordflow">foreach</span>( 2, n )</div><div class="line"></div><div class="line"><span class="comment">//Code</span></div><div class="line"></div><div class="line">@psub( myVar, 1 ) <span class="comment">//Decrement myVar on each loop</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( myVar )</div><div class="line"></div><div class="line"><span class="comment">//Code that shouldn&#39;t be printed in the last iteration</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>Because psub will be evaluated before expanding the foreach. </p>
</blockquote>
<h3>@counter( variable )</h3>
<p>Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.</p>
<p>Examples: </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@counter( myVar )   1</div><div class="line"></div><div class="line">@counter( myVar )   2</div></div><!-- fragment --><h3>@value( variable )</h3>
<p>Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@value( myVar )     1</div><div class="line"></div><div class="line">@value( myVar )     1</div></div><!-- fragment --><h3>@set add sub mul div mod min max</h3>
<p>Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.</p>
<p>Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c</p>
<p>Useful in combination with @counter and @value</p>
<table class="doxtable">
<tr>
<th>Expression </th><th>Output </th><th>Math  </th></tr>
<tr>
<td>@set( myVar, 1 ) <br />
 @value( myVar ) </td><td>1 </td><td>myVar = 1 </td></tr>
<tr>
<td>@add( myVar, 5 )<br />
 @value( myVar ) </td><td>6 </td><td>myVar = 1 + 5 </td></tr>
<tr>
<td>@div( myVar, 2 ) <br />
 @value( myVar ) </td><td>3 </td><td>myVar = 6 / 2 </td></tr>
<tr>
<td>@mul( myVar, myVar )<br />
 @value( myVar ) </td><td>9 </td><td>myVar = 3 * 3 </td></tr>
<tr>
<td>@mod( myVar, 5 ) <br />
 @value( myVar ) </td><td>4 </td><td>myVar = 9 % 5 </td></tr>
<tr>
<td>@add( myVar, 1, 1 ) <br />
 @value( myVar ) </td><td>2 </td><td>myVar = 1 + 1 </td></tr>
</table>
<h3>@piece( nameOfPiece )</h3>
<p>Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won't be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                        Output</div><div class="line"></div><div class="line">@piece( VertexTransform )         </div><div class="line"></div><div class="line">outPos = worldViewProj * inPos   </div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><h3>@insertpiece( nameOfPiece )</h3>
<p>Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                                                     Output</div><div class="line"></div><div class="line">@piece( VertexTransform )outPos = worldViewProj * inPos@end   void main()</div><div class="line"></div><div class="line">void main()                                                    {</div><div class="line"></div><div class="line">{                                                              outPos = worldViewProj * inPos</div><div class="line"></div><div class="line">@insertpiece( VertexTransform )                                }</div><div class="line"></div><div class="line">@insertpiece( InexistentPiece )                                </div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h3>@pset padd psub pmul pdiv pmod pmin pmax</h3>
<p>Analogous to <a href="#toc304"><em>the family of math functions without the 'p' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.</p>
<p>i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )</p>
<p>One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.</p>
<p>If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.</p>
<h1><a class="anchor" id="shaders"></a>
Creation of shaders</h1>
<p>There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:</p>
<ol type="1">
<li>The Datablock/Material. Does it have Normal maps? Then include code to sample the normal map and affect the lighting calculations. Does it have a diffuse map? If not, avoid sampling the diffuse map and multiplying it against the diffuse colour, etc.</li>
<li>The Mesh. Is it skeletally animated? Then include skeletal animation code. How many blend weights? Modify the skeletal animation code appropiately. It doesn't have tangents? Then skip the normal map defined in the material. And so on.</li>
</ol>
<p>When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.</p>
<p>If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).</p>
<p>The following graph summarizes the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_hash.svg">hlms_hash.svg</object>
</div>
<p>Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a “<a href="#toc567"><em>pass hash</em></a>” instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).</p>
<p>While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_caching.svg">hlms_caching.svg</object>
</div>
<h1><a class="anchor" id="cpp"></a>
C++ interaction with shader templates</h1>
<p>Note: This section is relevant to those seeking to write their own Hlms implementation.</p>
<p>C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set “key” to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod</p>
<p>To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.</p>
<p>The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.</p>
<p>In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.</p>
<p>Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.</p>
<p>For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.</p>
<p>The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.</p>
<h2>Common conventions</h2>
<p>Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.</p>
<p>Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.</p>
<p>For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.</p>
<p>Properties in underscore_case are set from C++; propierties in camelCase are set from the template.</p>
<p>Propierties and pieces starting with 'custom_' are for user customizations of the template</p>
<p>TBD</p>
<h2>Disabling a stage</h2>
<p>By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.</p>
<p>Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.</p>
<h1><a class="anchor" id="customization"></a>
Customization</h1>
<p>In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.</p>
<p>Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.</p>
<p>Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.</p>
<p>There are different levels in which an Hlms implementation can be customized:</p>
<ol type="1">
<li>Using a library, see <a href="#toc574"><em>Hlms Initialization</em></a>. pass a set of piece files in a folder by pushing the folder to ArchiveVec. The files in that folder will be parsed first, in order (archiveVec[0] then archiveVec[1], … archiveVec[N-1]); which will let you define your own pieces to insert code into the default template (see the the table at the end). You can also do clever tricky things to avoid dealing with C++ code at all even if there are no 'custom_' pieces for it. For example, you can write the following code to override the BRDF declarations and provide a custom BRDF: <div class="fragment"><div class="line"><span class="comment">//Disable all known BRDFs that the implementation may enable</span></div><div class="line"></div><div class="line">@pset( BRDF_CookTorrance, 0 )</div><div class="line"></div><div class="line">@pset( BRDF_Default, 0 )</div><div class="line"></div><div class="line">@piece( DeclareBRDF )</div><div class="line"></div><div class="line"><span class="comment">// Your BRDF code declaration here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --></li>
</ol>
<ol type="1">
<li>Via listener, through HlmsListener. This allows you to have access to the buffer pass to fill extra information; or bind extra buffers to the shader.</li>
<li>Overload HlmsPbs. Useful for overriding only specific parts, or adding new functionality that requires storing extra information in a datablock (e.g. overload HlmsPbsDatablock to add more variables, and then overload HlmsPbs::createDatablockImpl to create these custom datablocks)</li>
<li>Directly modify HlmsPbs, HlmsPbsDatablock and the template. <table class="doxtable">
<tr>
<th>Variable </th><th>Description  </th></tr>
<tr>
<td>custom_passBuffer </td><td>Piece where users can add extra information for the pass buffer (only useful if the user is using HlmsListener or overloaded HlmsPbs. </td></tr>
<tr>
<td>custom_VStoPS </td><td>Piece where users can add more interpolants for passing data from the vertex to the pixel shader. </td></tr>
<tr>
<td>custom_vs_attributes </td><td>Custom vertex shader attributes in the Vertex Shader (i.e. a special texcoord, etc). </td></tr>
<tr>
<td>custom_vs_uniformDeclaration </td><td>Data declaration (textures, texture buffers, uniform buffers) in the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_posExecution </td><td>Executed after all code from the Vertex Shader has been performed. </td></tr>
<tr>
<td>custom_ps_uniformDeclaration </td><td>Same as custom_vs_uniformDeclaration, but for the Pixel Shader </td></tr>
<tr>
<td>custom_ps_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Pixel Shader. </td></tr>
<tr>
<td>custom_ps_posMaterialLoad </td><td>Executed right after loading material data; and before anything else. May not get executed if there is no relevant material data (i.e. doesn't have normals or QTangents for lighting calculation) </td></tr>
<tr>
<td>custom_ps_preLights </td><td>Executed right before any light (i.e. to perform your own ambient / global illumination pass). All relevant texture data should be loaded by now. </td></tr>
<tr>
<td>custom_ps_posExecution </td><td>Executed after all code from the Pixel Shader has been performed. </td></tr>
</table>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: RTSS: Run Time Shader System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rtss.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">RTSS: Run Time Shader System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#core-feats">Core features of the system</a></li>
<li class="level1"><a href="#rtss_overview">System overview</a><ul><li class="level2"><a href="#rtss_custom_api">Customising via API</a></li>
<li class="level2"><a href="#rtss_custom_mat">Customizing via Material Script</a></li>
</ul>
</li>
<li class="level1"><a href="#rtss_indepth">The RTSS in Depth</a><ul><li class="level2"><a href="#rtss__components">Main components</a></li>
<li class="level2"><a href="#creating-extensions">Creating custom shader extensions</a></li>
<li class="level2"><a href="#debugging">Tips for debugging shaders</a></li>
</ul>
</li>
<li class="level1"><a href="#history">Historical background</a></li>
<li class="level1"><a href="#pros-cons">Pros and Cons</a></li>
</ul>
</div>
<div class="textblock"><p>This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.</p>
<h1><a class="anchor" id="core-feats"></a>
Core features of the system</h1>
<ul>
<li>Runtime shader generation synchronized with scene state. Each time scene settings change, a new set of shaders is generated.</li>
<li>Full Fixed Function Pipeline (FFP) emulation. This feature is most useful combined with render system that doesn't provide any FFP functionality (OpenGL ES 2.0, D3D11 etc).</li>
<li>Shader language independent interface: the logic representation of the shader programs is completely independent from the target shader language. You can generate code for different shader languages from the same program.</li>
<li>Pluggable interface allows extending the target shader languages set.</li>
<li>Pluggable interface allows adding new shader based effects to the system in a seamless way. Each effect code will be automatically combined with the rest of the shader code.</li>
<li>Smart program management: each shader program is created only once and may be used by multiple passes.</li>
<li>Automatic vertex shader compacting mechanism: no more compacting variables by hand. In case the amount of used vertex shader output registers exceeds the maximum allowed (12 to 32, depending on <a href="http://msdn.microsoft.com/en-us/library/bb172918%28v=VS.85%29.aspx">D3DPSHADERCAPS2_0.NumTemps</a>), a compacting algorithm packs the vertex shader outputs and adds unpack code in the fragment shader side.</li>
<li>Material script support, for both export and import.</li>
</ul>
<h1><a class="anchor" id="rtss_overview"></a>
System overview</h1>
<p>The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.</p>
<p>Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.</p>
<p>To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.</p>
<p>After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.</p>
<p>Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates</p>
<div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">uniform mat4    worldviewproj_matrix;</div><div class="line">uniform mat4    texture_matrix1;</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">in  vec4    vertex;</div><div class="line">in  vec4    uv0;</div><div class="line">out vec4    oTexcoord4_0;</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    FFP_Transform(worldviewproj_matrix, vertex, gl_Position);</div><div class="line">    FFP_TransformTexCoord(texture_matrix1, uv0.xy, oTexcoord4_0.xy);</div><div class="line">}</div></div><!-- fragment --><p>It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)</p>
<p>Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.</p>
<p>The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.</p>
<h2><a class="anchor" id="rtss_custom_api"></a>
Customising via API</h2>
<p>The first option is to globally enforce per-pixel lighting, you can do the following</p>
<div class="fragment"><div class="line">        <span class="comment">// Grab the scheme render state.</span></div><div class="line">        <a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">Ogre::RTShader::RenderState</a>* schemRenderState =</div><div class="line">            mShaderGenerator-&gt;getRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line">        <span class="comment">// Add per pixel lighting sub render state to the global scheme render state.</span></div><div class="line">        <span class="comment">// It will override the default FFP lighting sub render state.</span></div><div class="line">        <span class="keywordflow">if</span> (usePerPixelLighting) {</div><div class="line">            <a class="code" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">Ogre::RTShader::SubRenderState</a>* perPixelLightModel =</div><div class="line">                mShaderGenerator-&gt;createSubRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_per_pixel_lighting.html#ae766f76cad4b3a4339a0cd50abbddcc2">Ogre::RTShader::PerPixelLighting::Type</a>);</div><div class="line"></div><div class="line">            schemRenderState-&gt;<a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html#af66edaf33c654e03ef89f1eaec384a1f">addTemplateSubRenderState</a>(perPixelLightModel);</div><div class="line">        }</div></div><!-- fragment --><p> any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.</p>
<h2><a class="anchor" id="rtss_custom_mat"></a>
Customizing via Material Script</h2>
<p>Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following</p>
<div class="fragment"><div class="line">            <span class="comment">// RT Shader system section.</span></div><div class="line">            rtshader_system</div><div class="line">            {       </div><div class="line">                <span class="comment">// Override lighting stage with per pixel lighting.             </span></div><div class="line">                lighting_stage per_pixel                </div><div class="line">            }   </div></div><!-- fragment --><p> for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.</p>
<p>Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:</p>
<ul>
<li><a href="#lighting_stage">lighting_stage</a></li>
<li><a href="#light_count">light_count</a></li>
<li><a href="#triplanarTexturing">triplanarTexturing</a></li>
<li><a href="#integrated_pssm4">integrated_pssm4</a></li>
<li><a href="#layered_blend">layered_blend</a></li>
<li><a href="#source_modifier">source_modifier</a></li>
</ul>
<p><a class="anchor" id="lighting_stage"></a></p>
<h3>lighting_stage</h3>
<p>Force a specific lighting model.</p>
<p>Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code></p>
<p>Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code></p>
<p>Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_r_t_shader_1_1_normal_map_lighting.html#adc6b4bdd1ea31c2232336599d2b30b60" title="Normal map space definition. ">Ogre::RTShader::NormalMapLighting::NormalMapSpace</a> </dd>
<dd>
<a class="el" href="group___general.html#ga21a0186392e9c9ce16d29c5568a773c5" title="High-level filtering options providing shortcuts to settings the minification, magnification and mip ...">Ogre::TextureFilterOptions</a></dd></dl>
<p><a class="anchor" id="light_count"></a></p>
<h3>light_count</h3>
<p>Override dynamic light count. Allows to customize which lights the RTSS will consider.</p>
<p>Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code></p>
<p><a class="anchor" id="triplanarTexturing"></a></p>
<h3>triplanarTexturing</h3>
<p>Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a></p>
<p>Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code></p>
<p>Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureScale</td><td>texture coordinates are multiplied by this. </td></tr>
    <tr><td class="paramname">plateauSize</td><td>plateau on which small components of the normal have no influence. </td></tr>
    <tr><td class="paramname">transitionSpeed</td><td>transitions speed between the three textures Valid values are [0; 0.57] not bigger to avoid division by zero </td></tr>
    <tr><td class="paramname">textureFromX</td><td>Texture for the x-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromY</td><td>Texture for the y-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromZ</td><td>Texture for the z-direction planar mapping</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="integrated_pssm4"></a></p>
<h3>integrated_pssm4</h3>
<p>Integrated PSSM shadow receiver with 3 splits. Custom split points.</p>
<p>Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code></p>
<p><a class="anchor" id="layered_blend"></a></p>
<h3>layered_blend</h3>
<p>Apply photoshop-like blend effects to texture layers</p>
<p>Format: <code>layered_blend &lt;effect&gt;</code></p>
<p>Example: layered_blend luminosity</p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">effect</td><td>one of <code>default, normal, lighten, darken, multiply, average, add, subtract, difference, negation, exclusion, screen, overlay, hard_light, soft_light, color_dodge, color_burn, linear_dodge, linear_burn, linear_light, vivid_light, pin_light, hard_mix, reflect, glow, phoenix, saturation, color, luminosity</code></td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="source_modifier"></a></p>
<h3>source_modifier</h3>
<p>Apply custom modulate effect to texture layer</p>
<p>Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code></p>
<p>Example: <code>source_modifier src1_inverse_modulate custom 2</code></p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>one of <code>src1_modulate, src2_modulate, src1_inverse_modulate, src2_inverse_modulate</code> </td></tr>
    <tr><td class="paramname">parameterNum</td><td>number of the custom shader parameter that controls the operation</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="rtss_indepth"></a>
The RTSS in Depth</h1>
<p>When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.</p>
<p>The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).</p>
<p>Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.</p>
<p>The following steps are executed in order to generate shaders for a given technique:</p>
<ul>
<li>For each pass in the technique the system builds a set of sub render states that describe the logic process of the rendering pipeline from the draw call submission until the final pixel color.</li>
<li>Each render state is translated into a set of logic shader programs (currently only pixel and vertex shader). The logic programs are then sent to specific shader language writers that produce source code for the respective shader language. The source code is used to create the GPU programs that are applied to the destination pass. Before rendering of an object that uses generated shaders the system allows each sub render state to update the GPU constants associated with it.</li>
</ul>
<h2>Initializing the system</h2>
<dl class="section note"><dt>Note</dt><dd>If you are using the <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>, the following steps will be taken automatically for you.</dd></dl>
<p>Initializing the system is composed of the following steps:</p><ul>
<li>Create the internal managers and structures via the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260" title="Initialize the Shader Generator System. ">Ogre::RTShader::ShaderGenerator::initialize()</a></code> method.</li>
<li>Set the target cache path. This is the place on your disk where the output shaders will be written to or will be read from in case they were generated by previous runs of your application.</li>
<li>Verify that the location of the shader libs needed by the system is added to the ResourceGroupManager via the <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d" title="Adds a location to the list of searchable locations for a Resource type. ">Ogre::ResourceGroupManager::addResourceLocation()</a></code> method.</li>
<li>Assign the target scene manager to the shader generator.</li>
<li>Add one or more specialized sub-render states that are to be shared among all materials (per pixel lighting, textured fog, etc...).</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260">Ogre::RTShader::ShaderGenerator::initialize</a>())</div><div class="line">{</div><div class="line">    <span class="comment">// Grab the shader generator pointer.</span></div><div class="line">    mShaderGenerator = <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">Ogre::RTShader::ShaderGenerator::getSingletonPtr</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Add the shader libs resource location. a sample shader lib can be found in Samples\Media\RTShaderLib</span></div><div class="line">    <a class="code" href="class_ogre_1_1_resource_group_manager.html#a45101333f0f9ff132fc381dd5c4a1d60">Ogre::ResourceGroupManager::getSingleton</a>().<a class="code" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d">addResourceLocation</a>(shaderLibPath, <span class="stringliteral">&quot;FileSystem&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Set shader cache path.</span></div><div class="line">    mShaderGenerator-&gt;setShaderCachePath(shaderCachePath);      </div><div class="line"></div><div class="line">    <span class="comment">// Set the scene manager.</span></div><div class="line">    mShaderGenerator-&gt;addSceneManager(sceneMgr);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><h2>Creating shader based technique</h2>
<p>This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.</p>
<p>To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.</p>
<p>Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// Create shader based technique from the default technique of the given material.</span></div><div class="line">mShaderGenerator-&gt;createShaderBasedTechnique(<span class="stringliteral">&quot;Examples/BeachStones&quot;</span>, <a class="code" href="class_ogre_1_1_material_manager.html#a290b828b5d44637ee4d247a09ea81bd6">Ogre::MaterialManager::DEFAULT_SCHEME_NAME</a>, <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line"><span class="comment">// Apply the shader generated based techniques.</span></div><div class="line">mViewport-&gt;setMaterialScheme(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div></div><!-- fragment --> <div class="image">
<object type="image/svg+xml" data="CreateShaderBasedTech.svg">CreateShaderBasedTech.svg</object>
</div>
<h2>Runtime shader generation</h2>
<p>During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.</p>
<div class="image">
<object type="image/svg+xml" data="RuntimeShaderGeneration.svg">RuntimeShaderGeneration.svg</object>
</div>
<h2><a class="anchor" id="rtss__components"></a>
Main components</h2>
<p>The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.</p>
<h3>ShaderGenerator</h3>
<p>The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.</p>
<h3>RenderState classes</h3>
<p>A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.</p>
<p>RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.</p>
<h3>SubRenderState classes</h3>
<p>Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.</p>
<p>There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_transform.html" title="Transform sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTransform</a> - responsible for adding code to the vertex shader which computes the position of the vertex in projection space</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_colour.html" title="Colour sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPColour</a> - responsible for adding code to the shaders that calculate the base diffuse and specular color of the object regardless of lights or textures. The color is calculated based on the ambient, diffuse, specular and emissive properties of the object and scene, color tracking and the specified hardware buffer color.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_lighting.html" title="Lighting sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPLighting</a> - responsible for adding code to the shaders that calculate the luminescence added to the object by light. Then add that value to the color calculated by the color SRS stage.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_texturing.html" title="Texturing sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTexturing</a> - responsible for adding code that modulates the color of the pixels based on textures assigned to the material.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_fog.html" title="Fog sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPFog</a> - responsible for adding code that modulates the color of a pixel based on the scene or object fog parameters.</li>
</ul>
<p>There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...</p>
<h3>SubRenderStateFactory</h3>
<p>As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.</p>
<p>These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.</p>
<h2><a class="anchor" id="creating-extensions"></a>
Creating custom shader extensions</h2>
<p>Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.</p>
<p>In order to extend the system with your own shader effects you'll have to follow these steps:</p><ul>
<li>Implement the SubRenderState interface - This is the main class that is responsible for the actual effect processing such as preparing the destination pass, updating the CPU shader programs, updating the GPU shader parameters etc.</li>
<li>Implement the SubRenderStateFactory interface: This class will allow the RTSS to create instances of the previous class via code or script as well as export it to material script file.</li>
<li>Register the factory to the RTSS using the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac266946244d79b2d4732607ae9479bd9" title="Add sub render state factory. ">Ogre::RTShader::ShaderGenerator::addSubRenderStateFactory</a> method.</li>
<li>Add shader files that will supply all the actual shader functions your SubRenderState needs. In order to support multiple shader languages you should supply code for your entire desired target shading languages (CG, HLSL, GLSL etc). These files should be placed in a way that the resource manager could access them. This can be done by placing them in a valid resource location or by dynamically adding resource location.</li>
</ul>
<p>Implementing the SubRenderState requires overriding the pure methods of the base class.</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#ae91b7b8f76848d67652b6e5832a27a49" title="Get the type of this sub render state. ">Ogre::RTShader::SubRenderState::getType()</a> should return unique string that identify the sub class implementation. That value is shared among all instances and can be stored in a static string variable. It uses to system to match between SubRenderState instance and the factory to should destroy it.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#acb48c34ee231f0220f68c967fb32f1e5" title="Get the execution order of this sub render state. ">Ogre::RTShader::SubRenderState::getExecutionOrder()</a> should return integer value that will use the system to sort all SubRenderState instances of the same render state before each one of them will create its part in the CPU shader programs. Note that:<ul>
<li>The execution order does not imply the order of the parameter definitions and function calls within the generated shader.</li>
<li>If an execution number is set to be the same as one of the basic fixed pipeline SRSs. Than that SRS will be built <b>instead</b> of the fixed pipeline SRS.</li>
</ul>
</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a5dfe9f03413e0fe99ea2640f06c1f13c" title="Copy details from a given sub render state to this one. ">Ogre::RTShader::SubRenderState::copyFrom()</a> a simple copy method that uses the system when coping one instance to another. <b>Note:</b> Only configuration data attributes should be copy here.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4b43c261946926ebbc6456deccc6697a" title="Create sub programs that represents this sub render state as part of a program set. ">Ogre::RTShader::SubRenderState::createCpuSubPrograms</a> - This is the heart of this interface. This method should update the CPU shader programs with the specific details of the overriding class.</li>
</ul>
<p>The SubRenderState supply default implementation for this method which break down this method into three stages:</p><ul>
<li>Resolving parameters: this stage should grab all the needed parameters for this SubRrenderState. In case of the FFPTransform it should resolve the world view projection matrix and vertex shader input and output position parameters.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Function* vsEntry = vsProgram-&gt;getEntryPointFunction();</div><div class="line">    </div><div class="line">    <span class="comment">// Resolve World View Projection Matrix.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#ae0e6b89f6ed3986b0a87e2472e3ff7f1">UniformParameterPtr</a> wvpMatrix = vsProgram-&gt;resolveAutoParameterInt(GpuProgramParameters::ACT_WORLDVIEWPROJ_MATRIX, 0);</div><div class="line">        </div><div class="line">    <span class="comment">// Resolve input position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionIn = vsEntry-&gt;resolveInputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_OBJECT_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>); </div><div class="line">    </div><div class="line">    <span class="comment">// Resolve output position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionOut = vsEntry-&gt;resolveOutputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_PROJECTIVE_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!wvpMatrix || !positionIn || !positionOut)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___general.html#gaf27f0d64dfeb225d37a513c253eaa1a0">OGRE_EXCEPT</a>( Exception::ERR_INTERNAL_ERROR, </div><div class="line">                <span class="stringliteral">&quot;Not all parameters could be constructed for the sub-render state.&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;FFPTransform::createCpuSubPrograms&quot;</span> );</div><div class="line">    }</div></div><!-- fragment --><ul>
<li>Resolving dependencies: this stage should provide the name of the external shader library files that contains the actual shader code needed by this SubRenderState. In case of the FFPTexturing it will add the common and texturing library for both vertex and pixel shader program.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Program* psProgram = programSet-&gt;getCpuFragmentProgram();</div><div class="line"></div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);    </div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);</div></div><!-- fragment --><ul>
<li>Adding function invocations: this stage creates the function calls within this SubRenderState requires. Each function call has two keys that are used by the system to sort it before generating the actual shader code as well as set of in/out parameters. A function invocation is added to either vertex shader program or fragment shader program. In case of the FFPFog it will add vertex depth calculation to the vertex shader program.</li>
</ul>
<div class="fragment"><div class="line">        curFuncInvocation = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> FunctionInvocation(<a class="code" href="group___r_t_shader.html#gabaab1e89270cd7f763f2f8e0258c400e">FFP_FUNC_PIXELFOG_DEPTH</a>, <a class="code" href="group___r_t_shader.html#gga7d20b2397c3eab2b52ec405863c6f274a8b4930a3fd90d5b7222960fc5727b8cf">FFP_VS_FOG</a>);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mWorldViewProjMatrix, Operand::OPS_IN);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSInPos, Operand::OPS_IN);  </div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSOutDepth, Operand::OPS_OUT);  </div><div class="line">        vsMain-&gt;addAtomInstance(curFuncInvocation);     </div></div><!-- fragment --><p> Note:</p><ul>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can add as many function invocations as it needs.</li>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can different function invocations in different ordering.</li>
<li>The ordering of the function invocation is crucial. Use the FFPVertexShaderStage and FFPFragmentShaderStage enumarations to place your invocations in the desired order.</li>
<li>Make sure the parameter semantic (in/out) in the SubRenderState code matches to your shader code implementation you supplied in the library file. GLSL will fail to link to libray functions if it won't be able to find a perfect function declaration match.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4c2acbc15e44c3fe42868abce1116ec2" title="Update GPU programs parameters before a rendering operation occurs. ">Ogre::RTShader::SubRenderState::updateGpuProgramsParams</a> - As the name suggest this method should be overridden only in case your SubRenderState should update some parameter it created before.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#afd08043cfad43a1ae470c3c1be341ba1" title="Called before adding this sub render state to the given render state. ">Ogre::RTShader::SubRenderState::preAddToRenderState()</a>: this method called before adding this SubRenderState to a parent RenderState instances. It allows this SubRenderState to exclude itself from the list in case the source pass is not matching. I.E in case of SubRenderState that perform lighting calculations it can return false when the given source pass specifies that lighting calculations disabled for it.</li>
</ul>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (!srcPass-&gt;getLightingEnabled())</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div></div><!-- fragment --><p> This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.</p>
<p>Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods</p><ul>
<li>Ogre::RTShader::SubRenderStateFactory::createInstanceImpl(): This method should return instance for the SubRenderState sub class.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#a954d30cb82307ae1ba785792b833b689" title="Create an instance of the SubRenderState sub class it suppose to create. ">Ogre::RTShader::SubRenderStateFactory::createInstance()</a>: This method should return instasnce for the SubRenderState sub class using the given script compiler parameters. Implemet this method if you want to be able to creat your custom shader extension from material script.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#ada31909080bae96784504be42d9bd77c" title="Write the given sub-render state instance using the material serializer. ">Ogre::RTShader::SubRenderStateFactory::writeInstance()</a>: This method should write down the parameters of a given SubRenderState instance to material script file. Implement this method if you want to be able to export a material that contains your custom shader extension.</li>
</ul>
<h2><a class="anchor" id="debugging"></a>
Tips for debugging shaders</h2>
<p>A couple of notes on debugging shaders coming from the RTSS:</p><ul>
<li>Call <a class="el" href="class_ogre_bites_1_1_application_context.html#aaad4c1d25a7a5f60dd5c5f3812f1096b" title="make the RTSS write out the generated shaders for caching and debugging ">OgreBites::ApplicationContext::setRTSSWriteShadersToDisk</a>. This will cache the generated shaders onto the disk under the directory <code>{<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> directory}\Samples\Media\RTShaderLib\cache</code>. This is important for 2 reasons:<ul>
<li>It will make compilation problems easier to detect.</li>
<li>Once a shader is written to the disk, as long as you don't change the code behind it, the same shader will be picked up in the next application run even if its content has changed. If you have compilation or visual problems with the shader you can try to manually tinker with it without compiling the code again and again.</li>
</ul>
</li>
<li>Find the file OgreShaderProgramManager.cpp and add a breakpoint at <code>pGpuProgram.setNull();</code> (in createGpuProgram). If a shader will fail to compile it will usually fail there. Once that happens you can find the shader name under the <code>programName</code> parameter, then look for it in the cache directory you created.</li>
<li>Other common problems with creating shaders in RTSS usually occur from defining vertex shader parameters and using them in the pixel shader and vice versa. so watch out for those.</li>
</ul>
<h1><a class="anchor" id="history"></a>
Historical background</h1>
<p>When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).</p>
<p>As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.</p>
<p>Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.</p>
<p>The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.</p>
<p>With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.</p>
<h1><a class="anchor" id="pros-cons"></a>
Pros and Cons</h1>
<p>Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders</p><ul>
<li>Hardware animation (a.k.a hardware skinning)</li>
<li>Soft shadows</li>
<li>Normal/Bump maps</li>
<li>Specular maps</li>
<li>Advanced multi-texturing effects</li>
</ul>
<p>Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.</p>
<p>So why use a runtime shader system anyway?</p>
<ul>
<li>Save development time e.g. when your target scene has dynamic lights and the number changes, fog changes, ... and the number of material attributes increases the total count of needed shaders dramatically. It can easily cross 100 and it becomes a time consuming development task.</li>
<li>Reusable code - once you've written the shader extension you can use it anywhere due to its independent nature.</li>
<li>Custom shaders extension library - enjoy the shared library of effects created by the community. Unlike hand written shader code, which may require many adjustments to be plugged into your own shader code, using the extensions library requires minimum changes. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: RTSS: Run Time Shader System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('rtss.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">RTSS: Run Time Shader System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#core-feats">Core features of the system</a></li>
<li class="level1"><a href="#rtss_overview">System overview</a><ul><li class="level2"><a href="#rtss_custom_api">Customising via API</a></li>
<li class="level2"><a href="#rtss_custom_mat">Customizing via Material Script</a></li>
</ul>
</li>
<li class="level1"><a href="#rtss_indepth">The RTSS in Depth</a><ul><li class="level2"><a href="#rtss__components">Main components</a></li>
<li class="level2"><a href="#creating-extensions">Creating custom shader extensions</a></li>
<li class="level2"><a href="#debugging">Tips for debugging shaders</a></li>
</ul>
</li>
<li class="level1"><a href="#history">Historical background</a></li>
<li class="level1"><a href="#pros-cons">Pros and Cons</a></li>
</ul>
</div>
<div class="textblock"><p>This component is used to generate shaders on the fly based on object material properties, scene setup and other user definitions.</p>
<h1><a class="anchor" id="core-feats"></a>
Core features of the system</h1>
<ul>
<li>Runtime shader generation synchronized with scene state. Each time scene settings change, a new set of shaders is generated.</li>
<li>Full Fixed Function Pipeline (FFP) emulation. This feature is most useful combined with render system that doesn't provide any FFP functionality (OpenGL ES 2.0, D3D11 etc).</li>
<li>Shader language independent interface: the logic representation of the shader programs is completely independent from the target shader language. You can generate code for different shader languages from the same program.</li>
<li>Pluggable interface allows extending the target shader languages set.</li>
<li>Pluggable interface allows adding new shader based effects to the system in a seamless way. Each effect code will be automatically combined with the rest of the shader code.</li>
<li>Smart program management: each shader program is created only once and may be used by multiple passes.</li>
<li>Automatic vertex shader compacting mechanism: no more compacting variables by hand. In case the amount of used vertex shader output registers exceeds the maximum allowed (12 to 32, depending on <a href="http://msdn.microsoft.com/en-us/library/bb172918%28v=VS.85%29.aspx">D3DPSHADERCAPS2_0.NumTemps</a>), a compacting algorithm packs the vertex shader outputs and adds unpack code in the fragment shader side.</li>
<li>Material script support, for both export and import.</li>
</ul>
<h1><a class="anchor" id="rtss_overview"></a>
System overview</h1>
<p>The RTSS is not another Uber shader with an exploding amount of <code>#ifdefs</code> that make it increasingly difficult to add new functionality. Instead, it manages a set of opaque isolated components (SubRenderStates) where each implements a specific effect. These "effects" include Fixed Function transformation and lighting. At the core these components are plain shader files providing a set of functions; e.g. <a class="el" href="group___r_t_shader.html#ga64839e79eb9f1102d5ba2f9a8de44529">FFP_FUNC_LIGHT_DIRECTIONAL_DIFFUSE</a>, <a class="el" href="group___r_t_shader.html#gae018fb3c504d2c78a7ae5df29613b369">FFP_FUNC_LIGHT_POINT_DIFFUSE</a>.</p>
<p>Correctly ordering these functions, providing them with the right input values and interconnecting them is the main purpose of the RTSS.</p>
<p>To this end the RTSS defines a set of stages; e.g <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a89872e19110c14f19fa11bd6c04755c4">Ogre::RTShader::FFP_TRANSFORM</a>, <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4633e1da9bc8ecbdecf34cd5cc4918d0">Ogre::RTShader::FFP_TEXTURING</a>. It then queries all registered SubRenderStates which in turn attach functions given a <a class="el" href="class_ogre_1_1_pass.html" title="Class defining a single pass of a Technique (of a Material), i.e. ">Ogre::Pass</a>. The stages are conceptually very similar to render queue groups.</p>
<p>After the RTSS has queried the SubRenderStates it continues to fill the entry function (e.g. <code>main()</code> for GLSL) by generating the actual function invocations.</p>
<p>Basically it performs the following (simplified) transformation, given </p><div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">$global_parameters</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">$input_parameters</div><div class="line">$output_parameters</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    $local_parameters</div><div class="line">    $FFP_VS_TRANSFORM</div><div class="line">    (...)</div><div class="line">    $FFP_VS_TEXTURING</div><div class="line">}</div></div><!-- fragment --><p> and <code>$FFP_VS_TRANSFORM = [FFP_FUNC_TRANSFORM]</code>, <code>$FFP_VS_TEXTURING = [FFP_FUNC_TRANSFORM_TEXCOORD]</code>, it generates</p>
<div class="fragment"><div class="line"><span class="comment">// GLOBAL PARAMETERS</span></div><div class="line">uniform mat4    worldviewproj_matrix;</div><div class="line">uniform mat4    texture_matrix1;</div><div class="line"><span class="comment">// FUNCTION</span></div><div class="line">in  vec4    vertex;</div><div class="line">in  vec4    uv0;</div><div class="line">out vec4    oTexcoord4_0;</div><div class="line"><span class="keywordtype">void</span> main() {</div><div class="line">    FFP_Transform(worldviewproj_matrix, vertex, gl_Position);</div><div class="line">    FFP_TransformTexCoord(texture_matrix1, uv0.xy, oTexcoord4_0.xy);</div><div class="line">}</div></div><!-- fragment --><p>It will automatically use <a class="el" href="class_ogre_1_1_gpu_program_parameters.html#a155c886f15e0c10d2c33c224f0d43ce3" title="Defines the types of automatically updated values that may be bound to GpuProgram parameters...">Ogre::GpuProgramParameters::AutoConstantType</a> as needed to obtain the required inputs and route them in the respective functions. In the above example no local parameters were allocated, but the RTSS will do it as needed. (for instance if you try to write to "vertex" in GLSL)</p>
<p>Now that you know what the RTSS does, you are probably wondering how to change which functions are emitted per stage to, lets say, change the lighting from the FFP style per-vertex lighting to per-pixel lighting.</p>
<p>The RTSS is flexible enough to "just" move the according calculations from the vertex shader to the pixel shader.</p>
<h2><a class="anchor" id="rtss_custom_api"></a>
Customising via API</h2>
<p>The first option is to globally enforce per-pixel lighting, you can do the following</p>
<div class="fragment"><div class="line">        <span class="comment">// Grab the scheme render state.</span></div><div class="line">        <a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html">Ogre::RTShader::RenderState</a>* schemRenderState =</div><div class="line">            mShaderGenerator-&gt;getRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line">        <span class="comment">// Add per pixel lighting sub render state to the global scheme render state.</span></div><div class="line">        <span class="comment">// It will override the default FFP lighting sub render state.</span></div><div class="line">        <span class="keywordflow">if</span> (usePerPixelLighting) {</div><div class="line">            <a class="code" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html">Ogre::RTShader::SubRenderState</a>* perPixelLightModel =</div><div class="line">                mShaderGenerator-&gt;createSubRenderState(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_per_pixel_lighting.html#ae766f76cad4b3a4339a0cd50abbddcc2">Ogre::RTShader::PerPixelLighting::Type</a>);</div><div class="line"></div><div class="line">            schemRenderState-&gt;<a class="code" href="class_ogre_1_1_r_t_shader_1_1_render_state.html#af66edaf33c654e03ef89f1eaec384a1f">addTemplateSubRenderState</a>(perPixelLightModel);</div><div class="line">        }</div></div><!-- fragment --><p> any non FFP SRS will automatically override the default SRS for the same stage. <a class="el" href="group___r_t_shader.html#gga4c92eba13eb8038d35530610c58ceff4a4981bd811954d8abdb7623226e81d9ab">Ogre::RTShader::FFP_LIGHTING</a> in this case.</p>
<h2><a class="anchor" id="rtss_custom_mat"></a>
Customizing via Material Script</h2>
<p>Alternatively you can enable per-pixel lighting for one material only, by adding a <code>rtshader_system</code> section to the pass as following</p>
<div class="fragment"><div class="line">            <span class="comment">// RT Shader system section.</span></div><div class="line">            rtshader_system</div><div class="line">            {       </div><div class="line">                <span class="comment">// Override lighting stage with per pixel lighting.             </span></div><div class="line">                lighting_stage per_pixel                </div><div class="line">            }   </div></div><!-- fragment --><p> for more examples see <code>Samples/Media/RTShaderLib/materials/RTShaderSystem.material</code>.</p>
<p>Here are the attributes you can use in a <code>rtshader_system</code> section of a .material script:</p>
<ul>
<li><a href="#lighting_stage">lighting_stage</a></li>
<li><a href="#light_count">light_count</a></li>
<li><a href="#triplanarTexturing">triplanarTexturing</a></li>
<li><a href="#integrated_pssm4">integrated_pssm4</a></li>
<li><a href="#layered_blend">layered_blend</a></li>
<li><a href="#source_modifier">source_modifier</a></li>
</ul>
<p><a class="anchor" id="lighting_stage"></a></p>
<h3>lighting_stage</h3>
<p>Force a specific lighting model.</p>
<p>Format1: <code>lighting_stage &lt;ffp|per_pixel&gt;</code></p>
<p>Format2: <code>lighting_stage normal_map &lt;texturename&gt; [tangent_space|object_space] [coordinateIndex] [none|bilinear|trilinear|anisotropic] [max_anisotropy] [mipmap_bias]</code></p>
<p>Example: <code>lighting_stage normal_map Panels_Normal_Tangent.png tangent_space 0 bilinear 1 -1.0</code></p>
<dl class="section see"><dt>See also</dt><dd><a class="el" href="class_ogre_1_1_r_t_shader_1_1_normal_map_lighting.html#adc6b4bdd1ea31c2232336599d2b30b60" title="Normal map space definition. ">Ogre::RTShader::NormalMapLighting::NormalMapSpace</a> </dd>
<dd>
<a class="el" href="group___general.html#ga21a0186392e9c9ce16d29c5568a773c5" title="High-level filtering options providing shortcuts to settings the minification, magnification and mip ...">Ogre::TextureFilterOptions</a></dd></dl>
<p><a class="anchor" id="light_count"></a></p>
<h3>light_count</h3>
<p>Override dynamic light count. Allows to customize which lights the RTSS will consider.</p>
<p>Format: <code>light_count &lt;pointLights&gt; &lt;directionalLights&gt; &lt;spotLights&gt;</code></p>
<p><a class="anchor" id="triplanarTexturing"></a></p>
<h3>triplanarTexturing</h3>
<p>Force <a href="https://www.volume-gfx.com/volume-rendering/triplanar-texturing/">triplanar texturing</a></p>
<p>Format: <code>triplanarTexturing &lt;textureScale&gt; &lt;plateauSize&gt; &lt;transitionSpeed&gt; &lt;textureFromX&gt; &lt;textureFromY&gt; &lt;textureFromZ&gt;</code></p>
<p>Example: <code>triplanarTexturing 0.05 0.2 4.0 BumpyMetal.jpg egyptrockyfull.jpg MtlPlat2.jpg</code></p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">textureScale</td><td>texture coordinates are multiplied by this. </td></tr>
    <tr><td class="paramname">plateauSize</td><td>plateau on which small components of the normal have no influence. </td></tr>
    <tr><td class="paramname">transitionSpeed</td><td>transitions speed between the three textures Valid values are [0; 0.57] not bigger to avoid division by zero </td></tr>
    <tr><td class="paramname">textureFromX</td><td>Texture for the x-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromY</td><td>Texture for the y-direction planar mapping </td></tr>
    <tr><td class="paramname">textureFromZ</td><td>Texture for the z-direction planar mapping</td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="integrated_pssm4"></a></p>
<h3>integrated_pssm4</h3>
<p>Integrated PSSM shadow receiver with 3 splits. Custom split points.</p>
<p>Format: <code>integrated_pssm4 &lt;sp0&gt; &lt;sp1&gt; &lt;sp2&gt; &lt;sp3&gt;</code></p>
<p><a class="anchor" id="layered_blend"></a></p>
<h3>layered_blend</h3>
<p>Apply photoshop-like blend effects to texture layers</p>
<p>Format: <code>layered_blend &lt;effect&gt;</code></p>
<p>Example: layered_blend luminosity</p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">effect</td><td>one of <code>default, normal, lighten, darken, multiply, average, add, subtract, difference, negation, exclusion, screen, overlay, hard_light, soft_light, color_dodge, color_burn, linear_dodge, linear_burn, linear_light, vivid_light, pin_light, hard_mix, reflect, glow, phoenix, saturation, color, luminosity</code></td></tr>
  </table>
  </dd>
</dl>
<p><a class="anchor" id="source_modifier"></a></p>
<h3>source_modifier</h3>
<p>Apply custom modulate effect to texture layer</p>
<p>Format: <code>source_modifier &lt;operation&gt; custom &lt;parameterNum&gt;</code></p>
<p>Example: <code>source_modifier src1_inverse_modulate custom 2</code></p>
<dl class="section note"><dt>Note</dt><dd>only applicable inside a texture_unit section</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">operation</td><td>one of <code>src1_modulate, src2_modulate, src1_inverse_modulate, src2_inverse_modulate</code> </td></tr>
    <tr><td class="paramname">parameterNum</td><td>number of the custom shader parameter that controls the operation</td></tr>
  </table>
  </dd>
</dl>
<h1><a class="anchor" id="rtss_indepth"></a>
The RTSS in Depth</h1>
<p>When the user asks the system to generate shaders for a given technique it has to provide the system a name for the target technique scheme. The system in turn, then creates a new technique based on the source technique but with a different scheme name. <b>Note:</b> In order to avoid clashes the source technique must NOT contain any shaders otherwise this step will fail.</p>
<p>The idea behind this concept is to use <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s built in mechanism of material schemes, so all the user has to do in order to use the new technique is to change the material scheme of his viewport(s).</p>
<p>Before each viewport update, the system performs a validation step of all associated shader based techniques it created. This step includes automatic synchronization with the scene lights and fog states. When the system detects that a scheme is out of date it generates the appropriate shaders for each technique new.</p>
<p>The following steps are executed in order to generate shaders for a given technique:</p>
<ul>
<li>For each pass in the technique the system builds a set of sub render states that describe the logic process of the rendering pipeline from the draw call submission until the final pixel color.</li>
<li>Each render state is translated into a set of logic shader programs (currently only pixel and vertex shader). The logic programs are then sent to specific shader language writers that produce source code for the respective shader language. The source code is used to create the GPU programs that are applied to the destination pass. Before rendering of an object that uses generated shaders the system allows each sub render state to update the GPU constants associated with it.</li>
</ul>
<h2>Initializing the system</h2>
<dl class="section note"><dt>Note</dt><dd>If you are using the <a class="el" href="class_ogre_bites_1_1_application_context.html" title="Base class responsible for setting up a common context for applications. ">OgreBites::ApplicationContext</a>, the following steps will be taken automatically for you.</dd></dl>
<p>Initializing the system is composed of the following steps:</p><ul>
<li>Create the internal managers and structures via the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260" title="Initialize the Shader Generator System. ">Ogre::RTShader::ShaderGenerator::initialize()</a></code> method.</li>
<li>Set the target cache path. This is the place on your disk where the output shaders will be written to or will be read from in case they were generated by previous runs of your application.</li>
<li>Verify that the location of the shader libs needed by the system is added to the ResourceGroupManager via the <code><a class="el" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d" title="Adds a location to the list of searchable locations for a Resource type. ">Ogre::ResourceGroupManager::addResourceLocation()</a></code> method.</li>
<li>Assign the target scene manager to the shader generator.</li>
<li>Add one or more specialized sub-render states that are to be shared among all materials (per pixel lighting, textured fog, etc...).</li>
</ul>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ad206fa320c81f6482dbe6898a2aec260">Ogre::RTShader::ShaderGenerator::initialize</a>())</div><div class="line">{</div><div class="line">    <span class="comment">// Grab the shader generator pointer.</span></div><div class="line">    mShaderGenerator = <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#acd96bb2cad55be69d0fe8c6dc28d3590">Ogre::RTShader::ShaderGenerator::getSingletonPtr</a>();</div><div class="line"></div><div class="line">    <span class="comment">// Add the shader libs resource location. a sample shader lib can be found in Samples\Media\RTShaderLib</span></div><div class="line">    <a class="code" href="class_ogre_1_1_resource_group_manager.html#a45101333f0f9ff132fc381dd5c4a1d60">Ogre::ResourceGroupManager::getSingleton</a>().<a class="code" href="class_ogre_1_1_resource_group_manager.html#a6ff0efec5d27cedb448cfba8b2b78c8d">addResourceLocation</a>(shaderLibPath, <span class="stringliteral">&quot;FileSystem&quot;</span>);</div><div class="line"></div><div class="line">    <span class="comment">// Set shader cache path.</span></div><div class="line">    mShaderGenerator-&gt;setShaderCachePath(shaderCachePath);      </div><div class="line"></div><div class="line">    <span class="comment">// Set the scene manager.</span></div><div class="line">    mShaderGenerator-&gt;addSceneManager(sceneMgr);</div><div class="line"></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><h2>Creating shader based technique</h2>
<p>This step will associate the given technique with a destination shader generated based technique. Calling the <code><a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#af02d3e93da75e66ed3312b5790d18868" title="Create shader based technique from a given technique. ">Ogre::RTShader::ShaderGenerator::createShaderBasedTechnique()</a></code> will cause the system to generate internal data structures associated with the source technique and will add new technique to the source material. This new technique will have the scheme name that was passed as an argument to this method and all its passes will contain shaders that the system will generate and update during the application runtime.</p>
<p>To use the generated technique set the change material scheme of your viewport(s) to the same scheme name you passed as argument to this method.</p>
<p>Note that you can automate the shader generation process for all materials. First set the viewport scheme to the destination scheme of the RTSS shaders. Second register to the <code><a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html" title="Listener on any general material events. ">Ogre::MaterialManager::Listener</a></code> and implement the <code>handleSchemeNotFound()</code> function. If the function requests a scheme for the RTSS, generate it based on functions parameters.</p>
<div class="fragment"><div class="line"><span class="comment">// Create shader based technique from the default technique of the given material.</span></div><div class="line">mShaderGenerator-&gt;createShaderBasedTechnique(<span class="stringliteral">&quot;Examples/BeachStones&quot;</span>, <a class="code" href="class_ogre_1_1_material_manager.html#a290b828b5d44637ee4d247a09ea81bd6">Ogre::MaterialManager::DEFAULT_SCHEME_NAME</a>, <a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div><div class="line"></div><div class="line"><span class="comment">// Apply the shader generated based techniques.</span></div><div class="line">mViewport-&gt;setMaterialScheme(<a class="code" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#a50a41bdc60047796354703d8d77d028a">Ogre::RTShader::ShaderGenerator::DEFAULT_SCHEME_NAME</a>);</div></div><!-- fragment --> <div class="image">
<object type="image/svg+xml" data="CreateShaderBasedTech.svg">CreateShaderBasedTech.svg</object>
</div>
<h2>Runtime shader generation</h2>
<p>During the application runtime the ShaderGenerator instance receives notifications on per frame basis from its target SceneManager. At this point it checks the material scheme in use. In case the current scheme has representations in the manager, it executes its validate method. The SGScheme validation includes synchronization with scene light and fog settings. In case it is out of date it will rebuild all shader generated techniques. The first step is to loop over every SGTechnique associated with this SGScheme and build its RenderStates - one for each pass. Each RenderState has its own hash code and it is cached at the ShaderGenerator. The same RenderState can be shared by multiple SGPasses. The second step is to loop again on every SGTechnique and acquire a program set for each SGPass. The actual acquiring process is done by the ProgramManager that generates CPU program representation, send them to a matching ProgramWriter that is chosen by the active target language, the writer generates source code that is the basis for the GPU programs. The result of this entire process is that each technique associated with the SGScheme has vertex and pixel shaders applied to all its passes. These shaders are synchronized with scene lights and fog settings.</p>
<div class="image">
<object type="image/svg+xml" data="RuntimeShaderGeneration.svg">RuntimeShaderGeneration.svg</object>
</div>
<h2><a class="anchor" id="rtss__components"></a>
Main components</h2>
<p>The following is an partial list of components within the RTSS. These components are listed as they have great importance in understanding controlling and later extending the RTSS system.</p>
<h3>ShaderGenerator</h3>
<p>The ShaderGenerator is the main interface to the RTSS system. Through it you can request to generate and destroy the shaders, influence from what parts to create the shaders, and control general system settings such as the shading language and shader caching.</p>
<h3>RenderState classes</h3>
<p>A render state describes the different components that a shader will be created from. These components are referred to as SubRenderStates.</p>
<p>RenderStates exist on 2 levels: scheme and pass. Scheme RenderStates describe the SubRenderStates that will be used when creating a shader for a given material scheme. Pass RenderState describe the SubRenderStates that will be used when creating a specific pass of a specific material. When a shader is generated for a given material the system combines the SubRenderStates from both RenderStates to create a shader specific for a material pass in a specific scheme.</p>
<h3>SubRenderState classes</h3>
<p>Sub-render states (SRS) are components designed to generate the code of the RTSS shaders. Each SRS usually has a specific role to fill within the shader's construction. These components can be combined in different combinations to create shaders with different capabilities.</p>
<p>There are 5 basic SRSs. These are used to recreate the functionality provided by the fixed pipeline and are added by default to every scheme RenderState:</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_transform.html" title="Transform sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTransform</a> - responsible for adding code to the vertex shader which computes the position of the vertex in projection space</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_colour.html" title="Colour sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPColour</a> - responsible for adding code to the shaders that calculate the base diffuse and specular color of the object regardless of lights or textures. The color is calculated based on the ambient, diffuse, specular and emissive properties of the object and scene, color tracking and the specified hardware buffer color.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_lighting.html" title="Lighting sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPLighting</a> - responsible for adding code to the shaders that calculate the luminescence added to the object by light. Then add that value to the color calculated by the color SRS stage.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_texturing.html" title="Texturing sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPTexturing</a> - responsible for adding code that modulates the color of the pixels based on textures assigned to the material.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_f_f_p_fog.html" title="Fog sub render state implementation of the Fixed Function Pipeline. ">Ogre::RTShader::FFPFog</a> - responsible for adding code that modulates the color of a pixel based on the scene or object fog parameters.</li>
</ul>
<p>There are many more sub render states that already exist in the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> system and new ones can be added. Some of the existing SRSs include capabilities such as: per-pixel lighting, texture atlas, advanced texture blend, bump mapping, efficient multiple lights (sample), textured fog (sample), etc...</p>
<h3>SubRenderStateFactory</h3>
<p>As the name suggests, sub render state factories are factories that produce sub render states. Each factory generates a specific SRS.</p>
<p>These type of components are note worthy for 2 reason. The first and obvious one is that they allow the system to generate new SRSs for the materials it is asked to generate. The second reason is that they perform as script readers and writers allowing the system to create specific or specialized SRSs per material.</p>
<h2><a class="anchor" id="creating-extensions"></a>
Creating custom shader extensions</h2>
<p>Although the system implements some common shader based effects such as per pixel lighting, normal map, etc., you may find it useful to write your own shader extensions.</p>
<p>In order to extend the system with your own shader effects you'll have to follow these steps:</p><ul>
<li>Implement the SubRenderState interface - This is the main class that is responsible for the actual effect processing such as preparing the destination pass, updating the CPU shader programs, updating the GPU shader parameters etc.</li>
<li>Implement the SubRenderStateFactory interface: This class will allow the RTSS to create instances of the previous class via code or script as well as export it to material script file.</li>
<li>Register the factory to the RTSS using the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_shader_generator.html#ac266946244d79b2d4732607ae9479bd9" title="Add sub render state factory. ">Ogre::RTShader::ShaderGenerator::addSubRenderStateFactory</a> method.</li>
<li>Add shader files that will supply all the actual shader functions your SubRenderState needs. In order to support multiple shader languages you should supply code for your entire desired target shading languages (CG, HLSL, GLSL etc). These files should be placed in a way that the resource manager could access them. This can be done by placing them in a valid resource location or by dynamically adding resource location.</li>
</ul>
<p>Implementing the SubRenderState requires overriding the pure methods of the base class.</p><ul>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#ae91b7b8f76848d67652b6e5832a27a49" title="Get the type of this sub render state. ">Ogre::RTShader::SubRenderState::getType()</a> should return unique string that identify the sub class implementation. That value is shared among all instances and can be stored in a static string variable. It uses to system to match between SubRenderState instance and the factory to should destroy it.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#acb48c34ee231f0220f68c967fb32f1e5" title="Get the execution order of this sub render state. ">Ogre::RTShader::SubRenderState::getExecutionOrder()</a> should return integer value that will use the system to sort all SubRenderState instances of the same render state before each one of them will create its part in the CPU shader programs. Note that:<ul>
<li>The execution order does not imply the order of the parameter definitions and function calls within the generated shader.</li>
<li>If an execution number is set to be the same as one of the basic fixed pipeline SRSs. Than that SRS will be built <b>instead</b> of the fixed pipeline SRS.</li>
</ul>
</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a5dfe9f03413e0fe99ea2640f06c1f13c" title="Copy details from a given sub render state to this one. ">Ogre::RTShader::SubRenderState::copyFrom()</a> a simple copy method that uses the system when coping one instance to another. <b>Note:</b> Only configuration data attributes should be copy here.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4b43c261946926ebbc6456deccc6697a" title="Create sub programs that represents this sub render state as part of a program set. ">Ogre::RTShader::SubRenderState::createCpuSubPrograms</a> - This is the heart of this interface. This method should update the CPU shader programs with the specific details of the overriding class.</li>
</ul>
<p>The SubRenderState supply default implementation for this method which break down this method into three stages:</p><ul>
<li>Resolving parameters: this stage should grab all the needed parameters for this SubRrenderState. In case of the FFPTransform it should resolve the world view projection matrix and vertex shader input and output position parameters.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Function* vsEntry = vsProgram-&gt;getEntryPointFunction();</div><div class="line">    </div><div class="line">    <span class="comment">// Resolve World View Projection Matrix.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#ae0e6b89f6ed3986b0a87e2472e3ff7f1">UniformParameterPtr</a> wvpMatrix = vsProgram-&gt;resolveAutoParameterInt(GpuProgramParameters::ACT_WORLDVIEWPROJ_MATRIX, 0);</div><div class="line">        </div><div class="line">    <span class="comment">// Resolve input position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionIn = vsEntry-&gt;resolveInputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_OBJECT_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>); </div><div class="line">    </div><div class="line">    <span class="comment">// Resolve output position parameter.</span></div><div class="line">    <a class="code" href="namespace_ogre_1_1_r_t_shader.html#a9b50e9cfcf817b897c37fc77e67f1bbf">ParameterPtr</a> positionOut = vsEntry-&gt;resolveOutputParameter(Parameter::SPS_POSITION, 0, Parameter::SPC_POSITION_PROJECTIVE_SPACE, <a class="code" href="group___materials.html#gga9c5b2950be06ff56a6ee0bace240d447a466febc90367dab6c895c98edfff7681">GCT_FLOAT4</a>);</div><div class="line"></div><div class="line">    <span class="keywordflow">if</span> (!wvpMatrix || !positionIn || !positionOut)</div><div class="line">    {</div><div class="line">        <a class="code" href="group___general.html#gaf27f0d64dfeb225d37a513c253eaa1a0">OGRE_EXCEPT</a>( Exception::ERR_INTERNAL_ERROR, </div><div class="line">                <span class="stringliteral">&quot;Not all parameters could be constructed for the sub-render state.&quot;</span>,</div><div class="line">                <span class="stringliteral">&quot;FFPTransform::createCpuSubPrograms&quot;</span> );</div><div class="line">    }</div></div><!-- fragment --><ul>
<li>Resolving dependencies: this stage should provide the name of the external shader library files that contains the actual shader code needed by this SubRenderState. In case of the FFPTexturing it will add the common and texturing library for both vertex and pixel shader program.</li>
</ul>
<div class="fragment"><div class="line">    Program* vsProgram = programSet-&gt;getCpuVertexProgram();</div><div class="line">    Program* psProgram = programSet-&gt;getCpuFragmentProgram();</div><div class="line"></div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    vsProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);    </div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gaf315dcdcd0eeb960135ab30110ae77ba">FFP_LIB_COMMON</a>);</div><div class="line">    psProgram-&gt;addDependency(<a class="code" href="group___r_t_shader.html#gab7d72f56d81dc214ac28a7e40bfa56c3">FFP_LIB_TEXTURING</a>);</div></div><!-- fragment --><ul>
<li>Adding function invocations: this stage creates the function calls within this SubRenderState requires. Each function call has two keys that are used by the system to sort it before generating the actual shader code as well as set of in/out parameters. A function invocation is added to either vertex shader program or fragment shader program. In case of the FFPFog it will add vertex depth calculation to the vertex shader program.</li>
</ul>
<div class="fragment"><div class="line">        curFuncInvocation = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> FunctionInvocation(<a class="code" href="group___r_t_shader.html#gabaab1e89270cd7f763f2f8e0258c400e">FFP_FUNC_PIXELFOG_DEPTH</a>, <a class="code" href="group___r_t_shader.html#gga7d20b2397c3eab2b52ec405863c6f274a8b4930a3fd90d5b7222960fc5727b8cf">FFP_VS_FOG</a>);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mWorldViewProjMatrix, Operand::OPS_IN);</div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSInPos, Operand::OPS_IN);  </div><div class="line">        curFuncInvocation-&gt;pushOperand(mVSOutDepth, Operand::OPS_OUT);  </div><div class="line">        vsMain-&gt;addAtomInstance(curFuncInvocation);     </div></div><!-- fragment --><p> Note:</p><ul>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can add as many function invocations as it needs.</li>
<li>Each <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html" title="This class is the base interface of sub part from a shader based rendering pipeline. ">Ogre::RTShader::SubRenderState</a> can different function invocations in different ordering.</li>
<li>The ordering of the function invocation is crucial. Use the FFPVertexShaderStage and FFPFragmentShaderStage enumarations to place your invocations in the desired order.</li>
<li>Make sure the parameter semantic (in/out) in the SubRenderState code matches to your shader code implementation you supplied in the library file. GLSL will fail to link to libray functions if it won't be able to find a perfect function declaration match.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#a4c2acbc15e44c3fe42868abce1116ec2" title="Update GPU programs parameters before a rendering operation occurs. ">Ogre::RTShader::SubRenderState::updateGpuProgramsParams</a> - As the name suggest this method should be overridden only in case your SubRenderState should update some parameter it created before.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state.html#afd08043cfad43a1ae470c3c1be341ba1" title="Called before adding this sub render state to the given render state. ">Ogre::RTShader::SubRenderState::preAddToRenderState()</a>: this method called before adding this SubRenderState to a parent RenderState instances. It allows this SubRenderState to exclude itself from the list in case the source pass is not matching. I.E in case of SubRenderState that perform lighting calculations it can return false when the given source pass specifies that lighting calculations disabled for it.</li>
</ul>
<div class="fragment"><div class="line">    <span class="keywordflow">if</span> (!srcPass-&gt;getLightingEnabled())</div><div class="line">        <span class="keywordflow">return</span> <span class="keyword">false</span>;</div></div><!-- fragment --><p> This method also let the SubRenderState to opportunity to modify the destination pass. I.E the NormalMapLighting instance adds the normal map texture unit in this context.</p>
<p>Implementing the <a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html" title="Abstract factory interface for creating SubRenderState implementation instances. ">Ogre::RTShader::SubRenderStateFactory</a> is much simpler and involves implementing the following methods</p><ul>
<li>Ogre::RTShader::SubRenderStateFactory::createInstanceImpl(): This method should return instance for the SubRenderState sub class.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#a954d30cb82307ae1ba785792b833b689" title="Create an instance of the SubRenderState sub class it suppose to create. ">Ogre::RTShader::SubRenderStateFactory::createInstance()</a>: This method should return instasnce for the SubRenderState sub class using the given script compiler parameters. Implemet this method if you want to be able to creat your custom shader extension from material script.</li>
<li><a class="el" href="class_ogre_1_1_r_t_shader_1_1_sub_render_state_factory.html#ada31909080bae96784504be42d9bd77c" title="Write the given sub-render state instance using the material serializer. ">Ogre::RTShader::SubRenderStateFactory::writeInstance()</a>: This method should write down the parameters of a given SubRenderState instance to material script file. Implement this method if you want to be able to export a material that contains your custom shader extension.</li>
</ul>
<h2><a class="anchor" id="debugging"></a>
Tips for debugging shaders</h2>
<p>A couple of notes on debugging shaders coming from the RTSS:</p><ul>
<li>Call <a class="el" href="class_ogre_bites_1_1_application_context.html#aaad4c1d25a7a5f60dd5c5f3812f1096b" title="make the RTSS write out the generated shaders for caching and debugging ">OgreBites::ApplicationContext::setRTSSWriteShadersToDisk</a>. This will cache the generated shaders onto the disk under the directory <code>{<a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> directory}\Samples\Media\RTShaderLib\cache</code>. This is important for 2 reasons:<ul>
<li>It will make compilation problems easier to detect.</li>
<li>Once a shader is written to the disk, as long as you don't change the code behind it, the same shader will be picked up in the next application run even if its content has changed. If you have compilation or visual problems with the shader you can try to manually tinker with it without compiling the code again and again.</li>
</ul>
</li>
<li>Find the file OgreShaderProgramManager.cpp and add a breakpoint at <code>pGpuProgram.setNull();</code> (in createGpuProgram). If a shader will fail to compile it will usually fail there. Once that happens you can find the shader name under the <code>programName</code> parameter, then look for it in the cache directory you created.</li>
<li>Other common problems with creating shaders in RTSS usually occur from defining vertex shader parameters and using them in the pixel shader and vice versa. so watch out for those.</li>
</ul>
<h1><a class="anchor" id="history"></a>
Historical background</h1>
<p>When the early graphic cards came into the market they contained a fixed but large set of functions with which you could influence how 3D object were rendered. These included influencing object positions using matrices, calculating the effect of textures on a pixel, calculating the effect of lights on vertices and so on. These set of functions and their implementation in hardware became later known as the graphic card fixed pipeline (or Fixed Function Pipeline).</p>
<p>As graphic cards became more powerful and graphic application became more complex, a need for new ways to manipulate the rendering of 3D models became apparent. This need saw the introduction of shaders.</p>
<p>Shaders are small custom made programs that run directly on the graphics card. Using these programs, one could replace the calculations that were made by the fixed pipeline and add new functionality. However there was a catch: If shaders are used on an object, the object can no longer use any of the functionality of the fixed pipeline. Any calculation that was used in the fixed pipeline needed to be recreated in the shaders. With early graphics applications this was not problematic. Shaders were simple and their numbers were kept low. However as applications grew in complexity this meant that the need for shaders grew as well. As a programmer you were left with 2 choices, both bad. Either create an exuberant amount of small shaders that soon became too many to effectively maintain. Or create an uber shader, a huge complex shader, that soon became too complex to effectively maintain as well.</p>
<p>The RTSS seeks to fix those problems by automatically generating shaders based on the operations previously required from the fixed pipeline and new capabilities required by the user.</p>
<p>With the introduction of the version 11 of Direct3D, a new reason for having an RTSS like system became apparent. With D3D11 support for fixed pipeline functionality was removed. Meaning, you can only render objects using shaders. The RTSS becomes an excellent tool for this purpose.</p>
<h1><a class="anchor" id="pros-cons"></a>
Pros and Cons</h1>
<p>Writing shading programs became a very common task when developing 3D based application during the last couple of years. Most of the visual effects used by 3D based applications involve shader programs. Here is just a short list of some common effects using shaders</p><ul>
<li>Hardware animation (a.k.a hardware skinning)</li>
<li>Soft shadows</li>
<li>Normal/Bump maps</li>
<li>Specular maps</li>
<li>Advanced multi-texturing effects</li>
</ul>
<p>Writing shaders by hand is in many cases the best solution as one has full control of the shader code and hence optimizations based on the target scene nature can be made, etc.</p>
<p>So why use a runtime shader system anyway?</p>
<ul>
<li>Save development time e.g. when your target scene has dynamic lights and the number changes, fog changes, ... and the number of material attributes increases the total count of needed shaders dramatically. It can easily cross 100 and it becomes a time consuming development task.</li>
<li>Reusable code - once you've written the shader extension you can use it anywhere due to its independent nature.</li>
<li>Custom shaders extension library - enjoy the shared library of effects created by the community. Unlike hand written shader code, which may require many adjustments to be plugged into your own shader code, using the extensions library requires minimum changes. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: HLMS: High Level Material System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hlms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HLMS: High Level Material System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#components">The three components</a></li>
<li class="level1"><a href="#materials">Compared to classical materials</a></li>
<li class="level1"><a href="#data">Material parameters are stored in “Blocks”</a><ul><li class="level2"><a href="#toc52">Datablocks</a></li>
</ul>
</li>
<li class="level1"><a href="#toc69">Hlms templates</a><ul><li class="level2"><a href="#preproc">The Hlms preprocessor</a></li>
<li class="level2"><a href="#syntax">Preprocessor syntax</a></li>
</ul>
</li>
<li class="level1"><a href="#shaders">Creation of shaders</a></li>
<li class="level1"><a href="#cpp">C++ interaction with shader templates</a></li>
<li class="level1"><a href="#customization">Customization</a></li>
</ul>
</div>
<div class="textblock"><p>This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.</p>
<p>Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.</p>
<p>Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.</p>
<p>But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.</p>
<p>Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.</p>
<h1><a class="anchor" id="components"></a>
The three components</h1>
<div class="image">
<object type="image/svg+xml" data="hlms_components.svg">hlms_components.svg</object>
</div>
<ol type="1">
<li>Scripts. To set the material properties (i.e. type of Hlms to use: PBS, Toon shading, GUI; what textures, diffuse colour, roughness, etc). <b>You currently have to do this from C++.</b> Everybody will be using this part.</li>
<li>Shader template. The Hlms takes a couple hand-written glsl/hlsl files as template and then adapts it to fit the needs on the fly (i.e. if the mesh doesn’t contain skeleton, the bit of code pertaining to skeletal animation is stripped from the vertex shader). The Hlms provides a simple preprocessor to deal with this entirely within from the template, but you’re not forced to use it. Here’s a simple example of the preprocessor. I won’t be explaining the main keywords today. Advanced users will probably want to modify these files (or write some of their own) to fit their custom needs.</li>
<li>C++ classes implementation. The C++ takes care of picking the shader templates and manipulating them before compiling; and most importantly it feeds the shaders with uniform/constans data and sets the textures that are being in use. It is extremely flexible, powerful, efficient and scalable, but it’s harder to use than good ol’ Materials because those used to be data-driven: there are no AutoParamsSource here. Want the view matrix? You better grab it from the camera when the scene pass is about to start, and then pass it yourself to the shader. This is very powerful, because in D3D11/GL3+ you can just set the uniform buffer with the view matrix just once for the entire frame, and thus have multiple uniforms buffers sorted by update frequency. Very advanced user will be using messing with this part.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Material scripts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.x do not yet support the HLMS - you must use the C++ API. e.g. <a class="el" href="class_ogre_1_1_pbs_material.html">Ogre::PbsMaterial</a>.</dd></dl>
<p>Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.</p>
<p>For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.</p>
<p>It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.</p>
<h1><a class="anchor" id="materials"></a>
Compared to classical materials</h1>
<p>Materials are still useful for:</p>
<ul>
<li>Quick iteration. You need to write a shader, just define the material and start coding. Why would you deal with the template’s syntax or a C++ module when you can just write a script and start coding?. The HLMS though comes with a Command line tool to know how your template translates into a final shader (which is very handy for iteration, it’s fast, and will check for syntax errors!), but it’s most useful when you want to write your own C++ module or change the template, not when you want to just experiment. Besides, old timers are used to writing materials.</li>
<li>Postprocessing effects. Materials are much better suited for this. Materials are data driven, easy to write. Postprocessing FXs don’t need an awful lot of permutations (i.e. having to deal with shadow mapping, instancing, skeleton animation, facial animation). And they’re at no performance disadvantage compared to HLMS: Each FX is a fullscreen pass that needs different shaders, different textures, its own uniforms. Basically, API overhead we can’t optimize. But it doesn’t matter much either, because it’s not like there are 100 fullscreen passes. Usually there’s less than 10.</li>
</ul>
<h1><a class="anchor" id="data"></a>
Material parameters are stored in “Blocks”</h1>
<p>You could be thinking the reason I came up with these two is to fit with D3D11′s grand scheme of things while being compatible with OpenGL. But that’s a half truth and an awesome side effect. I’ve been developing the Hlms using OpenGL this whole time.</p>
<p>An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and they’re right about that.</p>
<p>However, there are big advantages for using blocks:</p>
<ol type="1">
<li>Many materials in practice share the same Macro- &amp; Blendblock parameters. In an age where we want many 3D primitives with the same shader but slightly different parameters like texture, colour, or roughness (which equals, a different material) having these settings repeated per material wastes a lot of memory space… and a lot of bandwidth (and wastes cache space). <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 is bandwidth bound, so having all materials share the same pointer to the same Macroblock can potentially save a lot of bandwidth, and be friendlier to the cache at the same time.This stays true whether we use D3D11, D3D12, OpenGL, GL ES 2, or Mantle.</li>
<li>Sorting by Macroblock is a lot easier (and faster) than sorting by its individual parameters: when preparing the hash used for sorting, it’s much easier to just do (every frame, per object) <code>hash |= (macroblock-&gt;getId() &lt;&lt; bits) &amp; mask</code> than to do: <code>hash =| m-&gt;depth_check | m-&gt;depthWrite &lt;&lt; 1 | m-&gt;depthBias &lt;&lt; 2 | m-&gt;depth_slope_bias &lt;&lt; 3 | m-&gt;cullMode &lt;&lt; 18 | ... ;</code> We also need a lot more bits we can’t afford. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 imposes a limit on the amount of live Macroblocks you can have at the same time; as we run out of hashing space (by the way, D3D11 has its own limit). It operates around the idea that most setting combinations won’t be used in practice.</li>
</ol>
<p>Of course it’s not perfect, it can’t fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); you’ll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. We’re aiming the general use case.</p>
<p>These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since I’m not used to driver development. However from an engine perspective, blocks make sense.</p>
<h2><a class="anchor" id="toc52"></a>
Datablocks</h2>
<p>We’re introducing the concept of Datablocks. A Datablock is a “material” from the user’s perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.</p>
<div class="image">
<object type="image/svg+xml" data="hlms_blocks.svg">hlms_blocks.svg</object>
</div>
<p>The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.</p>
<dl class="section note"><dt>Note</dt><dd>Macroblocks and Blendblocks are not available in 1.x - use <a class="el" href="class_ogre_1_1_pass.html#ae454faee87f8cb0b8540810e48118788" title="Sets whether or not this pass renders with depth-buffer checking on or not. ">Ogre::Pass::setDepthCheckEnabled</a> etc. as usual, to change the respective properties</dd></dl>
<h1><a class="anchor" id="toc69"></a>
Hlms templates</h1>
<p>The Hlms will parse the template files from the template folder according to the following rules:</p>
<ol type="1">
<li>The files with the names "VertexShader_vs", "PixelShader_ps", "GeometryShader_gs", "HullShader_hs", "DomainShader_ds" will be fully parsed and compiled into the shader. If an implementation only provides "VertexShader_vs.glslt", "PixelShader_ps.glslt"; only the vertex and pixel shaders for OpenGL will be created. There will be no geometry or tesellation shaders.</li>
<li>The files that contain the string "_piece_vs" in their filenames will be parsed only for collecting pieces (more on pieces later). Likewise, the words "_piece_ps", "_piece_gs", "_piece_hs", "_piece_ds” correspond to the pieces for their respective shader stages. Note that you can concatenate, thus "MyUtilities_piece_vs_piece_ps.glslt” will be collected both in the vertex and pixel shader stages.</li>
</ol>
<p>The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.</p>
<h2><a class="anchor" id="preproc"></a>
The Hlms preprocessor</h2>
<p>The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.</p>
<p>For example </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can't evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can't check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable “IncludeLightingEquals2” and check whether it's non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can't see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you'll depend on the driver implementation having a good macro preprocessor.</p>
<h2><a class="anchor" id="syntax"></a>
Preprocessor syntax</h2>
<p>The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:</p>
<ul>
<li>@property</li>
<li>@foreach</li>
<li>@counter</li>
<li>@value</li>
<li>@set add sub mul div mod min max</li>
<li>@piece</li>
<li>@insertpiece</li>
<li>@pset padd psub pmul pdiv pmod pmin pmax</li>
</ul>
<h3>@property( expression )</h3>
<p>Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.</p>
<p>The logical operands &amp;&amp; || ! are valid.</p>
<p>Examples: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: </p><div class="fragment"><div class="line">hasLights != 0                              hasLights == 0</div><div class="line">diffuse = surfaceDiffuse * lightDiffuse;   diffuse = surfaceDiffuse ;</div></div><!-- fragment --><h3>@foreach( scopedVar, count, [start] )</h3>
<p>Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.</p>
<ul>
<li>scopedVar is a variable that can be used to print the current iteration of the loop while inside the block. i.e. “@scopedVar” will be converted into a number in the range [start; count)</li>
<li>count The number of times to repeat the loop (if start = 0). Count can read variables.</li>
<li>start Optional. Allows to start from a value different than 0. Start can read variables.</li>
</ul>
<p>Newlines are very important, as they will be printed with the loop.</p>
<p>Examples: </p><table class="doxtable">
<tr>
<th>Expression </th><th>Output  </th></tr>
<tr>
<td>@foreach( 4, n ) <br />
&emsp; @n@end </td><td><br />
0<br />
1<br />
2<br />
3 </td></tr>
<tr>
<td>@foreach( 4, n ) @n@end </td><td>0 1 2 3 </td></tr>
<tr>
<td>@foreach( 4, n )<br />
&emsp;@n<br />
@end </td><td><br />
0<br />
<br />
1<br />
<br />
2<br />
<br />
3<br />
 </td></tr>
<tr>
<td>@foreach( 4, n, 2 ) @n@end </td><td>2 3 </td></tr>
<tr>
<td>@pset( myStartVar, 1 )<br />
@pset( myCountVar, 3 )<br />
@foreach( myStartVar, n, myCountVar )<br />
&emsp;@n@end </td><td>1<br />
2 </td></tr>
<tr>
<td>@foreach( 2, n )<br />
&emsp;@insertpiece( pieceName@n )@end </td><td>@insertpiece( pieceName0 )<br />
 @insertpiece( pieceName1 ) </td></tr>
</table>
<blockquote class="doxtable">
<p><b>Attention #1!</b></p>
<p>Don't use the common letter i for the loop counter. It will conflict with other keywords.</p>
<p>i.e. “@foreach( 1, i )@insertpiece( pieceName )@end” will print “0nsertpiece( pieceName )” which is probably not what you intended.</p>
<p><b>Attention #2!</b></p>
<p>foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.</p>
<p>i.e. The following code will not work:</p>
<div class="fragment"><div class="line">@pset( myVar, 1 )</div><div class="line"></div><div class="line">@<span class="keywordflow">foreach</span>( 2, n )</div><div class="line"></div><div class="line"><span class="comment">//Code</span></div><div class="line"></div><div class="line">@psub( myVar, 1 ) <span class="comment">//Decrement myVar on each loop</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( myVar )</div><div class="line"></div><div class="line"><span class="comment">//Code that shouldn&#39;t be printed in the last iteration</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>Because psub will be evaluated before expanding the foreach. </p>
</blockquote>
<h3>@counter( variable )</h3>
<p>Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.</p>
<p>Examples: </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@counter( myVar )   1</div><div class="line"></div><div class="line">@counter( myVar )   2</div></div><!-- fragment --><h3>@value( variable )</h3>
<p>Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@value( myVar )     1</div><div class="line"></div><div class="line">@value( myVar )     1</div></div><!-- fragment --><h3>@set add sub mul div mod min max</h3>
<p>Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.</p>
<p>Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c</p>
<p>Useful in combination with @counter and @value</p>
<table class="doxtable">
<tr>
<th>Expression </th><th>Output </th><th>Math  </th></tr>
<tr>
<td>@set( myVar, 1 ) <br />
 @value( myVar ) </td><td>1 </td><td>myVar = 1 </td></tr>
<tr>
<td>@add( myVar, 5 )<br />
 @value( myVar ) </td><td>6 </td><td>myVar = 1 + 5 </td></tr>
<tr>
<td>@div( myVar, 2 ) <br />
 @value( myVar ) </td><td>3 </td><td>myVar = 6 / 2 </td></tr>
<tr>
<td>@mul( myVar, myVar )<br />
 @value( myVar ) </td><td>9 </td><td>myVar = 3 * 3 </td></tr>
<tr>
<td>@mod( myVar, 5 ) <br />
 @value( myVar ) </td><td>4 </td><td>myVar = 9 % 5 </td></tr>
<tr>
<td>@add( myVar, 1, 1 ) <br />
 @value( myVar ) </td><td>2 </td><td>myVar = 1 + 1 </td></tr>
</table>
<h3>@piece( nameOfPiece )</h3>
<p>Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won't be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                        Output</div><div class="line"></div><div class="line">@piece( VertexTransform )         </div><div class="line"></div><div class="line">outPos = worldViewProj * inPos   </div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><h3>@insertpiece( nameOfPiece )</h3>
<p>Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                                                     Output</div><div class="line"></div><div class="line">@piece( VertexTransform )outPos = worldViewProj * inPos@end   void main()</div><div class="line"></div><div class="line">void main()                                                    {</div><div class="line"></div><div class="line">{                                                              outPos = worldViewProj * inPos</div><div class="line"></div><div class="line">@insertpiece( VertexTransform )                                }</div><div class="line"></div><div class="line">@insertpiece( InexistentPiece )                                </div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h3>@pset padd psub pmul pdiv pmod pmin pmax</h3>
<p>Analogous to <a href="#toc304"><em>the family of math functions without the 'p' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.</p>
<p>i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )</p>
<p>One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.</p>
<p>If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.</p>
<h1><a class="anchor" id="shaders"></a>
Creation of shaders</h1>
<p>There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:</p>
<ol type="1">
<li>The Datablock/Material. Does it have Normal maps? Then include code to sample the normal map and affect the lighting calculations. Does it have a diffuse map? If not, avoid sampling the diffuse map and multiplying it against the diffuse colour, etc.</li>
<li>The Mesh. Is it skeletally animated? Then include skeletal animation code. How many blend weights? Modify the skeletal animation code appropiately. It doesn't have tangents? Then skip the normal map defined in the material. And so on.</li>
</ol>
<p>When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.</p>
<p>If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).</p>
<p>The following graph summarizes the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_hash.svg">hlms_hash.svg</object>
</div>
<p>Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a “<a href="#toc567"><em>pass hash</em></a>” instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).</p>
<p>While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_caching.svg">hlms_caching.svg</object>
</div>
<h1><a class="anchor" id="cpp"></a>
C++ interaction with shader templates</h1>
<p>Note: This section is relevant to those seeking to write their own Hlms implementation.</p>
<p>C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set “key” to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod</p>
<p>To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.</p>
<p>The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.</p>
<p>In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.</p>
<p>Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.</p>
<p>For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.</p>
<p>The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.</p>
<h2>Common conventions</h2>
<p>Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.</p>
<p>Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.</p>
<p>For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.</p>
<p>Properties in underscore_case are set from C++; propierties in camelCase are set from the template.</p>
<p>Propierties and pieces starting with 'custom_' are for user customizations of the template</p>
<p>TBD</p>
<h2>Disabling a stage</h2>
<p>By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.</p>
<p>Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.</p>
<h1><a class="anchor" id="customization"></a>
Customization</h1>
<p>In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.</p>
<p>Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.</p>
<p>Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.</p>
<p>There are different levels in which an Hlms implementation can be customized:</p>
<ol type="1">
<li>Using a library, see <a href="#toc574"><em>Hlms Initialization</em></a>. pass a set of piece files in a folder by pushing the folder to ArchiveVec. The files in that folder will be parsed first, in order (archiveVec[0] then archiveVec[1], … archiveVec[N-1]); which will let you define your own pieces to insert code into the default template (see the the table at the end). You can also do clever tricky things to avoid dealing with C++ code at all even if there are no 'custom_' pieces for it. For example, you can write the following code to override the BRDF declarations and provide a custom BRDF: <div class="fragment"><div class="line"><span class="comment">//Disable all known BRDFs that the implementation may enable</span></div><div class="line"></div><div class="line">@pset( BRDF_CookTorrance, 0 )</div><div class="line"></div><div class="line">@pset( BRDF_Default, 0 )</div><div class="line"></div><div class="line">@piece( DeclareBRDF )</div><div class="line"></div><div class="line"><span class="comment">// Your BRDF code declaration here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --></li>
</ol>
<ol type="1">
<li>Via listener, through HlmsListener. This allows you to have access to the buffer pass to fill extra information; or bind extra buffers to the shader.</li>
<li>Overload HlmsPbs. Useful for overriding only specific parts, or adding new functionality that requires storing extra information in a datablock (e.g. overload HlmsPbsDatablock to add more variables, and then overload HlmsPbs::createDatablockImpl to create these custom datablocks)</li>
<li>Directly modify HlmsPbs, HlmsPbsDatablock and the template. <table class="doxtable">
<tr>
<th>Variable </th><th>Description  </th></tr>
<tr>
<td>custom_passBuffer </td><td>Piece where users can add extra information for the pass buffer (only useful if the user is using HlmsListener or overloaded HlmsPbs. </td></tr>
<tr>
<td>custom_VStoPS </td><td>Piece where users can add more interpolants for passing data from the vertex to the pixel shader. </td></tr>
<tr>
<td>custom_vs_attributes </td><td>Custom vertex shader attributes in the Vertex Shader (i.e. a special texcoord, etc). </td></tr>
<tr>
<td>custom_vs_uniformDeclaration </td><td>Data declaration (textures, texture buffers, uniform buffers) in the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_posExecution </td><td>Executed after all code from the Vertex Shader has been performed. </td></tr>
<tr>
<td>custom_ps_uniformDeclaration </td><td>Same as custom_vs_uniformDeclaration, but for the Pixel Shader </td></tr>
<tr>
<td>custom_ps_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Pixel Shader. </td></tr>
<tr>
<td>custom_ps_posMaterialLoad </td><td>Executed right after loading material data; and before anything else. May not get executed if there is no relevant material data (i.e. doesn't have normals or QTangents for lighting calculation) </td></tr>
<tr>
<td>custom_ps_preLights </td><td>Executed right before any light (i.e. to perform your own ambient / global illumination pass). All relevant texture data should be loaded by now. </td></tr>
<tr>
<td>custom_ps_posExecution </td><td>Executed after all code from the Pixel Shader has been performed. </td></tr>
</table>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: HLMS: High Level Material System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hlms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HLMS: High Level Material System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#components">The three components</a></li>
<li class="level1"><a href="#materials">Compared to classical materials</a></li>
<li class="level1"><a href="#data">Material parameters are stored in “Blocks”</a><ul><li class="level2"><a href="#toc52">Datablocks</a></li>
</ul>
</li>
<li class="level1"><a href="#toc69">Hlms templates</a><ul><li class="level2"><a href="#preproc">The Hlms preprocessor</a></li>
<li class="level2"><a href="#syntax">Preprocessor syntax</a></li>
</ul>
</li>
<li class="level1"><a href="#shaders">Creation of shaders</a></li>
<li class="level1"><a href="#cpp">C++ interaction with shader templates</a></li>
<li class="level1"><a href="#customization">Customization</a></li>
</ul>
</div>
<div class="textblock"><p>This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.</p>
<p>Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.</p>
<p>Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.</p>
<p>But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.</p>
<p>Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.</p>
<h1><a class="anchor" id="components"></a>
The three components</h1>
<div class="image">
<object type="image/svg+xml" data="hlms_components.svg">hlms_components.svg</object>
</div>
<ol type="1">
<li>Scripts. To set the material properties (i.e. type of Hlms to use: PBS, Toon shading, GUI; what textures, diffuse colour, roughness, etc). <b>You currently have to do this from C++.</b> Everybody will be using this part.</li>
<li>Shader template. The Hlms takes a couple hand-written glsl/hlsl files as template and then adapts it to fit the needs on the fly (i.e. if the mesh doesn’t contain skeleton, the bit of code pertaining to skeletal animation is stripped from the vertex shader). The Hlms provides a simple preprocessor to deal with this entirely within from the template, but you’re not forced to use it. Here’s a simple example of the preprocessor. I won’t be explaining the main keywords today. Advanced users will probably want to modify these files (or write some of their own) to fit their custom needs.</li>
<li>C++ classes implementation. The C++ takes care of picking the shader templates and manipulating them before compiling; and most importantly it feeds the shaders with uniform/constans data and sets the textures that are being in use. It is extremely flexible, powerful, efficient and scalable, but it’s harder to use than good ol’ Materials because those used to be data-driven: there are no AutoParamsSource here. Want the view matrix? You better grab it from the camera when the scene pass is about to start, and then pass it yourself to the shader. This is very powerful, because in D3D11/GL3+ you can just set the uniform buffer with the view matrix just once for the entire frame, and thus have multiple uniforms buffers sorted by update frequency. Very advanced user will be using messing with this part.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Material scripts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.x do not yet support the HLMS - you must use the C++ API. e.g. <a class="el" href="class_ogre_1_1_pbs_material.html">Ogre::PbsMaterial</a>.</dd></dl>
<p>Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.</p>
<p>For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.</p>
<p>It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.</p>
<h1><a class="anchor" id="materials"></a>
Compared to classical materials</h1>
<p>Materials are still useful for:</p>
<ul>
<li>Quick iteration. You need to write a shader, just define the material and start coding. Why would you deal with the template’s syntax or a C++ module when you can just write a script and start coding?. The HLMS though comes with a Command line tool to know how your template translates into a final shader (which is very handy for iteration, it’s fast, and will check for syntax errors!), but it’s most useful when you want to write your own C++ module or change the template, not when you want to just experiment. Besides, old timers are used to writing materials.</li>
<li>Postprocessing effects. Materials are much better suited for this. Materials are data driven, easy to write. Postprocessing FXs don’t need an awful lot of permutations (i.e. having to deal with shadow mapping, instancing, skeleton animation, facial animation). And they’re at no performance disadvantage compared to HLMS: Each FX is a fullscreen pass that needs different shaders, different textures, its own uniforms. Basically, API overhead we can’t optimize. But it doesn’t matter much either, because it’s not like there are 100 fullscreen passes. Usually there’s less than 10.</li>
</ul>
<h1><a class="anchor" id="data"></a>
Material parameters are stored in “Blocks”</h1>
<p>You could be thinking the reason I came up with these two is to fit with D3D11′s grand scheme of things while being compatible with OpenGL. But that’s a half truth and an awesome side effect. I’ve been developing the Hlms using OpenGL this whole time.</p>
<p>An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and they’re right about that.</p>
<p>However, there are big advantages for using blocks:</p>
<ol type="1">
<li>Many materials in practice share the same Macro- &amp; Blendblock parameters. In an age where we want many 3D primitives with the same shader but slightly different parameters like texture, colour, or roughness (which equals, a different material) having these settings repeated per material wastes a lot of memory space… and a lot of bandwidth (and wastes cache space). <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 is bandwidth bound, so having all materials share the same pointer to the same Macroblock can potentially save a lot of bandwidth, and be friendlier to the cache at the same time.This stays true whether we use D3D11, D3D12, OpenGL, GL ES 2, or Mantle.</li>
<li>Sorting by Macroblock is a lot easier (and faster) than sorting by its individual parameters: when preparing the hash used for sorting, it’s much easier to just do (every frame, per object) <code>hash |= (macroblock-&gt;getId() &lt;&lt; bits) &amp; mask</code> than to do: <code>hash =| m-&gt;depth_check | m-&gt;depthWrite &lt;&lt; 1 | m-&gt;depthBias &lt;&lt; 2 | m-&gt;depth_slope_bias &lt;&lt; 3 | m-&gt;cullMode &lt;&lt; 18 | ... ;</code> We also need a lot more bits we can’t afford. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 imposes a limit on the amount of live Macroblocks you can have at the same time; as we run out of hashing space (by the way, D3D11 has its own limit). It operates around the idea that most setting combinations won’t be used in practice.</li>
</ol>
<p>Of course it’s not perfect, it can’t fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); you’ll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. We’re aiming the general use case.</p>
<p>These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since I’m not used to driver development. However from an engine perspective, blocks make sense.</p>
<h2><a class="anchor" id="toc52"></a>
Datablocks</h2>
<p>We’re introducing the concept of Datablocks. A Datablock is a “material” from the user’s perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.</p>
<div class="image">
<object type="image/svg+xml" data="hlms_blocks.svg">hlms_blocks.svg</object>
</div>
<p>The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.</p>
<dl class="section note"><dt>Note</dt><dd>Macroblocks and Blendblocks are not available in 1.x - use <a class="el" href="class_ogre_1_1_pass.html#ae454faee87f8cb0b8540810e48118788" title="Sets whether or not this pass renders with depth-buffer checking on or not. ">Ogre::Pass::setDepthCheckEnabled</a> etc. as usual, to change the respective properties</dd></dl>
<h1><a class="anchor" id="toc69"></a>
Hlms templates</h1>
<p>The Hlms will parse the template files from the template folder according to the following rules:</p>
<ol type="1">
<li>The files with the names "VertexShader_vs", "PixelShader_ps", "GeometryShader_gs", "HullShader_hs", "DomainShader_ds" will be fully parsed and compiled into the shader. If an implementation only provides "VertexShader_vs.glslt", "PixelShader_ps.glslt"; only the vertex and pixel shaders for OpenGL will be created. There will be no geometry or tesellation shaders.</li>
<li>The files that contain the string "_piece_vs" in their filenames will be parsed only for collecting pieces (more on pieces later). Likewise, the words "_piece_ps", "_piece_gs", "_piece_hs", "_piece_ds” correspond to the pieces for their respective shader stages. Note that you can concatenate, thus "MyUtilities_piece_vs_piece_ps.glslt” will be collected both in the vertex and pixel shader stages.</li>
</ol>
<p>The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.</p>
<h2><a class="anchor" id="preproc"></a>
The Hlms preprocessor</h2>
<p>The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.</p>
<p>For example </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can't evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can't check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable “IncludeLightingEquals2” and check whether it's non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can't see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you'll depend on the driver implementation having a good macro preprocessor.</p>
<h2><a class="anchor" id="syntax"></a>
Preprocessor syntax</h2>
<p>The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:</p>
<ul>
<li>@property</li>
<li>@foreach</li>
<li>@counter</li>
<li>@value</li>
<li>@set add sub mul div mod min max</li>
<li>@piece</li>
<li>@insertpiece</li>
<li>@pset padd psub pmul pdiv pmod pmin pmax</li>
</ul>
<h3>@property( expression )</h3>
<p>Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.</p>
<p>The logical operands &amp;&amp; || ! are valid.</p>
<p>Examples: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: </p><div class="fragment"><div class="line">hasLights != 0                              hasLights == 0</div><div class="line">diffuse = surfaceDiffuse * lightDiffuse;   diffuse = surfaceDiffuse ;</div></div><!-- fragment --><h3>@foreach( scopedVar, count, [start] )</h3>
<p>Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.</p>
<ul>
<li>scopedVar is a variable that can be used to print the current iteration of the loop while inside the block. i.e. “@scopedVar” will be converted into a number in the range [start; count)</li>
<li>count The number of times to repeat the loop (if start = 0). Count can read variables.</li>
<li>start Optional. Allows to start from a value different than 0. Start can read variables.</li>
</ul>
<p>Newlines are very important, as they will be printed with the loop.</p>
<p>Examples: </p><table class="doxtable">
<tr>
<th>Expression </th><th>Output  </th></tr>
<tr>
<td>@foreach( 4, n ) <br />
&emsp; @n@end </td><td><br />
0<br />
1<br />
2<br />
3 </td></tr>
<tr>
<td>@foreach( 4, n ) @n@end </td><td>0 1 2 3 </td></tr>
<tr>
<td>@foreach( 4, n )<br />
&emsp;@n<br />
@end </td><td><br />
0<br />
<br />
1<br />
<br />
2<br />
<br />
3<br />
 </td></tr>
<tr>
<td>@foreach( 4, n, 2 ) @n@end </td><td>2 3 </td></tr>
<tr>
<td>@pset( myStartVar, 1 )<br />
@pset( myCountVar, 3 )<br />
@foreach( myStartVar, n, myCountVar )<br />
&emsp;@n@end </td><td>1<br />
2 </td></tr>
<tr>
<td>@foreach( 2, n )<br />
&emsp;@insertpiece( pieceName@n )@end </td><td>@insertpiece( pieceName0 )<br />
 @insertpiece( pieceName1 ) </td></tr>
</table>
<blockquote class="doxtable">
<p><b>Attention #1!</b></p>
<p>Don't use the common letter i for the loop counter. It will conflict with other keywords.</p>
<p>i.e. “@foreach( 1, i )@insertpiece( pieceName )@end” will print “0nsertpiece( pieceName )” which is probably not what you intended.</p>
<p><b>Attention #2!</b></p>
<p>foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.</p>
<p>i.e. The following code will not work:</p>
<div class="fragment"><div class="line">@pset( myVar, 1 )</div><div class="line"></div><div class="line">@<span class="keywordflow">foreach</span>( 2, n )</div><div class="line"></div><div class="line"><span class="comment">//Code</span></div><div class="line"></div><div class="line">@psub( myVar, 1 ) <span class="comment">//Decrement myVar on each loop</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( myVar )</div><div class="line"></div><div class="line"><span class="comment">//Code that shouldn&#39;t be printed in the last iteration</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>Because psub will be evaluated before expanding the foreach. </p>
</blockquote>
<h3>@counter( variable )</h3>
<p>Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.</p>
<p>Examples: </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@counter( myVar )   1</div><div class="line"></div><div class="line">@counter( myVar )   2</div></div><!-- fragment --><h3>@value( variable )</h3>
<p>Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@value( myVar )     1</div><div class="line"></div><div class="line">@value( myVar )     1</div></div><!-- fragment --><h3>@set add sub mul div mod min max</h3>
<p>Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.</p>
<p>Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c</p>
<p>Useful in combination with @counter and @value</p>
<table class="doxtable">
<tr>
<th>Expression </th><th>Output </th><th>Math  </th></tr>
<tr>
<td>@set( myVar, 1 ) <br />
 @value( myVar ) </td><td>1 </td><td>myVar = 1 </td></tr>
<tr>
<td>@add( myVar, 5 )<br />
 @value( myVar ) </td><td>6 </td><td>myVar = 1 + 5 </td></tr>
<tr>
<td>@div( myVar, 2 ) <br />
 @value( myVar ) </td><td>3 </td><td>myVar = 6 / 2 </td></tr>
<tr>
<td>@mul( myVar, myVar )<br />
 @value( myVar ) </td><td>9 </td><td>myVar = 3 * 3 </td></tr>
<tr>
<td>@mod( myVar, 5 ) <br />
 @value( myVar ) </td><td>4 </td><td>myVar = 9 % 5 </td></tr>
<tr>
<td>@add( myVar, 1, 1 ) <br />
 @value( myVar ) </td><td>2 </td><td>myVar = 1 + 1 </td></tr>
</table>
<h3>@piece( nameOfPiece )</h3>
<p>Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won't be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                        Output</div><div class="line"></div><div class="line">@piece( VertexTransform )         </div><div class="line"></div><div class="line">outPos = worldViewProj * inPos   </div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><h3>@insertpiece( nameOfPiece )</h3>
<p>Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                                                     Output</div><div class="line"></div><div class="line">@piece( VertexTransform )outPos = worldViewProj * inPos@end   void main()</div><div class="line"></div><div class="line">void main()                                                    {</div><div class="line"></div><div class="line">{                                                              outPos = worldViewProj * inPos</div><div class="line"></div><div class="line">@insertpiece( VertexTransform )                                }</div><div class="line"></div><div class="line">@insertpiece( InexistentPiece )                                </div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h3>@pset padd psub pmul pdiv pmod pmin pmax</h3>
<p>Analogous to <a href="#toc304"><em>the family of math functions without the 'p' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.</p>
<p>i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )</p>
<p>One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.</p>
<p>If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.</p>
<h1><a class="anchor" id="shaders"></a>
Creation of shaders</h1>
<p>There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:</p>
<ol type="1">
<li>The Datablock/Material. Does it have Normal maps? Then include code to sample the normal map and affect the lighting calculations. Does it have a diffuse map? If not, avoid sampling the diffuse map and multiplying it against the diffuse colour, etc.</li>
<li>The Mesh. Is it skeletally animated? Then include skeletal animation code. How many blend weights? Modify the skeletal animation code appropiately. It doesn't have tangents? Then skip the normal map defined in the material. And so on.</li>
</ol>
<p>When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.</p>
<p>If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).</p>
<p>The following graph summarizes the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_hash.svg">hlms_hash.svg</object>
</div>
<p>Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a “<a href="#toc567"><em>pass hash</em></a>” instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).</p>
<p>While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_caching.svg">hlms_caching.svg</object>
</div>
<h1><a class="anchor" id="cpp"></a>
C++ interaction with shader templates</h1>
<p>Note: This section is relevant to those seeking to write their own Hlms implementation.</p>
<p>C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set “key” to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod</p>
<p>To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.</p>
<p>The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.</p>
<p>In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.</p>
<p>Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.</p>
<p>For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.</p>
<p>The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.</p>
<h2>Common conventions</h2>
<p>Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.</p>
<p>Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.</p>
<p>For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.</p>
<p>Properties in underscore_case are set from C++; propierties in camelCase are set from the template.</p>
<p>Propierties and pieces starting with 'custom_' are for user customizations of the template</p>
<p>TBD</p>
<h2>Disabling a stage</h2>
<p>By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.</p>
<p>Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.</p>
<h1><a class="anchor" id="customization"></a>
Customization</h1>
<p>In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.</p>
<p>Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.</p>
<p>Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.</p>
<p>There are different levels in which an Hlms implementation can be customized:</p>
<ol type="1">
<li>Using a library, see <a href="#toc574"><em>Hlms Initialization</em></a>. pass a set of piece files in a folder by pushing the folder to ArchiveVec. The files in that folder will be parsed first, in order (archiveVec[0] then archiveVec[1], … archiveVec[N-1]); which will let you define your own pieces to insert code into the default template (see the the table at the end). You can also do clever tricky things to avoid dealing with C++ code at all even if there are no 'custom_' pieces for it. For example, you can write the following code to override the BRDF declarations and provide a custom BRDF: <div class="fragment"><div class="line"><span class="comment">//Disable all known BRDFs that the implementation may enable</span></div><div class="line"></div><div class="line">@pset( BRDF_CookTorrance, 0 )</div><div class="line"></div><div class="line">@pset( BRDF_Default, 0 )</div><div class="line"></div><div class="line">@piece( DeclareBRDF )</div><div class="line"></div><div class="line"><span class="comment">// Your BRDF code declaration here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --></li>
</ol>
<ol type="1">
<li>Via listener, through HlmsListener. This allows you to have access to the buffer pass to fill extra information; or bind extra buffers to the shader.</li>
<li>Overload HlmsPbs. Useful for overriding only specific parts, or adding new functionality that requires storing extra information in a datablock (e.g. overload HlmsPbsDatablock to add more variables, and then overload HlmsPbs::createDatablockImpl to create these custom datablocks)</li>
<li>Directly modify HlmsPbs, HlmsPbsDatablock and the template. <table class="doxtable">
<tr>
<th>Variable </th><th>Description  </th></tr>
<tr>
<td>custom_passBuffer </td><td>Piece where users can add extra information for the pass buffer (only useful if the user is using HlmsListener or overloaded HlmsPbs. </td></tr>
<tr>
<td>custom_VStoPS </td><td>Piece where users can add more interpolants for passing data from the vertex to the pixel shader. </td></tr>
<tr>
<td>custom_vs_attributes </td><td>Custom vertex shader attributes in the Vertex Shader (i.e. a special texcoord, etc). </td></tr>
<tr>
<td>custom_vs_uniformDeclaration </td><td>Data declaration (textures, texture buffers, uniform buffers) in the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_posExecution </td><td>Executed after all code from the Vertex Shader has been performed. </td></tr>
<tr>
<td>custom_ps_uniformDeclaration </td><td>Same as custom_vs_uniformDeclaration, but for the Pixel Shader </td></tr>
<tr>
<td>custom_ps_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Pixel Shader. </td></tr>
<tr>
<td>custom_ps_posMaterialLoad </td><td>Executed right after loading material data; and before anything else. May not get executed if there is no relevant material data (i.e. doesn't have normals or QTangents for lighting calculation) </td></tr>
<tr>
<td>custom_ps_preLights </td><td>Executed right before any light (i.e. to perform your own ambient / global illumination pass). All relevant texture data should be loaded by now. </td></tr>
<tr>
<td>custom_ps_posExecution </td><td>Executed after all code from the Pixel Shader has been performed. </td></tr>
</table>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Trays GUI System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('trays.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Trays GUI System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#trays-1">Trays</a></li>
<li class="level1"><a href="#traymanager">TrayManager</a></li>
<li class="level1"><a href="#widgets">Widgets</a></li>
<li class="level1"><a href="#special-widgets">Special Widgets</a></li>
<li class="level1"><a href="#tray-listener">TrayListener</a></li>
<li class="level1"><a href="#things-to-try">Things to Try</a></li>
</ul>
</div>
<div class="textblock"><p>Ever wanted really simple GUI controls for your sample? Don't want to write one from scratch, but CEGUI's just a little too much? The Trays system was created to address this issue. It's a simple GUI system based on the OGRE Overlay system and designed just for samples. Because it's simple, you're not going to be able to skin it or build very unique interfaces, but you'll also find it much easier to use. The entire system is based on the OGRE Overlay system.</p>
<h1><a class="anchor" id="trays-1"></a>
Trays</h1>
<p>Why trays? The concept of trays is central to the system in that it removes the need for the GUI designer (you) to calculate or specify positional coordinates of any kind. Think about the widget locations in a typical GUI. They are almost always in any of the four corners, along any of the four edges or, on the rare occasion, in the center of the screen. In Trays, there are nine "trays", one in each of the locations previously mentioned. When you create a widget, you specify one of these nine locations, and the widget will be added to the tray at that location. Your widget will be added directly beneath the last widget in that tray. When you add a widget to a tray, the tray grows in size. Trays along the top of the screen grow downward, Trays along the bottom grow upward, and the trays in the middle row grow vertically in both directions. Visually, the trays are semi-transparent panels that fit the widgets they contain. Only non-empty trays are visible. If this is hard to visualise, don't worry, here's a picture to help you out. </p><div class="image">
<img src="Gui2.jpg" alt="Gui2.jpg"/>
</div>
<h1><a class="anchor" id="traymanager"></a>
TrayManager</h1>
<p>To use Trays, you have to create an TrayManager. This is the class through which you will create and manage all your widgets, manipulate the cursor, change the backdrop image, adjust tray properties, pop up dialogs, show/hide the loading bar, etc. You can have multiple tray managers in one application. For example, the OGRE Sample Browser uses its own tray manager and hides it when a sample is running, and the SDK samples also have their own tray managers, which are hidden when the samples are paused by the browser. The TrayManager requires "Trays.zip", so you can only create it after loading that resource. Also, make sure you're using the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> namespace (Trays is part of the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Samples Framework). Create your tray manager like so: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>* mTrayMgr = <span class="keyword">new</span> <a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>(<span class="stringliteral">&quot;InterfaceName&quot;</span>, mWindow, <span class="keyword">this</span>);</div></div><!-- fragment --><p> You must pass in a name for your interface, an <code><a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a></code> and an <code><a class="el" href="class_ogre_bites_1_1_tray_listener.html" title="Listener class for responding to tray events. ">OgreBites::TrayListener</a></code>. You can extend your sample or sample context to be a tray listener. Destroy your tray manager like so: </p><div class="fragment"><div class="line"><span class="keyword">delete</span> mTrayMgr;</div><div class="line">mTrayMgr = 0;</div></div><!-- fragment --><p> Once you have your tray manager, make sure you relay your OIS events to it. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> mousePressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseDown(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseReleased(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseUp(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseMoved(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_motion_event.html">OgreBites::MouseMotionEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseMove(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> The injection methods return true if the event was relevant to the tray manager, and should not be processed again by you. For example, if you click a button that is over an interactive part of your scene, you want the button to be pressed, but you don't want the scene interaction to take place. So the injection methods double as filters for your mouse events.</p>
<p>You're now free to create widgets! Try adding a button to the top-left tray: </p><div class="fragment"><div class="line">Button* b = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">createButton</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530afe04de8736168ab0dd6e7938e679c292">TL_TOPLEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <span class="stringliteral">&quot;Click Me!&quot;</span>);</div></div><!-- fragment --><p> TrayManager is a huge class, and you can do tons of things with it. For some examples, see the Things to Try section below.</p>
<h2>The Cursor</h2>
<p>The cursor has three parts in the Trays system: The layer it moves around in Overlay, the container which positions the cursor (OverlayContainer), and the cursor image, which is a child of the container (OverlayElement). When hiding/showing the cursor, the entire cursor layer is hidden/shown. The top left corner of the cursor container is used as the hotspot of the cursor. By positioning the cursor image relative to the cursor container, you can basically decide which part of the cursor image is the "clicking part". For the default arrow cursor, the image is simply lined up with the container, meaning the top left is the hotspot. However, for something like a crosshair cursor, you could move the cursor image so that its center is over the top left corner of the cursor container. To show the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1cc48ac157278b5845d425abbe9acefd" title="Displays specified material on cursor, or the last material used if none specified. ">OgreBites::TrayManager::showCursor</a></code>, which takes an optional material name for the cursor image. If unspecified, the cursor image is not changed. To hide the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a979ff2ad2d729223259b3bebb237cafb">OgreBites::TrayManager::hideCursor</a></code>. You can get the cursor's different parts using getCursorLayer, getCursorContainer, and getCursorImage. Note that if the cursor is hidden, all interactions with widgets are disabled.</p>
<h2>The Backdrop</h2>
<p>If you want to show a backdrop, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ad554418c27edb907f0e3bead8659b83c" title="Displays specified material on backdrop, or the last material used if none specified. ">OgreBites::TrayManager::showBackdrop</a></code>, which takes an optional material name for the backdrop. If unspecified, the backdrop image is not changed. To hide it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a6129a1e92ac22789a4602cf36f9c5394">OgreBites::TrayManager::hideBackdrop</a></code>.</p>
<h1><a class="anchor" id="widgets"></a>
Widgets</h1>
<p>There are 10 basic widgets. Each widget is just an instance of an OverlayElement template, and all widgets use {LEX()}pixel{LEX} metrics. You can get access to any widget's underlying OverlayElement through <code><a class="el" href="class_ogre_bites_1_1_widget.html#a379d3f1a2ca6eaf13fc5c52afaafd0d2">OgreBites::Widget::getOverlayElement</a></code>. Do not instantiate and delete widgets manually. Create and destroy them using the TrayManager. The first argument to any one of TrayManager's widget creation methods is the location of the tray you want the widget to be in. This is of the enumerated type TrayLocation. The second argument is the name of your widget (this is not your widget's caption, but a unique string identifier for your widget). The rest of the arguments are specific to the type of widget.</p>
<h2>Button</h2>
<p>This is the most basic widget of all. To create a button, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">OgreBites::TrayManager::createButton</a></code>. In addition to a tray location and a name, you must specify a caption for your button, and an optional width. If width is not specified, the button will automatically resize to fit its caption. There are no button states. You only get notified when a button is pushed. To see how to respond to button push events, see the TrayListener section below.</p>
<h2>TextBox</h2>
<p>This widget consists of a bold caption bar and a text area that can be scrolled vertically. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a07a8d212939266339e877ff2118250a6">OgreBites::TrayManager::createTextBox</a></code> takes a caption, width, and height. You can set/get the caption, the text area contents, text padding, text alignment, manually change the scroll bar position, among other things.</p>
<h2>SelectMenu</h2>
<p>A basic drop-down menu. To create it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a60864ca00d65b2bf1b97bb8545fab737">OgreBites::TrayManager::createLongSelectMenu</a></code> or <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a98f478c8daa5084b53146de03adbc216">OgreBites::TrayManager::createThickSelectMenu</a></code>. Both these methods return a SelectMenu object, but they give one of two different visual styles to the widget. One is thicker, but shorter, because it places the caption over the item box. This style of menu is good for putting in the side trays. The other is longer, but thinner, because it places the item box next to the caption. This style of menu is good for putting in the top or bottom trays. createThickSelectMenu takes a tray location, a name, a caption, the width of the whole widget, the maximum number of visible items when expanded, and an optional string vector of items. The medthod <code>createLongSelectMenu</code> takes nearly the same arguments, except that it needs the width of the text box that shows the currently selected item. Also, for long menus, it is optional to specify the total width because it will automatically resize to fit the item box and the caption. You can set/get the caption, and set/get the items in many different ways. You can also manually change the selection, with the option of not firing an event. To see how to respond to menu item selection events, see the TrayListener section below.</p>
<h2>Label</h2>
<p>A big, semi-transparent, tabby-looking label. This widget uses a different font from the rest of the widgets, and is good for section headings and such. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a15375d59b5c57059c9c6549fc5a1bfcd">OgreBites::TrayManager::createLabel</a></code> takes a caption, and an optional width. If the width is not specified, the label automatically adjusts its width to fill the tray it's currently in, so it matches the other contents of the tray. Labels can also be clicked. To see how to respond to label click events, see the TrayListener section below.</p>
<h2>Separator</h2>
<p>A horizontal line which looks like it was etched into the tray. Good for dividing up other widgets into sections without taking up as much space as a label. <code>TrayManager::createSeparator</code> takes a tray location, name, and an optional width. If the width is not specified, the behaviour is the same as a Label's.</p>
<h2>Slider</h2>
<p>A slider bar consists of a container box, a small text box to display the value, and a track + handle. Sliders are type-agnostic. Using three parameters - a minimum value, a maximum value, and the number of "snapping points", you can give your slider track of any kind of discrete scale - integer, floating point, or even nominal. Snapping points are basically the "steps" on your slider track. By specifying how many of them there are, you are in effect specifying an entire range of values all the way from your minimum value to your maximum value. Let's say you have minimum value 0, maximum value 1, and 6 snapping points. Underneath the surface, each slider stores a floating point value, so in this case you would be able to display 6 floating point values: {0, 0.2, 0.4, 0.6, 0.8, 1}. The slider will display your value in the cleanest way possible (using <code><a class="el" href="class_ogre_1_1_string_converter.html#a45fb498a2f798c82bbf88116a5a34c53" title="Converts a float to a String. ">Ogre::StringConverter::toString</a></code>). This means that if all your values happen to land on integers, then they will be displayed as integers without decimals. You can also exploit this by using your slider's integer values as indices into an array of string values, and manually set your slider's value to the new string value. Basically, you can make your slider display things like Low, Medium, High, 1/4, 3/4, $4.00, N/A, etc. This requires you to respond to slider move events. More on this in the TrayListener section below. Then your Like select menus, sliders also come in two flavours - thick and long. The thick style places the caption and the value box above the track, while the long style places the caption, track, and value box side by side in that order. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a597ec173c1b424980e18fd92e0c56905">OgreBites::TrayManager::createThickSlider</a></code> takes a tray location, name, caption, total width, value box width, minimum value, maximum value, and the number of snapping points. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a321429ade975d3a63dfc1125b4375e78">OgreBites::TrayManager::createLongSlider</a></code> takes a an optional total width, track width, value box width, minimum value, maximum value, and the number of snapping points. If the total width is not specified, the slider will automatically scale to fit the track, the value box, and the caption text. You can get/set the slider's caption, displayed value, actual value, and range of values. When you change the range, the value is reset to be the minimum value. When you change the value, you also have the option of not firing an event. To respond to slider move events, see the TrayListener section below.</p>
<h2>ParamsPanel</h2>
<p>This panel displays an arbitrary number of parameters and their values. This could be anything you want. For example, the stats panel in the SDK samples shows the average framerate, best framerate, batch count, etc. The details panel in the SDK samples shows the texture filtering technique, the polygon mode, and the camera position and orientation. To create a ParamsPanel, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a5ae6b66603e05193b3077f30900209eb">OgreBites::TrayManager::createParamsPanel</a></code>, which takes a tray location, a name, a width, and then either a string vector of parameter names or the number of parameters (lines) to leave room for. The parameter names will be left justified, and their values will be right justified on the same line. At any time, you can set/get the parameter names and values either one at a time, or all at once using a string vector.</p>
<h2>CheckBox</h2>
<p>Self-explanatory. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7433f3e89c5b3a1b1b0012dfcb121f1d">OgreBites::TrayManager::createCheckBox</a></code> takes a tray location, name, caption, and an optional width. Unspecified width means auto-fit to caption. You can set/get the state of the check box, with the option of not triggering an event. To respond to check box state change events, see the TrayListener section below. </p><h2>DecorWidget</h2>
<p>This widget takes any OverlayElement template, and creates a widget out of it. If you want to put your own picture, icons, or other static objects into the trays, make an OverlayElement template out of it, and then turn it into a DecorWidget. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a24d1b3a3b95ddcf274bf899b7600deba">OgreBites::TrayManager::createDecorWidget</a></code> takes a tray location, a name, and an OverlayElement template name. These are basically the same things you would normally use to create an OverlayElement from a template. The OGRE logo in the SDK samples is a DecorWidget. </p><h2>ProgressBar</h2>
<p>A progress bar with a caption, a comment/details box, and a meter that fills up. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a431a347db6465bbf66af82ef363c875f">OgreBites::TrayManager::createProgressBar</a></code> takes a tray location, a name, a caption, a total width, and comment box width. You can use progress bars to show any kind of progress you want, but for the most common kind (loading resources), there's a special instance of ProgressBar already created by TrayManager which you can use. See Loading Bar below.</p>
<h2>The Null Tray</h2>
<p>In addition to the nine trays you can place your widgets in, there is also a "null tray". This is an imaginary tray, whose location is specified by <code>TL_NONE</code>. This tray is virtual, invisible, and does not arrange widgets within it. Basically, if you place a widget in this tray, it becomes "free-floating", and you're allowed to manually position it anywhere on the screen. Widgets must always reside in a tray for as long as they exist, so when a widget is removed from a tray, it is automatically placed in the null tray.</p>
<h1><a class="anchor" id="special-widgets"></a>
Special Widgets</h1>
<p>Some widgets are so common they deserve special treatment.</p>
<h2>Frame Stats</h2>
<p>This is not exactly one widget, but a combination of Label that displays the current FPS, and a ParamsPanel that displays advanced frame statistics (such as average FPS and batch count). Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a49e2f792fee94e75b1b472826bcc8019" title="Shows frame statistics widget set in the specified location. ">OgreBites::TrayManager::showFrameStats</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1c2e9618a3e6b061a9cfeac4f2cb55e9" title="Hides frame statistics widget set. ">OgreBites::TrayManager::hideFrameStats</a></code> to show/hide this special widget. You can choose where to put it. When the user clicks the FPS label, it toggles the visibility of the advanced frame stats, so they can be out of the way when they're unwanted. You can also manually toggle the visibility of the advanced frame stats using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aed00f8a1009f2ebf6806774cb894d0d7" title="Toggles visibility of advanced statistics. ">OgreBites::TrayManager::toggleAdvancedFrameStats</a></code>.</p>
<h2>Logo</h2>
<p>This is just a decor widget of the OGRE logo. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#affee57f47066e25437649d64daaa7dd9" title="Shows logo in the specified location. ">OgreBites::TrayManager::showLogo</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ac1ee637b7ef5e887170c8a9aca1c4c7b">OgreBites::TrayManager::hideLogo</a></code> to show/hide the logo. You can choose where to put it.</p>
<h2>Loading Bar</h2>
<p>This is a progress bar that shows you the progress of your current resource loading job. The comment box will show the current resource being loaded. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a0d51005a4b148a4df2c1c6b55e34f085" title="Shows loading bar. ">OgreBites::TrayManager::showLoadingBar</a></code> before you begin your loading job. Specify the number of resource groups you will initialise, the number of groups you will load, and, if you want to, the proportion of time you think will go to initialisation (default estimate is 70%). You cannot decide where to place this loading bar. The screen will be darkened, and the loading bar will appear in the center. Any other dialog or loading bar will be closed. When you finish your loading job, call <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aab014a2c48c8f91556182e42684d44ad">OgreBites::TrayManager::hideLoadingBar</a></code>.</p>
<h2>Information Dialog</h2>
<p>This is a dialog which tells the user something and displays an OK button. It's a combination of a TextBox and a Button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#abf3bd8e4ef9a6d0d76f27535a6010623" title="Pops up a message dialog with an OK button. ">OgreBites::TrayManager::showOkDialog</a></code> to display an information dialog. Specify the caption of the TextBox, and the message you want to display in it. Any other dialog or loading bar will be closed. The screen will be darkened, and the dialog will appear in the center. All other widget interactions are disabled until the dialog is closed. You can manually close a dialog using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#af5d95dcaa7c74d3345308e4f4e3035e8" title="Hides whatever dialog is currently showing. ">OgreBites::TrayManager::closeDialog</a></code>. To respond to information dialog closing events, see the TrayListenersection below.</p>
<h2>Question Dialog</h2>
<p>Same as the Information Dialog except it asks the user something and displays a Yes button and a No button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a85d47aa11d761742884dc6457ec11cdf" title="Pops up a question dialog with Yes and No buttons. ">OgreBites::TrayManager::showYesNoDialog</a></code> to display a question dialog. Specify the caption of the TextBox, and the question you want to display in it. To respond to question dialog closing events, see the TrayListener section below.</p>
<h1><a class="anchor" id="tray-listener"></a>
TrayListener</h1>
<p>This class contains handlers for all the different events that your widgets can fire. The TrayManager class itself is an TrayListener, because it responds to events from its special widgets. You should extend your sample class from TrayListener as well as Sample if you want to handle widget events. If you're using SdkSample, you're all set because it's already an TrayListener. Some widgets give you an option of not firing an event when you change their state. This is helpful for initialising or resetting a widget, in which case there shouldn't be a response of any sort. For example, if you're initialising your slider bar before the scene is set up, and your slider bar is used to control some part of your scene, firing an event would cause an error. Below is a list of the different handlers. All handlers have return type void.</p><ul>
<li><b>buttonHit</b>: Gives you a pointer to the Button which was hit.</li>
<li><b>itemSelected</b>: Gives you a pointer to the SelectMenu the item was chosen from. You can then use the SelectMenu to see which item was selected.</li>
<li><b>labelHit</b>: Gives you a pointer to the Label that was clicked.</li>
<li><b>sliderMoved</b>: Gives you a pointer to the Slider whose value was changed. You can then use the Slider to see what its new value is. Also, you can convert this value into a more suitable form and display it using Slider::setDisplayedValue.</li>
<li><b>checkBoxToggled</b>: Gives you a pointer to the CheckBox whose state was changed. You can then use the CheckBox to see if it's been checked or unchecked.</li>
<li><b>okDialogClosed</b>: Gives you the message of the OK dialog that was closed.</li>
<li><b>yesNoDialogClosed</b>: Gives you the question of the Yes-No dialog that was closed, and a boolean indicating whether or not the Yes button was pressed.</li>
</ul>
<h1><a class="anchor" id="things-to-try"></a>
Things to Try</h1>
<p>Getting access to widgets: </p><div class="fragment"><div class="line">Button* b;</div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);  <span class="comment">// by tray and position</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by tray and name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#af968c01a627ee654409f558e4ef55537">getWidgetIterator</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>).<a class="code" href="class_ogre_1_1_vector_iterator_wrapper.html#a2460c8adb6819235849de954db6a0f64">getNext</a>();  <span class="comment">// by iterator</span></div></div><!-- fragment --><p> Counting widgets: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>();  <span class="comment">// total</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);  <span class="comment">// by tray</span></div></div><!-- fragment --><p> Moving widgets to other trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div></div><!-- fragment --><p> Removing widgets from trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a04a1085bdee61d7234849663cce08664">TL_NONE</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a77ba6e4d641c146e262b6cdd2c8b04a0">clearTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9787ec5e8989bf6cfa89d03c6ddd27b6">clearAllTrays</a>();</div></div><!-- fragment --><p> Destroying widgets: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4a89cd6f7d87e0e538aa842f1a42a7bc">destroyAllWidgetsInTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aadb1f5a3b7e3b5397b10bdd3449e1603">destroyAllWidgets</a>();</div></div><!-- fragment --><p> Finding the position of a widget in a tray: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa993d2b60cfbcb903aecbff1c4896b67">locateWidgetInTray</a>(b);</div></div><!-- fragment --><p> Finding the tray a widget is in: </p><div class="fragment"><div class="line"><a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530">TrayLocation</a> trayLoc = b-&gt;getTrayLocation();</div></div><!-- fragment --><p> Changing the tray listener object: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a3235fea714a0c61e463dee69ae308be8">setListener</a>(newListener);</div></div><!-- fragment --><p> Toggling system visibility: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a075805136b2241cbb03eeb2c3d27b40d">showAll</a>();</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a188f1d5f5ca16af3b28d11ecd553105a">hideAll</a>();</div></div><!-- fragment --><p> Changing horizontal widget alignment in one tray: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#adfbbc97615fd5f1a939be6e7a1f00c07">setTrayWidgetAlignment</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <a class="code" href="group___overlays.html#gga3396780cdb2d731aa5e4389148bdc5f3a270f18cf07dbe4e75e1b790d02924205">GHA_RIGHT</a>);</div></div><!-- fragment --><p> Changing spacing and padding: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a33a3e3f66a3989dd3de48b4c4577422f">setWidgetSpacing</a>(5);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a52d3fc8638533540232232c37b257de6">setWidgetPadding</a>(3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a866229b6d88dc9d3a609115eaab46e67">setTrayPadding</a>(12);</div></div><!-- fragment --><p> Casting 3D ray from under cursor into the scene: </p><div class="fragment"><div class="line">Ray r = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9dd5d303968329462e9bf4225f59722e">getCursorRay</a>(mCamera);</div></div><!-- fragment --><p> Casting 3D ray from any 2D screen coordinate into the scene: </p><div class="fragment"><div class="line">Ray r = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#a6833f46b0303b559a050f310fa0204fc">OgreBites::TrayManager::screenToScene</a>(mCamera, Vector2(320, 240));</div></div><!-- fragment --><p> Converting a 3D scene coordinate to a 2D screen coordinate: </p><div class="fragment"><div class="line">Vector2 p = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa7a456c2c0c37123e2ab0e497f2c0ccc">OgreBites::TrayManager::sceneToScreen</a>(mCamera, Vector3::ZERO);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: HLMS: High Level Material System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hlms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HLMS: High Level Material System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#components">The three components</a></li>
<li class="level1"><a href="#materials">Compared to classical materials</a></li>
<li class="level1"><a href="#data">Material parameters are stored in “Blocks”</a><ul><li class="level2"><a href="#toc52">Datablocks</a></li>
</ul>
</li>
<li class="level1"><a href="#toc69">Hlms templates</a><ul><li class="level2"><a href="#preproc">The Hlms preprocessor</a></li>
<li class="level2"><a href="#syntax">Preprocessor syntax</a></li>
</ul>
</li>
<li class="level1"><a href="#shaders">Creation of shaders</a></li>
<li class="level1"><a href="#cpp">C++ interaction with shader templates</a></li>
<li class="level1"><a href="#customization">Customization</a></li>
</ul>
</div>
<div class="textblock"><p>This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.</p>
<p>Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.</p>
<p>Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.</p>
<p>But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.</p>
<p>Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.</p>
<h1><a class="anchor" id="components"></a>
The three components</h1>
<div class="image">
<object type="image/svg+xml" data="hlms_components.svg">hlms_components.svg</object>
</div>
<ol type="1">
<li>Scripts. To set the material properties (i.e. type of Hlms to use: PBS, Toon shading, GUI; what textures, diffuse colour, roughness, etc). <b>You currently have to do this from C++.</b> Everybody will be using this part.</li>
<li>Shader template. The Hlms takes a couple hand-written glsl/hlsl files as template and then adapts it to fit the needs on the fly (i.e. if the mesh doesn’t contain skeleton, the bit of code pertaining to skeletal animation is stripped from the vertex shader). The Hlms provides a simple preprocessor to deal with this entirely within from the template, but you’re not forced to use it. Here’s a simple example of the preprocessor. I won’t be explaining the main keywords today. Advanced users will probably want to modify these files (or write some of their own) to fit their custom needs.</li>
<li>C++ classes implementation. The C++ takes care of picking the shader templates and manipulating them before compiling; and most importantly it feeds the shaders with uniform/constans data and sets the textures that are being in use. It is extremely flexible, powerful, efficient and scalable, but it’s harder to use than good ol’ Materials because those used to be data-driven: there are no AutoParamsSource here. Want the view matrix? You better grab it from the camera when the scene pass is about to start, and then pass it yourself to the shader. This is very powerful, because in D3D11/GL3+ you can just set the uniform buffer with the view matrix just once for the entire frame, and thus have multiple uniforms buffers sorted by update frequency. Very advanced user will be using messing with this part.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Material scripts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.x do not yet support the HLMS - you must use the C++ API. e.g. <a class="el" href="class_ogre_1_1_pbs_material.html">Ogre::PbsMaterial</a>.</dd></dl>
<p>Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.</p>
<p>For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.</p>
<p>It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.</p>
<h1><a class="anchor" id="materials"></a>
Compared to classical materials</h1>
<p>Materials are still useful for:</p>
<ul>
<li>Quick iteration. You need to write a shader, just define the material and start coding. Why would you deal with the template’s syntax or a C++ module when you can just write a script and start coding?. The HLMS though comes with a Command line tool to know how your template translates into a final shader (which is very handy for iteration, it’s fast, and will check for syntax errors!), but it’s most useful when you want to write your own C++ module or change the template, not when you want to just experiment. Besides, old timers are used to writing materials.</li>
<li>Postprocessing effects. Materials are much better suited for this. Materials are data driven, easy to write. Postprocessing FXs don’t need an awful lot of permutations (i.e. having to deal with shadow mapping, instancing, skeleton animation, facial animation). And they’re at no performance disadvantage compared to HLMS: Each FX is a fullscreen pass that needs different shaders, different textures, its own uniforms. Basically, API overhead we can’t optimize. But it doesn’t matter much either, because it’s not like there are 100 fullscreen passes. Usually there’s less than 10.</li>
</ul>
<h1><a class="anchor" id="data"></a>
Material parameters are stored in “Blocks”</h1>
<p>You could be thinking the reason I came up with these two is to fit with D3D11′s grand scheme of things while being compatible with OpenGL. But that’s a half truth and an awesome side effect. I’ve been developing the Hlms using OpenGL this whole time.</p>
<p>An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and they’re right about that.</p>
<p>However, there are big advantages for using blocks:</p>
<ol type="1">
<li>Many materials in practice share the same Macro- &amp; Blendblock parameters. In an age where we want many 3D primitives with the same shader but slightly different parameters like texture, colour, or roughness (which equals, a different material) having these settings repeated per material wastes a lot of memory space… and a lot of bandwidth (and wastes cache space). <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 is bandwidth bound, so having all materials share the same pointer to the same Macroblock can potentially save a lot of bandwidth, and be friendlier to the cache at the same time.This stays true whether we use D3D11, D3D12, OpenGL, GL ES 2, or Mantle.</li>
<li>Sorting by Macroblock is a lot easier (and faster) than sorting by its individual parameters: when preparing the hash used for sorting, it’s much easier to just do (every frame, per object) <code>hash |= (macroblock-&gt;getId() &lt;&lt; bits) &amp; mask</code> than to do: <code>hash =| m-&gt;depth_check | m-&gt;depthWrite &lt;&lt; 1 | m-&gt;depthBias &lt;&lt; 2 | m-&gt;depth_slope_bias &lt;&lt; 3 | m-&gt;cullMode &lt;&lt; 18 | ... ;</code> We also need a lot more bits we can’t afford. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 imposes a limit on the amount of live Macroblocks you can have at the same time; as we run out of hashing space (by the way, D3D11 has its own limit). It operates around the idea that most setting combinations won’t be used in practice.</li>
</ol>
<p>Of course it’s not perfect, it can’t fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); you’ll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. We’re aiming the general use case.</p>
<p>These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since I’m not used to driver development. However from an engine perspective, blocks make sense.</p>
<h2><a class="anchor" id="toc52"></a>
Datablocks</h2>
<p>We’re introducing the concept of Datablocks. A Datablock is a “material” from the user’s perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.</p>
<div class="image">
<object type="image/svg+xml" data="hlms_blocks.svg">hlms_blocks.svg</object>
</div>
<p>The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.</p>
<dl class="section note"><dt>Note</dt><dd>Macroblocks and Blendblocks are not available in 1.x - use <a class="el" href="class_ogre_1_1_pass.html#ae454faee87f8cb0b8540810e48118788" title="Sets whether or not this pass renders with depth-buffer checking on or not. ">Ogre::Pass::setDepthCheckEnabled</a> etc. as usual, to change the respective properties</dd></dl>
<h1><a class="anchor" id="toc69"></a>
Hlms templates</h1>
<p>The Hlms will parse the template files from the template folder according to the following rules:</p>
<ol type="1">
<li>The files with the names "VertexShader_vs", "PixelShader_ps", "GeometryShader_gs", "HullShader_hs", "DomainShader_ds" will be fully parsed and compiled into the shader. If an implementation only provides "VertexShader_vs.glslt", "PixelShader_ps.glslt"; only the vertex and pixel shaders for OpenGL will be created. There will be no geometry or tesellation shaders.</li>
<li>The files that contain the string "_piece_vs" in their filenames will be parsed only for collecting pieces (more on pieces later). Likewise, the words "_piece_ps", "_piece_gs", "_piece_hs", "_piece_ds” correspond to the pieces for their respective shader stages. Note that you can concatenate, thus "MyUtilities_piece_vs_piece_ps.glslt” will be collected both in the vertex and pixel shader stages.</li>
</ol>
<p>The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.</p>
<h2><a class="anchor" id="preproc"></a>
The Hlms preprocessor</h2>
<p>The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.</p>
<p>For example </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can't evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can't check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable “IncludeLightingEquals2” and check whether it's non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can't see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you'll depend on the driver implementation having a good macro preprocessor.</p>
<h2><a class="anchor" id="syntax"></a>
Preprocessor syntax</h2>
<p>The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:</p>
<ul>
<li>@property</li>
<li>@foreach</li>
<li>@counter</li>
<li>@value</li>
<li>@set add sub mul div mod min max</li>
<li>@piece</li>
<li>@insertpiece</li>
<li>@pset padd psub pmul pdiv pmod pmin pmax</li>
</ul>
<h3>@property( expression )</h3>
<p>Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.</p>
<p>The logical operands &amp;&amp; || ! are valid.</p>
<p>Examples: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: </p><div class="fragment"><div class="line">hasLights != 0                              hasLights == 0</div><div class="line">diffuse = surfaceDiffuse * lightDiffuse;   diffuse = surfaceDiffuse ;</div></div><!-- fragment --><h3>@foreach( scopedVar, count, [start] )</h3>
<p>Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.</p>
<ul>
<li>scopedVar is a variable that can be used to print the current iteration of the loop while inside the block. i.e. “@scopedVar” will be converted into a number in the range [start; count)</li>
<li>count The number of times to repeat the loop (if start = 0). Count can read variables.</li>
<li>start Optional. Allows to start from a value different than 0. Start can read variables.</li>
</ul>
<p>Newlines are very important, as they will be printed with the loop.</p>
<p>Examples: </p><table class="doxtable">
<tr>
<th>Expression </th><th>Output  </th></tr>
<tr>
<td>@foreach( 4, n ) <br />
&emsp; @n@end </td><td><br />
0<br />
1<br />
2<br />
3 </td></tr>
<tr>
<td>@foreach( 4, n ) @n@end </td><td>0 1 2 3 </td></tr>
<tr>
<td>@foreach( 4, n )<br />
&emsp;@n<br />
@end </td><td><br />
0<br />
<br />
1<br />
<br />
2<br />
<br />
3<br />
 </td></tr>
<tr>
<td>@foreach( 4, n, 2 ) @n@end </td><td>2 3 </td></tr>
<tr>
<td>@pset( myStartVar, 1 )<br />
@pset( myCountVar, 3 )<br />
@foreach( myStartVar, n, myCountVar )<br />
&emsp;@n@end </td><td>1<br />
2 </td></tr>
<tr>
<td>@foreach( 2, n )<br />
&emsp;@insertpiece( pieceName@n )@end </td><td>@insertpiece( pieceName0 )<br />
 @insertpiece( pieceName1 ) </td></tr>
</table>
<blockquote class="doxtable">
<p><b>Attention #1!</b></p>
<p>Don't use the common letter i for the loop counter. It will conflict with other keywords.</p>
<p>i.e. “@foreach( 1, i )@insertpiece( pieceName )@end” will print “0nsertpiece( pieceName )” which is probably not what you intended.</p>
<p><b>Attention #2!</b></p>
<p>foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.</p>
<p>i.e. The following code will not work:</p>
<div class="fragment"><div class="line">@pset( myVar, 1 )</div><div class="line"></div><div class="line">@<span class="keywordflow">foreach</span>( 2, n )</div><div class="line"></div><div class="line"><span class="comment">//Code</span></div><div class="line"></div><div class="line">@psub( myVar, 1 ) <span class="comment">//Decrement myVar on each loop</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( myVar )</div><div class="line"></div><div class="line"><span class="comment">//Code that shouldn&#39;t be printed in the last iteration</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>Because psub will be evaluated before expanding the foreach. </p>
</blockquote>
<h3>@counter( variable )</h3>
<p>Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.</p>
<p>Examples: </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@counter( myVar )   1</div><div class="line"></div><div class="line">@counter( myVar )   2</div></div><!-- fragment --><h3>@value( variable )</h3>
<p>Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@value( myVar )     1</div><div class="line"></div><div class="line">@value( myVar )     1</div></div><!-- fragment --><h3>@set add sub mul div mod min max</h3>
<p>Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.</p>
<p>Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c</p>
<p>Useful in combination with @counter and @value</p>
<table class="doxtable">
<tr>
<th>Expression </th><th>Output </th><th>Math  </th></tr>
<tr>
<td>@set( myVar, 1 ) <br />
 @value( myVar ) </td><td>1 </td><td>myVar = 1 </td></tr>
<tr>
<td>@add( myVar, 5 )<br />
 @value( myVar ) </td><td>6 </td><td>myVar = 1 + 5 </td></tr>
<tr>
<td>@div( myVar, 2 ) <br />
 @value( myVar ) </td><td>3 </td><td>myVar = 6 / 2 </td></tr>
<tr>
<td>@mul( myVar, myVar )<br />
 @value( myVar ) </td><td>9 </td><td>myVar = 3 * 3 </td></tr>
<tr>
<td>@mod( myVar, 5 ) <br />
 @value( myVar ) </td><td>4 </td><td>myVar = 9 % 5 </td></tr>
<tr>
<td>@add( myVar, 1, 1 ) <br />
 @value( myVar ) </td><td>2 </td><td>myVar = 1 + 1 </td></tr>
</table>
<h3>@piece( nameOfPiece )</h3>
<p>Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won't be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                        Output</div><div class="line"></div><div class="line">@piece( VertexTransform )         </div><div class="line"></div><div class="line">outPos = worldViewProj * inPos   </div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><h3>@insertpiece( nameOfPiece )</h3>
<p>Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                                                     Output</div><div class="line"></div><div class="line">@piece( VertexTransform )outPos = worldViewProj * inPos@end   void main()</div><div class="line"></div><div class="line">void main()                                                    {</div><div class="line"></div><div class="line">{                                                              outPos = worldViewProj * inPos</div><div class="line"></div><div class="line">@insertpiece( VertexTransform )                                }</div><div class="line"></div><div class="line">@insertpiece( InexistentPiece )                                </div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h3>@pset padd psub pmul pdiv pmod pmin pmax</h3>
<p>Analogous to <a href="#toc304"><em>the family of math functions without the 'p' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.</p>
<p>i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )</p>
<p>One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.</p>
<p>If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.</p>
<h1><a class="anchor" id="shaders"></a>
Creation of shaders</h1>
<p>There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:</p>
<ol type="1">
<li>The Datablock/Material. Does it have Normal maps? Then include code to sample the normal map and affect the lighting calculations. Does it have a diffuse map? If not, avoid sampling the diffuse map and multiplying it against the diffuse colour, etc.</li>
<li>The Mesh. Is it skeletally animated? Then include skeletal animation code. How many blend weights? Modify the skeletal animation code appropiately. It doesn't have tangents? Then skip the normal map defined in the material. And so on.</li>
</ol>
<p>When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.</p>
<p>If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).</p>
<p>The following graph summarizes the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_hash.svg">hlms_hash.svg</object>
</div>
<p>Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a “<a href="#toc567"><em>pass hash</em></a>” instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).</p>
<p>While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_caching.svg">hlms_caching.svg</object>
</div>
<h1><a class="anchor" id="cpp"></a>
C++ interaction with shader templates</h1>
<p>Note: This section is relevant to those seeking to write their own Hlms implementation.</p>
<p>C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set “key” to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod</p>
<p>To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.</p>
<p>The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.</p>
<p>In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.</p>
<p>Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.</p>
<p>For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.</p>
<p>The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.</p>
<h2>Common conventions</h2>
<p>Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.</p>
<p>Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.</p>
<p>For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.</p>
<p>Properties in underscore_case are set from C++; propierties in camelCase are set from the template.</p>
<p>Propierties and pieces starting with 'custom_' are for user customizations of the template</p>
<p>TBD</p>
<h2>Disabling a stage</h2>
<p>By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.</p>
<p>Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.</p>
<h1><a class="anchor" id="customization"></a>
Customization</h1>
<p>In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.</p>
<p>Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.</p>
<p>Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.</p>
<p>There are different levels in which an Hlms implementation can be customized:</p>
<ol type="1">
<li>Using a library, see <a href="#toc574"><em>Hlms Initialization</em></a>. pass a set of piece files in a folder by pushing the folder to ArchiveVec. The files in that folder will be parsed first, in order (archiveVec[0] then archiveVec[1], … archiveVec[N-1]); which will let you define your own pieces to insert code into the default template (see the the table at the end). You can also do clever tricky things to avoid dealing with C++ code at all even if there are no 'custom_' pieces for it. For example, you can write the following code to override the BRDF declarations and provide a custom BRDF: <div class="fragment"><div class="line"><span class="comment">//Disable all known BRDFs that the implementation may enable</span></div><div class="line"></div><div class="line">@pset( BRDF_CookTorrance, 0 )</div><div class="line"></div><div class="line">@pset( BRDF_Default, 0 )</div><div class="line"></div><div class="line">@piece( DeclareBRDF )</div><div class="line"></div><div class="line"><span class="comment">// Your BRDF code declaration here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --></li>
</ol>
<ol type="1">
<li>Via listener, through HlmsListener. This allows you to have access to the buffer pass to fill extra information; or bind extra buffers to the shader.</li>
<li>Overload HlmsPbs. Useful for overriding only specific parts, or adding new functionality that requires storing extra information in a datablock (e.g. overload HlmsPbsDatablock to add more variables, and then overload HlmsPbs::createDatablockImpl to create these custom datablocks)</li>
<li>Directly modify HlmsPbs, HlmsPbsDatablock and the template. <table class="doxtable">
<tr>
<th>Variable </th><th>Description  </th></tr>
<tr>
<td>custom_passBuffer </td><td>Piece where users can add extra information for the pass buffer (only useful if the user is using HlmsListener or overloaded HlmsPbs. </td></tr>
<tr>
<td>custom_VStoPS </td><td>Piece where users can add more interpolants for passing data from the vertex to the pixel shader. </td></tr>
<tr>
<td>custom_vs_attributes </td><td>Custom vertex shader attributes in the Vertex Shader (i.e. a special texcoord, etc). </td></tr>
<tr>
<td>custom_vs_uniformDeclaration </td><td>Data declaration (textures, texture buffers, uniform buffers) in the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_posExecution </td><td>Executed after all code from the Vertex Shader has been performed. </td></tr>
<tr>
<td>custom_ps_uniformDeclaration </td><td>Same as custom_vs_uniformDeclaration, but for the Pixel Shader </td></tr>
<tr>
<td>custom_ps_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Pixel Shader. </td></tr>
<tr>
<td>custom_ps_posMaterialLoad </td><td>Executed right after loading material data; and before anything else. May not get executed if there is no relevant material data (i.e. doesn't have normals or QTangents for lighting calculation) </td></tr>
<tr>
<td>custom_ps_preLights </td><td>Executed right before any light (i.e. to perform your own ambient / global illumination pass). All relevant texture data should be loaded by now. </td></tr>
<tr>
<td>custom_ps_posExecution </td><td>Executed after all code from the Pixel Shader has been performed. </td></tr>
</table>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: HLMS: High Level Material System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hlms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HLMS: High Level Material System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#components">The three components</a></li>
<li class="level1"><a href="#materials">Compared to classical materials</a></li>
<li class="level1"><a href="#data">Material parameters are stored in “Blocks”</a><ul><li class="level2"><a href="#toc52">Datablocks</a></li>
</ul>
</li>
<li class="level1"><a href="#toc69">Hlms templates</a><ul><li class="level2"><a href="#preproc">The Hlms preprocessor</a></li>
<li class="level2"><a href="#syntax">Preprocessor syntax</a></li>
</ul>
</li>
<li class="level1"><a href="#shaders">Creation of shaders</a></li>
<li class="level1"><a href="#cpp">C++ interaction with shader templates</a></li>
<li class="level1"><a href="#customization">Customization</a></li>
</ul>
</div>
<div class="textblock"><p>This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.</p>
<p>Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.</p>
<p>Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.</p>
<p>But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.</p>
<p>Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.</p>
<h1><a class="anchor" id="components"></a>
The three components</h1>
<div class="image">
<object type="image/svg+xml" data="hlms_components.svg">hlms_components.svg</object>
</div>
<ol type="1">
<li>Scripts. To set the material properties (i.e. type of Hlms to use: PBS, Toon shading, GUI; what textures, diffuse colour, roughness, etc). <b>You currently have to do this from C++.</b> Everybody will be using this part.</li>
<li>Shader template. The Hlms takes a couple hand-written glsl/hlsl files as template and then adapts it to fit the needs on the fly (i.e. if the mesh doesn’t contain skeleton, the bit of code pertaining to skeletal animation is stripped from the vertex shader). The Hlms provides a simple preprocessor to deal with this entirely within from the template, but you’re not forced to use it. Here’s a simple example of the preprocessor. I won’t be explaining the main keywords today. Advanced users will probably want to modify these files (or write some of their own) to fit their custom needs.</li>
<li>C++ classes implementation. The C++ takes care of picking the shader templates and manipulating them before compiling; and most importantly it feeds the shaders with uniform/constans data and sets the textures that are being in use. It is extremely flexible, powerful, efficient and scalable, but it’s harder to use than good ol’ Materials because those used to be data-driven: there are no AutoParamsSource here. Want the view matrix? You better grab it from the camera when the scene pass is about to start, and then pass it yourself to the shader. This is very powerful, because in D3D11/GL3+ you can just set the uniform buffer with the view matrix just once for the entire frame, and thus have multiple uniforms buffers sorted by update frequency. Very advanced user will be using messing with this part.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Material scripts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.x do not yet support the HLMS - you must use the C++ API. e.g. <a class="el" href="class_ogre_1_1_pbs_material.html">Ogre::PbsMaterial</a>.</dd></dl>
<p>Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.</p>
<p>For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.</p>
<p>It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.</p>
<h1><a class="anchor" id="materials"></a>
Compared to classical materials</h1>
<p>Materials are still useful for:</p>
<ul>
<li>Quick iteration. You need to write a shader, just define the material and start coding. Why would you deal with the template’s syntax or a C++ module when you can just write a script and start coding?. The HLMS though comes with a Command line tool to know how your template translates into a final shader (which is very handy for iteration, it’s fast, and will check for syntax errors!), but it’s most useful when you want to write your own C++ module or change the template, not when you want to just experiment. Besides, old timers are used to writing materials.</li>
<li>Postprocessing effects. Materials are much better suited for this. Materials are data driven, easy to write. Postprocessing FXs don’t need an awful lot of permutations (i.e. having to deal with shadow mapping, instancing, skeleton animation, facial animation). And they’re at no performance disadvantage compared to HLMS: Each FX is a fullscreen pass that needs different shaders, different textures, its own uniforms. Basically, API overhead we can’t optimize. But it doesn’t matter much either, because it’s not like there are 100 fullscreen passes. Usually there’s less than 10.</li>
</ul>
<h1><a class="anchor" id="data"></a>
Material parameters are stored in “Blocks”</h1>
<p>You could be thinking the reason I came up with these two is to fit with D3D11′s grand scheme of things while being compatible with OpenGL. But that’s a half truth and an awesome side effect. I’ve been developing the Hlms using OpenGL this whole time.</p>
<p>An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and they’re right about that.</p>
<p>However, there are big advantages for using blocks:</p>
<ol type="1">
<li>Many materials in practice share the same Macro- &amp; Blendblock parameters. In an age where we want many 3D primitives with the same shader but slightly different parameters like texture, colour, or roughness (which equals, a different material) having these settings repeated per material wastes a lot of memory space… and a lot of bandwidth (and wastes cache space). <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 is bandwidth bound, so having all materials share the same pointer to the same Macroblock can potentially save a lot of bandwidth, and be friendlier to the cache at the same time.This stays true whether we use D3D11, D3D12, OpenGL, GL ES 2, or Mantle.</li>
<li>Sorting by Macroblock is a lot easier (and faster) than sorting by its individual parameters: when preparing the hash used for sorting, it’s much easier to just do (every frame, per object) <code>hash |= (macroblock-&gt;getId() &lt;&lt; bits) &amp; mask</code> than to do: <code>hash =| m-&gt;depth_check | m-&gt;depthWrite &lt;&lt; 1 | m-&gt;depthBias &lt;&lt; 2 | m-&gt;depth_slope_bias &lt;&lt; 3 | m-&gt;cullMode &lt;&lt; 18 | ... ;</code> We also need a lot more bits we can’t afford. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 imposes a limit on the amount of live Macroblocks you can have at the same time; as we run out of hashing space (by the way, D3D11 has its own limit). It operates around the idea that most setting combinations won’t be used in practice.</li>
</ol>
<p>Of course it’s not perfect, it can’t fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); you’ll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. We’re aiming the general use case.</p>
<p>These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since I’m not used to driver development. However from an engine perspective, blocks make sense.</p>
<h2><a class="anchor" id="toc52"></a>
Datablocks</h2>
<p>We’re introducing the concept of Datablocks. A Datablock is a “material” from the user’s perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.</p>
<div class="image">
<object type="image/svg+xml" data="hlms_blocks.svg">hlms_blocks.svg</object>
</div>
<p>The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.</p>
<dl class="section note"><dt>Note</dt><dd>Macroblocks and Blendblocks are not available in 1.x - use <a class="el" href="class_ogre_1_1_pass.html#ae454faee87f8cb0b8540810e48118788" title="Sets whether or not this pass renders with depth-buffer checking on or not. ">Ogre::Pass::setDepthCheckEnabled</a> etc. as usual, to change the respective properties</dd></dl>
<h1><a class="anchor" id="toc69"></a>
Hlms templates</h1>
<p>The Hlms will parse the template files from the template folder according to the following rules:</p>
<ol type="1">
<li>The files with the names "VertexShader_vs", "PixelShader_ps", "GeometryShader_gs", "HullShader_hs", "DomainShader_ds" will be fully parsed and compiled into the shader. If an implementation only provides "VertexShader_vs.glslt", "PixelShader_ps.glslt"; only the vertex and pixel shaders for OpenGL will be created. There will be no geometry or tesellation shaders.</li>
<li>The files that contain the string "_piece_vs" in their filenames will be parsed only for collecting pieces (more on pieces later). Likewise, the words "_piece_ps", "_piece_gs", "_piece_hs", "_piece_ds” correspond to the pieces for their respective shader stages. Note that you can concatenate, thus "MyUtilities_piece_vs_piece_ps.glslt” will be collected both in the vertex and pixel shader stages.</li>
</ol>
<p>The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.</p>
<h2><a class="anchor" id="preproc"></a>
The Hlms preprocessor</h2>
<p>The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.</p>
<p>For example </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can't evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can't check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable “IncludeLightingEquals2” and check whether it's non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can't see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you'll depend on the driver implementation having a good macro preprocessor.</p>
<h2><a class="anchor" id="syntax"></a>
Preprocessor syntax</h2>
<p>The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:</p>
<ul>
<li>@property</li>
<li>@foreach</li>
<li>@counter</li>
<li>@value</li>
<li>@set add sub mul div mod min max</li>
<li>@piece</li>
<li>@insertpiece</li>
<li>@pset padd psub pmul pdiv pmod pmin pmax</li>
</ul>
<h3>@property( expression )</h3>
<p>Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.</p>
<p>The logical operands &amp;&amp; || ! are valid.</p>
<p>Examples: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: </p><div class="fragment"><div class="line">hasLights != 0                              hasLights == 0</div><div class="line">diffuse = surfaceDiffuse * lightDiffuse;   diffuse = surfaceDiffuse ;</div></div><!-- fragment --><h3>@foreach( scopedVar, count, [start] )</h3>
<p>Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.</p>
<ul>
<li>scopedVar is a variable that can be used to print the current iteration of the loop while inside the block. i.e. “@scopedVar” will be converted into a number in the range [start; count)</li>
<li>count The number of times to repeat the loop (if start = 0). Count can read variables.</li>
<li>start Optional. Allows to start from a value different than 0. Start can read variables.</li>
</ul>
<p>Newlines are very important, as they will be printed with the loop.</p>
<p>Examples: </p><table class="doxtable">
<tr>
<th>Expression </th><th>Output  </th></tr>
<tr>
<td>@foreach( 4, n ) <br />
&emsp; @n@end </td><td><br />
0<br />
1<br />
2<br />
3 </td></tr>
<tr>
<td>@foreach( 4, n ) @n@end </td><td>0 1 2 3 </td></tr>
<tr>
<td>@foreach( 4, n )<br />
&emsp;@n<br />
@end </td><td><br />
0<br />
<br />
1<br />
<br />
2<br />
<br />
3<br />
 </td></tr>
<tr>
<td>@foreach( 4, n, 2 ) @n@end </td><td>2 3 </td></tr>
<tr>
<td>@pset( myStartVar, 1 )<br />
@pset( myCountVar, 3 )<br />
@foreach( myStartVar, n, myCountVar )<br />
&emsp;@n@end </td><td>1<br />
2 </td></tr>
<tr>
<td>@foreach( 2, n )<br />
&emsp;@insertpiece( pieceName@n )@end </td><td>@insertpiece( pieceName0 )<br />
 @insertpiece( pieceName1 ) </td></tr>
</table>
<blockquote class="doxtable">
<p><b>Attention #1!</b></p>
<p>Don't use the common letter i for the loop counter. It will conflict with other keywords.</p>
<p>i.e. “@foreach( 1, i )@insertpiece( pieceName )@end” will print “0nsertpiece( pieceName )” which is probably not what you intended.</p>
<p><b>Attention #2!</b></p>
<p>foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.</p>
<p>i.e. The following code will not work:</p>
<div class="fragment"><div class="line">@pset( myVar, 1 )</div><div class="line"></div><div class="line">@<span class="keywordflow">foreach</span>( 2, n )</div><div class="line"></div><div class="line"><span class="comment">//Code</span></div><div class="line"></div><div class="line">@psub( myVar, 1 ) <span class="comment">//Decrement myVar on each loop</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( myVar )</div><div class="line"></div><div class="line"><span class="comment">//Code that shouldn&#39;t be printed in the last iteration</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>Because psub will be evaluated before expanding the foreach. </p>
</blockquote>
<h3>@counter( variable )</h3>
<p>Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.</p>
<p>Examples: </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@counter( myVar )   1</div><div class="line"></div><div class="line">@counter( myVar )   2</div></div><!-- fragment --><h3>@value( variable )</h3>
<p>Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@value( myVar )     1</div><div class="line"></div><div class="line">@value( myVar )     1</div></div><!-- fragment --><h3>@set add sub mul div mod min max</h3>
<p>Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.</p>
<p>Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c</p>
<p>Useful in combination with @counter and @value</p>
<table class="doxtable">
<tr>
<th>Expression </th><th>Output </th><th>Math  </th></tr>
<tr>
<td>@set( myVar, 1 ) <br />
 @value( myVar ) </td><td>1 </td><td>myVar = 1 </td></tr>
<tr>
<td>@add( myVar, 5 )<br />
 @value( myVar ) </td><td>6 </td><td>myVar = 1 + 5 </td></tr>
<tr>
<td>@div( myVar, 2 ) <br />
 @value( myVar ) </td><td>3 </td><td>myVar = 6 / 2 </td></tr>
<tr>
<td>@mul( myVar, myVar )<br />
 @value( myVar ) </td><td>9 </td><td>myVar = 3 * 3 </td></tr>
<tr>
<td>@mod( myVar, 5 ) <br />
 @value( myVar ) </td><td>4 </td><td>myVar = 9 % 5 </td></tr>
<tr>
<td>@add( myVar, 1, 1 ) <br />
 @value( myVar ) </td><td>2 </td><td>myVar = 1 + 1 </td></tr>
</table>
<h3>@piece( nameOfPiece )</h3>
<p>Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won't be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                        Output</div><div class="line"></div><div class="line">@piece( VertexTransform )         </div><div class="line"></div><div class="line">outPos = worldViewProj * inPos   </div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><h3>@insertpiece( nameOfPiece )</h3>
<p>Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                                                     Output</div><div class="line"></div><div class="line">@piece( VertexTransform )outPos = worldViewProj * inPos@end   void main()</div><div class="line"></div><div class="line">void main()                                                    {</div><div class="line"></div><div class="line">{                                                              outPos = worldViewProj * inPos</div><div class="line"></div><div class="line">@insertpiece( VertexTransform )                                }</div><div class="line"></div><div class="line">@insertpiece( InexistentPiece )                                </div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h3>@pset padd psub pmul pdiv pmod pmin pmax</h3>
<p>Analogous to <a href="#toc304"><em>the family of math functions without the 'p' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.</p>
<p>i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )</p>
<p>One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.</p>
<p>If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.</p>
<h1><a class="anchor" id="shaders"></a>
Creation of shaders</h1>
<p>There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:</p>
<ol type="1">
<li>The Datablock/Material. Does it have Normal maps? Then include code to sample the normal map and affect the lighting calculations. Does it have a diffuse map? If not, avoid sampling the diffuse map and multiplying it against the diffuse colour, etc.</li>
<li>The Mesh. Is it skeletally animated? Then include skeletal animation code. How many blend weights? Modify the skeletal animation code appropiately. It doesn't have tangents? Then skip the normal map defined in the material. And so on.</li>
</ol>
<p>When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.</p>
<p>If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).</p>
<p>The following graph summarizes the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_hash.svg">hlms_hash.svg</object>
</div>
<p>Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a “<a href="#toc567"><em>pass hash</em></a>” instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).</p>
<p>While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_caching.svg">hlms_caching.svg</object>
</div>
<h1><a class="anchor" id="cpp"></a>
C++ interaction with shader templates</h1>
<p>Note: This section is relevant to those seeking to write their own Hlms implementation.</p>
<p>C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set “key” to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod</p>
<p>To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.</p>
<p>The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.</p>
<p>In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.</p>
<p>Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.</p>
<p>For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.</p>
<p>The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.</p>
<h2>Common conventions</h2>
<p>Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.</p>
<p>Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.</p>
<p>For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.</p>
<p>Properties in underscore_case are set from C++; propierties in camelCase are set from the template.</p>
<p>Propierties and pieces starting with 'custom_' are for user customizations of the template</p>
<p>TBD</p>
<h2>Disabling a stage</h2>
<p>By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.</p>
<p>Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.</p>
<h1><a class="anchor" id="customization"></a>
Customization</h1>
<p>In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.</p>
<p>Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.</p>
<p>Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.</p>
<p>There are different levels in which an Hlms implementation can be customized:</p>
<ol type="1">
<li>Using a library, see <a href="#toc574"><em>Hlms Initialization</em></a>. pass a set of piece files in a folder by pushing the folder to ArchiveVec. The files in that folder will be parsed first, in order (archiveVec[0] then archiveVec[1], … archiveVec[N-1]); which will let you define your own pieces to insert code into the default template (see the the table at the end). You can also do clever tricky things to avoid dealing with C++ code at all even if there are no 'custom_' pieces for it. For example, you can write the following code to override the BRDF declarations and provide a custom BRDF: <div class="fragment"><div class="line"><span class="comment">//Disable all known BRDFs that the implementation may enable</span></div><div class="line"></div><div class="line">@pset( BRDF_CookTorrance, 0 )</div><div class="line"></div><div class="line">@pset( BRDF_Default, 0 )</div><div class="line"></div><div class="line">@piece( DeclareBRDF )</div><div class="line"></div><div class="line"><span class="comment">// Your BRDF code declaration here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --></li>
</ol>
<ol type="1">
<li>Via listener, through HlmsListener. This allows you to have access to the buffer pass to fill extra information; or bind extra buffers to the shader.</li>
<li>Overload HlmsPbs. Useful for overriding only specific parts, or adding new functionality that requires storing extra information in a datablock (e.g. overload HlmsPbsDatablock to add more variables, and then overload HlmsPbs::createDatablockImpl to create these custom datablocks)</li>
<li>Directly modify HlmsPbs, HlmsPbsDatablock and the template. <table class="doxtable">
<tr>
<th>Variable </th><th>Description  </th></tr>
<tr>
<td>custom_passBuffer </td><td>Piece where users can add extra information for the pass buffer (only useful if the user is using HlmsListener or overloaded HlmsPbs. </td></tr>
<tr>
<td>custom_VStoPS </td><td>Piece where users can add more interpolants for passing data from the vertex to the pixel shader. </td></tr>
<tr>
<td>custom_vs_attributes </td><td>Custom vertex shader attributes in the Vertex Shader (i.e. a special texcoord, etc). </td></tr>
<tr>
<td>custom_vs_uniformDeclaration </td><td>Data declaration (textures, texture buffers, uniform buffers) in the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_posExecution </td><td>Executed after all code from the Vertex Shader has been performed. </td></tr>
<tr>
<td>custom_ps_uniformDeclaration </td><td>Same as custom_vs_uniformDeclaration, but for the Pixel Shader </td></tr>
<tr>
<td>custom_ps_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Pixel Shader. </td></tr>
<tr>
<td>custom_ps_posMaterialLoad </td><td>Executed right after loading material data; and before anything else. May not get executed if there is no relevant material data (i.e. doesn't have normals or QTangents for lighting calculation) </td></tr>
<tr>
<td>custom_ps_preLights </td><td>Executed right before any light (i.e. to perform your own ambient / global illumination pass). All relevant texture data should be loaded by now. </td></tr>
<tr>
<td>custom_ps_posExecution </td><td>Executed after all code from the Pixel Shader has been performed. </td></tr>
</table>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Trays GUI System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('trays.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Trays GUI System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#trays-1">Trays</a></li>
<li class="level1"><a href="#traymanager">TrayManager</a></li>
<li class="level1"><a href="#widgets">Widgets</a></li>
<li class="level1"><a href="#special-widgets">Special Widgets</a></li>
<li class="level1"><a href="#tray-listener">TrayListener</a></li>
<li class="level1"><a href="#things-to-try">Things to Try</a></li>
</ul>
</div>
<div class="textblock"><p>Ever wanted really simple GUI controls for your sample? Don't want to write one from scratch, but CEGUI's just a little too much? The Trays system was created to address this issue. It's a simple GUI system based on the OGRE Overlay system and designed just for samples. Because it's simple, you're not going to be able to skin it or build very unique interfaces, but you'll also find it much easier to use. The entire system is based on the OGRE Overlay system.</p>
<h1><a class="anchor" id="trays-1"></a>
Trays</h1>
<p>Why trays? The concept of trays is central to the system in that it removes the need for the GUI designer (you) to calculate or specify positional coordinates of any kind. Think about the widget locations in a typical GUI. They are almost always in any of the four corners, along any of the four edges or, on the rare occasion, in the center of the screen. In Trays, there are nine "trays", one in each of the locations previously mentioned. When you create a widget, you specify one of these nine locations, and the widget will be added to the tray at that location. Your widget will be added directly beneath the last widget in that tray. When you add a widget to a tray, the tray grows in size. Trays along the top of the screen grow downward, Trays along the bottom grow upward, and the trays in the middle row grow vertically in both directions. Visually, the trays are semi-transparent panels that fit the widgets they contain. Only non-empty trays are visible. If this is hard to visualise, don't worry, here's a picture to help you out. </p><div class="image">
<img src="Gui2.jpg" alt="Gui2.jpg"/>
</div>
<h1><a class="anchor" id="traymanager"></a>
TrayManager</h1>
<p>To use Trays, you have to create an TrayManager. This is the class through which you will create and manage all your widgets, manipulate the cursor, change the backdrop image, adjust tray properties, pop up dialogs, show/hide the loading bar, etc. You can have multiple tray managers in one application. For example, the OGRE Sample Browser uses its own tray manager and hides it when a sample is running, and the SDK samples also have their own tray managers, which are hidden when the samples are paused by the browser. The TrayManager requires "Trays.zip", so you can only create it after loading that resource. Also, make sure you're using the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> namespace (Trays is part of the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Samples Framework). Create your tray manager like so: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>* mTrayMgr = <span class="keyword">new</span> <a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>(<span class="stringliteral">&quot;InterfaceName&quot;</span>, mWindow, <span class="keyword">this</span>);</div></div><!-- fragment --><p> You must pass in a name for your interface, an <code><a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a></code> and an <code><a class="el" href="class_ogre_bites_1_1_tray_listener.html" title="Listener class for responding to tray events. ">OgreBites::TrayListener</a></code>. You can extend your sample or sample context to be a tray listener. Destroy your tray manager like so: </p><div class="fragment"><div class="line"><span class="keyword">delete</span> mTrayMgr;</div><div class="line">mTrayMgr = 0;</div></div><!-- fragment --><p> Once you have your tray manager, make sure you relay your OIS events to it. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> mousePressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseDown(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseReleased(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseUp(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseMoved(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_motion_event.html">OgreBites::MouseMotionEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseMove(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> The injection methods return true if the event was relevant to the tray manager, and should not be processed again by you. For example, if you click a button that is over an interactive part of your scene, you want the button to be pressed, but you don't want the scene interaction to take place. So the injection methods double as filters for your mouse events.</p>
<p>You're now free to create widgets! Try adding a button to the top-left tray: </p><div class="fragment"><div class="line">Button* b = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">createButton</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530afe04de8736168ab0dd6e7938e679c292">TL_TOPLEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <span class="stringliteral">&quot;Click Me!&quot;</span>);</div></div><!-- fragment --><p> TrayManager is a huge class, and you can do tons of things with it. For some examples, see the Things to Try section below.</p>
<h2>The Cursor</h2>
<p>The cursor has three parts in the Trays system: The layer it moves around in Overlay, the container which positions the cursor (OverlayContainer), and the cursor image, which is a child of the container (OverlayElement). When hiding/showing the cursor, the entire cursor layer is hidden/shown. The top left corner of the cursor container is used as the hotspot of the cursor. By positioning the cursor image relative to the cursor container, you can basically decide which part of the cursor image is the "clicking part". For the default arrow cursor, the image is simply lined up with the container, meaning the top left is the hotspot. However, for something like a crosshair cursor, you could move the cursor image so that its center is over the top left corner of the cursor container. To show the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1cc48ac157278b5845d425abbe9acefd" title="Displays specified material on cursor, or the last material used if none specified. ">OgreBites::TrayManager::showCursor</a></code>, which takes an optional material name for the cursor image. If unspecified, the cursor image is not changed. To hide the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a979ff2ad2d729223259b3bebb237cafb">OgreBites::TrayManager::hideCursor</a></code>. You can get the cursor's different parts using getCursorLayer, getCursorContainer, and getCursorImage. Note that if the cursor is hidden, all interactions with widgets are disabled.</p>
<h2>The Backdrop</h2>
<p>If you want to show a backdrop, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ad554418c27edb907f0e3bead8659b83c" title="Displays specified material on backdrop, or the last material used if none specified. ">OgreBites::TrayManager::showBackdrop</a></code>, which takes an optional material name for the backdrop. If unspecified, the backdrop image is not changed. To hide it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a6129a1e92ac22789a4602cf36f9c5394">OgreBites::TrayManager::hideBackdrop</a></code>.</p>
<h1><a class="anchor" id="widgets"></a>
Widgets</h1>
<p>There are 10 basic widgets. Each widget is just an instance of an OverlayElement template, and all widgets use {LEX()}pixel{LEX} metrics. You can get access to any widget's underlying OverlayElement through <code><a class="el" href="class_ogre_bites_1_1_widget.html#a379d3f1a2ca6eaf13fc5c52afaafd0d2">OgreBites::Widget::getOverlayElement</a></code>. Do not instantiate and delete widgets manually. Create and destroy them using the TrayManager. The first argument to any one of TrayManager's widget creation methods is the location of the tray you want the widget to be in. This is of the enumerated type TrayLocation. The second argument is the name of your widget (this is not your widget's caption, but a unique string identifier for your widget). The rest of the arguments are specific to the type of widget.</p>
<h2>Button</h2>
<p>This is the most basic widget of all. To create a button, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">OgreBites::TrayManager::createButton</a></code>. In addition to a tray location and a name, you must specify a caption for your button, and an optional width. If width is not specified, the button will automatically resize to fit its caption. There are no button states. You only get notified when a button is pushed. To see how to respond to button push events, see the TrayListener section below.</p>
<h2>TextBox</h2>
<p>This widget consists of a bold caption bar and a text area that can be scrolled vertically. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a07a8d212939266339e877ff2118250a6">OgreBites::TrayManager::createTextBox</a></code> takes a caption, width, and height. You can set/get the caption, the text area contents, text padding, text alignment, manually change the scroll bar position, among other things.</p>
<h2>SelectMenu</h2>
<p>A basic drop-down menu. To create it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a60864ca00d65b2bf1b97bb8545fab737">OgreBites::TrayManager::createLongSelectMenu</a></code> or <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a98f478c8daa5084b53146de03adbc216">OgreBites::TrayManager::createThickSelectMenu</a></code>. Both these methods return a SelectMenu object, but they give one of two different visual styles to the widget. One is thicker, but shorter, because it places the caption over the item box. This style of menu is good for putting in the side trays. The other is longer, but thinner, because it places the item box next to the caption. This style of menu is good for putting in the top or bottom trays. createThickSelectMenu takes a tray location, a name, a caption, the width of the whole widget, the maximum number of visible items when expanded, and an optional string vector of items. The medthod <code>createLongSelectMenu</code> takes nearly the same arguments, except that it needs the width of the text box that shows the currently selected item. Also, for long menus, it is optional to specify the total width because it will automatically resize to fit the item box and the caption. You can set/get the caption, and set/get the items in many different ways. You can also manually change the selection, with the option of not firing an event. To see how to respond to menu item selection events, see the TrayListener section below.</p>
<h2>Label</h2>
<p>A big, semi-transparent, tabby-looking label. This widget uses a different font from the rest of the widgets, and is good for section headings and such. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a15375d59b5c57059c9c6549fc5a1bfcd">OgreBites::TrayManager::createLabel</a></code> takes a caption, and an optional width. If the width is not specified, the label automatically adjusts its width to fill the tray it's currently in, so it matches the other contents of the tray. Labels can also be clicked. To see how to respond to label click events, see the TrayListener section below.</p>
<h2>Separator</h2>
<p>A horizontal line which looks like it was etched into the tray. Good for dividing up other widgets into sections without taking up as much space as a label. <code>TrayManager::createSeparator</code> takes a tray location, name, and an optional width. If the width is not specified, the behaviour is the same as a Label's.</p>
<h2>Slider</h2>
<p>A slider bar consists of a container box, a small text box to display the value, and a track + handle. Sliders are type-agnostic. Using three parameters - a minimum value, a maximum value, and the number of "snapping points", you can give your slider track of any kind of discrete scale - integer, floating point, or even nominal. Snapping points are basically the "steps" on your slider track. By specifying how many of them there are, you are in effect specifying an entire range of values all the way from your minimum value to your maximum value. Let's say you have minimum value 0, maximum value 1, and 6 snapping points. Underneath the surface, each slider stores a floating point value, so in this case you would be able to display 6 floating point values: {0, 0.2, 0.4, 0.6, 0.8, 1}. The slider will display your value in the cleanest way possible (using <code><a class="el" href="class_ogre_1_1_string_converter.html#a45fb498a2f798c82bbf88116a5a34c53" title="Converts a float to a String. ">Ogre::StringConverter::toString</a></code>). This means that if all your values happen to land on integers, then they will be displayed as integers without decimals. You can also exploit this by using your slider's integer values as indices into an array of string values, and manually set your slider's value to the new string value. Basically, you can make your slider display things like Low, Medium, High, 1/4, 3/4, $4.00, N/A, etc. This requires you to respond to slider move events. More on this in the TrayListener section below. Then your Like select menus, sliders also come in two flavours - thick and long. The thick style places the caption and the value box above the track, while the long style places the caption, track, and value box side by side in that order. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a597ec173c1b424980e18fd92e0c56905">OgreBites::TrayManager::createThickSlider</a></code> takes a tray location, name, caption, total width, value box width, minimum value, maximum value, and the number of snapping points. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a321429ade975d3a63dfc1125b4375e78">OgreBites::TrayManager::createLongSlider</a></code> takes a an optional total width, track width, value box width, minimum value, maximum value, and the number of snapping points. If the total width is not specified, the slider will automatically scale to fit the track, the value box, and the caption text. You can get/set the slider's caption, displayed value, actual value, and range of values. When you change the range, the value is reset to be the minimum value. When you change the value, you also have the option of not firing an event. To respond to slider move events, see the TrayListener section below.</p>
<h2>ParamsPanel</h2>
<p>This panel displays an arbitrary number of parameters and their values. This could be anything you want. For example, the stats panel in the SDK samples shows the average framerate, best framerate, batch count, etc. The details panel in the SDK samples shows the texture filtering technique, the polygon mode, and the camera position and orientation. To create a ParamsPanel, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a5ae6b66603e05193b3077f30900209eb">OgreBites::TrayManager::createParamsPanel</a></code>, which takes a tray location, a name, a width, and then either a string vector of parameter names or the number of parameters (lines) to leave room for. The parameter names will be left justified, and their values will be right justified on the same line. At any time, you can set/get the parameter names and values either one at a time, or all at once using a string vector.</p>
<h2>CheckBox</h2>
<p>Self-explanatory. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7433f3e89c5b3a1b1b0012dfcb121f1d">OgreBites::TrayManager::createCheckBox</a></code> takes a tray location, name, caption, and an optional width. Unspecified width means auto-fit to caption. You can set/get the state of the check box, with the option of not triggering an event. To respond to check box state change events, see the TrayListener section below. </p><h2>DecorWidget</h2>
<p>This widget takes any OverlayElement template, and creates a widget out of it. If you want to put your own picture, icons, or other static objects into the trays, make an OverlayElement template out of it, and then turn it into a DecorWidget. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a24d1b3a3b95ddcf274bf899b7600deba">OgreBites::TrayManager::createDecorWidget</a></code> takes a tray location, a name, and an OverlayElement template name. These are basically the same things you would normally use to create an OverlayElement from a template. The OGRE logo in the SDK samples is a DecorWidget. </p><h2>ProgressBar</h2>
<p>A progress bar with a caption, a comment/details box, and a meter that fills up. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a431a347db6465bbf66af82ef363c875f">OgreBites::TrayManager::createProgressBar</a></code> takes a tray location, a name, a caption, a total width, and comment box width. You can use progress bars to show any kind of progress you want, but for the most common kind (loading resources), there's a special instance of ProgressBar already created by TrayManager which you can use. See Loading Bar below.</p>
<h2>The Null Tray</h2>
<p>In addition to the nine trays you can place your widgets in, there is also a "null tray". This is an imaginary tray, whose location is specified by <code>TL_NONE</code>. This tray is virtual, invisible, and does not arrange widgets within it. Basically, if you place a widget in this tray, it becomes "free-floating", and you're allowed to manually position it anywhere on the screen. Widgets must always reside in a tray for as long as they exist, so when a widget is removed from a tray, it is automatically placed in the null tray.</p>
<h1><a class="anchor" id="special-widgets"></a>
Special Widgets</h1>
<p>Some widgets are so common they deserve special treatment.</p>
<h2>Frame Stats</h2>
<p>This is not exactly one widget, but a combination of Label that displays the current FPS, and a ParamsPanel that displays advanced frame statistics (such as average FPS and batch count). Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a49e2f792fee94e75b1b472826bcc8019" title="Shows frame statistics widget set in the specified location. ">OgreBites::TrayManager::showFrameStats</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1c2e9618a3e6b061a9cfeac4f2cb55e9" title="Hides frame statistics widget set. ">OgreBites::TrayManager::hideFrameStats</a></code> to show/hide this special widget. You can choose where to put it. When the user clicks the FPS label, it toggles the visibility of the advanced frame stats, so they can be out of the way when they're unwanted. You can also manually toggle the visibility of the advanced frame stats using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aed00f8a1009f2ebf6806774cb894d0d7" title="Toggles visibility of advanced statistics. ">OgreBites::TrayManager::toggleAdvancedFrameStats</a></code>.</p>
<h2>Logo</h2>
<p>This is just a decor widget of the OGRE logo. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#affee57f47066e25437649d64daaa7dd9" title="Shows logo in the specified location. ">OgreBites::TrayManager::showLogo</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ac1ee637b7ef5e887170c8a9aca1c4c7b">OgreBites::TrayManager::hideLogo</a></code> to show/hide the logo. You can choose where to put it.</p>
<h2>Loading Bar</h2>
<p>This is a progress bar that shows you the progress of your current resource loading job. The comment box will show the current resource being loaded. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a0d51005a4b148a4df2c1c6b55e34f085" title="Shows loading bar. ">OgreBites::TrayManager::showLoadingBar</a></code> before you begin your loading job. Specify the number of resource groups you will initialise, the number of groups you will load, and, if you want to, the proportion of time you think will go to initialisation (default estimate is 70%). You cannot decide where to place this loading bar. The screen will be darkened, and the loading bar will appear in the center. Any other dialog or loading bar will be closed. When you finish your loading job, call <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aab014a2c48c8f91556182e42684d44ad">OgreBites::TrayManager::hideLoadingBar</a></code>.</p>
<h2>Information Dialog</h2>
<p>This is a dialog which tells the user something and displays an OK button. It's a combination of a TextBox and a Button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#abf3bd8e4ef9a6d0d76f27535a6010623" title="Pops up a message dialog with an OK button. ">OgreBites::TrayManager::showOkDialog</a></code> to display an information dialog. Specify the caption of the TextBox, and the message you want to display in it. Any other dialog or loading bar will be closed. The screen will be darkened, and the dialog will appear in the center. All other widget interactions are disabled until the dialog is closed. You can manually close a dialog using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#af5d95dcaa7c74d3345308e4f4e3035e8" title="Hides whatever dialog is currently showing. ">OgreBites::TrayManager::closeDialog</a></code>. To respond to information dialog closing events, see the TrayListenersection below.</p>
<h2>Question Dialog</h2>
<p>Same as the Information Dialog except it asks the user something and displays a Yes button and a No button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a85d47aa11d761742884dc6457ec11cdf" title="Pops up a question dialog with Yes and No buttons. ">OgreBites::TrayManager::showYesNoDialog</a></code> to display a question dialog. Specify the caption of the TextBox, and the question you want to display in it. To respond to question dialog closing events, see the TrayListener section below.</p>
<h1><a class="anchor" id="tray-listener"></a>
TrayListener</h1>
<p>This class contains handlers for all the different events that your widgets can fire. The TrayManager class itself is an TrayListener, because it responds to events from its special widgets. You should extend your sample class from TrayListener as well as Sample if you want to handle widget events. If you're using SdkSample, you're all set because it's already an TrayListener. Some widgets give you an option of not firing an event when you change their state. This is helpful for initialising or resetting a widget, in which case there shouldn't be a response of any sort. For example, if you're initialising your slider bar before the scene is set up, and your slider bar is used to control some part of your scene, firing an event would cause an error. Below is a list of the different handlers. All handlers have return type void.</p><ul>
<li><b>buttonHit</b>: Gives you a pointer to the Button which was hit.</li>
<li><b>itemSelected</b>: Gives you a pointer to the SelectMenu the item was chosen from. You can then use the SelectMenu to see which item was selected.</li>
<li><b>labelHit</b>: Gives you a pointer to the Label that was clicked.</li>
<li><b>sliderMoved</b>: Gives you a pointer to the Slider whose value was changed. You can then use the Slider to see what its new value is. Also, you can convert this value into a more suitable form and display it using Slider::setDisplayedValue.</li>
<li><b>checkBoxToggled</b>: Gives you a pointer to the CheckBox whose state was changed. You can then use the CheckBox to see if it's been checked or unchecked.</li>
<li><b>okDialogClosed</b>: Gives you the message of the OK dialog that was closed.</li>
<li><b>yesNoDialogClosed</b>: Gives you the question of the Yes-No dialog that was closed, and a boolean indicating whether or not the Yes button was pressed.</li>
</ul>
<h1><a class="anchor" id="things-to-try"></a>
Things to Try</h1>
<p>Getting access to widgets: </p><div class="fragment"><div class="line">Button* b;</div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);  <span class="comment">// by tray and position</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by tray and name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#af968c01a627ee654409f558e4ef55537">getWidgetIterator</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>).<a class="code" href="class_ogre_1_1_vector_iterator_wrapper.html#a2460c8adb6819235849de954db6a0f64">getNext</a>();  <span class="comment">// by iterator</span></div></div><!-- fragment --><p> Counting widgets: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>();  <span class="comment">// total</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);  <span class="comment">// by tray</span></div></div><!-- fragment --><p> Moving widgets to other trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div></div><!-- fragment --><p> Removing widgets from trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a04a1085bdee61d7234849663cce08664">TL_NONE</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a77ba6e4d641c146e262b6cdd2c8b04a0">clearTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9787ec5e8989bf6cfa89d03c6ddd27b6">clearAllTrays</a>();</div></div><!-- fragment --><p> Destroying widgets: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4a89cd6f7d87e0e538aa842f1a42a7bc">destroyAllWidgetsInTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aadb1f5a3b7e3b5397b10bdd3449e1603">destroyAllWidgets</a>();</div></div><!-- fragment --><p> Finding the position of a widget in a tray: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa993d2b60cfbcb903aecbff1c4896b67">locateWidgetInTray</a>(b);</div></div><!-- fragment --><p> Finding the tray a widget is in: </p><div class="fragment"><div class="line"><a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530">TrayLocation</a> trayLoc = b-&gt;getTrayLocation();</div></div><!-- fragment --><p> Changing the tray listener object: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a3235fea714a0c61e463dee69ae308be8">setListener</a>(newListener);</div></div><!-- fragment --><p> Toggling system visibility: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a075805136b2241cbb03eeb2c3d27b40d">showAll</a>();</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a188f1d5f5ca16af3b28d11ecd553105a">hideAll</a>();</div></div><!-- fragment --><p> Changing horizontal widget alignment in one tray: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#adfbbc97615fd5f1a939be6e7a1f00c07">setTrayWidgetAlignment</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <a class="code" href="group___overlays.html#gga3396780cdb2d731aa5e4389148bdc5f3a270f18cf07dbe4e75e1b790d02924205">GHA_RIGHT</a>);</div></div><!-- fragment --><p> Changing spacing and padding: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a33a3e3f66a3989dd3de48b4c4577422f">setWidgetSpacing</a>(5);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a52d3fc8638533540232232c37b257de6">setWidgetPadding</a>(3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a866229b6d88dc9d3a609115eaab46e67">setTrayPadding</a>(12);</div></div><!-- fragment --><p> Casting 3D ray from under cursor into the scene: </p><div class="fragment"><div class="line">Ray r = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9dd5d303968329462e9bf4225f59722e">getCursorRay</a>(mCamera);</div></div><!-- fragment --><p> Casting 3D ray from any 2D screen coordinate into the scene: </p><div class="fragment"><div class="line">Ray r = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#a6833f46b0303b559a050f310fa0204fc">OgreBites::TrayManager::screenToScene</a>(mCamera, Vector2(320, 240));</div></div><!-- fragment --><p> Converting a 3D scene coordinate to a 2D screen coordinate: </p><div class="fragment"><div class="line">Vector2 p = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa7a456c2c0c37123e2ab0e497f2c0ccc">OgreBites::TrayManager::sceneToScreen</a>(mCamera, Vector3::ZERO);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: HLMS: High Level Material System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hlms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HLMS: High Level Material System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#components">The three components</a></li>
<li class="level1"><a href="#materials">Compared to classical materials</a></li>
<li class="level1"><a href="#data">Material parameters are stored in “Blocks”</a><ul><li class="level2"><a href="#toc52">Datablocks</a></li>
</ul>
</li>
<li class="level1"><a href="#toc69">Hlms templates</a><ul><li class="level2"><a href="#preproc">The Hlms preprocessor</a></li>
<li class="level2"><a href="#syntax">Preprocessor syntax</a></li>
</ul>
</li>
<li class="level1"><a href="#shaders">Creation of shaders</a></li>
<li class="level1"><a href="#cpp">C++ interaction with shader templates</a></li>
<li class="level1"><a href="#customization">Customization</a></li>
</ul>
</div>
<div class="textblock"><p>This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.</p>
<p>Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.</p>
<p>Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.</p>
<p>But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.</p>
<p>Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.</p>
<h1><a class="anchor" id="components"></a>
The three components</h1>
<div class="image">
<object type="image/svg+xml" data="hlms_components.svg">hlms_components.svg</object>
</div>
<ol type="1">
<li>Scripts. To set the material properties (i.e. type of Hlms to use: PBS, Toon shading, GUI; what textures, diffuse colour, roughness, etc). <b>You currently have to do this from C++.</b> Everybody will be using this part.</li>
<li>Shader template. The Hlms takes a couple hand-written glsl/hlsl files as template and then adapts it to fit the needs on the fly (i.e. if the mesh doesn’t contain skeleton, the bit of code pertaining to skeletal animation is stripped from the vertex shader). The Hlms provides a simple preprocessor to deal with this entirely within from the template, but you’re not forced to use it. Here’s a simple example of the preprocessor. I won’t be explaining the main keywords today. Advanced users will probably want to modify these files (or write some of their own) to fit their custom needs.</li>
<li>C++ classes implementation. The C++ takes care of picking the shader templates and manipulating them before compiling; and most importantly it feeds the shaders with uniform/constans data and sets the textures that are being in use. It is extremely flexible, powerful, efficient and scalable, but it’s harder to use than good ol’ Materials because those used to be data-driven: there are no AutoParamsSource here. Want the view matrix? You better grab it from the camera when the scene pass is about to start, and then pass it yourself to the shader. This is very powerful, because in D3D11/GL3+ you can just set the uniform buffer with the view matrix just once for the entire frame, and thus have multiple uniforms buffers sorted by update frequency. Very advanced user will be using messing with this part.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Material scripts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.x do not yet support the HLMS - you must use the C++ API. e.g. <a class="el" href="class_ogre_1_1_pbs_material.html">Ogre::PbsMaterial</a>.</dd></dl>
<p>Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.</p>
<p>For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.</p>
<p>It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.</p>
<h1><a class="anchor" id="materials"></a>
Compared to classical materials</h1>
<p>Materials are still useful for:</p>
<ul>
<li>Quick iteration. You need to write a shader, just define the material and start coding. Why would you deal with the template’s syntax or a C++ module when you can just write a script and start coding?. The HLMS though comes with a Command line tool to know how your template translates into a final shader (which is very handy for iteration, it’s fast, and will check for syntax errors!), but it’s most useful when you want to write your own C++ module or change the template, not when you want to just experiment. Besides, old timers are used to writing materials.</li>
<li>Postprocessing effects. Materials are much better suited for this. Materials are data driven, easy to write. Postprocessing FXs don’t need an awful lot of permutations (i.e. having to deal with shadow mapping, instancing, skeleton animation, facial animation). And they’re at no performance disadvantage compared to HLMS: Each FX is a fullscreen pass that needs different shaders, different textures, its own uniforms. Basically, API overhead we can’t optimize. But it doesn’t matter much either, because it’s not like there are 100 fullscreen passes. Usually there’s less than 10.</li>
</ul>
<h1><a class="anchor" id="data"></a>
Material parameters are stored in “Blocks”</h1>
<p>You could be thinking the reason I came up with these two is to fit with D3D11′s grand scheme of things while being compatible with OpenGL. But that’s a half truth and an awesome side effect. I’ve been developing the Hlms using OpenGL this whole time.</p>
<p>An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and they’re right about that.</p>
<p>However, there are big advantages for using blocks:</p>
<ol type="1">
<li>Many materials in practice share the same Macro- &amp; Blendblock parameters. In an age where we want many 3D primitives with the same shader but slightly different parameters like texture, colour, or roughness (which equals, a different material) having these settings repeated per material wastes a lot of memory space… and a lot of bandwidth (and wastes cache space). <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 is bandwidth bound, so having all materials share the same pointer to the same Macroblock can potentially save a lot of bandwidth, and be friendlier to the cache at the same time.This stays true whether we use D3D11, D3D12, OpenGL, GL ES 2, or Mantle.</li>
<li>Sorting by Macroblock is a lot easier (and faster) than sorting by its individual parameters: when preparing the hash used for sorting, it’s much easier to just do (every frame, per object) <code>hash |= (macroblock-&gt;getId() &lt;&lt; bits) &amp; mask</code> than to do: <code>hash =| m-&gt;depth_check | m-&gt;depthWrite &lt;&lt; 1 | m-&gt;depthBias &lt;&lt; 2 | m-&gt;depth_slope_bias &lt;&lt; 3 | m-&gt;cullMode &lt;&lt; 18 | ... ;</code> We also need a lot more bits we can’t afford. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 imposes a limit on the amount of live Macroblocks you can have at the same time; as we run out of hashing space (by the way, D3D11 has its own limit). It operates around the idea that most setting combinations won’t be used in practice.</li>
</ol>
<p>Of course it’s not perfect, it can’t fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); you’ll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. We’re aiming the general use case.</p>
<p>These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since I’m not used to driver development. However from an engine perspective, blocks make sense.</p>
<h2><a class="anchor" id="toc52"></a>
Datablocks</h2>
<p>We’re introducing the concept of Datablocks. A Datablock is a “material” from the user’s perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.</p>
<div class="image">
<object type="image/svg+xml" data="hlms_blocks.svg">hlms_blocks.svg</object>
</div>
<p>The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.</p>
<dl class="section note"><dt>Note</dt><dd>Macroblocks and Blendblocks are not available in 1.x - use <a class="el" href="class_ogre_1_1_pass.html#ae454faee87f8cb0b8540810e48118788" title="Sets whether or not this pass renders with depth-buffer checking on or not. ">Ogre::Pass::setDepthCheckEnabled</a> etc. as usual, to change the respective properties</dd></dl>
<h1><a class="anchor" id="toc69"></a>
Hlms templates</h1>
<p>The Hlms will parse the template files from the template folder according to the following rules:</p>
<ol type="1">
<li>The files with the names "VertexShader_vs", "PixelShader_ps", "GeometryShader_gs", "HullShader_hs", "DomainShader_ds" will be fully parsed and compiled into the shader. If an implementation only provides "VertexShader_vs.glslt", "PixelShader_ps.glslt"; only the vertex and pixel shaders for OpenGL will be created. There will be no geometry or tesellation shaders.</li>
<li>The files that contain the string "_piece_vs" in their filenames will be parsed only for collecting pieces (more on pieces later). Likewise, the words "_piece_ps", "_piece_gs", "_piece_hs", "_piece_ds” correspond to the pieces for their respective shader stages. Note that you can concatenate, thus "MyUtilities_piece_vs_piece_ps.glslt” will be collected both in the vertex and pixel shader stages.</li>
</ol>
<p>The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.</p>
<h2><a class="anchor" id="preproc"></a>
The Hlms preprocessor</h2>
<p>The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.</p>
<p>For example </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can't evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can't check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable “IncludeLightingEquals2” and check whether it's non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can't see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you'll depend on the driver implementation having a good macro preprocessor.</p>
<h2><a class="anchor" id="syntax"></a>
Preprocessor syntax</h2>
<p>The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:</p>
<ul>
<li>@property</li>
<li>@foreach</li>
<li>@counter</li>
<li>@value</li>
<li>@set add sub mul div mod min max</li>
<li>@piece</li>
<li>@insertpiece</li>
<li>@pset padd psub pmul pdiv pmod pmin pmax</li>
</ul>
<h3>@property( expression )</h3>
<p>Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.</p>
<p>The logical operands &amp;&amp; || ! are valid.</p>
<p>Examples: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: </p><div class="fragment"><div class="line">hasLights != 0                              hasLights == 0</div><div class="line">diffuse = surfaceDiffuse * lightDiffuse;   diffuse = surfaceDiffuse ;</div></div><!-- fragment --><h3>@foreach( scopedVar, count, [start] )</h3>
<p>Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.</p>
<ul>
<li>scopedVar is a variable that can be used to print the current iteration of the loop while inside the block. i.e. “@scopedVar” will be converted into a number in the range [start; count)</li>
<li>count The number of times to repeat the loop (if start = 0). Count can read variables.</li>
<li>start Optional. Allows to start from a value different than 0. Start can read variables.</li>
</ul>
<p>Newlines are very important, as they will be printed with the loop.</p>
<p>Examples: </p><table class="doxtable">
<tr>
<th>Expression </th><th>Output  </th></tr>
<tr>
<td>@foreach( 4, n ) <br />
&emsp; @n@end </td><td><br />
0<br />
1<br />
2<br />
3 </td></tr>
<tr>
<td>@foreach( 4, n ) @n@end </td><td>0 1 2 3 </td></tr>
<tr>
<td>@foreach( 4, n )<br />
&emsp;@n<br />
@end </td><td><br />
0<br />
<br />
1<br />
<br />
2<br />
<br />
3<br />
 </td></tr>
<tr>
<td>@foreach( 4, n, 2 ) @n@end </td><td>2 3 </td></tr>
<tr>
<td>@pset( myStartVar, 1 )<br />
@pset( myCountVar, 3 )<br />
@foreach( myStartVar, n, myCountVar )<br />
&emsp;@n@end </td><td>1<br />
2 </td></tr>
<tr>
<td>@foreach( 2, n )<br />
&emsp;@insertpiece( pieceName@n )@end </td><td>@insertpiece( pieceName0 )<br />
 @insertpiece( pieceName1 ) </td></tr>
</table>
<blockquote class="doxtable">
<p><b>Attention #1!</b></p>
<p>Don't use the common letter i for the loop counter. It will conflict with other keywords.</p>
<p>i.e. “@foreach( 1, i )@insertpiece( pieceName )@end” will print “0nsertpiece( pieceName )” which is probably not what you intended.</p>
<p><b>Attention #2!</b></p>
<p>foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.</p>
<p>i.e. The following code will not work:</p>
<div class="fragment"><div class="line">@pset( myVar, 1 )</div><div class="line"></div><div class="line">@<span class="keywordflow">foreach</span>( 2, n )</div><div class="line"></div><div class="line"><span class="comment">//Code</span></div><div class="line"></div><div class="line">@psub( myVar, 1 ) <span class="comment">//Decrement myVar on each loop</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( myVar )</div><div class="line"></div><div class="line"><span class="comment">//Code that shouldn&#39;t be printed in the last iteration</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>Because psub will be evaluated before expanding the foreach. </p>
</blockquote>
<h3>@counter( variable )</h3>
<p>Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.</p>
<p>Examples: </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@counter( myVar )   1</div><div class="line"></div><div class="line">@counter( myVar )   2</div></div><!-- fragment --><h3>@value( variable )</h3>
<p>Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@value( myVar )     1</div><div class="line"></div><div class="line">@value( myVar )     1</div></div><!-- fragment --><h3>@set add sub mul div mod min max</h3>
<p>Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.</p>
<p>Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c</p>
<p>Useful in combination with @counter and @value</p>
<table class="doxtable">
<tr>
<th>Expression </th><th>Output </th><th>Math  </th></tr>
<tr>
<td>@set( myVar, 1 ) <br />
 @value( myVar ) </td><td>1 </td><td>myVar = 1 </td></tr>
<tr>
<td>@add( myVar, 5 )<br />
 @value( myVar ) </td><td>6 </td><td>myVar = 1 + 5 </td></tr>
<tr>
<td>@div( myVar, 2 ) <br />
 @value( myVar ) </td><td>3 </td><td>myVar = 6 / 2 </td></tr>
<tr>
<td>@mul( myVar, myVar )<br />
 @value( myVar ) </td><td>9 </td><td>myVar = 3 * 3 </td></tr>
<tr>
<td>@mod( myVar, 5 ) <br />
 @value( myVar ) </td><td>4 </td><td>myVar = 9 % 5 </td></tr>
<tr>
<td>@add( myVar, 1, 1 ) <br />
 @value( myVar ) </td><td>2 </td><td>myVar = 1 + 1 </td></tr>
</table>
<h3>@piece( nameOfPiece )</h3>
<p>Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won't be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                        Output</div><div class="line"></div><div class="line">@piece( VertexTransform )         </div><div class="line"></div><div class="line">outPos = worldViewProj * inPos   </div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><h3>@insertpiece( nameOfPiece )</h3>
<p>Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                                                     Output</div><div class="line"></div><div class="line">@piece( VertexTransform )outPos = worldViewProj * inPos@end   void main()</div><div class="line"></div><div class="line">void main()                                                    {</div><div class="line"></div><div class="line">{                                                              outPos = worldViewProj * inPos</div><div class="line"></div><div class="line">@insertpiece( VertexTransform )                                }</div><div class="line"></div><div class="line">@insertpiece( InexistentPiece )                                </div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h3>@pset padd psub pmul pdiv pmod pmin pmax</h3>
<p>Analogous to <a href="#toc304"><em>the family of math functions without the 'p' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.</p>
<p>i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )</p>
<p>One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.</p>
<p>If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.</p>
<h1><a class="anchor" id="shaders"></a>
Creation of shaders</h1>
<p>There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:</p>
<ol type="1">
<li>The Datablock/Material. Does it have Normal maps? Then include code to sample the normal map and affect the lighting calculations. Does it have a diffuse map? If not, avoid sampling the diffuse map and multiplying it against the diffuse colour, etc.</li>
<li>The Mesh. Is it skeletally animated? Then include skeletal animation code. How many blend weights? Modify the skeletal animation code appropiately. It doesn't have tangents? Then skip the normal map defined in the material. And so on.</li>
</ol>
<p>When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.</p>
<p>If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).</p>
<p>The following graph summarizes the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_hash.svg">hlms_hash.svg</object>
</div>
<p>Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a “<a href="#toc567"><em>pass hash</em></a>” instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).</p>
<p>While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_caching.svg">hlms_caching.svg</object>
</div>
<h1><a class="anchor" id="cpp"></a>
C++ interaction with shader templates</h1>
<p>Note: This section is relevant to those seeking to write their own Hlms implementation.</p>
<p>C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set “key” to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod</p>
<p>To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.</p>
<p>The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.</p>
<p>In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.</p>
<p>Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.</p>
<p>For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.</p>
<p>The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.</p>
<h2>Common conventions</h2>
<p>Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.</p>
<p>Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.</p>
<p>For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.</p>
<p>Properties in underscore_case are set from C++; propierties in camelCase are set from the template.</p>
<p>Propierties and pieces starting with 'custom_' are for user customizations of the template</p>
<p>TBD</p>
<h2>Disabling a stage</h2>
<p>By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.</p>
<p>Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.</p>
<h1><a class="anchor" id="customization"></a>
Customization</h1>
<p>In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.</p>
<p>Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.</p>
<p>Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.</p>
<p>There are different levels in which an Hlms implementation can be customized:</p>
<ol type="1">
<li>Using a library, see <a href="#toc574"><em>Hlms Initialization</em></a>. pass a set of piece files in a folder by pushing the folder to ArchiveVec. The files in that folder will be parsed first, in order (archiveVec[0] then archiveVec[1], … archiveVec[N-1]); which will let you define your own pieces to insert code into the default template (see the the table at the end). You can also do clever tricky things to avoid dealing with C++ code at all even if there are no 'custom_' pieces for it. For example, you can write the following code to override the BRDF declarations and provide a custom BRDF: <div class="fragment"><div class="line"><span class="comment">//Disable all known BRDFs that the implementation may enable</span></div><div class="line"></div><div class="line">@pset( BRDF_CookTorrance, 0 )</div><div class="line"></div><div class="line">@pset( BRDF_Default, 0 )</div><div class="line"></div><div class="line">@piece( DeclareBRDF )</div><div class="line"></div><div class="line"><span class="comment">// Your BRDF code declaration here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --></li>
</ol>
<ol type="1">
<li>Via listener, through HlmsListener. This allows you to have access to the buffer pass to fill extra information; or bind extra buffers to the shader.</li>
<li>Overload HlmsPbs. Useful for overriding only specific parts, or adding new functionality that requires storing extra information in a datablock (e.g. overload HlmsPbsDatablock to add more variables, and then overload HlmsPbs::createDatablockImpl to create these custom datablocks)</li>
<li>Directly modify HlmsPbs, HlmsPbsDatablock and the template. <table class="doxtable">
<tr>
<th>Variable </th><th>Description  </th></tr>
<tr>
<td>custom_passBuffer </td><td>Piece where users can add extra information for the pass buffer (only useful if the user is using HlmsListener or overloaded HlmsPbs. </td></tr>
<tr>
<td>custom_VStoPS </td><td>Piece where users can add more interpolants for passing data from the vertex to the pixel shader. </td></tr>
<tr>
<td>custom_vs_attributes </td><td>Custom vertex shader attributes in the Vertex Shader (i.e. a special texcoord, etc). </td></tr>
<tr>
<td>custom_vs_uniformDeclaration </td><td>Data declaration (textures, texture buffers, uniform buffers) in the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_posExecution </td><td>Executed after all code from the Vertex Shader has been performed. </td></tr>
<tr>
<td>custom_ps_uniformDeclaration </td><td>Same as custom_vs_uniformDeclaration, but for the Pixel Shader </td></tr>
<tr>
<td>custom_ps_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Pixel Shader. </td></tr>
<tr>
<td>custom_ps_posMaterialLoad </td><td>Executed right after loading material data; and before anything else. May not get executed if there is no relevant material data (i.e. doesn't have normals or QTangents for lighting calculation) </td></tr>
<tr>
<td>custom_ps_preLights </td><td>Executed right before any light (i.e. to perform your own ambient / global illumination pass). All relevant texture data should be loaded by now. </td></tr>
<tr>
<td>custom_ps_posExecution </td><td>Executed after all code from the Pixel Shader has been performed. </td></tr>
</table>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Trays GUI System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('trays.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Trays GUI System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#trays-1">Trays</a></li>
<li class="level1"><a href="#traymanager">TrayManager</a></li>
<li class="level1"><a href="#widgets">Widgets</a></li>
<li class="level1"><a href="#special-widgets">Special Widgets</a></li>
<li class="level1"><a href="#tray-listener">TrayListener</a></li>
<li class="level1"><a href="#things-to-try">Things to Try</a></li>
</ul>
</div>
<div class="textblock"><p>Ever wanted really simple GUI controls for your sample? Don't want to write one from scratch, but CEGUI's just a little too much? The Trays system was created to address this issue. It's a simple GUI system based on the OGRE Overlay system and designed just for samples. Because it's simple, you're not going to be able to skin it or build very unique interfaces, but you'll also find it much easier to use. The entire system is based on the OGRE Overlay system.</p>
<h1><a class="anchor" id="trays-1"></a>
Trays</h1>
<p>Why trays? The concept of trays is central to the system in that it removes the need for the GUI designer (you) to calculate or specify positional coordinates of any kind. Think about the widget locations in a typical GUI. They are almost always in any of the four corners, along any of the four edges or, on the rare occasion, in the center of the screen. In Trays, there are nine "trays", one in each of the locations previously mentioned. When you create a widget, you specify one of these nine locations, and the widget will be added to the tray at that location. Your widget will be added directly beneath the last widget in that tray. When you add a widget to a tray, the tray grows in size. Trays along the top of the screen grow downward, Trays along the bottom grow upward, and the trays in the middle row grow vertically in both directions. Visually, the trays are semi-transparent panels that fit the widgets they contain. Only non-empty trays are visible. If this is hard to visualise, don't worry, here's a picture to help you out. </p><div class="image">
<img src="Gui2.jpg" alt="Gui2.jpg"/>
</div>
<h1><a class="anchor" id="traymanager"></a>
TrayManager</h1>
<p>To use Trays, you have to create an TrayManager. This is the class through which you will create and manage all your widgets, manipulate the cursor, change the backdrop image, adjust tray properties, pop up dialogs, show/hide the loading bar, etc. You can have multiple tray managers in one application. For example, the OGRE Sample Browser uses its own tray manager and hides it when a sample is running, and the SDK samples also have their own tray managers, which are hidden when the samples are paused by the browser. The TrayManager requires "Trays.zip", so you can only create it after loading that resource. Also, make sure you're using the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> namespace (Trays is part of the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Samples Framework). Create your tray manager like so: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>* mTrayMgr = <span class="keyword">new</span> <a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>(<span class="stringliteral">&quot;InterfaceName&quot;</span>, mWindow, <span class="keyword">this</span>);</div></div><!-- fragment --><p> You must pass in a name for your interface, an <code><a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a></code> and an <code><a class="el" href="class_ogre_bites_1_1_tray_listener.html" title="Listener class for responding to tray events. ">OgreBites::TrayListener</a></code>. You can extend your sample or sample context to be a tray listener. Destroy your tray manager like so: </p><div class="fragment"><div class="line"><span class="keyword">delete</span> mTrayMgr;</div><div class="line">mTrayMgr = 0;</div></div><!-- fragment --><p> Once you have your tray manager, make sure you relay your OIS events to it. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> mousePressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseDown(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseReleased(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseUp(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseMoved(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_motion_event.html">OgreBites::MouseMotionEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseMove(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> The injection methods return true if the event was relevant to the tray manager, and should not be processed again by you. For example, if you click a button that is over an interactive part of your scene, you want the button to be pressed, but you don't want the scene interaction to take place. So the injection methods double as filters for your mouse events.</p>
<p>You're now free to create widgets! Try adding a button to the top-left tray: </p><div class="fragment"><div class="line">Button* b = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">createButton</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530afe04de8736168ab0dd6e7938e679c292">TL_TOPLEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <span class="stringliteral">&quot;Click Me!&quot;</span>);</div></div><!-- fragment --><p> TrayManager is a huge class, and you can do tons of things with it. For some examples, see the Things to Try section below.</p>
<h2>The Cursor</h2>
<p>The cursor has three parts in the Trays system: The layer it moves around in Overlay, the container which positions the cursor (OverlayContainer), and the cursor image, which is a child of the container (OverlayElement). When hiding/showing the cursor, the entire cursor layer is hidden/shown. The top left corner of the cursor container is used as the hotspot of the cursor. By positioning the cursor image relative to the cursor container, you can basically decide which part of the cursor image is the "clicking part". For the default arrow cursor, the image is simply lined up with the container, meaning the top left is the hotspot. However, for something like a crosshair cursor, you could move the cursor image so that its center is over the top left corner of the cursor container. To show the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1cc48ac157278b5845d425abbe9acefd" title="Displays specified material on cursor, or the last material used if none specified. ">OgreBites::TrayManager::showCursor</a></code>, which takes an optional material name for the cursor image. If unspecified, the cursor image is not changed. To hide the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a979ff2ad2d729223259b3bebb237cafb">OgreBites::TrayManager::hideCursor</a></code>. You can get the cursor's different parts using getCursorLayer, getCursorContainer, and getCursorImage. Note that if the cursor is hidden, all interactions with widgets are disabled.</p>
<h2>The Backdrop</h2>
<p>If you want to show a backdrop, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ad554418c27edb907f0e3bead8659b83c" title="Displays specified material on backdrop, or the last material used if none specified. ">OgreBites::TrayManager::showBackdrop</a></code>, which takes an optional material name for the backdrop. If unspecified, the backdrop image is not changed. To hide it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a6129a1e92ac22789a4602cf36f9c5394">OgreBites::TrayManager::hideBackdrop</a></code>.</p>
<h1><a class="anchor" id="widgets"></a>
Widgets</h1>
<p>There are 10 basic widgets. Each widget is just an instance of an OverlayElement template, and all widgets use {LEX()}pixel{LEX} metrics. You can get access to any widget's underlying OverlayElement through <code><a class="el" href="class_ogre_bites_1_1_widget.html#a379d3f1a2ca6eaf13fc5c52afaafd0d2">OgreBites::Widget::getOverlayElement</a></code>. Do not instantiate and delete widgets manually. Create and destroy them using the TrayManager. The first argument to any one of TrayManager's widget creation methods is the location of the tray you want the widget to be in. This is of the enumerated type TrayLocation. The second argument is the name of your widget (this is not your widget's caption, but a unique string identifier for your widget). The rest of the arguments are specific to the type of widget.</p>
<h2>Button</h2>
<p>This is the most basic widget of all. To create a button, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">OgreBites::TrayManager::createButton</a></code>. In addition to a tray location and a name, you must specify a caption for your button, and an optional width. If width is not specified, the button will automatically resize to fit its caption. There are no button states. You only get notified when a button is pushed. To see how to respond to button push events, see the TrayListener section below.</p>
<h2>TextBox</h2>
<p>This widget consists of a bold caption bar and a text area that can be scrolled vertically. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a07a8d212939266339e877ff2118250a6">OgreBites::TrayManager::createTextBox</a></code> takes a caption, width, and height. You can set/get the caption, the text area contents, text padding, text alignment, manually change the scroll bar position, among other things.</p>
<h2>SelectMenu</h2>
<p>A basic drop-down menu. To create it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a60864ca00d65b2bf1b97bb8545fab737">OgreBites::TrayManager::createLongSelectMenu</a></code> or <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a98f478c8daa5084b53146de03adbc216">OgreBites::TrayManager::createThickSelectMenu</a></code>. Both these methods return a SelectMenu object, but they give one of two different visual styles to the widget. One is thicker, but shorter, because it places the caption over the item box. This style of menu is good for putting in the side trays. The other is longer, but thinner, because it places the item box next to the caption. This style of menu is good for putting in the top or bottom trays. createThickSelectMenu takes a tray location, a name, a caption, the width of the whole widget, the maximum number of visible items when expanded, and an optional string vector of items. The medthod <code>createLongSelectMenu</code> takes nearly the same arguments, except that it needs the width of the text box that shows the currently selected item. Also, for long menus, it is optional to specify the total width because it will automatically resize to fit the item box and the caption. You can set/get the caption, and set/get the items in many different ways. You can also manually change the selection, with the option of not firing an event. To see how to respond to menu item selection events, see the TrayListener section below.</p>
<h2>Label</h2>
<p>A big, semi-transparent, tabby-looking label. This widget uses a different font from the rest of the widgets, and is good for section headings and such. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a15375d59b5c57059c9c6549fc5a1bfcd">OgreBites::TrayManager::createLabel</a></code> takes a caption, and an optional width. If the width is not specified, the label automatically adjusts its width to fill the tray it's currently in, so it matches the other contents of the tray. Labels can also be clicked. To see how to respond to label click events, see the TrayListener section below.</p>
<h2>Separator</h2>
<p>A horizontal line which looks like it was etched into the tray. Good for dividing up other widgets into sections without taking up as much space as a label. <code>TrayManager::createSeparator</code> takes a tray location, name, and an optional width. If the width is not specified, the behaviour is the same as a Label's.</p>
<h2>Slider</h2>
<p>A slider bar consists of a container box, a small text box to display the value, and a track + handle. Sliders are type-agnostic. Using three parameters - a minimum value, a maximum value, and the number of "snapping points", you can give your slider track of any kind of discrete scale - integer, floating point, or even nominal. Snapping points are basically the "steps" on your slider track. By specifying how many of them there are, you are in effect specifying an entire range of values all the way from your minimum value to your maximum value. Let's say you have minimum value 0, maximum value 1, and 6 snapping points. Underneath the surface, each slider stores a floating point value, so in this case you would be able to display 6 floating point values: {0, 0.2, 0.4, 0.6, 0.8, 1}. The slider will display your value in the cleanest way possible (using <code><a class="el" href="class_ogre_1_1_string_converter.html#a45fb498a2f798c82bbf88116a5a34c53" title="Converts a float to a String. ">Ogre::StringConverter::toString</a></code>). This means that if all your values happen to land on integers, then they will be displayed as integers without decimals. You can also exploit this by using your slider's integer values as indices into an array of string values, and manually set your slider's value to the new string value. Basically, you can make your slider display things like Low, Medium, High, 1/4, 3/4, $4.00, N/A, etc. This requires you to respond to slider move events. More on this in the TrayListener section below. Then your Like select menus, sliders also come in two flavours - thick and long. The thick style places the caption and the value box above the track, while the long style places the caption, track, and value box side by side in that order. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a597ec173c1b424980e18fd92e0c56905">OgreBites::TrayManager::createThickSlider</a></code> takes a tray location, name, caption, total width, value box width, minimum value, maximum value, and the number of snapping points. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a321429ade975d3a63dfc1125b4375e78">OgreBites::TrayManager::createLongSlider</a></code> takes a an optional total width, track width, value box width, minimum value, maximum value, and the number of snapping points. If the total width is not specified, the slider will automatically scale to fit the track, the value box, and the caption text. You can get/set the slider's caption, displayed value, actual value, and range of values. When you change the range, the value is reset to be the minimum value. When you change the value, you also have the option of not firing an event. To respond to slider move events, see the TrayListener section below.</p>
<h2>ParamsPanel</h2>
<p>This panel displays an arbitrary number of parameters and their values. This could be anything you want. For example, the stats panel in the SDK samples shows the average framerate, best framerate, batch count, etc. The details panel in the SDK samples shows the texture filtering technique, the polygon mode, and the camera position and orientation. To create a ParamsPanel, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a5ae6b66603e05193b3077f30900209eb">OgreBites::TrayManager::createParamsPanel</a></code>, which takes a tray location, a name, a width, and then either a string vector of parameter names or the number of parameters (lines) to leave room for. The parameter names will be left justified, and their values will be right justified on the same line. At any time, you can set/get the parameter names and values either one at a time, or all at once using a string vector.</p>
<h2>CheckBox</h2>
<p>Self-explanatory. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7433f3e89c5b3a1b1b0012dfcb121f1d">OgreBites::TrayManager::createCheckBox</a></code> takes a tray location, name, caption, and an optional width. Unspecified width means auto-fit to caption. You can set/get the state of the check box, with the option of not triggering an event. To respond to check box state change events, see the TrayListener section below. </p><h2>DecorWidget</h2>
<p>This widget takes any OverlayElement template, and creates a widget out of it. If you want to put your own picture, icons, or other static objects into the trays, make an OverlayElement template out of it, and then turn it into a DecorWidget. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a24d1b3a3b95ddcf274bf899b7600deba">OgreBites::TrayManager::createDecorWidget</a></code> takes a tray location, a name, and an OverlayElement template name. These are basically the same things you would normally use to create an OverlayElement from a template. The OGRE logo in the SDK samples is a DecorWidget. </p><h2>ProgressBar</h2>
<p>A progress bar with a caption, a comment/details box, and a meter that fills up. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a431a347db6465bbf66af82ef363c875f">OgreBites::TrayManager::createProgressBar</a></code> takes a tray location, a name, a caption, a total width, and comment box width. You can use progress bars to show any kind of progress you want, but for the most common kind (loading resources), there's a special instance of ProgressBar already created by TrayManager which you can use. See Loading Bar below.</p>
<h2>The Null Tray</h2>
<p>In addition to the nine trays you can place your widgets in, there is also a "null tray". This is an imaginary tray, whose location is specified by <code>TL_NONE</code>. This tray is virtual, invisible, and does not arrange widgets within it. Basically, if you place a widget in this tray, it becomes "free-floating", and you're allowed to manually position it anywhere on the screen. Widgets must always reside in a tray for as long as they exist, so when a widget is removed from a tray, it is automatically placed in the null tray.</p>
<h1><a class="anchor" id="special-widgets"></a>
Special Widgets</h1>
<p>Some widgets are so common they deserve special treatment.</p>
<h2>Frame Stats</h2>
<p>This is not exactly one widget, but a combination of Label that displays the current FPS, and a ParamsPanel that displays advanced frame statistics (such as average FPS and batch count). Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a49e2f792fee94e75b1b472826bcc8019" title="Shows frame statistics widget set in the specified location. ">OgreBites::TrayManager::showFrameStats</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1c2e9618a3e6b061a9cfeac4f2cb55e9" title="Hides frame statistics widget set. ">OgreBites::TrayManager::hideFrameStats</a></code> to show/hide this special widget. You can choose where to put it. When the user clicks the FPS label, it toggles the visibility of the advanced frame stats, so they can be out of the way when they're unwanted. You can also manually toggle the visibility of the advanced frame stats using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aed00f8a1009f2ebf6806774cb894d0d7" title="Toggles visibility of advanced statistics. ">OgreBites::TrayManager::toggleAdvancedFrameStats</a></code>.</p>
<h2>Logo</h2>
<p>This is just a decor widget of the OGRE logo. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#affee57f47066e25437649d64daaa7dd9" title="Shows logo in the specified location. ">OgreBites::TrayManager::showLogo</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ac1ee637b7ef5e887170c8a9aca1c4c7b">OgreBites::TrayManager::hideLogo</a></code> to show/hide the logo. You can choose where to put it.</p>
<h2>Loading Bar</h2>
<p>This is a progress bar that shows you the progress of your current resource loading job. The comment box will show the current resource being loaded. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a0d51005a4b148a4df2c1c6b55e34f085" title="Shows loading bar. ">OgreBites::TrayManager::showLoadingBar</a></code> before you begin your loading job. Specify the number of resource groups you will initialise, the number of groups you will load, and, if you want to, the proportion of time you think will go to initialisation (default estimate is 70%). You cannot decide where to place this loading bar. The screen will be darkened, and the loading bar will appear in the center. Any other dialog or loading bar will be closed. When you finish your loading job, call <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aab014a2c48c8f91556182e42684d44ad">OgreBites::TrayManager::hideLoadingBar</a></code>.</p>
<h2>Information Dialog</h2>
<p>This is a dialog which tells the user something and displays an OK button. It's a combination of a TextBox and a Button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#abf3bd8e4ef9a6d0d76f27535a6010623" title="Pops up a message dialog with an OK button. ">OgreBites::TrayManager::showOkDialog</a></code> to display an information dialog. Specify the caption of the TextBox, and the message you want to display in it. Any other dialog or loading bar will be closed. The screen will be darkened, and the dialog will appear in the center. All other widget interactions are disabled until the dialog is closed. You can manually close a dialog using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#af5d95dcaa7c74d3345308e4f4e3035e8" title="Hides whatever dialog is currently showing. ">OgreBites::TrayManager::closeDialog</a></code>. To respond to information dialog closing events, see the TrayListenersection below.</p>
<h2>Question Dialog</h2>
<p>Same as the Information Dialog except it asks the user something and displays a Yes button and a No button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a85d47aa11d761742884dc6457ec11cdf" title="Pops up a question dialog with Yes and No buttons. ">OgreBites::TrayManager::showYesNoDialog</a></code> to display a question dialog. Specify the caption of the TextBox, and the question you want to display in it. To respond to question dialog closing events, see the TrayListener section below.</p>
<h1><a class="anchor" id="tray-listener"></a>
TrayListener</h1>
<p>This class contains handlers for all the different events that your widgets can fire. The TrayManager class itself is an TrayListener, because it responds to events from its special widgets. You should extend your sample class from TrayListener as well as Sample if you want to handle widget events. If you're using SdkSample, you're all set because it's already an TrayListener. Some widgets give you an option of not firing an event when you change their state. This is helpful for initialising or resetting a widget, in which case there shouldn't be a response of any sort. For example, if you're initialising your slider bar before the scene is set up, and your slider bar is used to control some part of your scene, firing an event would cause an error. Below is a list of the different handlers. All handlers have return type void.</p><ul>
<li><b>buttonHit</b>: Gives you a pointer to the Button which was hit.</li>
<li><b>itemSelected</b>: Gives you a pointer to the SelectMenu the item was chosen from. You can then use the SelectMenu to see which item was selected.</li>
<li><b>labelHit</b>: Gives you a pointer to the Label that was clicked.</li>
<li><b>sliderMoved</b>: Gives you a pointer to the Slider whose value was changed. You can then use the Slider to see what its new value is. Also, you can convert this value into a more suitable form and display it using Slider::setDisplayedValue.</li>
<li><b>checkBoxToggled</b>: Gives you a pointer to the CheckBox whose state was changed. You can then use the CheckBox to see if it's been checked or unchecked.</li>
<li><b>okDialogClosed</b>: Gives you the message of the OK dialog that was closed.</li>
<li><b>yesNoDialogClosed</b>: Gives you the question of the Yes-No dialog that was closed, and a boolean indicating whether or not the Yes button was pressed.</li>
</ul>
<h1><a class="anchor" id="things-to-try"></a>
Things to Try</h1>
<p>Getting access to widgets: </p><div class="fragment"><div class="line">Button* b;</div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);  <span class="comment">// by tray and position</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by tray and name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#af968c01a627ee654409f558e4ef55537">getWidgetIterator</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>).<a class="code" href="class_ogre_1_1_vector_iterator_wrapper.html#a2460c8adb6819235849de954db6a0f64">getNext</a>();  <span class="comment">// by iterator</span></div></div><!-- fragment --><p> Counting widgets: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>();  <span class="comment">// total</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);  <span class="comment">// by tray</span></div></div><!-- fragment --><p> Moving widgets to other trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div></div><!-- fragment --><p> Removing widgets from trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a04a1085bdee61d7234849663cce08664">TL_NONE</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a77ba6e4d641c146e262b6cdd2c8b04a0">clearTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9787ec5e8989bf6cfa89d03c6ddd27b6">clearAllTrays</a>();</div></div><!-- fragment --><p> Destroying widgets: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4a89cd6f7d87e0e538aa842f1a42a7bc">destroyAllWidgetsInTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aadb1f5a3b7e3b5397b10bdd3449e1603">destroyAllWidgets</a>();</div></div><!-- fragment --><p> Finding the position of a widget in a tray: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa993d2b60cfbcb903aecbff1c4896b67">locateWidgetInTray</a>(b);</div></div><!-- fragment --><p> Finding the tray a widget is in: </p><div class="fragment"><div class="line"><a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530">TrayLocation</a> trayLoc = b-&gt;getTrayLocation();</div></div><!-- fragment --><p> Changing the tray listener object: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a3235fea714a0c61e463dee69ae308be8">setListener</a>(newListener);</div></div><!-- fragment --><p> Toggling system visibility: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a075805136b2241cbb03eeb2c3d27b40d">showAll</a>();</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a188f1d5f5ca16af3b28d11ecd553105a">hideAll</a>();</div></div><!-- fragment --><p> Changing horizontal widget alignment in one tray: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#adfbbc97615fd5f1a939be6e7a1f00c07">setTrayWidgetAlignment</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <a class="code" href="group___overlays.html#gga3396780cdb2d731aa5e4389148bdc5f3a270f18cf07dbe4e75e1b790d02924205">GHA_RIGHT</a>);</div></div><!-- fragment --><p> Changing spacing and padding: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a33a3e3f66a3989dd3de48b4c4577422f">setWidgetSpacing</a>(5);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a52d3fc8638533540232232c37b257de6">setWidgetPadding</a>(3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a866229b6d88dc9d3a609115eaab46e67">setTrayPadding</a>(12);</div></div><!-- fragment --><p> Casting 3D ray from under cursor into the scene: </p><div class="fragment"><div class="line">Ray r = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9dd5d303968329462e9bf4225f59722e">getCursorRay</a>(mCamera);</div></div><!-- fragment --><p> Casting 3D ray from any 2D screen coordinate into the scene: </p><div class="fragment"><div class="line">Ray r = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#a6833f46b0303b559a050f310fa0204fc">OgreBites::TrayManager::screenToScene</a>(mCamera, Vector2(320, 240));</div></div><!-- fragment --><p> Converting a 3D scene coordinate to a 2D screen coordinate: </p><div class="fragment"><div class="line">Vector2 p = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa7a456c2c0c37123e2ab0e497f2c0ccc">OgreBites::TrayManager::sceneToScreen</a>(mCamera, Vector3::ZERO);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: HLMS: High Level Material System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('hlms.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">HLMS: High Level Material System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#components">The three components</a></li>
<li class="level1"><a href="#materials">Compared to classical materials</a></li>
<li class="level1"><a href="#data">Material parameters are stored in “Blocks”</a><ul><li class="level2"><a href="#toc52">Datablocks</a></li>
</ul>
</li>
<li class="level1"><a href="#toc69">Hlms templates</a><ul><li class="level2"><a href="#preproc">The Hlms preprocessor</a></li>
<li class="level2"><a href="#syntax">Preprocessor syntax</a></li>
</ul>
</li>
<li class="level1"><a href="#shaders">Creation of shaders</a></li>
<li class="level1"><a href="#cpp">C++ interaction with shader templates</a></li>
<li class="level1"><a href="#customization">Customization</a></li>
</ul>
</div>
<div class="textblock"><p>This component allows you to manage shader variations of a specific shader template. It is a different take to the Uber shader management, but instead of using plain <code>#ifdef</code>s it uses a custom, more powerful preprocessor language.</p>
<p>Additionally it allows you to define a set of abstract properties that are then used to configure the shader generation.</p>
<p>Basically it solves the same problem like the <a class="el" href="rtss.html">RTSS: Run Time Shader System</a> : automatically generate a shader based on an abstract description so you do not have to write them yourself.</p>
<p>But while the RTSS uses the classical <a class="el" href="_material-_scripts.html">Material Scripts</a> and several C++ classes to glue code together, the HLMS instead relies on textual shader templates.</p>
<p>Currently there is only the Physically Based Shading (PBS) material implementation based on the HLMS that does not read the classical Materials and therefore does not respect the settings for fog, diffuse_color etc.</p>
<h1><a class="anchor" id="components"></a>
The three components</h1>
<div class="image">
<object type="image/svg+xml" data="hlms_components.svg">hlms_components.svg</object>
</div>
<ol type="1">
<li>Scripts. To set the material properties (i.e. type of Hlms to use: PBS, Toon shading, GUI; what textures, diffuse colour, roughness, etc). <b>You currently have to do this from C++.</b> Everybody will be using this part.</li>
<li>Shader template. The Hlms takes a couple hand-written glsl/hlsl files as template and then adapts it to fit the needs on the fly (i.e. if the mesh doesn’t contain skeleton, the bit of code pertaining to skeletal animation is stripped from the vertex shader). The Hlms provides a simple preprocessor to deal with this entirely within from the template, but you’re not forced to use it. Here’s a simple example of the preprocessor. I won’t be explaining the main keywords today. Advanced users will probably want to modify these files (or write some of their own) to fit their custom needs.</li>
<li>C++ classes implementation. The C++ takes care of picking the shader templates and manipulating them before compiling; and most importantly it feeds the shaders with uniform/constans data and sets the textures that are being in use. It is extremely flexible, powerful, efficient and scalable, but it’s harder to use than good ol’ Materials because those used to be data-driven: there are no AutoParamsSource here. Want the view matrix? You better grab it from the camera when the scene pass is about to start, and then pass it yourself to the shader. This is very powerful, because in D3D11/GL3+ you can just set the uniform buffer with the view matrix just once for the entire frame, and thus have multiple uniforms buffers sorted by update frequency. Very advanced user will be using messing with this part.</li>
</ol>
<dl class="section note"><dt>Note</dt><dd>Material scripts in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 1.x do not yet support the HLMS - you must use the C++ API. e.g. <a class="el" href="class_ogre_1_1_pbs_material.html">Ogre::PbsMaterial</a>.</dd></dl>
<p>Based on your skillset and needs, you can pick up to which parts you want to mess with. Most users will just use the scripts to define materials, advanced users will change the template, and very advanced users who need something entirely different will change all three.</p>
<p>For example the PBS material has its own C++ implementation and its own set of shader templates. The Toon Shading has its own C++ implementation and set of shaders.</p>
<p>It is theoretically possible to implement both Toon &amp; PBS in the same C++ module, but that would be crazy, hard to maintain and not very modular.</p>
<h1><a class="anchor" id="materials"></a>
Compared to classical materials</h1>
<p>Materials are still useful for:</p>
<ul>
<li>Quick iteration. You need to write a shader, just define the material and start coding. Why would you deal with the template’s syntax or a C++ module when you can just write a script and start coding?. The HLMS though comes with a Command line tool to know how your template translates into a final shader (which is very handy for iteration, it’s fast, and will check for syntax errors!), but it’s most useful when you want to write your own C++ module or change the template, not when you want to just experiment. Besides, old timers are used to writing materials.</li>
<li>Postprocessing effects. Materials are much better suited for this. Materials are data driven, easy to write. Postprocessing FXs don’t need an awful lot of permutations (i.e. having to deal with shadow mapping, instancing, skeleton animation, facial animation). And they’re at no performance disadvantage compared to HLMS: Each FX is a fullscreen pass that needs different shaders, different textures, its own uniforms. Basically, API overhead we can’t optimize. But it doesn’t matter much either, because it’s not like there are 100 fullscreen passes. Usually there’s less than 10.</li>
</ul>
<h1><a class="anchor" id="data"></a>
Material parameters are stored in “Blocks”</h1>
<p>You could be thinking the reason I came up with these two is to fit with D3D11′s grand scheme of things while being compatible with OpenGL. But that’s a half truth and an awesome side effect. I’ve been developing the Hlms using OpenGL this whole time.</p>
<p>An OpenGL fan will tell you that grouping these together in single call like D3D11 did barely reduce API overhead in practice (as long as you keep sorting by state), and they’re right about that.</p>
<p>However, there are big advantages for using blocks:</p>
<ol type="1">
<li>Many materials in practice share the same Macro- &amp; Blendblock parameters. In an age where we want many 3D primitives with the same shader but slightly different parameters like texture, colour, or roughness (which equals, a different material) having these settings repeated per material wastes a lot of memory space… and a lot of bandwidth (and wastes cache space). <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 is bandwidth bound, so having all materials share the same pointer to the same Macroblock can potentially save a lot of bandwidth, and be friendlier to the cache at the same time.This stays true whether we use D3D11, D3D12, OpenGL, GL ES 2, or Mantle.</li>
<li>Sorting by Macroblock is a lot easier (and faster) than sorting by its individual parameters: when preparing the hash used for sorting, it’s much easier to just do (every frame, per object) <code>hash |= (macroblock-&gt;getId() &lt;&lt; bits) &amp; mask</code> than to do: <code>hash =| m-&gt;depth_check | m-&gt;depthWrite &lt;&lt; 1 | m-&gt;depthBias &lt;&lt; 2 | m-&gt;depth_slope_bias &lt;&lt; 3 | m-&gt;cullMode &lt;&lt; 18 | ... ;</code> We also need a lot more bits we can’t afford. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> 2.0 imposes a limit on the amount of live Macroblocks you can have at the same time; as we run out of hashing space (by the way, D3D11 has its own limit). It operates around the idea that most setting combinations won’t be used in practice.</li>
</ol>
<p>Of course it’s not perfect, it can’t fit every use case. We inherit the same problems D3D11 has. If a particular rendering technique relies on regularly changing a property that lives in a Macroblock (i.e. like alternating depth comparison function between less &amp; greater with every draw call, or gradually incrementing the depth bias on each draw call); you’ll end up redundantly changing a lot of other states (culling mode, polygon mode, depth check &amp; write flags, depth bias) alongside it. This is rare. We’re aiming the general use case.</p>
<p>These problems make me wonder if D3D11 made the right choice of using blocks from an API perspective, since I’m not used to driver development. However from an engine perspective, blocks make sense.</p>
<h2><a class="anchor" id="toc52"></a>
Datablocks</h2>
<p>We’re introducing the concept of Datablocks. A Datablock is a “material” from the user’s perspective. It holds data (i.e. material properties) that will be passed directly to the shaders.</p>
<div class="image">
<object type="image/svg+xml" data="hlms_blocks.svg">hlms_blocks.svg</object>
</div>
<p>The diagram shows a typical layout of a datablock. Samplerblocks do not live inside base <a class="el" href="class_ogre_1_1_hlms_datablock.html">Ogre::HlmsDatablock</a>, but rather in its derived implementation. This is because some implementations may not need textures at all, and the number of samplerblocks is unknown. Some implementations may want one samplerblock per texture, whereas others may just need one.</p>
<dl class="section note"><dt>Note</dt><dd>Macroblocks and Blendblocks are not available in 1.x - use <a class="el" href="class_ogre_1_1_pass.html#ae454faee87f8cb0b8540810e48118788" title="Sets whether or not this pass renders with depth-buffer checking on or not. ">Ogre::Pass::setDepthCheckEnabled</a> etc. as usual, to change the respective properties</dd></dl>
<h1><a class="anchor" id="toc69"></a>
Hlms templates</h1>
<p>The Hlms will parse the template files from the template folder according to the following rules:</p>
<ol type="1">
<li>The files with the names "VertexShader_vs", "PixelShader_ps", "GeometryShader_gs", "HullShader_hs", "DomainShader_ds" will be fully parsed and compiled into the shader. If an implementation only provides "VertexShader_vs.glslt", "PixelShader_ps.glslt"; only the vertex and pixel shaders for OpenGL will be created. There will be no geometry or tesellation shaders.</li>
<li>The files that contain the string "_piece_vs" in their filenames will be parsed only for collecting pieces (more on pieces later). Likewise, the words "_piece_ps", "_piece_gs", "_piece_hs", "_piece_ds” correspond to the pieces for their respective shader stages. Note that you can concatenate, thus "MyUtilities_piece_vs_piece_ps.glslt” will be collected both in the vertex and pixel shader stages.</li>
</ol>
<p>The Hlms takes a template file (i.e. a file written in GLSL or HLSL) and spits out valid shader code. Templates can take advantage of the Hlms' preprocessor, which is a simple yet powerful macro-like preprocessor that helps writing the required code.</p>
<h2><a class="anchor" id="preproc"></a>
The Hlms preprocessor</h2>
<p>The preprocessor was written with speed and simplicity in mind. It does not implement an AST or anything fancy. This is very important to account while writing templates because there will be cases when using the preprocessor may feel counter-intuitive or frustrating.</p>
<p>For example </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( IncludeLighting )</div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>is analogous to </p><div class="fragment"><div class="line"><span class="preprocessor">#if IncludeLighting != 0</span></div><div class="line"></div><div class="line"><span class="comment">/* code here */</span></div><div class="line"></div><div class="line"><span class="preprocessor">#endif</span></div></div><!-- fragment --><p>However you can't evaluate IncludeLighting to anything other than zero and non-zero, i.e. you can't check whether IncludeLighting == 2 with the Hlms preprocessor. A simple workaround is to define, from C++, the variable “IncludeLightingEquals2” and check whether it's non-zero. Another solution is to use the GLSL/HLSL preprocessor itself instead of Hlms'. However, the advantage of Hlms is that you can see its generated output in a file for inspection, whereas you can't see the GLSL/HLSL after the macro preprocessor without vendor-specific tools. Plus, in the case of GLSL, you'll depend on the driver implementation having a good macro preprocessor.</p>
<h2><a class="anchor" id="syntax"></a>
Preprocessor syntax</h2>
<p>The preprocessor always starts with @ followed by the command, and often with arguments inside parenthesis. Note that the preprocessor is always case-sensitive. The following keywords are recognized:</p>
<ul>
<li>@property</li>
<li>@foreach</li>
<li>@counter</li>
<li>@value</li>
<li>@set add sub mul div mod min max</li>
<li>@piece</li>
<li>@insertpiece</li>
<li>@pset padd psub pmul pdiv pmod pmin pmax</li>
</ul>
<h3>@property( expression )</h3>
<p>Checks whether the variables in the expression are true, if so, the text inside the block is printed. Must be finazlied with @end. The expression is case-sensitive. When the variable hasn't been declared, it evaluates to false.</p>
<p>The logical operands &amp;&amp; || ! are valid.</p>
<p>Examples: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_skeleton &amp;&amp; !hlms_normal )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has skeleton animation but no normals</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal || hlms_tangent )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals or tangents</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( hlms_normal &amp;&amp; (!hlms_skeleton || hlms_tangent) )</div><div class="line"></div><div class="line"><span class="comment">//Print this code if it has normals and either no skeleton or tangents</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>It is very similar to #if hlms_skeleton != 0 #endif; however there is no equivalent #else or #elif syntax. As a simple workaround you can do: </p><div class="fragment"><div class="line">\<span class="keyword">@property</span>( hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Skeleton animation code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span> \<span class="keyword">@property</span>( !hlms_skeleton )</div><div class="line"></div><div class="line"><span class="comment">//Non-Skeleton code here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><p>Newlines are not necessary. The following is perfectly valid: </p><div class="fragment"><div class="line">diffuse = surfaceDiffuse \@property( hasLights )* lightDiffuse@end ;</div></div><!-- fragment --><p>Which will print: </p><div class="fragment"><div class="line">hasLights != 0                              hasLights == 0</div><div class="line">diffuse = surfaceDiffuse * lightDiffuse;   diffuse = surfaceDiffuse ;</div></div><!-- fragment --><h3>@foreach( scopedVar, count, [start] )</h3>
<p>Loop that prints the text inside the block, The text is repeated count - start times. Must be finalized with @end.</p>
<ul>
<li>scopedVar is a variable that can be used to print the current iteration of the loop while inside the block. i.e. “@scopedVar” will be converted into a number in the range [start; count)</li>
<li>count The number of times to repeat the loop (if start = 0). Count can read variables.</li>
<li>start Optional. Allows to start from a value different than 0. Start can read variables.</li>
</ul>
<p>Newlines are very important, as they will be printed with the loop.</p>
<p>Examples: </p><table class="doxtable">
<tr>
<th>Expression </th><th>Output  </th></tr>
<tr>
<td>@foreach( 4, n ) <br />
&emsp; @n@end </td><td><br />
0<br />
1<br />
2<br />
3 </td></tr>
<tr>
<td>@foreach( 4, n ) @n@end </td><td>0 1 2 3 </td></tr>
<tr>
<td>@foreach( 4, n )<br />
&emsp;@n<br />
@end </td><td><br />
0<br />
<br />
1<br />
<br />
2<br />
<br />
3<br />
 </td></tr>
<tr>
<td>@foreach( 4, n, 2 ) @n@end </td><td>2 3 </td></tr>
<tr>
<td>@pset( myStartVar, 1 )<br />
@pset( myCountVar, 3 )<br />
@foreach( myStartVar, n, myCountVar )<br />
&emsp;@n@end </td><td>1<br />
2 </td></tr>
<tr>
<td>@foreach( 2, n )<br />
&emsp;@insertpiece( pieceName@n )@end </td><td>@insertpiece( pieceName0 )<br />
 @insertpiece( pieceName1 ) </td></tr>
</table>
<blockquote class="doxtable">
<p><b>Attention #1!</b></p>
<p>Don't use the common letter i for the loop counter. It will conflict with other keywords.</p>
<p>i.e. “@foreach( 1, i )@insertpiece( pieceName )@end” will print “0nsertpiece( pieceName )” which is probably not what you intended.</p>
<p><b>Attention #2!</b></p>
<p>foreach is parsed after property math (pset, padd, etc). That means that driving each iteration through a combination of properties and padd functions will not work as you would expect.</p>
<p>i.e. The following code will not work:</p>
<div class="fragment"><div class="line">@pset( myVar, 1 )</div><div class="line"></div><div class="line">@<span class="keywordflow">foreach</span>( 2, n )</div><div class="line"></div><div class="line"><span class="comment">//Code</span></div><div class="line"></div><div class="line">@psub( myVar, 1 ) <span class="comment">//Decrement myVar on each loop</span></div><div class="line"></div><div class="line">\<span class="keyword">@property</span>( myVar )</div><div class="line"></div><div class="line"><span class="comment">//Code that shouldn&#39;t be printed in the last iteration</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div><div class="line"></div><div class="line">@end</div></div><!-- fragment --><p>Because psub will be evaluated before expanding the foreach. </p>
</blockquote>
<h3>@counter( variable )</h3>
<p>Prints the current value of variable and increments it by 1. If the variable hasn't been declared yet, it is initialized to 0.</p>
<p>Examples: </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@counter( myVar )   1</div><div class="line"></div><div class="line">@counter( myVar )   2</div></div><!-- fragment --><h3>@value( variable )</h3>
<p>Prints the current value of variable without incrementing it. If the variable hasn't been declared, prints 0. </p><div class="fragment"><div class="line">Expression          Output</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@value( myVar )     0</div><div class="line"></div><div class="line">@counter( myVar )   0</div><div class="line"></div><div class="line">@value( myVar )     1</div><div class="line"></div><div class="line">@value( myVar )     1</div></div><!-- fragment --><h3>@set add sub mul div mod min max</h3>
<p>Sets a variable to a given value, adds, subtracts, multiplies, divides, calculates modulus, or the minimum/maximum of a variable and a constant, or two variables. This family of functions get evaluated after foreach(s) have been expanded and pieces have been inserted. Doesn't print its value.</p>
<p>Arguments can be in the form @add(a, b) meaning a += b; or in the form @add( a, b, c ) meaning a = b + c</p>
<p>Useful in combination with @counter and @value</p>
<table class="doxtable">
<tr>
<th>Expression </th><th>Output </th><th>Math  </th></tr>
<tr>
<td>@set( myVar, 1 ) <br />
 @value( myVar ) </td><td>1 </td><td>myVar = 1 </td></tr>
<tr>
<td>@add( myVar, 5 )<br />
 @value( myVar ) </td><td>6 </td><td>myVar = 1 + 5 </td></tr>
<tr>
<td>@div( myVar, 2 ) <br />
 @value( myVar ) </td><td>3 </td><td>myVar = 6 / 2 </td></tr>
<tr>
<td>@mul( myVar, myVar )<br />
 @value( myVar ) </td><td>9 </td><td>myVar = 3 * 3 </td></tr>
<tr>
<td>@mod( myVar, 5 ) <br />
 @value( myVar ) </td><td>4 </td><td>myVar = 9 % 5 </td></tr>
<tr>
<td>@add( myVar, 1, 1 ) <br />
 @value( myVar ) </td><td>2 </td><td>myVar = 1 + 1 </td></tr>
</table>
<h3>@piece( nameOfPiece )</h3>
<p>Saves all the text inside the blocks and saves it as a named piece. If a piece with the given name already exists, a compiler error will be thrown. The text that was inside the block won't be printed. Useful when in combination with @insertpiece. Pieces can also be defined from C++ or <a href="#toc69"><em>collected</em></a> from piece template files.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                        Output</div><div class="line"></div><div class="line">@piece( VertexTransform )         </div><div class="line"></div><div class="line">outPos = worldViewProj * inPos   </div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --><h3>@insertpiece( nameOfPiece )</h3>
<p>Prints a block of text that was previously saved with piece (or from C++). If no piece with such name exists, prints nothing.</p>
<p>Example: </p><div class="fragment"><div class="line">Expression                                                     Output</div><div class="line"></div><div class="line">@piece( VertexTransform )outPos = worldViewProj * inPos@end   void main()</div><div class="line"></div><div class="line">void main()                                                    {</div><div class="line"></div><div class="line">{                                                              outPos = worldViewProj * inPos</div><div class="line"></div><div class="line">@insertpiece( VertexTransform )                                }</div><div class="line"></div><div class="line">@insertpiece( InexistentPiece )                                </div><div class="line"></div><div class="line">}</div></div><!-- fragment --><h3>@pset padd psub pmul pdiv pmod pmin pmax</h3>
<p>Analogous to <a href="#toc304"><em>the family of math functions without the 'p' prefix</em></a>. The difference is that the math is evaluated before anything else. There is no much use to these functions, probably except for quickly testing whether a given flag/variable is being properly set from C++ without having to recompile.</p>
<p>i.e. If you suspect hlms_normal is never being set, try @pset( hlms_normal, 1 )</p>
<p>One important use worth mentioning, is that variables retain their values across shader stages. First the vertex shader template is parsed, then the pixel shader one. If 'myVal' is 0 and the vertex shader contains @counter( myVal ); when the pixel shader is parsed @value( myVal ) will return 1, not 0.</p>
<p>If you need to reset these variables across shader stages, you can use pset( myVal, 0 ); which is guaranteed to reset your variable to 0 before anything else happens; even if the pset is stored in a piece file.</p>
<h1><a class="anchor" id="shaders"></a>
Creation of shaders</h1>
<p>There are two components that needs to be evaluated that may affect the shader itself and would need to be recompiled:</p>
<ol type="1">
<li>The Datablock/Material. Does it have Normal maps? Then include code to sample the normal map and affect the lighting calculations. Does it have a diffuse map? If not, avoid sampling the diffuse map and multiplying it against the diffuse colour, etc.</li>
<li>The Mesh. Is it skeletally animated? Then include skeletal animation code. How many blend weights? Modify the skeletal animation code appropiately. It doesn't have tangents? Then skip the normal map defined in the material. And so on.</li>
</ol>
<p>When calling <a class="el" href="class_ogre_1_1_scene_manager.html#a29ba8a2cad151d307d04781f749e7e84" title="Prompts the class to send its contents to the renderer. ">Ogre::SceneManager::_renderScene</a>, what happens is that <a class="el" href="group___hlms.html#ga72e50c625adeeef2ca44ba7281c92574">Ogre::ShaderManager::getGpuProgram</a> will get called and this function evaluates both the mesh and datablock compatibility.</p>
<p>If they're compatible, all the variables (aka properties) and pieces are generated and cached in a structure (mShaderCache) with a hash key to this cache entry. If a different pair of datablock-mesh ends up having the same properties and pieces, they will get the same hash (and share the same shader).</p>
<p>The following graph summarizes the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_hash.svg">hlms_hash.svg</object>
</div>
<p>Later on during rendering, at the start each render pass, a similar process is done, which ends up generating a “<a href="#toc567"><em>pass hash</em></a>” instead of a renderable hash. Pass data stores settings like number of shadow casting lights, number of lights per type (directional, point, spot).</p>
<p>While iterating each renderable for render, the hash key is read from the Renderable and merged with the pass' hash. With the merged hash, the shader is retrieved from a cache. If it's not in the cache, the shader will be generated and compiled by merging the cached data (pieces and variables) from the Renderable and the Pass. The following graph illustrates the process:</p>
<div class="image">
<object type="image/svg+xml" data="hlms_caching.svg">hlms_caching.svg</object>
</div>
<h1><a class="anchor" id="cpp"></a>
C++ interaction with shader templates</h1>
<p>Note: This section is relevant to those seeking to write their own Hlms implementation.</p>
<p>C++ can use <a class="el" href="group___hlms.html#ga650d837deeed1b6756ac0adb3f7b6eef">Ogre::HlmsMaterialBase::getPropertyMap()</a>.setProperty( "key", value ) to set “key” to the given value. This value can be read by @property, @foreach, @add/sub/mul/div/mod, @counter, @value and @padd/psub/pmul/pdiv/pmod</p>
<p>To create pieces (or read them) you need to pass your custom Hlms::PiecesMap to Hlms::addRenderableCache.</p>
<p>The recommended place to do this is in Hlms::calculateHashForPreCreate and Hlms::calculateHashForPreCaster. Both are virtual. The former gets called right before adding the set of properties, pieces and hash to the cache, while the latter happens right before adding the similar set for the shadow caster pass.</p>
<p>In those two functions you get the chance to call setProperty to set your own variables and add your own pieces.</p>
<p>Another option is to overload Hlms::calculateHashFor which gives you more control but you'll have to do some of the work the base class does.</p>
<p>For some particularly complex features, the Hlms preprocessor may not be enough, too difficult, or just impossible to implement, and thus you can generate the string from C++ and send it as a piece. The template shader can insert it using @insertpiece.</p>
<p>The function Hlms::createShaderCacheEntry is the main responsible for generating the shaders and parsing the template through the Hlms preprocessor. If you overload it, you can ignore pieces, properties; basically override the entire Hlms system and provide the source for the shaders yourself.</p>
<h2>Common conventions</h2>
<p>Properties starting with 'hlms_' prefix are common to all or most Hlms implementations. i.e. 'hlms_skeleton' is set to 1 when a skeleton is present and hardware skinning should be performed.</p>
<p>Save properties' IdStrings (hashed strings) into constant as performance optimizations. Ideally the compiler should detect the constant propagation and this shouldn't be needed, but this often isn't the case.</p>
<p>For mobile, avoid mat4 and do the math yourself. As for 4x3 matrices (i.e. skinning), perform the math manually as many GLES2 drivers have issues compiling valid glsl code.</p>
<p>Properties in underscore_case are set from C++; propierties in camelCase are set from the template.</p>
<p>Propierties and pieces starting with 'custom_' are for user customizations of the template</p>
<p>TBD</p>
<h2>Disabling a stage</h2>
<p>By default if a template isn't present, the shader stage won't be created. e.g. if there is no GeometryShader_gs.glsl file, no geometry shader will be created. However there are times where you want to use a template but only use this stage in particular scenarios (e.g. toggled by a material parameter, disable it for shadow mapping, etc.). In this case, set the property hlms_disable_stage to non-zero from within the template (i.e. using @set) . The value of this property is reset to 0 for every stage.</p>
<p>Note that even when disabled, the Hlms template will be fully parsed and dumped to disk; and any modification you perform to the Hlms properties will be carried over to the next stages. Setting hlms_disable_stage is not an early out or an abort.</p>
<h1><a class="anchor" id="customization"></a>
Customization</h1>
<p>In many cases, users may want to slightly customize the shaders to achieve a particular look, implement a specific feature, or solve a unique problem; without having to rewrite the whole implementation.</p>
<p>Maximum flexibility can be get by directly modifying the original source code. However this isn't modular, making it difficult to merge when the original source code has changed. Most of of the customizations don't require such intrusive approach.</p>
<p>Note: For performance reasons, the listener interface does not allow you to add customizations that work per Renderable, as that loop is performance sensitive. The only listener callback that works inside Hlms::fillBuffersFor is hlmsTypeChanged which only gets evaluated when the previous Renderable used a different Hlms implementation; which is rare, and since we sort the RenderQueue, it often branch predicts well.</p>
<p>There are different levels in which an Hlms implementation can be customized:</p>
<ol type="1">
<li>Using a library, see <a href="#toc574"><em>Hlms Initialization</em></a>. pass a set of piece files in a folder by pushing the folder to ArchiveVec. The files in that folder will be parsed first, in order (archiveVec[0] then archiveVec[1], … archiveVec[N-1]); which will let you define your own pieces to insert code into the default template (see the the table at the end). You can also do clever tricky things to avoid dealing with C++ code at all even if there are no 'custom_' pieces for it. For example, you can write the following code to override the BRDF declarations and provide a custom BRDF: <div class="fragment"><div class="line"><span class="comment">//Disable all known BRDFs that the implementation may enable</span></div><div class="line"></div><div class="line">@pset( BRDF_CookTorrance, 0 )</div><div class="line"></div><div class="line">@pset( BRDF_Default, 0 )</div><div class="line"></div><div class="line">@piece( DeclareBRDF )</div><div class="line"></div><div class="line"><span class="comment">// Your BRDF code declaration here</span></div><div class="line"></div><div class="line"><span class="keyword">@end</span></div></div><!-- fragment --></li>
</ol>
<ol type="1">
<li>Via listener, through HlmsListener. This allows you to have access to the buffer pass to fill extra information; or bind extra buffers to the shader.</li>
<li>Overload HlmsPbs. Useful for overriding only specific parts, or adding new functionality that requires storing extra information in a datablock (e.g. overload HlmsPbsDatablock to add more variables, and then overload HlmsPbs::createDatablockImpl to create these custom datablocks)</li>
<li>Directly modify HlmsPbs, HlmsPbsDatablock and the template. <table class="doxtable">
<tr>
<th>Variable </th><th>Description  </th></tr>
<tr>
<td>custom_passBuffer </td><td>Piece where users can add extra information for the pass buffer (only useful if the user is using HlmsListener or overloaded HlmsPbs. </td></tr>
<tr>
<td>custom_VStoPS </td><td>Piece where users can add more interpolants for passing data from the vertex to the pixel shader. </td></tr>
<tr>
<td>custom_vs_attributes </td><td>Custom vertex shader attributes in the Vertex Shader (i.e. a special texcoord, etc). </td></tr>
<tr>
<td>custom_vs_uniformDeclaration </td><td>Data declaration (textures, texture buffers, uniform buffers) in the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Vertex Shader. </td></tr>
<tr>
<td>custom_vs_posExecution </td><td>Executed after all code from the Vertex Shader has been performed. </td></tr>
<tr>
<td>custom_ps_uniformDeclaration </td><td>Same as custom_vs_uniformDeclaration, but for the Pixel Shader </td></tr>
<tr>
<td>custom_ps_preExecution </td><td>Executed before <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>'s code from the Pixel Shader. </td></tr>
<tr>
<td>custom_ps_posMaterialLoad </td><td>Executed right after loading material data; and before anything else. May not get executed if there is no relevant material data (i.e. doesn't have normals or QTangents for lighting calculation) </td></tr>
<tr>
<td>custom_ps_preLights </td><td>Executed right before any light (i.e. to perform your own ambient / global illumination pass). All relevant texture data should be loaded by now. </td></tr>
<tr>
<td>custom_ps_posExecution </td><td>Executed after all code from the Pixel Shader has been performed. </td></tr>
</table>
</li>
</ol>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Volume Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('volume.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Volume Component </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howto">How to use it</a></li>
<li class="level1"><a href="#creation">Manual creation of a CSG-Tree</a></li>
<li class="level1"><a href="#triangles">Getting the triangles of the chunks</a></li>
<li class="level1"><a href="#intersecting">Intersecting a ray with a volume</a></li>
<li class="level1"><a href="#editing">Editing a Volume made from a GridSource</a></li>
</ul>
</div>
<div class="textblock"><p>Welcome to the Volume Component of OGRE. It is a component to render volumes. It can handle any volume data but featurewise has a tedency towards terrains. The terrain aspect means, that it's all about huge meshes being displayed with high performance via a level of detail mechanism. Thanks to volume rendering, caves, cliffes, holes and similar geometry can be displayed. Also constructive solid geometry gets easy.</p>
<p>A dense list of the features:</p><ul>
<li>Volume Rendering via Dual Marching Cubes</li>
<li>LOD mechanism via a chunk tree and marching squares skirts for crack patching</li>
<li>Data-Sources: 3D Textures with density values and the ability to buildup a CSG-Tree with 3D Textures, Spheres, Cubes, Planes, Intersection, Union, Difference and Negation, SimplexNoise addition</li>
<li>Loading a 3D Texture Scene from config files</li>
<li>An own file format for discrete density values which compresses a lot better</li>
<li>Realtime editing</li>
<li>Serialization and Deserialization from and to an own file format for discrete density values which compresses a lot better than 3D textures</li>
<li>A triplanar texturing example material</li>
<li>A triplanar texturing SubRenderState for the RTSS</li>
</ul>
<p>This documentation is only intended for the usage of the Volume Component, not the algorithms which make it work. If you want to get to know the theory behind it, you can read the articles on this page: <a href="http://volume-gfx.com/">http://volume-gfx.com/</a></p>
<h1><a class="anchor" id="howto"></a>
How to use it</h1>
<p>Here is an example loading the volume scene from a configuration file. The configuration file must be findable by the resource system of course. Only "OgreVolumeChunk.h" has to be included. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> <a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a>();</div><div class="line">SceneNode *volumeRootNode = mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(<span class="stringliteral">&quot;VolumeParent&quot;</span>);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, mSceneMgr, <span class="stringliteral">&quot;volumeTerrain.cfg&quot;</span>);</div></div><!-- fragment --><p> The first line creates the volume chunk which is the MovableObject holding the Volume-Root. Next, a SceneNode is created where the volume(-tree) is attached to. And lastly, the volume is loaded from the configuration file "volumeTerrain.cfg". mSceneMgr is the SceneManager who should show the volume. Later, when you don't need it anymore, you have to free the volumeRoot Chunk via OGRE_DELETE.</p>
<h1><a class="anchor" id="creation"></a>
Manual creation of a CSG-Tree</h1>
<p>This example skips the configuration file and loads a simple CSG-Scene: An union of a 3D Texture and a sphere with 5 LOD levels. It also setups a material LOD system. First, create a sphere with the radius 5 at the coordinates 128, 150, 128: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_sphere_source.html">Ogre::Volume::CSGSphereSource</a> sphere (5, Vector3(128, 150, 128));</div></div><!-- fragment --><p> Now a 3D texture from "volumeTerrainBig.dds" which has the world dimensions 256, 256, 256. The next flag indicates that the trilinear interpolation of the value-selection should be activated. We switch off the trilinear interpolation and the sobel filter of the normal for the sake of faster loading times: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_texture_source.html">Ogre::Volume::TextureSource</a> volumeTexture (<span class="stringliteral">&quot;volumeTerrainBig.dds&quot;</span>, 256, 256, 256, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div></div><!-- fragment --><p> Now combine them: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_union_source.html">Ogre::Volume::CSGUnionSource</a> unionSrc (&amp;sphere, &amp;volumeTexture);</div></div><!-- fragment --><p> Set the general parameters, see the comments for their meaning: </p><div class="fragment"><div class="line"><a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html">Ogre::Volume::ChunkParameters</a> parameters;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a3e154a179b8c824f79b1b426608743ad">sceneManager</a> = mSceneMgr;       <span class="comment">// The SceneManager to use</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a> = &amp;unionSrc;                <span class="comment">// The just created density source.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a4444eac27c71e02886615dcf7fbfed27">baseError</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.8;          <span class="comment">// The error of the highest LOD-level</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aa6186649b7323f937b83828eb86711fa">errorMultiplicator</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.9; <span class="comment">// The factor between each LOD-level (error = baseError * errorMultiplicator  * level)</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a986b4a97b153d50f65603ab507bb4614">skirtFactor</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.7;        <span class="comment">// Controls how long the skirts are. The lower the number, the shorter the skirts are. This saves geometry. But if they are too short, cracks might occure.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#af6ed62b76c67d04eb98424414fb1dc72">scale</a> = 10;                     <span class="comment">// The displayed volume will be scaled by this factor.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#ae125003c00de0d6c0a1a4bd6b99c4ebf">maxScreenSpaceError</a> = 30;       <span class="comment">// The screen space error controlling when the LOD-levels change.</span></div></div><!-- fragment --><p>Create the root-chunk and load now. The two vectors define the area to be scanned in the volume-source. The following integer determines the amount of LOD-levels. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> Chunk();</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(mVolumeRootNode, Vector3::ZERO, Vector3(256), 5, &amp;parameters);</div></div><!-- fragment --><p> Now setup the global volume material: </p><div class="fragment"><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a5129bccc53d17060635ada67443324f7">setMaterial</a>(<span class="stringliteral">&quot;triplanarReference&quot;</span>);</div></div><!-- fragment --> <h1><a class="anchor" id="triangles"></a>
Getting the triangles of the chunks</h1>
<p>When you want to integrate the volume triangles in a physics engine for example, you need to hand over the exact triangles. For this scenario, the ChunkParameters hold a pointer to a ''MeshBuilderCallback'' and a number ''lodCallbackLod''. The first is an interface with a single function ''trianglesReady'' which is called, when the triangles of a chunk are ready. The chunks are chosen via the ''lodCallbackLod''. If you build a volume with 3 LOD levels and you want the triangles of the highest detail level, you set this parameter to 3. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyMeshBuilderCallback : <span class="keyword">public</span> MeshBuilderCallback</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span>  ready(<span class="keyword">const</span> SimpleRenderable *simpleRenderable, <span class="keyword">const</span> <a class="code" href="group___volume.html#gabf42f450c9ea75c61753f6d485cb8357">VecVertex</a> &amp;vertices, <span class="keyword">const</span> <a class="code" href="group___volume.html#ga325b1df965bf0137edd13bb52bc422be">VecIndices</a> &amp;indices, <span class="keywordtype">size_t</span> level, <span class="keywordtype">int</span> inProcess)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">size_t</span> count = indices.size();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count; i += 3)</div><div class="line">        {</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v1 = vertices[indices[i]];</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v2 = vertices[indices[i + 1]];</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v3 = vertices[indices[i + 2]];</div><div class="line">            <span class="comment">// Do something with the Triangle...</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>And using it like this: </p><div class="fragment"><div class="line"><a class="code" href="group___volume.html#ga89fbc5eed010b8802358563eb88e674a">ChunkParameters</a> parameters;</div><div class="line">...</div><div class="line">MyMeshBuilderCallback callback;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a6403e2875cc7b81aefd43ba9f22c2b31">lodCallback</a> = &amp;callback;</div><div class="line">parameters.lodCallbackLod = 3;</div><div class="line">...</div><div class="line">rootChunk-&gt;load(parent, from, to, 3, &amp;parameters);</div></div><!-- fragment --><p> Or in case of loading from a configuration file: </p><div class="fragment"><div class="line">MyMeshBuilderCallback callback;</div><div class="line">rootChunk-&gt;load(parent, sceneManager, <span class="stringliteral">&quot;myVolume.cfg&quot;</span>, 0, &amp;callback, 3);</div></div><!-- fragment --><p>You might have seen, that a pointer to a SimpleRenderable is handed in, too. This is actually the Chunk whose triangles are loaded. It's parent class is used to not create a circular dependency. You might get the triangle data from it, too by getting the Renderoperation.</p>
<h1><a class="anchor" id="intersecting"></a>
Intersecting a ray with a volume</h1>
<p>When you want to do something exactly on the volume surface, you can cast rays and find their first intersection point. Behold that the triangle representation might be slightly different than the actual volume surface. And you have to scale the ray origin just like the volume. Here is an example which uses the negative z-axis of the camera as ray as it might be done like in an ego-shooter: </p><div class="fragment"><div class="line">Ray ray(mCamera-&gt;getPosition() / rootChunk-&gt;getScale(), -mCamera-&gt;getOrientation().zAxis());</div><div class="line">Vector3 intersection;</div><div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> scale = mVolumeRoot-&gt;getChunkParameters()-&gt;scale;</div><div class="line"><span class="keywordtype">bool</span> intersects = mVolumeRoot-&gt;getChunkParameters()-&gt;src-&gt;getFirstRayIntersection(ray, intersection, scale);</div><div class="line"><span class="keywordflow">if</span> (intersects)</div><div class="line">{</div><div class="line">    intersection *= scale; <span class="comment">// As it is in volume space.</span></div><div class="line">    <span class="comment">// Do something with intersection.</span></div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="editing"></a>
Editing a Volume made from a GridSource</h1>
<p>A usecase is realtime editing of volume terrain as seen as in the sample. Let's union the terrain with a sphere of the radius 2.5 and the center 123/123/123. <b>volumeRoot</b> is the Chunk instance with which the terrain was initially loaded. The factor 1.5 is just to have a save border arround the sphere which also gets updated. The rest of the parameters are 5 LOD levels and a volume mesh covering an area of 384^3. </p><div class="fragment"><div class="line">Vector3 center(123);</div><div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> radius = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)2.5;</div><div class="line">CSGSphereSource sphere(radius, center);</div><div class="line">CSGUnionSource operation;</div><div class="line"><span class="keyword">static_cast&lt;</span>GridSource*<span class="keyword">&gt;</span>(volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a>)-&gt;combineWithSource(&amp;operation, &amp;sphere, center, radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aeefacd1d618206fcb432ed947b58e06e">updateFrom</a> = center - radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5;</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#afe30999e8cc71a1f48d87d68bf43059d">updateTo</a> = center + radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5;</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, Vector3::ZERO, Vector3(384), 5, volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>());</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Trays GUI System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('trays.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Trays GUI System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#trays-1">Trays</a></li>
<li class="level1"><a href="#traymanager">TrayManager</a></li>
<li class="level1"><a href="#widgets">Widgets</a></li>
<li class="level1"><a href="#special-widgets">Special Widgets</a></li>
<li class="level1"><a href="#tray-listener">TrayListener</a></li>
<li class="level1"><a href="#things-to-try">Things to Try</a></li>
</ul>
</div>
<div class="textblock"><p>Ever wanted really simple GUI controls for your sample? Don't want to write one from scratch, but CEGUI's just a little too much? The Trays system was created to address this issue. It's a simple GUI system based on the OGRE Overlay system and designed just for samples. Because it's simple, you're not going to be able to skin it or build very unique interfaces, but you'll also find it much easier to use. The entire system is based on the OGRE Overlay system.</p>
<h1><a class="anchor" id="trays-1"></a>
Trays</h1>
<p>Why trays? The concept of trays is central to the system in that it removes the need for the GUI designer (you) to calculate or specify positional coordinates of any kind. Think about the widget locations in a typical GUI. They are almost always in any of the four corners, along any of the four edges or, on the rare occasion, in the center of the screen. In Trays, there are nine "trays", one in each of the locations previously mentioned. When you create a widget, you specify one of these nine locations, and the widget will be added to the tray at that location. Your widget will be added directly beneath the last widget in that tray. When you add a widget to a tray, the tray grows in size. Trays along the top of the screen grow downward, Trays along the bottom grow upward, and the trays in the middle row grow vertically in both directions. Visually, the trays are semi-transparent panels that fit the widgets they contain. Only non-empty trays are visible. If this is hard to visualise, don't worry, here's a picture to help you out. </p><div class="image">
<img src="Gui2.jpg" alt="Gui2.jpg"/>
</div>
<h1><a class="anchor" id="traymanager"></a>
TrayManager</h1>
<p>To use Trays, you have to create an TrayManager. This is the class through which you will create and manage all your widgets, manipulate the cursor, change the backdrop image, adjust tray properties, pop up dialogs, show/hide the loading bar, etc. You can have multiple tray managers in one application. For example, the OGRE Sample Browser uses its own tray manager and hides it when a sample is running, and the SDK samples also have their own tray managers, which are hidden when the samples are paused by the browser. The TrayManager requires "Trays.zip", so you can only create it after loading that resource. Also, make sure you're using the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> namespace (Trays is part of the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Samples Framework). Create your tray manager like so: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>* mTrayMgr = <span class="keyword">new</span> <a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>(<span class="stringliteral">&quot;InterfaceName&quot;</span>, mWindow, <span class="keyword">this</span>);</div></div><!-- fragment --><p> You must pass in a name for your interface, an <code><a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a></code> and an <code><a class="el" href="class_ogre_bites_1_1_tray_listener.html" title="Listener class for responding to tray events. ">OgreBites::TrayListener</a></code>. You can extend your sample or sample context to be a tray listener. Destroy your tray manager like so: </p><div class="fragment"><div class="line"><span class="keyword">delete</span> mTrayMgr;</div><div class="line">mTrayMgr = 0;</div></div><!-- fragment --><p> Once you have your tray manager, make sure you relay your OIS events to it. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> mousePressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseDown(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseReleased(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseUp(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseMoved(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_motion_event.html">OgreBites::MouseMotionEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseMove(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> The injection methods return true if the event was relevant to the tray manager, and should not be processed again by you. For example, if you click a button that is over an interactive part of your scene, you want the button to be pressed, but you don't want the scene interaction to take place. So the injection methods double as filters for your mouse events.</p>
<p>You're now free to create widgets! Try adding a button to the top-left tray: </p><div class="fragment"><div class="line">Button* b = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">createButton</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530afe04de8736168ab0dd6e7938e679c292">TL_TOPLEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <span class="stringliteral">&quot;Click Me!&quot;</span>);</div></div><!-- fragment --><p> TrayManager is a huge class, and you can do tons of things with it. For some examples, see the Things to Try section below.</p>
<h2>The Cursor</h2>
<p>The cursor has three parts in the Trays system: The layer it moves around in Overlay, the container which positions the cursor (OverlayContainer), and the cursor image, which is a child of the container (OverlayElement). When hiding/showing the cursor, the entire cursor layer is hidden/shown. The top left corner of the cursor container is used as the hotspot of the cursor. By positioning the cursor image relative to the cursor container, you can basically decide which part of the cursor image is the "clicking part". For the default arrow cursor, the image is simply lined up with the container, meaning the top left is the hotspot. However, for something like a crosshair cursor, you could move the cursor image so that its center is over the top left corner of the cursor container. To show the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1cc48ac157278b5845d425abbe9acefd" title="Displays specified material on cursor, or the last material used if none specified. ">OgreBites::TrayManager::showCursor</a></code>, which takes an optional material name for the cursor image. If unspecified, the cursor image is not changed. To hide the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a979ff2ad2d729223259b3bebb237cafb">OgreBites::TrayManager::hideCursor</a></code>. You can get the cursor's different parts using getCursorLayer, getCursorContainer, and getCursorImage. Note that if the cursor is hidden, all interactions with widgets are disabled.</p>
<h2>The Backdrop</h2>
<p>If you want to show a backdrop, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ad554418c27edb907f0e3bead8659b83c" title="Displays specified material on backdrop, or the last material used if none specified. ">OgreBites::TrayManager::showBackdrop</a></code>, which takes an optional material name for the backdrop. If unspecified, the backdrop image is not changed. To hide it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a6129a1e92ac22789a4602cf36f9c5394">OgreBites::TrayManager::hideBackdrop</a></code>.</p>
<h1><a class="anchor" id="widgets"></a>
Widgets</h1>
<p>There are 10 basic widgets. Each widget is just an instance of an OverlayElement template, and all widgets use {LEX()}pixel{LEX} metrics. You can get access to any widget's underlying OverlayElement through <code><a class="el" href="class_ogre_bites_1_1_widget.html#a379d3f1a2ca6eaf13fc5c52afaafd0d2">OgreBites::Widget::getOverlayElement</a></code>. Do not instantiate and delete widgets manually. Create and destroy them using the TrayManager. The first argument to any one of TrayManager's widget creation methods is the location of the tray you want the widget to be in. This is of the enumerated type TrayLocation. The second argument is the name of your widget (this is not your widget's caption, but a unique string identifier for your widget). The rest of the arguments are specific to the type of widget.</p>
<h2>Button</h2>
<p>This is the most basic widget of all. To create a button, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">OgreBites::TrayManager::createButton</a></code>. In addition to a tray location and a name, you must specify a caption for your button, and an optional width. If width is not specified, the button will automatically resize to fit its caption. There are no button states. You only get notified when a button is pushed. To see how to respond to button push events, see the TrayListener section below.</p>
<h2>TextBox</h2>
<p>This widget consists of a bold caption bar and a text area that can be scrolled vertically. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a07a8d212939266339e877ff2118250a6">OgreBites::TrayManager::createTextBox</a></code> takes a caption, width, and height. You can set/get the caption, the text area contents, text padding, text alignment, manually change the scroll bar position, among other things.</p>
<h2>SelectMenu</h2>
<p>A basic drop-down menu. To create it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a60864ca00d65b2bf1b97bb8545fab737">OgreBites::TrayManager::createLongSelectMenu</a></code> or <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a98f478c8daa5084b53146de03adbc216">OgreBites::TrayManager::createThickSelectMenu</a></code>. Both these methods return a SelectMenu object, but they give one of two different visual styles to the widget. One is thicker, but shorter, because it places the caption over the item box. This style of menu is good for putting in the side trays. The other is longer, but thinner, because it places the item box next to the caption. This style of menu is good for putting in the top or bottom trays. createThickSelectMenu takes a tray location, a name, a caption, the width of the whole widget, the maximum number of visible items when expanded, and an optional string vector of items. The medthod <code>createLongSelectMenu</code> takes nearly the same arguments, except that it needs the width of the text box that shows the currently selected item. Also, for long menus, it is optional to specify the total width because it will automatically resize to fit the item box and the caption. You can set/get the caption, and set/get the items in many different ways. You can also manually change the selection, with the option of not firing an event. To see how to respond to menu item selection events, see the TrayListener section below.</p>
<h2>Label</h2>
<p>A big, semi-transparent, tabby-looking label. This widget uses a different font from the rest of the widgets, and is good for section headings and such. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a15375d59b5c57059c9c6549fc5a1bfcd">OgreBites::TrayManager::createLabel</a></code> takes a caption, and an optional width. If the width is not specified, the label automatically adjusts its width to fill the tray it's currently in, so it matches the other contents of the tray. Labels can also be clicked. To see how to respond to label click events, see the TrayListener section below.</p>
<h2>Separator</h2>
<p>A horizontal line which looks like it was etched into the tray. Good for dividing up other widgets into sections without taking up as much space as a label. <code>TrayManager::createSeparator</code> takes a tray location, name, and an optional width. If the width is not specified, the behaviour is the same as a Label's.</p>
<h2>Slider</h2>
<p>A slider bar consists of a container box, a small text box to display the value, and a track + handle. Sliders are type-agnostic. Using three parameters - a minimum value, a maximum value, and the number of "snapping points", you can give your slider track of any kind of discrete scale - integer, floating point, or even nominal. Snapping points are basically the "steps" on your slider track. By specifying how many of them there are, you are in effect specifying an entire range of values all the way from your minimum value to your maximum value. Let's say you have minimum value 0, maximum value 1, and 6 snapping points. Underneath the surface, each slider stores a floating point value, so in this case you would be able to display 6 floating point values: {0, 0.2, 0.4, 0.6, 0.8, 1}. The slider will display your value in the cleanest way possible (using <code><a class="el" href="class_ogre_1_1_string_converter.html#a45fb498a2f798c82bbf88116a5a34c53" title="Converts a float to a String. ">Ogre::StringConverter::toString</a></code>). This means that if all your values happen to land on integers, then they will be displayed as integers without decimals. You can also exploit this by using your slider's integer values as indices into an array of string values, and manually set your slider's value to the new string value. Basically, you can make your slider display things like Low, Medium, High, 1/4, 3/4, $4.00, N/A, etc. This requires you to respond to slider move events. More on this in the TrayListener section below. Then your Like select menus, sliders also come in two flavours - thick and long. The thick style places the caption and the value box above the track, while the long style places the caption, track, and value box side by side in that order. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a597ec173c1b424980e18fd92e0c56905">OgreBites::TrayManager::createThickSlider</a></code> takes a tray location, name, caption, total width, value box width, minimum value, maximum value, and the number of snapping points. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a321429ade975d3a63dfc1125b4375e78">OgreBites::TrayManager::createLongSlider</a></code> takes a an optional total width, track width, value box width, minimum value, maximum value, and the number of snapping points. If the total width is not specified, the slider will automatically scale to fit the track, the value box, and the caption text. You can get/set the slider's caption, displayed value, actual value, and range of values. When you change the range, the value is reset to be the minimum value. When you change the value, you also have the option of not firing an event. To respond to slider move events, see the TrayListener section below.</p>
<h2>ParamsPanel</h2>
<p>This panel displays an arbitrary number of parameters and their values. This could be anything you want. For example, the stats panel in the SDK samples shows the average framerate, best framerate, batch count, etc. The details panel in the SDK samples shows the texture filtering technique, the polygon mode, and the camera position and orientation. To create a ParamsPanel, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a5ae6b66603e05193b3077f30900209eb">OgreBites::TrayManager::createParamsPanel</a></code>, which takes a tray location, a name, a width, and then either a string vector of parameter names or the number of parameters (lines) to leave room for. The parameter names will be left justified, and their values will be right justified on the same line. At any time, you can set/get the parameter names and values either one at a time, or all at once using a string vector.</p>
<h2>CheckBox</h2>
<p>Self-explanatory. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7433f3e89c5b3a1b1b0012dfcb121f1d">OgreBites::TrayManager::createCheckBox</a></code> takes a tray location, name, caption, and an optional width. Unspecified width means auto-fit to caption. You can set/get the state of the check box, with the option of not triggering an event. To respond to check box state change events, see the TrayListener section below. </p><h2>DecorWidget</h2>
<p>This widget takes any OverlayElement template, and creates a widget out of it. If you want to put your own picture, icons, or other static objects into the trays, make an OverlayElement template out of it, and then turn it into a DecorWidget. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a24d1b3a3b95ddcf274bf899b7600deba">OgreBites::TrayManager::createDecorWidget</a></code> takes a tray location, a name, and an OverlayElement template name. These are basically the same things you would normally use to create an OverlayElement from a template. The OGRE logo in the SDK samples is a DecorWidget. </p><h2>ProgressBar</h2>
<p>A progress bar with a caption, a comment/details box, and a meter that fills up. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a431a347db6465bbf66af82ef363c875f">OgreBites::TrayManager::createProgressBar</a></code> takes a tray location, a name, a caption, a total width, and comment box width. You can use progress bars to show any kind of progress you want, but for the most common kind (loading resources), there's a special instance of ProgressBar already created by TrayManager which you can use. See Loading Bar below.</p>
<h2>The Null Tray</h2>
<p>In addition to the nine trays you can place your widgets in, there is also a "null tray". This is an imaginary tray, whose location is specified by <code>TL_NONE</code>. This tray is virtual, invisible, and does not arrange widgets within it. Basically, if you place a widget in this tray, it becomes "free-floating", and you're allowed to manually position it anywhere on the screen. Widgets must always reside in a tray for as long as they exist, so when a widget is removed from a tray, it is automatically placed in the null tray.</p>
<h1><a class="anchor" id="special-widgets"></a>
Special Widgets</h1>
<p>Some widgets are so common they deserve special treatment.</p>
<h2>Frame Stats</h2>
<p>This is not exactly one widget, but a combination of Label that displays the current FPS, and a ParamsPanel that displays advanced frame statistics (such as average FPS and batch count). Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a49e2f792fee94e75b1b472826bcc8019" title="Shows frame statistics widget set in the specified location. ">OgreBites::TrayManager::showFrameStats</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1c2e9618a3e6b061a9cfeac4f2cb55e9" title="Hides frame statistics widget set. ">OgreBites::TrayManager::hideFrameStats</a></code> to show/hide this special widget. You can choose where to put it. When the user clicks the FPS label, it toggles the visibility of the advanced frame stats, so they can be out of the way when they're unwanted. You can also manually toggle the visibility of the advanced frame stats using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aed00f8a1009f2ebf6806774cb894d0d7" title="Toggles visibility of advanced statistics. ">OgreBites::TrayManager::toggleAdvancedFrameStats</a></code>.</p>
<h2>Logo</h2>
<p>This is just a decor widget of the OGRE logo. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#affee57f47066e25437649d64daaa7dd9" title="Shows logo in the specified location. ">OgreBites::TrayManager::showLogo</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ac1ee637b7ef5e887170c8a9aca1c4c7b">OgreBites::TrayManager::hideLogo</a></code> to show/hide the logo. You can choose where to put it.</p>
<h2>Loading Bar</h2>
<p>This is a progress bar that shows you the progress of your current resource loading job. The comment box will show the current resource being loaded. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a0d51005a4b148a4df2c1c6b55e34f085" title="Shows loading bar. ">OgreBites::TrayManager::showLoadingBar</a></code> before you begin your loading job. Specify the number of resource groups you will initialise, the number of groups you will load, and, if you want to, the proportion of time you think will go to initialisation (default estimate is 70%). You cannot decide where to place this loading bar. The screen will be darkened, and the loading bar will appear in the center. Any other dialog or loading bar will be closed. When you finish your loading job, call <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aab014a2c48c8f91556182e42684d44ad">OgreBites::TrayManager::hideLoadingBar</a></code>.</p>
<h2>Information Dialog</h2>
<p>This is a dialog which tells the user something and displays an OK button. It's a combination of a TextBox and a Button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#abf3bd8e4ef9a6d0d76f27535a6010623" title="Pops up a message dialog with an OK button. ">OgreBites::TrayManager::showOkDialog</a></code> to display an information dialog. Specify the caption of the TextBox, and the message you want to display in it. Any other dialog or loading bar will be closed. The screen will be darkened, and the dialog will appear in the center. All other widget interactions are disabled until the dialog is closed. You can manually close a dialog using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#af5d95dcaa7c74d3345308e4f4e3035e8" title="Hides whatever dialog is currently showing. ">OgreBites::TrayManager::closeDialog</a></code>. To respond to information dialog closing events, see the TrayListenersection below.</p>
<h2>Question Dialog</h2>
<p>Same as the Information Dialog except it asks the user something and displays a Yes button and a No button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a85d47aa11d761742884dc6457ec11cdf" title="Pops up a question dialog with Yes and No buttons. ">OgreBites::TrayManager::showYesNoDialog</a></code> to display a question dialog. Specify the caption of the TextBox, and the question you want to display in it. To respond to question dialog closing events, see the TrayListener section below.</p>
<h1><a class="anchor" id="tray-listener"></a>
TrayListener</h1>
<p>This class contains handlers for all the different events that your widgets can fire. The TrayManager class itself is an TrayListener, because it responds to events from its special widgets. You should extend your sample class from TrayListener as well as Sample if you want to handle widget events. If you're using SdkSample, you're all set because it's already an TrayListener. Some widgets give you an option of not firing an event when you change their state. This is helpful for initialising or resetting a widget, in which case there shouldn't be a response of any sort. For example, if you're initialising your slider bar before the scene is set up, and your slider bar is used to control some part of your scene, firing an event would cause an error. Below is a list of the different handlers. All handlers have return type void.</p><ul>
<li><b>buttonHit</b>: Gives you a pointer to the Button which was hit.</li>
<li><b>itemSelected</b>: Gives you a pointer to the SelectMenu the item was chosen from. You can then use the SelectMenu to see which item was selected.</li>
<li><b>labelHit</b>: Gives you a pointer to the Label that was clicked.</li>
<li><b>sliderMoved</b>: Gives you a pointer to the Slider whose value was changed. You can then use the Slider to see what its new value is. Also, you can convert this value into a more suitable form and display it using Slider::setDisplayedValue.</li>
<li><b>checkBoxToggled</b>: Gives you a pointer to the CheckBox whose state was changed. You can then use the CheckBox to see if it's been checked or unchecked.</li>
<li><b>okDialogClosed</b>: Gives you the message of the OK dialog that was closed.</li>
<li><b>yesNoDialogClosed</b>: Gives you the question of the Yes-No dialog that was closed, and a boolean indicating whether or not the Yes button was pressed.</li>
</ul>
<h1><a class="anchor" id="things-to-try"></a>
Things to Try</h1>
<p>Getting access to widgets: </p><div class="fragment"><div class="line">Button* b;</div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);  <span class="comment">// by tray and position</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by tray and name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#af968c01a627ee654409f558e4ef55537">getWidgetIterator</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>).<a class="code" href="class_ogre_1_1_vector_iterator_wrapper.html#a2460c8adb6819235849de954db6a0f64">getNext</a>();  <span class="comment">// by iterator</span></div></div><!-- fragment --><p> Counting widgets: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>();  <span class="comment">// total</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);  <span class="comment">// by tray</span></div></div><!-- fragment --><p> Moving widgets to other trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div></div><!-- fragment --><p> Removing widgets from trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a04a1085bdee61d7234849663cce08664">TL_NONE</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a77ba6e4d641c146e262b6cdd2c8b04a0">clearTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9787ec5e8989bf6cfa89d03c6ddd27b6">clearAllTrays</a>();</div></div><!-- fragment --><p> Destroying widgets: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4a89cd6f7d87e0e538aa842f1a42a7bc">destroyAllWidgetsInTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aadb1f5a3b7e3b5397b10bdd3449e1603">destroyAllWidgets</a>();</div></div><!-- fragment --><p> Finding the position of a widget in a tray: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa993d2b60cfbcb903aecbff1c4896b67">locateWidgetInTray</a>(b);</div></div><!-- fragment --><p> Finding the tray a widget is in: </p><div class="fragment"><div class="line"><a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530">TrayLocation</a> trayLoc = b-&gt;getTrayLocation();</div></div><!-- fragment --><p> Changing the tray listener object: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a3235fea714a0c61e463dee69ae308be8">setListener</a>(newListener);</div></div><!-- fragment --><p> Toggling system visibility: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a075805136b2241cbb03eeb2c3d27b40d">showAll</a>();</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a188f1d5f5ca16af3b28d11ecd553105a">hideAll</a>();</div></div><!-- fragment --><p> Changing horizontal widget alignment in one tray: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#adfbbc97615fd5f1a939be6e7a1f00c07">setTrayWidgetAlignment</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <a class="code" href="group___overlays.html#gga3396780cdb2d731aa5e4389148bdc5f3a270f18cf07dbe4e75e1b790d02924205">GHA_RIGHT</a>);</div></div><!-- fragment --><p> Changing spacing and padding: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a33a3e3f66a3989dd3de48b4c4577422f">setWidgetSpacing</a>(5);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a52d3fc8638533540232232c37b257de6">setWidgetPadding</a>(3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a866229b6d88dc9d3a609115eaab46e67">setTrayPadding</a>(12);</div></div><!-- fragment --><p> Casting 3D ray from under cursor into the scene: </p><div class="fragment"><div class="line">Ray r = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9dd5d303968329462e9bf4225f59722e">getCursorRay</a>(mCamera);</div></div><!-- fragment --><p> Casting 3D ray from any 2D screen coordinate into the scene: </p><div class="fragment"><div class="line">Ray r = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#a6833f46b0303b559a050f310fa0204fc">OgreBites::TrayManager::screenToScene</a>(mCamera, Vector2(320, 240));</div></div><!-- fragment --><p> Converting a 3D scene coordinate to a 2D screen coordinate: </p><div class="fragment"><div class="line">Vector2 p = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa7a456c2c0c37123e2ab0e497f2c0ccc">OgreBites::TrayManager::sceneToScreen</a>(mCamera, Vector3::ZERO);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Volume Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('volume.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Volume Component </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howto">How to use it</a></li>
<li class="level1"><a href="#creation">Manual creation of a CSG-Tree</a></li>
<li class="level1"><a href="#triangles">Getting the triangles of the chunks</a></li>
<li class="level1"><a href="#intersecting">Intersecting a ray with a volume</a></li>
<li class="level1"><a href="#editing">Editing a Volume made from a GridSource</a></li>
</ul>
</div>
<div class="textblock"><p>Welcome to the Volume Component of OGRE. It is a component to render volumes. It can handle any volume data but featurewise has a tedency towards terrains. The terrain aspect means, that it's all about huge meshes being displayed with high performance via a level of detail mechanism. Thanks to volume rendering, caves, cliffes, holes and similar geometry can be displayed. Also constructive solid geometry gets easy.</p>
<p>A dense list of the features:</p><ul>
<li>Volume Rendering via Dual Marching Cubes</li>
<li>LOD mechanism via a chunk tree and marching squares skirts for crack patching</li>
<li>Data-Sources: 3D Textures with density values and the ability to buildup a CSG-Tree with 3D Textures, Spheres, Cubes, Planes, Intersection, Union, Difference and Negation, SimplexNoise addition</li>
<li>Loading a 3D Texture Scene from config files</li>
<li>An own file format for discrete density values which compresses a lot better</li>
<li>Realtime editing</li>
<li>Serialization and Deserialization from and to an own file format for discrete density values which compresses a lot better than 3D textures</li>
<li>A triplanar texturing example material</li>
<li>A triplanar texturing SubRenderState for the RTSS</li>
</ul>
<p>This documentation is only intended for the usage of the Volume Component, not the algorithms which make it work. If you want to get to know the theory behind it, you can read the articles on this page: <a href="http://volume-gfx.com/">http://volume-gfx.com/</a></p>
<h1><a class="anchor" id="howto"></a>
How to use it</h1>
<p>Here is an example loading the volume scene from a configuration file. The configuration file must be findable by the resource system of course. Only "OgreVolumeChunk.h" has to be included. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> <a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a>();</div><div class="line">SceneNode *volumeRootNode = mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(<span class="stringliteral">&quot;VolumeParent&quot;</span>);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, mSceneMgr, <span class="stringliteral">&quot;volumeTerrain.cfg&quot;</span>);</div></div><!-- fragment --><p> The first line creates the volume chunk which is the MovableObject holding the Volume-Root. Next, a SceneNode is created where the volume(-tree) is attached to. And lastly, the volume is loaded from the configuration file "volumeTerrain.cfg". mSceneMgr is the SceneManager who should show the volume. Later, when you don't need it anymore, you have to free the volumeRoot Chunk via OGRE_DELETE.</p>
<h1><a class="anchor" id="creation"></a>
Manual creation of a CSG-Tree</h1>
<p>This example skips the configuration file and loads a simple CSG-Scene: An union of a 3D Texture and a sphere with 5 LOD levels. It also setups a material LOD system. First, create a sphere with the radius 5 at the coordinates 128, 150, 128: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_sphere_source.html">Ogre::Volume::CSGSphereSource</a> sphere (5, Vector3(128, 150, 128));</div></div><!-- fragment --><p> Now a 3D texture from "volumeTerrainBig.dds" which has the world dimensions 256, 256, 256. The next flag indicates that the trilinear interpolation of the value-selection should be activated. We switch off the trilinear interpolation and the sobel filter of the normal for the sake of faster loading times: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_texture_source.html">Ogre::Volume::TextureSource</a> volumeTexture (<span class="stringliteral">&quot;volumeTerrainBig.dds&quot;</span>, 256, 256, 256, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div></div><!-- fragment --><p> Now combine them: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_union_source.html">Ogre::Volume::CSGUnionSource</a> unionSrc (&amp;sphere, &amp;volumeTexture);</div></div><!-- fragment --><p> Set the general parameters, see the comments for their meaning: </p><div class="fragment"><div class="line"><a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html">Ogre::Volume::ChunkParameters</a> parameters;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a3e154a179b8c824f79b1b426608743ad">sceneManager</a> = mSceneMgr;       <span class="comment">// The SceneManager to use</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a> = &amp;unionSrc;                <span class="comment">// The just created density source.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a4444eac27c71e02886615dcf7fbfed27">baseError</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.8;          <span class="comment">// The error of the highest LOD-level</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aa6186649b7323f937b83828eb86711fa">errorMultiplicator</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.9; <span class="comment">// The factor between each LOD-level (error = baseError * errorMultiplicator  * level)</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a986b4a97b153d50f65603ab507bb4614">skirtFactor</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.7;        <span class="comment">// Controls how long the skirts are. The lower the number, the shorter the skirts are. This saves geometry. But if they are too short, cracks might occure.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#af6ed62b76c67d04eb98424414fb1dc72">scale</a> = 10;                     <span class="comment">// The displayed volume will be scaled by this factor.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#ae125003c00de0d6c0a1a4bd6b99c4ebf">maxScreenSpaceError</a> = 30;       <span class="comment">// The screen space error controlling when the LOD-levels change.</span></div></div><!-- fragment --><p>Create the root-chunk and load now. The two vectors define the area to be scanned in the volume-source. The following integer determines the amount of LOD-levels. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> Chunk();</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(mVolumeRootNode, Vector3::ZERO, Vector3(256), 5, &amp;parameters);</div></div><!-- fragment --><p> Now setup the global volume material: </p><div class="fragment"><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a5129bccc53d17060635ada67443324f7">setMaterial</a>(<span class="stringliteral">&quot;triplanarReference&quot;</span>);</div></div><!-- fragment --> <h1><a class="anchor" id="triangles"></a>
Getting the triangles of the chunks</h1>
<p>When you want to integrate the volume triangles in a physics engine for example, you need to hand over the exact triangles. For this scenario, the ChunkParameters hold a pointer to a ''MeshBuilderCallback'' and a number ''lodCallbackLod''. The first is an interface with a single function ''trianglesReady'' which is called, when the triangles of a chunk are ready. The chunks are chosen via the ''lodCallbackLod''. If you build a volume with 3 LOD levels and you want the triangles of the highest detail level, you set this parameter to 3. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyMeshBuilderCallback : <span class="keyword">public</span> MeshBuilderCallback</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span>  ready(<span class="keyword">const</span> SimpleRenderable *simpleRenderable, <span class="keyword">const</span> <a class="code" href="group___volume.html#gabf42f450c9ea75c61753f6d485cb8357">VecVertex</a> &amp;vertices, <span class="keyword">const</span> <a class="code" href="group___volume.html#ga325b1df965bf0137edd13bb52bc422be">VecIndices</a> &amp;indices, <span class="keywordtype">size_t</span> level, <span class="keywordtype">int</span> inProcess)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">size_t</span> count = indices.size();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count; i += 3)</div><div class="line">        {</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v1 = vertices[indices[i]];</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v2 = vertices[indices[i + 1]];</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v3 = vertices[indices[i + 2]];</div><div class="line">            <span class="comment">// Do something with the Triangle...</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>And using it like this: </p><div class="fragment"><div class="line"><a class="code" href="group___volume.html#ga89fbc5eed010b8802358563eb88e674a">ChunkParameters</a> parameters;</div><div class="line">...</div><div class="line">MyMeshBuilderCallback callback;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a6403e2875cc7b81aefd43ba9f22c2b31">lodCallback</a> = &amp;callback;</div><div class="line">parameters.lodCallbackLod = 3;</div><div class="line">...</div><div class="line">rootChunk-&gt;load(parent, from, to, 3, &amp;parameters);</div></div><!-- fragment --><p> Or in case of loading from a configuration file: </p><div class="fragment"><div class="line">MyMeshBuilderCallback callback;</div><div class="line">rootChunk-&gt;load(parent, sceneManager, <span class="stringliteral">&quot;myVolume.cfg&quot;</span>, 0, &amp;callback, 3);</div></div><!-- fragment --><p>You might have seen, that a pointer to a SimpleRenderable is handed in, too. This is actually the Chunk whose triangles are loaded. It's parent class is used to not create a circular dependency. You might get the triangle data from it, too by getting the Renderoperation.</p>
<h1><a class="anchor" id="intersecting"></a>
Intersecting a ray with a volume</h1>
<p>When you want to do something exactly on the volume surface, you can cast rays and find their first intersection point. Behold that the triangle representation might be slightly different than the actual volume surface. And you have to scale the ray origin just like the volume. Here is an example which uses the negative z-axis of the camera as ray as it might be done like in an ego-shooter: </p><div class="fragment"><div class="line">Ray ray(mCamera-&gt;getPosition() / rootChunk-&gt;getScale(), -mCamera-&gt;getOrientation().zAxis());</div><div class="line">Vector3 intersection;</div><div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> scale = mVolumeRoot-&gt;getChunkParameters()-&gt;scale;</div><div class="line"><span class="keywordtype">bool</span> intersects = mVolumeRoot-&gt;getChunkParameters()-&gt;src-&gt;getFirstRayIntersection(ray, intersection, scale);</div><div class="line"><span class="keywordflow">if</span> (intersects)</div><div class="line">{</div><div class="line">    intersection *= scale; <span class="comment">// As it is in volume space.</span></div><div class="line">    <span class="comment">// Do something with intersection.</span></div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="editing"></a>
Editing a Volume made from a GridSource</h1>
<p>A usecase is realtime editing of volume terrain as seen as in the sample. Let's union the terrain with a sphere of the radius 2.5 and the center 123/123/123. <b>volumeRoot</b> is the Chunk instance with which the terrain was initially loaded. The factor 1.5 is just to have a save border arround the sphere which also gets updated. The rest of the parameters are 5 LOD levels and a volume mesh covering an area of 384^3. </p><div class="fragment"><div class="line">Vector3 center(123);</div><div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> radius = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)2.5;</div><div class="line">CSGSphereSource sphere(radius, center);</div><div class="line">CSGUnionSource operation;</div><div class="line"><span class="keyword">static_cast&lt;</span>GridSource*<span class="keyword">&gt;</span>(volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a>)-&gt;combineWithSource(&amp;operation, &amp;sphere, center, radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aeefacd1d618206fcb432ed947b58e06e">updateFrom</a> = center - radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5;</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#afe30999e8cc71a1f48d87d68bf43059d">updateTo</a> = center + radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5;</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, Vector3::ZERO, Vector3(384), 5, volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>());</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Volume Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('volume.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Volume Component </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howto">How to use it</a></li>
<li class="level1"><a href="#creation">Manual creation of a CSG-Tree</a></li>
<li class="level1"><a href="#triangles">Getting the triangles of the chunks</a></li>
<li class="level1"><a href="#intersecting">Intersecting a ray with a volume</a></li>
<li class="level1"><a href="#editing">Editing a Volume made from a GridSource</a></li>
</ul>
</div>
<div class="textblock"><p>Welcome to the Volume Component of OGRE. It is a component to render volumes. It can handle any volume data but featurewise has a tedency towards terrains. The terrain aspect means, that it's all about huge meshes being displayed with high performance via a level of detail mechanism. Thanks to volume rendering, caves, cliffes, holes and similar geometry can be displayed. Also constructive solid geometry gets easy.</p>
<p>A dense list of the features:</p><ul>
<li>Volume Rendering via Dual Marching Cubes</li>
<li>LOD mechanism via a chunk tree and marching squares skirts for crack patching</li>
<li>Data-Sources: 3D Textures with density values and the ability to buildup a CSG-Tree with 3D Textures, Spheres, Cubes, Planes, Intersection, Union, Difference and Negation, SimplexNoise addition</li>
<li>Loading a 3D Texture Scene from config files</li>
<li>An own file format for discrete density values which compresses a lot better</li>
<li>Realtime editing</li>
<li>Serialization and Deserialization from and to an own file format for discrete density values which compresses a lot better than 3D textures</li>
<li>A triplanar texturing example material</li>
<li>A triplanar texturing SubRenderState for the RTSS</li>
</ul>
<p>This documentation is only intended for the usage of the Volume Component, not the algorithms which make it work. If you want to get to know the theory behind it, you can read the articles on this page: <a href="http://volume-gfx.com/">http://volume-gfx.com/</a></p>
<h1><a class="anchor" id="howto"></a>
How to use it</h1>
<p>Here is an example loading the volume scene from a configuration file. The configuration file must be findable by the resource system of course. Only "OgreVolumeChunk.h" has to be included. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> <a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a>();</div><div class="line">SceneNode *volumeRootNode = mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(<span class="stringliteral">&quot;VolumeParent&quot;</span>);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, mSceneMgr, <span class="stringliteral">&quot;volumeTerrain.cfg&quot;</span>);</div></div><!-- fragment --><p> The first line creates the volume chunk which is the MovableObject holding the Volume-Root. Next, a SceneNode is created where the volume(-tree) is attached to. And lastly, the volume is loaded from the configuration file "volumeTerrain.cfg". mSceneMgr is the SceneManager who should show the volume. Later, when you don't need it anymore, you have to free the volumeRoot Chunk via OGRE_DELETE.</p>
<h1><a class="anchor" id="creation"></a>
Manual creation of a CSG-Tree</h1>
<p>This example skips the configuration file and loads a simple CSG-Scene: An union of a 3D Texture and a sphere with 5 LOD levels. It also setups a material LOD system. First, create a sphere with the radius 5 at the coordinates 128, 150, 128: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_sphere_source.html">Ogre::Volume::CSGSphereSource</a> sphere (5, Vector3(128, 150, 128));</div></div><!-- fragment --><p> Now a 3D texture from "volumeTerrainBig.dds" which has the world dimensions 256, 256, 256. The next flag indicates that the trilinear interpolation of the value-selection should be activated. We switch off the trilinear interpolation and the sobel filter of the normal for the sake of faster loading times: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_texture_source.html">Ogre::Volume::TextureSource</a> volumeTexture (<span class="stringliteral">&quot;volumeTerrainBig.dds&quot;</span>, 256, 256, 256, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div></div><!-- fragment --><p> Now combine them: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_union_source.html">Ogre::Volume::CSGUnionSource</a> unionSrc (&amp;sphere, &amp;volumeTexture);</div></div><!-- fragment --><p> Set the general parameters, see the comments for their meaning: </p><div class="fragment"><div class="line"><a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html">Ogre::Volume::ChunkParameters</a> parameters;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a3e154a179b8c824f79b1b426608743ad">sceneManager</a> = mSceneMgr;       <span class="comment">// The SceneManager to use</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a> = &amp;unionSrc;                <span class="comment">// The just created density source.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a4444eac27c71e02886615dcf7fbfed27">baseError</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.8;          <span class="comment">// The error of the highest LOD-level</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aa6186649b7323f937b83828eb86711fa">errorMultiplicator</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.9; <span class="comment">// The factor between each LOD-level (error = baseError * errorMultiplicator  * level)</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a986b4a97b153d50f65603ab507bb4614">skirtFactor</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.7;        <span class="comment">// Controls how long the skirts are. The lower the number, the shorter the skirts are. This saves geometry. But if they are too short, cracks might occure.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#af6ed62b76c67d04eb98424414fb1dc72">scale</a> = 10;                     <span class="comment">// The displayed volume will be scaled by this factor.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#ae125003c00de0d6c0a1a4bd6b99c4ebf">maxScreenSpaceError</a> = 30;       <span class="comment">// The screen space error controlling when the LOD-levels change.</span></div></div><!-- fragment --><p>Create the root-chunk and load now. The two vectors define the area to be scanned in the volume-source. The following integer determines the amount of LOD-levels. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> Chunk();</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(mVolumeRootNode, Vector3::ZERO, Vector3(256), 5, &amp;parameters);</div></div><!-- fragment --><p> Now setup the global volume material: </p><div class="fragment"><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a5129bccc53d17060635ada67443324f7">setMaterial</a>(<span class="stringliteral">&quot;triplanarReference&quot;</span>);</div></div><!-- fragment --> <h1><a class="anchor" id="triangles"></a>
Getting the triangles of the chunks</h1>
<p>When you want to integrate the volume triangles in a physics engine for example, you need to hand over the exact triangles. For this scenario, the ChunkParameters hold a pointer to a ''MeshBuilderCallback'' and a number ''lodCallbackLod''. The first is an interface with a single function ''trianglesReady'' which is called, when the triangles of a chunk are ready. The chunks are chosen via the ''lodCallbackLod''. If you build a volume with 3 LOD levels and you want the triangles of the highest detail level, you set this parameter to 3. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyMeshBuilderCallback : <span class="keyword">public</span> MeshBuilderCallback</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span>  ready(<span class="keyword">const</span> SimpleRenderable *simpleRenderable, <span class="keyword">const</span> <a class="code" href="group___volume.html#gabf42f450c9ea75c61753f6d485cb8357">VecVertex</a> &amp;vertices, <span class="keyword">const</span> <a class="code" href="group___volume.html#ga325b1df965bf0137edd13bb52bc422be">VecIndices</a> &amp;indices, <span class="keywordtype">size_t</span> level, <span class="keywordtype">int</span> inProcess)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">size_t</span> count = indices.size();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count; i += 3)</div><div class="line">        {</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v1 = vertices[indices[i]];</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v2 = vertices[indices[i + 1]];</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v3 = vertices[indices[i + 2]];</div><div class="line">            <span class="comment">// Do something with the Triangle...</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>And using it like this: </p><div class="fragment"><div class="line"><a class="code" href="group___volume.html#ga89fbc5eed010b8802358563eb88e674a">ChunkParameters</a> parameters;</div><div class="line">...</div><div class="line">MyMeshBuilderCallback callback;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a6403e2875cc7b81aefd43ba9f22c2b31">lodCallback</a> = &amp;callback;</div><div class="line">parameters.lodCallbackLod = 3;</div><div class="line">...</div><div class="line">rootChunk-&gt;load(parent, from, to, 3, &amp;parameters);</div></div><!-- fragment --><p> Or in case of loading from a configuration file: </p><div class="fragment"><div class="line">MyMeshBuilderCallback callback;</div><div class="line">rootChunk-&gt;load(parent, sceneManager, <span class="stringliteral">&quot;myVolume.cfg&quot;</span>, 0, &amp;callback, 3);</div></div><!-- fragment --><p>You might have seen, that a pointer to a SimpleRenderable is handed in, too. This is actually the Chunk whose triangles are loaded. It's parent class is used to not create a circular dependency. You might get the triangle data from it, too by getting the Renderoperation.</p>
<h1><a class="anchor" id="intersecting"></a>
Intersecting a ray with a volume</h1>
<p>When you want to do something exactly on the volume surface, you can cast rays and find their first intersection point. Behold that the triangle representation might be slightly different than the actual volume surface. And you have to scale the ray origin just like the volume. Here is an example which uses the negative z-axis of the camera as ray as it might be done like in an ego-shooter: </p><div class="fragment"><div class="line">Ray ray(mCamera-&gt;getPosition() / rootChunk-&gt;getScale(), -mCamera-&gt;getOrientation().zAxis());</div><div class="line">Vector3 intersection;</div><div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> scale = mVolumeRoot-&gt;getChunkParameters()-&gt;scale;</div><div class="line"><span class="keywordtype">bool</span> intersects = mVolumeRoot-&gt;getChunkParameters()-&gt;src-&gt;getFirstRayIntersection(ray, intersection, scale);</div><div class="line"><span class="keywordflow">if</span> (intersects)</div><div class="line">{</div><div class="line">    intersection *= scale; <span class="comment">// As it is in volume space.</span></div><div class="line">    <span class="comment">// Do something with intersection.</span></div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="editing"></a>
Editing a Volume made from a GridSource</h1>
<p>A usecase is realtime editing of volume terrain as seen as in the sample. Let's union the terrain with a sphere of the radius 2.5 and the center 123/123/123. <b>volumeRoot</b> is the Chunk instance with which the terrain was initially loaded. The factor 1.5 is just to have a save border arround the sphere which also gets updated. The rest of the parameters are 5 LOD levels and a volume mesh covering an area of 384^3. </p><div class="fragment"><div class="line">Vector3 center(123);</div><div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> radius = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)2.5;</div><div class="line">CSGSphereSource sphere(radius, center);</div><div class="line">CSGUnionSource operation;</div><div class="line"><span class="keyword">static_cast&lt;</span>GridSource*<span class="keyword">&gt;</span>(volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a>)-&gt;combineWithSource(&amp;operation, &amp;sphere, center, radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aeefacd1d618206fcb432ed947b58e06e">updateFrom</a> = center - radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5;</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#afe30999e8cc71a1f48d87d68bf43059d">updateTo</a> = center + radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5;</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, Vector3::ZERO, Vector3(384), 5, volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>());</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Volume Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('volume.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Volume Component </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howto">How to use it</a></li>
<li class="level1"><a href="#creation">Manual creation of a CSG-Tree</a></li>
<li class="level1"><a href="#triangles">Getting the triangles of the chunks</a></li>
<li class="level1"><a href="#intersecting">Intersecting a ray with a volume</a></li>
<li class="level1"><a href="#editing">Editing a Volume made from a GridSource</a></li>
</ul>
</div>
<div class="textblock"><p>Welcome to the Volume Component of OGRE. It is a component to render volumes. It can handle any volume data but featurewise has a tedency towards terrains. The terrain aspect means, that it's all about huge meshes being displayed with high performance via a level of detail mechanism. Thanks to volume rendering, caves, cliffes, holes and similar geometry can be displayed. Also constructive solid geometry gets easy.</p>
<p>A dense list of the features:</p><ul>
<li>Volume Rendering via Dual Marching Cubes</li>
<li>LOD mechanism via a chunk tree and marching squares skirts for crack patching</li>
<li>Data-Sources: 3D Textures with density values and the ability to buildup a CSG-Tree with 3D Textures, Spheres, Cubes, Planes, Intersection, Union, Difference and Negation, SimplexNoise addition</li>
<li>Loading a 3D Texture Scene from config files</li>
<li>An own file format for discrete density values which compresses a lot better</li>
<li>Realtime editing</li>
<li>Serialization and Deserialization from and to an own file format for discrete density values which compresses a lot better than 3D textures</li>
<li>A triplanar texturing example material</li>
<li>A triplanar texturing SubRenderState for the RTSS</li>
</ul>
<p>This documentation is only intended for the usage of the Volume Component, not the algorithms which make it work. If you want to get to know the theory behind it, you can read the articles on this page: <a href="http://volume-gfx.com/">http://volume-gfx.com/</a></p>
<h1><a class="anchor" id="howto"></a>
How to use it</h1>
<p>Here is an example loading the volume scene from a configuration file. The configuration file must be findable by the resource system of course. Only "OgreVolumeChunk.h" has to be included. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> <a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a>();</div><div class="line">SceneNode *volumeRootNode = mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(<span class="stringliteral">&quot;VolumeParent&quot;</span>);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, mSceneMgr, <span class="stringliteral">&quot;volumeTerrain.cfg&quot;</span>);</div></div><!-- fragment --><p> The first line creates the volume chunk which is the MovableObject holding the Volume-Root. Next, a SceneNode is created where the volume(-tree) is attached to. And lastly, the volume is loaded from the configuration file "volumeTerrain.cfg". mSceneMgr is the SceneManager who should show the volume. Later, when you don't need it anymore, you have to free the volumeRoot Chunk via OGRE_DELETE.</p>
<h1><a class="anchor" id="creation"></a>
Manual creation of a CSG-Tree</h1>
<p>This example skips the configuration file and loads a simple CSG-Scene: An union of a 3D Texture and a sphere with 5 LOD levels. It also setups a material LOD system. First, create a sphere with the radius 5 at the coordinates 128, 150, 128: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_sphere_source.html">Ogre::Volume::CSGSphereSource</a> sphere (5, Vector3(128, 150, 128));</div></div><!-- fragment --><p> Now a 3D texture from "volumeTerrainBig.dds" which has the world dimensions 256, 256, 256. The next flag indicates that the trilinear interpolation of the value-selection should be activated. We switch off the trilinear interpolation and the sobel filter of the normal for the sake of faster loading times: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_texture_source.html">Ogre::Volume::TextureSource</a> volumeTexture (<span class="stringliteral">&quot;volumeTerrainBig.dds&quot;</span>, 256, 256, 256, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div></div><!-- fragment --><p> Now combine them: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_union_source.html">Ogre::Volume::CSGUnionSource</a> unionSrc (&amp;sphere, &amp;volumeTexture);</div></div><!-- fragment --><p> Set the general parameters, see the comments for their meaning: </p><div class="fragment"><div class="line"><a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html">Ogre::Volume::ChunkParameters</a> parameters;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a3e154a179b8c824f79b1b426608743ad">sceneManager</a> = mSceneMgr;       <span class="comment">// The SceneManager to use</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a> = &amp;unionSrc;                <span class="comment">// The just created density source.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a4444eac27c71e02886615dcf7fbfed27">baseError</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.8;          <span class="comment">// The error of the highest LOD-level</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aa6186649b7323f937b83828eb86711fa">errorMultiplicator</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.9; <span class="comment">// The factor between each LOD-level (error = baseError * errorMultiplicator  * level)</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a986b4a97b153d50f65603ab507bb4614">skirtFactor</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.7;        <span class="comment">// Controls how long the skirts are. The lower the number, the shorter the skirts are. This saves geometry. But if they are too short, cracks might occure.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#af6ed62b76c67d04eb98424414fb1dc72">scale</a> = 10;                     <span class="comment">// The displayed volume will be scaled by this factor.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#ae125003c00de0d6c0a1a4bd6b99c4ebf">maxScreenSpaceError</a> = 30;       <span class="comment">// The screen space error controlling when the LOD-levels change.</span></div></div><!-- fragment --><p>Create the root-chunk and load now. The two vectors define the area to be scanned in the volume-source. The following integer determines the amount of LOD-levels. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> Chunk();</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(mVolumeRootNode, Vector3::ZERO, Vector3(256), 5, &amp;parameters);</div></div><!-- fragment --><p> Now setup the global volume material: </p><div class="fragment"><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a5129bccc53d17060635ada67443324f7">setMaterial</a>(<span class="stringliteral">&quot;triplanarReference&quot;</span>);</div></div><!-- fragment --> <h1><a class="anchor" id="triangles"></a>
Getting the triangles of the chunks</h1>
<p>When you want to integrate the volume triangles in a physics engine for example, you need to hand over the exact triangles. For this scenario, the ChunkParameters hold a pointer to a ''MeshBuilderCallback'' and a number ''lodCallbackLod''. The first is an interface with a single function ''trianglesReady'' which is called, when the triangles of a chunk are ready. The chunks are chosen via the ''lodCallbackLod''. If you build a volume with 3 LOD levels and you want the triangles of the highest detail level, you set this parameter to 3. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyMeshBuilderCallback : <span class="keyword">public</span> MeshBuilderCallback</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span>  ready(<span class="keyword">const</span> SimpleRenderable *simpleRenderable, <span class="keyword">const</span> <a class="code" href="group___volume.html#gabf42f450c9ea75c61753f6d485cb8357">VecVertex</a> &amp;vertices, <span class="keyword">const</span> <a class="code" href="group___volume.html#ga325b1df965bf0137edd13bb52bc422be">VecIndices</a> &amp;indices, <span class="keywordtype">size_t</span> level, <span class="keywordtype">int</span> inProcess)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">size_t</span> count = indices.size();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count; i += 3)</div><div class="line">        {</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v1 = vertices[indices[i]];</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v2 = vertices[indices[i + 1]];</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v3 = vertices[indices[i + 2]];</div><div class="line">            <span class="comment">// Do something with the Triangle...</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>And using it like this: </p><div class="fragment"><div class="line"><a class="code" href="group___volume.html#ga89fbc5eed010b8802358563eb88e674a">ChunkParameters</a> parameters;</div><div class="line">...</div><div class="line">MyMeshBuilderCallback callback;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a6403e2875cc7b81aefd43ba9f22c2b31">lodCallback</a> = &amp;callback;</div><div class="line">parameters.lodCallbackLod = 3;</div><div class="line">...</div><div class="line">rootChunk-&gt;load(parent, from, to, 3, &amp;parameters);</div></div><!-- fragment --><p> Or in case of loading from a configuration file: </p><div class="fragment"><div class="line">MyMeshBuilderCallback callback;</div><div class="line">rootChunk-&gt;load(parent, sceneManager, <span class="stringliteral">&quot;myVolume.cfg&quot;</span>, 0, &amp;callback, 3);</div></div><!-- fragment --><p>You might have seen, that a pointer to a SimpleRenderable is handed in, too. This is actually the Chunk whose triangles are loaded. It's parent class is used to not create a circular dependency. You might get the triangle data from it, too by getting the Renderoperation.</p>
<h1><a class="anchor" id="intersecting"></a>
Intersecting a ray with a volume</h1>
<p>When you want to do something exactly on the volume surface, you can cast rays and find their first intersection point. Behold that the triangle representation might be slightly different than the actual volume surface. And you have to scale the ray origin just like the volume. Here is an example which uses the negative z-axis of the camera as ray as it might be done like in an ego-shooter: </p><div class="fragment"><div class="line">Ray ray(mCamera-&gt;getPosition() / rootChunk-&gt;getScale(), -mCamera-&gt;getOrientation().zAxis());</div><div class="line">Vector3 intersection;</div><div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> scale = mVolumeRoot-&gt;getChunkParameters()-&gt;scale;</div><div class="line"><span class="keywordtype">bool</span> intersects = mVolumeRoot-&gt;getChunkParameters()-&gt;src-&gt;getFirstRayIntersection(ray, intersection, scale);</div><div class="line"><span class="keywordflow">if</span> (intersects)</div><div class="line">{</div><div class="line">    intersection *= scale; <span class="comment">// As it is in volume space.</span></div><div class="line">    <span class="comment">// Do something with intersection.</span></div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="editing"></a>
Editing a Volume made from a GridSource</h1>
<p>A usecase is realtime editing of volume terrain as seen as in the sample. Let's union the terrain with a sphere of the radius 2.5 and the center 123/123/123. <b>volumeRoot</b> is the Chunk instance with which the terrain was initially loaded. The factor 1.5 is just to have a save border arround the sphere which also gets updated. The rest of the parameters are 5 LOD levels and a volume mesh covering an area of 384^3. </p><div class="fragment"><div class="line">Vector3 center(123);</div><div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> radius = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)2.5;</div><div class="line">CSGSphereSource sphere(radius, center);</div><div class="line">CSGUnionSource operation;</div><div class="line"><span class="keyword">static_cast&lt;</span>GridSource*<span class="keyword">&gt;</span>(volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a>)-&gt;combineWithSource(&amp;operation, &amp;sphere, center, radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aeefacd1d618206fcb432ed947b58e06e">updateFrom</a> = center - radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5;</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#afe30999e8cc71a1f48d87d68bf43059d">updateTo</a> = center + radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5;</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, Vector3::ZERO, Vector3(384), 5, volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>());</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Trays GUI System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('trays.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Trays GUI System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#trays-1">Trays</a></li>
<li class="level1"><a href="#traymanager">TrayManager</a></li>
<li class="level1"><a href="#widgets">Widgets</a></li>
<li class="level1"><a href="#special-widgets">Special Widgets</a></li>
<li class="level1"><a href="#tray-listener">TrayListener</a></li>
<li class="level1"><a href="#things-to-try">Things to Try</a></li>
</ul>
</div>
<div class="textblock"><p>Ever wanted really simple GUI controls for your sample? Don't want to write one from scratch, but CEGUI's just a little too much? The Trays system was created to address this issue. It's a simple GUI system based on the OGRE Overlay system and designed just for samples. Because it's simple, you're not going to be able to skin it or build very unique interfaces, but you'll also find it much easier to use. The entire system is based on the OGRE Overlay system.</p>
<h1><a class="anchor" id="trays-1"></a>
Trays</h1>
<p>Why trays? The concept of trays is central to the system in that it removes the need for the GUI designer (you) to calculate or specify positional coordinates of any kind. Think about the widget locations in a typical GUI. They are almost always in any of the four corners, along any of the four edges or, on the rare occasion, in the center of the screen. In Trays, there are nine "trays", one in each of the locations previously mentioned. When you create a widget, you specify one of these nine locations, and the widget will be added to the tray at that location. Your widget will be added directly beneath the last widget in that tray. When you add a widget to a tray, the tray grows in size. Trays along the top of the screen grow downward, Trays along the bottom grow upward, and the trays in the middle row grow vertically in both directions. Visually, the trays are semi-transparent panels that fit the widgets they contain. Only non-empty trays are visible. If this is hard to visualise, don't worry, here's a picture to help you out. </p><div class="image">
<img src="Gui2.jpg" alt="Gui2.jpg"/>
</div>
<h1><a class="anchor" id="traymanager"></a>
TrayManager</h1>
<p>To use Trays, you have to create an TrayManager. This is the class through which you will create and manage all your widgets, manipulate the cursor, change the backdrop image, adjust tray properties, pop up dialogs, show/hide the loading bar, etc. You can have multiple tray managers in one application. For example, the OGRE Sample Browser uses its own tray manager and hides it when a sample is running, and the SDK samples also have their own tray managers, which are hidden when the samples are paused by the browser. The TrayManager requires "Trays.zip", so you can only create it after loading that resource. Also, make sure you're using the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> namespace (Trays is part of the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Samples Framework). Create your tray manager like so: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>* mTrayMgr = <span class="keyword">new</span> <a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>(<span class="stringliteral">&quot;InterfaceName&quot;</span>, mWindow, <span class="keyword">this</span>);</div></div><!-- fragment --><p> You must pass in a name for your interface, an <code><a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a></code> and an <code><a class="el" href="class_ogre_bites_1_1_tray_listener.html" title="Listener class for responding to tray events. ">OgreBites::TrayListener</a></code>. You can extend your sample or sample context to be a tray listener. Destroy your tray manager like so: </p><div class="fragment"><div class="line"><span class="keyword">delete</span> mTrayMgr;</div><div class="line">mTrayMgr = 0;</div></div><!-- fragment --><p> Once you have your tray manager, make sure you relay your OIS events to it. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> mousePressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseDown(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseReleased(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseUp(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseMoved(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_motion_event.html">OgreBites::MouseMotionEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseMove(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> The injection methods return true if the event was relevant to the tray manager, and should not be processed again by you. For example, if you click a button that is over an interactive part of your scene, you want the button to be pressed, but you don't want the scene interaction to take place. So the injection methods double as filters for your mouse events.</p>
<p>You're now free to create widgets! Try adding a button to the top-left tray: </p><div class="fragment"><div class="line">Button* b = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">createButton</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530afe04de8736168ab0dd6e7938e679c292">TL_TOPLEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <span class="stringliteral">&quot;Click Me!&quot;</span>);</div></div><!-- fragment --><p> TrayManager is a huge class, and you can do tons of things with it. For some examples, see the Things to Try section below.</p>
<h2>The Cursor</h2>
<p>The cursor has three parts in the Trays system: The layer it moves around in Overlay, the container which positions the cursor (OverlayContainer), and the cursor image, which is a child of the container (OverlayElement). When hiding/showing the cursor, the entire cursor layer is hidden/shown. The top left corner of the cursor container is used as the hotspot of the cursor. By positioning the cursor image relative to the cursor container, you can basically decide which part of the cursor image is the "clicking part". For the default arrow cursor, the image is simply lined up with the container, meaning the top left is the hotspot. However, for something like a crosshair cursor, you could move the cursor image so that its center is over the top left corner of the cursor container. To show the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1cc48ac157278b5845d425abbe9acefd" title="Displays specified material on cursor, or the last material used if none specified. ">OgreBites::TrayManager::showCursor</a></code>, which takes an optional material name for the cursor image. If unspecified, the cursor image is not changed. To hide the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a979ff2ad2d729223259b3bebb237cafb">OgreBites::TrayManager::hideCursor</a></code>. You can get the cursor's different parts using getCursorLayer, getCursorContainer, and getCursorImage. Note that if the cursor is hidden, all interactions with widgets are disabled.</p>
<h2>The Backdrop</h2>
<p>If you want to show a backdrop, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ad554418c27edb907f0e3bead8659b83c" title="Displays specified material on backdrop, or the last material used if none specified. ">OgreBites::TrayManager::showBackdrop</a></code>, which takes an optional material name for the backdrop. If unspecified, the backdrop image is not changed. To hide it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a6129a1e92ac22789a4602cf36f9c5394">OgreBites::TrayManager::hideBackdrop</a></code>.</p>
<h1><a class="anchor" id="widgets"></a>
Widgets</h1>
<p>There are 10 basic widgets. Each widget is just an instance of an OverlayElement template, and all widgets use {LEX()}pixel{LEX} metrics. You can get access to any widget's underlying OverlayElement through <code><a class="el" href="class_ogre_bites_1_1_widget.html#a379d3f1a2ca6eaf13fc5c52afaafd0d2">OgreBites::Widget::getOverlayElement</a></code>. Do not instantiate and delete widgets manually. Create and destroy them using the TrayManager. The first argument to any one of TrayManager's widget creation methods is the location of the tray you want the widget to be in. This is of the enumerated type TrayLocation. The second argument is the name of your widget (this is not your widget's caption, but a unique string identifier for your widget). The rest of the arguments are specific to the type of widget.</p>
<h2>Button</h2>
<p>This is the most basic widget of all. To create a button, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">OgreBites::TrayManager::createButton</a></code>. In addition to a tray location and a name, you must specify a caption for your button, and an optional width. If width is not specified, the button will automatically resize to fit its caption. There are no button states. You only get notified when a button is pushed. To see how to respond to button push events, see the TrayListener section below.</p>
<h2>TextBox</h2>
<p>This widget consists of a bold caption bar and a text area that can be scrolled vertically. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a07a8d212939266339e877ff2118250a6">OgreBites::TrayManager::createTextBox</a></code> takes a caption, width, and height. You can set/get the caption, the text area contents, text padding, text alignment, manually change the scroll bar position, among other things.</p>
<h2>SelectMenu</h2>
<p>A basic drop-down menu. To create it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a60864ca00d65b2bf1b97bb8545fab737">OgreBites::TrayManager::createLongSelectMenu</a></code> or <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a98f478c8daa5084b53146de03adbc216">OgreBites::TrayManager::createThickSelectMenu</a></code>. Both these methods return a SelectMenu object, but they give one of two different visual styles to the widget. One is thicker, but shorter, because it places the caption over the item box. This style of menu is good for putting in the side trays. The other is longer, but thinner, because it places the item box next to the caption. This style of menu is good for putting in the top or bottom trays. createThickSelectMenu takes a tray location, a name, a caption, the width of the whole widget, the maximum number of visible items when expanded, and an optional string vector of items. The medthod <code>createLongSelectMenu</code> takes nearly the same arguments, except that it needs the width of the text box that shows the currently selected item. Also, for long menus, it is optional to specify the total width because it will automatically resize to fit the item box and the caption. You can set/get the caption, and set/get the items in many different ways. You can also manually change the selection, with the option of not firing an event. To see how to respond to menu item selection events, see the TrayListener section below.</p>
<h2>Label</h2>
<p>A big, semi-transparent, tabby-looking label. This widget uses a different font from the rest of the widgets, and is good for section headings and such. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a15375d59b5c57059c9c6549fc5a1bfcd">OgreBites::TrayManager::createLabel</a></code> takes a caption, and an optional width. If the width is not specified, the label automatically adjusts its width to fill the tray it's currently in, so it matches the other contents of the tray. Labels can also be clicked. To see how to respond to label click events, see the TrayListener section below.</p>
<h2>Separator</h2>
<p>A horizontal line which looks like it was etched into the tray. Good for dividing up other widgets into sections without taking up as much space as a label. <code>TrayManager::createSeparator</code> takes a tray location, name, and an optional width. If the width is not specified, the behaviour is the same as a Label's.</p>
<h2>Slider</h2>
<p>A slider bar consists of a container box, a small text box to display the value, and a track + handle. Sliders are type-agnostic. Using three parameters - a minimum value, a maximum value, and the number of "snapping points", you can give your slider track of any kind of discrete scale - integer, floating point, or even nominal. Snapping points are basically the "steps" on your slider track. By specifying how many of them there are, you are in effect specifying an entire range of values all the way from your minimum value to your maximum value. Let's say you have minimum value 0, maximum value 1, and 6 snapping points. Underneath the surface, each slider stores a floating point value, so in this case you would be able to display 6 floating point values: {0, 0.2, 0.4, 0.6, 0.8, 1}. The slider will display your value in the cleanest way possible (using <code><a class="el" href="class_ogre_1_1_string_converter.html#a45fb498a2f798c82bbf88116a5a34c53" title="Converts a float to a String. ">Ogre::StringConverter::toString</a></code>). This means that if all your values happen to land on integers, then they will be displayed as integers without decimals. You can also exploit this by using your slider's integer values as indices into an array of string values, and manually set your slider's value to the new string value. Basically, you can make your slider display things like Low, Medium, High, 1/4, 3/4, $4.00, N/A, etc. This requires you to respond to slider move events. More on this in the TrayListener section below. Then your Like select menus, sliders also come in two flavours - thick and long. The thick style places the caption and the value box above the track, while the long style places the caption, track, and value box side by side in that order. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a597ec173c1b424980e18fd92e0c56905">OgreBites::TrayManager::createThickSlider</a></code> takes a tray location, name, caption, total width, value box width, minimum value, maximum value, and the number of snapping points. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a321429ade975d3a63dfc1125b4375e78">OgreBites::TrayManager::createLongSlider</a></code> takes a an optional total width, track width, value box width, minimum value, maximum value, and the number of snapping points. If the total width is not specified, the slider will automatically scale to fit the track, the value box, and the caption text. You can get/set the slider's caption, displayed value, actual value, and range of values. When you change the range, the value is reset to be the minimum value. When you change the value, you also have the option of not firing an event. To respond to slider move events, see the TrayListener section below.</p>
<h2>ParamsPanel</h2>
<p>This panel displays an arbitrary number of parameters and their values. This could be anything you want. For example, the stats panel in the SDK samples shows the average framerate, best framerate, batch count, etc. The details panel in the SDK samples shows the texture filtering technique, the polygon mode, and the camera position and orientation. To create a ParamsPanel, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a5ae6b66603e05193b3077f30900209eb">OgreBites::TrayManager::createParamsPanel</a></code>, which takes a tray location, a name, a width, and then either a string vector of parameter names or the number of parameters (lines) to leave room for. The parameter names will be left justified, and their values will be right justified on the same line. At any time, you can set/get the parameter names and values either one at a time, or all at once using a string vector.</p>
<h2>CheckBox</h2>
<p>Self-explanatory. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7433f3e89c5b3a1b1b0012dfcb121f1d">OgreBites::TrayManager::createCheckBox</a></code> takes a tray location, name, caption, and an optional width. Unspecified width means auto-fit to caption. You can set/get the state of the check box, with the option of not triggering an event. To respond to check box state change events, see the TrayListener section below. </p><h2>DecorWidget</h2>
<p>This widget takes any OverlayElement template, and creates a widget out of it. If you want to put your own picture, icons, or other static objects into the trays, make an OverlayElement template out of it, and then turn it into a DecorWidget. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a24d1b3a3b95ddcf274bf899b7600deba">OgreBites::TrayManager::createDecorWidget</a></code> takes a tray location, a name, and an OverlayElement template name. These are basically the same things you would normally use to create an OverlayElement from a template. The OGRE logo in the SDK samples is a DecorWidget. </p><h2>ProgressBar</h2>
<p>A progress bar with a caption, a comment/details box, and a meter that fills up. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a431a347db6465bbf66af82ef363c875f">OgreBites::TrayManager::createProgressBar</a></code> takes a tray location, a name, a caption, a total width, and comment box width. You can use progress bars to show any kind of progress you want, but for the most common kind (loading resources), there's a special instance of ProgressBar already created by TrayManager which you can use. See Loading Bar below.</p>
<h2>The Null Tray</h2>
<p>In addition to the nine trays you can place your widgets in, there is also a "null tray". This is an imaginary tray, whose location is specified by <code>TL_NONE</code>. This tray is virtual, invisible, and does not arrange widgets within it. Basically, if you place a widget in this tray, it becomes "free-floating", and you're allowed to manually position it anywhere on the screen. Widgets must always reside in a tray for as long as they exist, so when a widget is removed from a tray, it is automatically placed in the null tray.</p>
<h1><a class="anchor" id="special-widgets"></a>
Special Widgets</h1>
<p>Some widgets are so common they deserve special treatment.</p>
<h2>Frame Stats</h2>
<p>This is not exactly one widget, but a combination of Label that displays the current FPS, and a ParamsPanel that displays advanced frame statistics (such as average FPS and batch count). Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a49e2f792fee94e75b1b472826bcc8019" title="Shows frame statistics widget set in the specified location. ">OgreBites::TrayManager::showFrameStats</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1c2e9618a3e6b061a9cfeac4f2cb55e9" title="Hides frame statistics widget set. ">OgreBites::TrayManager::hideFrameStats</a></code> to show/hide this special widget. You can choose where to put it. When the user clicks the FPS label, it toggles the visibility of the advanced frame stats, so they can be out of the way when they're unwanted. You can also manually toggle the visibility of the advanced frame stats using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aed00f8a1009f2ebf6806774cb894d0d7" title="Toggles visibility of advanced statistics. ">OgreBites::TrayManager::toggleAdvancedFrameStats</a></code>.</p>
<h2>Logo</h2>
<p>This is just a decor widget of the OGRE logo. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#affee57f47066e25437649d64daaa7dd9" title="Shows logo in the specified location. ">OgreBites::TrayManager::showLogo</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ac1ee637b7ef5e887170c8a9aca1c4c7b">OgreBites::TrayManager::hideLogo</a></code> to show/hide the logo. You can choose where to put it.</p>
<h2>Loading Bar</h2>
<p>This is a progress bar that shows you the progress of your current resource loading job. The comment box will show the current resource being loaded. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a0d51005a4b148a4df2c1c6b55e34f085" title="Shows loading bar. ">OgreBites::TrayManager::showLoadingBar</a></code> before you begin your loading job. Specify the number of resource groups you will initialise, the number of groups you will load, and, if you want to, the proportion of time you think will go to initialisation (default estimate is 70%). You cannot decide where to place this loading bar. The screen will be darkened, and the loading bar will appear in the center. Any other dialog or loading bar will be closed. When you finish your loading job, call <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aab014a2c48c8f91556182e42684d44ad">OgreBites::TrayManager::hideLoadingBar</a></code>.</p>
<h2>Information Dialog</h2>
<p>This is a dialog which tells the user something and displays an OK button. It's a combination of a TextBox and a Button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#abf3bd8e4ef9a6d0d76f27535a6010623" title="Pops up a message dialog with an OK button. ">OgreBites::TrayManager::showOkDialog</a></code> to display an information dialog. Specify the caption of the TextBox, and the message you want to display in it. Any other dialog or loading bar will be closed. The screen will be darkened, and the dialog will appear in the center. All other widget interactions are disabled until the dialog is closed. You can manually close a dialog using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#af5d95dcaa7c74d3345308e4f4e3035e8" title="Hides whatever dialog is currently showing. ">OgreBites::TrayManager::closeDialog</a></code>. To respond to information dialog closing events, see the TrayListenersection below.</p>
<h2>Question Dialog</h2>
<p>Same as the Information Dialog except it asks the user something and displays a Yes button and a No button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a85d47aa11d761742884dc6457ec11cdf" title="Pops up a question dialog with Yes and No buttons. ">OgreBites::TrayManager::showYesNoDialog</a></code> to display a question dialog. Specify the caption of the TextBox, and the question you want to display in it. To respond to question dialog closing events, see the TrayListener section below.</p>
<h1><a class="anchor" id="tray-listener"></a>
TrayListener</h1>
<p>This class contains handlers for all the different events that your widgets can fire. The TrayManager class itself is an TrayListener, because it responds to events from its special widgets. You should extend your sample class from TrayListener as well as Sample if you want to handle widget events. If you're using SdkSample, you're all set because it's already an TrayListener. Some widgets give you an option of not firing an event when you change their state. This is helpful for initialising or resetting a widget, in which case there shouldn't be a response of any sort. For example, if you're initialising your slider bar before the scene is set up, and your slider bar is used to control some part of your scene, firing an event would cause an error. Below is a list of the different handlers. All handlers have return type void.</p><ul>
<li><b>buttonHit</b>: Gives you a pointer to the Button which was hit.</li>
<li><b>itemSelected</b>: Gives you a pointer to the SelectMenu the item was chosen from. You can then use the SelectMenu to see which item was selected.</li>
<li><b>labelHit</b>: Gives you a pointer to the Label that was clicked.</li>
<li><b>sliderMoved</b>: Gives you a pointer to the Slider whose value was changed. You can then use the Slider to see what its new value is. Also, you can convert this value into a more suitable form and display it using Slider::setDisplayedValue.</li>
<li><b>checkBoxToggled</b>: Gives you a pointer to the CheckBox whose state was changed. You can then use the CheckBox to see if it's been checked or unchecked.</li>
<li><b>okDialogClosed</b>: Gives you the message of the OK dialog that was closed.</li>
<li><b>yesNoDialogClosed</b>: Gives you the question of the Yes-No dialog that was closed, and a boolean indicating whether or not the Yes button was pressed.</li>
</ul>
<h1><a class="anchor" id="things-to-try"></a>
Things to Try</h1>
<p>Getting access to widgets: </p><div class="fragment"><div class="line">Button* b;</div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);  <span class="comment">// by tray and position</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by tray and name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#af968c01a627ee654409f558e4ef55537">getWidgetIterator</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>).<a class="code" href="class_ogre_1_1_vector_iterator_wrapper.html#a2460c8adb6819235849de954db6a0f64">getNext</a>();  <span class="comment">// by iterator</span></div></div><!-- fragment --><p> Counting widgets: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>();  <span class="comment">// total</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);  <span class="comment">// by tray</span></div></div><!-- fragment --><p> Moving widgets to other trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div></div><!-- fragment --><p> Removing widgets from trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a04a1085bdee61d7234849663cce08664">TL_NONE</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a77ba6e4d641c146e262b6cdd2c8b04a0">clearTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9787ec5e8989bf6cfa89d03c6ddd27b6">clearAllTrays</a>();</div></div><!-- fragment --><p> Destroying widgets: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4a89cd6f7d87e0e538aa842f1a42a7bc">destroyAllWidgetsInTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aadb1f5a3b7e3b5397b10bdd3449e1603">destroyAllWidgets</a>();</div></div><!-- fragment --><p> Finding the position of a widget in a tray: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa993d2b60cfbcb903aecbff1c4896b67">locateWidgetInTray</a>(b);</div></div><!-- fragment --><p> Finding the tray a widget is in: </p><div class="fragment"><div class="line"><a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530">TrayLocation</a> trayLoc = b-&gt;getTrayLocation();</div></div><!-- fragment --><p> Changing the tray listener object: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a3235fea714a0c61e463dee69ae308be8">setListener</a>(newListener);</div></div><!-- fragment --><p> Toggling system visibility: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a075805136b2241cbb03eeb2c3d27b40d">showAll</a>();</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a188f1d5f5ca16af3b28d11ecd553105a">hideAll</a>();</div></div><!-- fragment --><p> Changing horizontal widget alignment in one tray: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#adfbbc97615fd5f1a939be6e7a1f00c07">setTrayWidgetAlignment</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <a class="code" href="group___overlays.html#gga3396780cdb2d731aa5e4389148bdc5f3a270f18cf07dbe4e75e1b790d02924205">GHA_RIGHT</a>);</div></div><!-- fragment --><p> Changing spacing and padding: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a33a3e3f66a3989dd3de48b4c4577422f">setWidgetSpacing</a>(5);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a52d3fc8638533540232232c37b257de6">setWidgetPadding</a>(3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a866229b6d88dc9d3a609115eaab46e67">setTrayPadding</a>(12);</div></div><!-- fragment --><p> Casting 3D ray from under cursor into the scene: </p><div class="fragment"><div class="line">Ray r = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9dd5d303968329462e9bf4225f59722e">getCursorRay</a>(mCamera);</div></div><!-- fragment --><p> Casting 3D ray from any 2D screen coordinate into the scene: </p><div class="fragment"><div class="line">Ray r = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#a6833f46b0303b559a050f310fa0204fc">OgreBites::TrayManager::screenToScene</a>(mCamera, Vector2(320, 240));</div></div><!-- fragment --><p> Converting a 3D scene coordinate to a 2D screen coordinate: </p><div class="fragment"><div class="line">Vector2 p = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa7a456c2c0c37123e2ab0e497f2c0ccc">OgreBites::TrayManager::sceneToScreen</a>(mCamera, Vector3::ZERO);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Trays GUI System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('trays.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Trays GUI System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#trays-1">Trays</a></li>
<li class="level1"><a href="#traymanager">TrayManager</a></li>
<li class="level1"><a href="#widgets">Widgets</a></li>
<li class="level1"><a href="#special-widgets">Special Widgets</a></li>
<li class="level1"><a href="#tray-listener">TrayListener</a></li>
<li class="level1"><a href="#things-to-try">Things to Try</a></li>
</ul>
</div>
<div class="textblock"><p>Ever wanted really simple GUI controls for your sample? Don't want to write one from scratch, but CEGUI's just a little too much? The Trays system was created to address this issue. It's a simple GUI system based on the OGRE Overlay system and designed just for samples. Because it's simple, you're not going to be able to skin it or build very unique interfaces, but you'll also find it much easier to use. The entire system is based on the OGRE Overlay system.</p>
<h1><a class="anchor" id="trays-1"></a>
Trays</h1>
<p>Why trays? The concept of trays is central to the system in that it removes the need for the GUI designer (you) to calculate or specify positional coordinates of any kind. Think about the widget locations in a typical GUI. They are almost always in any of the four corners, along any of the four edges or, on the rare occasion, in the center of the screen. In Trays, there are nine "trays", one in each of the locations previously mentioned. When you create a widget, you specify one of these nine locations, and the widget will be added to the tray at that location. Your widget will be added directly beneath the last widget in that tray. When you add a widget to a tray, the tray grows in size. Trays along the top of the screen grow downward, Trays along the bottom grow upward, and the trays in the middle row grow vertically in both directions. Visually, the trays are semi-transparent panels that fit the widgets they contain. Only non-empty trays are visible. If this is hard to visualise, don't worry, here's a picture to help you out. </p><div class="image">
<img src="Gui2.jpg" alt="Gui2.jpg"/>
</div>
<h1><a class="anchor" id="traymanager"></a>
TrayManager</h1>
<p>To use Trays, you have to create an TrayManager. This is the class through which you will create and manage all your widgets, manipulate the cursor, change the backdrop image, adjust tray properties, pop up dialogs, show/hide the loading bar, etc. You can have multiple tray managers in one application. For example, the OGRE Sample Browser uses its own tray manager and hides it when a sample is running, and the SDK samples also have their own tray managers, which are hidden when the samples are paused by the browser. The TrayManager requires "Trays.zip", so you can only create it after loading that resource. Also, make sure you're using the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> namespace (Trays is part of the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Samples Framework). Create your tray manager like so: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>* mTrayMgr = <span class="keyword">new</span> <a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>(<span class="stringliteral">&quot;InterfaceName&quot;</span>, mWindow, <span class="keyword">this</span>);</div></div><!-- fragment --><p> You must pass in a name for your interface, an <code><a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a></code> and an <code><a class="el" href="class_ogre_bites_1_1_tray_listener.html" title="Listener class for responding to tray events. ">OgreBites::TrayListener</a></code>. You can extend your sample or sample context to be a tray listener. Destroy your tray manager like so: </p><div class="fragment"><div class="line"><span class="keyword">delete</span> mTrayMgr;</div><div class="line">mTrayMgr = 0;</div></div><!-- fragment --><p> Once you have your tray manager, make sure you relay your OIS events to it. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> mousePressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseDown(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseReleased(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseUp(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseMoved(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_motion_event.html">OgreBites::MouseMotionEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseMove(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> The injection methods return true if the event was relevant to the tray manager, and should not be processed again by you. For example, if you click a button that is over an interactive part of your scene, you want the button to be pressed, but you don't want the scene interaction to take place. So the injection methods double as filters for your mouse events.</p>
<p>You're now free to create widgets! Try adding a button to the top-left tray: </p><div class="fragment"><div class="line">Button* b = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">createButton</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530afe04de8736168ab0dd6e7938e679c292">TL_TOPLEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <span class="stringliteral">&quot;Click Me!&quot;</span>);</div></div><!-- fragment --><p> TrayManager is a huge class, and you can do tons of things with it. For some examples, see the Things to Try section below.</p>
<h2>The Cursor</h2>
<p>The cursor has three parts in the Trays system: The layer it moves around in Overlay, the container which positions the cursor (OverlayContainer), and the cursor image, which is a child of the container (OverlayElement). When hiding/showing the cursor, the entire cursor layer is hidden/shown. The top left corner of the cursor container is used as the hotspot of the cursor. By positioning the cursor image relative to the cursor container, you can basically decide which part of the cursor image is the "clicking part". For the default arrow cursor, the image is simply lined up with the container, meaning the top left is the hotspot. However, for something like a crosshair cursor, you could move the cursor image so that its center is over the top left corner of the cursor container. To show the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1cc48ac157278b5845d425abbe9acefd" title="Displays specified material on cursor, or the last material used if none specified. ">OgreBites::TrayManager::showCursor</a></code>, which takes an optional material name for the cursor image. If unspecified, the cursor image is not changed. To hide the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a979ff2ad2d729223259b3bebb237cafb">OgreBites::TrayManager::hideCursor</a></code>. You can get the cursor's different parts using getCursorLayer, getCursorContainer, and getCursorImage. Note that if the cursor is hidden, all interactions with widgets are disabled.</p>
<h2>The Backdrop</h2>
<p>If you want to show a backdrop, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ad554418c27edb907f0e3bead8659b83c" title="Displays specified material on backdrop, or the last material used if none specified. ">OgreBites::TrayManager::showBackdrop</a></code>, which takes an optional material name for the backdrop. If unspecified, the backdrop image is not changed. To hide it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a6129a1e92ac22789a4602cf36f9c5394">OgreBites::TrayManager::hideBackdrop</a></code>.</p>
<h1><a class="anchor" id="widgets"></a>
Widgets</h1>
<p>There are 10 basic widgets. Each widget is just an instance of an OverlayElement template, and all widgets use {LEX()}pixel{LEX} metrics. You can get access to any widget's underlying OverlayElement through <code><a class="el" href="class_ogre_bites_1_1_widget.html#a379d3f1a2ca6eaf13fc5c52afaafd0d2">OgreBites::Widget::getOverlayElement</a></code>. Do not instantiate and delete widgets manually. Create and destroy them using the TrayManager. The first argument to any one of TrayManager's widget creation methods is the location of the tray you want the widget to be in. This is of the enumerated type TrayLocation. The second argument is the name of your widget (this is not your widget's caption, but a unique string identifier for your widget). The rest of the arguments are specific to the type of widget.</p>
<h2>Button</h2>
<p>This is the most basic widget of all. To create a button, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">OgreBites::TrayManager::createButton</a></code>. In addition to a tray location and a name, you must specify a caption for your button, and an optional width. If width is not specified, the button will automatically resize to fit its caption. There are no button states. You only get notified when a button is pushed. To see how to respond to button push events, see the TrayListener section below.</p>
<h2>TextBox</h2>
<p>This widget consists of a bold caption bar and a text area that can be scrolled vertically. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a07a8d212939266339e877ff2118250a6">OgreBites::TrayManager::createTextBox</a></code> takes a caption, width, and height. You can set/get the caption, the text area contents, text padding, text alignment, manually change the scroll bar position, among other things.</p>
<h2>SelectMenu</h2>
<p>A basic drop-down menu. To create it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a60864ca00d65b2bf1b97bb8545fab737">OgreBites::TrayManager::createLongSelectMenu</a></code> or <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a98f478c8daa5084b53146de03adbc216">OgreBites::TrayManager::createThickSelectMenu</a></code>. Both these methods return a SelectMenu object, but they give one of two different visual styles to the widget. One is thicker, but shorter, because it places the caption over the item box. This style of menu is good for putting in the side trays. The other is longer, but thinner, because it places the item box next to the caption. This style of menu is good for putting in the top or bottom trays. createThickSelectMenu takes a tray location, a name, a caption, the width of the whole widget, the maximum number of visible items when expanded, and an optional string vector of items. The medthod <code>createLongSelectMenu</code> takes nearly the same arguments, except that it needs the width of the text box that shows the currently selected item. Also, for long menus, it is optional to specify the total width because it will automatically resize to fit the item box and the caption. You can set/get the caption, and set/get the items in many different ways. You can also manually change the selection, with the option of not firing an event. To see how to respond to menu item selection events, see the TrayListener section below.</p>
<h2>Label</h2>
<p>A big, semi-transparent, tabby-looking label. This widget uses a different font from the rest of the widgets, and is good for section headings and such. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a15375d59b5c57059c9c6549fc5a1bfcd">OgreBites::TrayManager::createLabel</a></code> takes a caption, and an optional width. If the width is not specified, the label automatically adjusts its width to fill the tray it's currently in, so it matches the other contents of the tray. Labels can also be clicked. To see how to respond to label click events, see the TrayListener section below.</p>
<h2>Separator</h2>
<p>A horizontal line which looks like it was etched into the tray. Good for dividing up other widgets into sections without taking up as much space as a label. <code>TrayManager::createSeparator</code> takes a tray location, name, and an optional width. If the width is not specified, the behaviour is the same as a Label's.</p>
<h2>Slider</h2>
<p>A slider bar consists of a container box, a small text box to display the value, and a track + handle. Sliders are type-agnostic. Using three parameters - a minimum value, a maximum value, and the number of "snapping points", you can give your slider track of any kind of discrete scale - integer, floating point, or even nominal. Snapping points are basically the "steps" on your slider track. By specifying how many of them there are, you are in effect specifying an entire range of values all the way from your minimum value to your maximum value. Let's say you have minimum value 0, maximum value 1, and 6 snapping points. Underneath the surface, each slider stores a floating point value, so in this case you would be able to display 6 floating point values: {0, 0.2, 0.4, 0.6, 0.8, 1}. The slider will display your value in the cleanest way possible (using <code><a class="el" href="class_ogre_1_1_string_converter.html#a45fb498a2f798c82bbf88116a5a34c53" title="Converts a float to a String. ">Ogre::StringConverter::toString</a></code>). This means that if all your values happen to land on integers, then they will be displayed as integers without decimals. You can also exploit this by using your slider's integer values as indices into an array of string values, and manually set your slider's value to the new string value. Basically, you can make your slider display things like Low, Medium, High, 1/4, 3/4, $4.00, N/A, etc. This requires you to respond to slider move events. More on this in the TrayListener section below. Then your Like select menus, sliders also come in two flavours - thick and long. The thick style places the caption and the value box above the track, while the long style places the caption, track, and value box side by side in that order. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a597ec173c1b424980e18fd92e0c56905">OgreBites::TrayManager::createThickSlider</a></code> takes a tray location, name, caption, total width, value box width, minimum value, maximum value, and the number of snapping points. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a321429ade975d3a63dfc1125b4375e78">OgreBites::TrayManager::createLongSlider</a></code> takes a an optional total width, track width, value box width, minimum value, maximum value, and the number of snapping points. If the total width is not specified, the slider will automatically scale to fit the track, the value box, and the caption text. You can get/set the slider's caption, displayed value, actual value, and range of values. When you change the range, the value is reset to be the minimum value. When you change the value, you also have the option of not firing an event. To respond to slider move events, see the TrayListener section below.</p>
<h2>ParamsPanel</h2>
<p>This panel displays an arbitrary number of parameters and their values. This could be anything you want. For example, the stats panel in the SDK samples shows the average framerate, best framerate, batch count, etc. The details panel in the SDK samples shows the texture filtering technique, the polygon mode, and the camera position and orientation. To create a ParamsPanel, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a5ae6b66603e05193b3077f30900209eb">OgreBites::TrayManager::createParamsPanel</a></code>, which takes a tray location, a name, a width, and then either a string vector of parameter names or the number of parameters (lines) to leave room for. The parameter names will be left justified, and their values will be right justified on the same line. At any time, you can set/get the parameter names and values either one at a time, or all at once using a string vector.</p>
<h2>CheckBox</h2>
<p>Self-explanatory. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7433f3e89c5b3a1b1b0012dfcb121f1d">OgreBites::TrayManager::createCheckBox</a></code> takes a tray location, name, caption, and an optional width. Unspecified width means auto-fit to caption. You can set/get the state of the check box, with the option of not triggering an event. To respond to check box state change events, see the TrayListener section below. </p><h2>DecorWidget</h2>
<p>This widget takes any OverlayElement template, and creates a widget out of it. If you want to put your own picture, icons, or other static objects into the trays, make an OverlayElement template out of it, and then turn it into a DecorWidget. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a24d1b3a3b95ddcf274bf899b7600deba">OgreBites::TrayManager::createDecorWidget</a></code> takes a tray location, a name, and an OverlayElement template name. These are basically the same things you would normally use to create an OverlayElement from a template. The OGRE logo in the SDK samples is a DecorWidget. </p><h2>ProgressBar</h2>
<p>A progress bar with a caption, a comment/details box, and a meter that fills up. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a431a347db6465bbf66af82ef363c875f">OgreBites::TrayManager::createProgressBar</a></code> takes a tray location, a name, a caption, a total width, and comment box width. You can use progress bars to show any kind of progress you want, but for the most common kind (loading resources), there's a special instance of ProgressBar already created by TrayManager which you can use. See Loading Bar below.</p>
<h2>The Null Tray</h2>
<p>In addition to the nine trays you can place your widgets in, there is also a "null tray". This is an imaginary tray, whose location is specified by <code>TL_NONE</code>. This tray is virtual, invisible, and does not arrange widgets within it. Basically, if you place a widget in this tray, it becomes "free-floating", and you're allowed to manually position it anywhere on the screen. Widgets must always reside in a tray for as long as they exist, so when a widget is removed from a tray, it is automatically placed in the null tray.</p>
<h1><a class="anchor" id="special-widgets"></a>
Special Widgets</h1>
<p>Some widgets are so common they deserve special treatment.</p>
<h2>Frame Stats</h2>
<p>This is not exactly one widget, but a combination of Label that displays the current FPS, and a ParamsPanel that displays advanced frame statistics (such as average FPS and batch count). Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a49e2f792fee94e75b1b472826bcc8019" title="Shows frame statistics widget set in the specified location. ">OgreBites::TrayManager::showFrameStats</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1c2e9618a3e6b061a9cfeac4f2cb55e9" title="Hides frame statistics widget set. ">OgreBites::TrayManager::hideFrameStats</a></code> to show/hide this special widget. You can choose where to put it. When the user clicks the FPS label, it toggles the visibility of the advanced frame stats, so they can be out of the way when they're unwanted. You can also manually toggle the visibility of the advanced frame stats using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aed00f8a1009f2ebf6806774cb894d0d7" title="Toggles visibility of advanced statistics. ">OgreBites::TrayManager::toggleAdvancedFrameStats</a></code>.</p>
<h2>Logo</h2>
<p>This is just a decor widget of the OGRE logo. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#affee57f47066e25437649d64daaa7dd9" title="Shows logo in the specified location. ">OgreBites::TrayManager::showLogo</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ac1ee637b7ef5e887170c8a9aca1c4c7b">OgreBites::TrayManager::hideLogo</a></code> to show/hide the logo. You can choose where to put it.</p>
<h2>Loading Bar</h2>
<p>This is a progress bar that shows you the progress of your current resource loading job. The comment box will show the current resource being loaded. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a0d51005a4b148a4df2c1c6b55e34f085" title="Shows loading bar. ">OgreBites::TrayManager::showLoadingBar</a></code> before you begin your loading job. Specify the number of resource groups you will initialise, the number of groups you will load, and, if you want to, the proportion of time you think will go to initialisation (default estimate is 70%). You cannot decide where to place this loading bar. The screen will be darkened, and the loading bar will appear in the center. Any other dialog or loading bar will be closed. When you finish your loading job, call <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aab014a2c48c8f91556182e42684d44ad">OgreBites::TrayManager::hideLoadingBar</a></code>.</p>
<h2>Information Dialog</h2>
<p>This is a dialog which tells the user something and displays an OK button. It's a combination of a TextBox and a Button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#abf3bd8e4ef9a6d0d76f27535a6010623" title="Pops up a message dialog with an OK button. ">OgreBites::TrayManager::showOkDialog</a></code> to display an information dialog. Specify the caption of the TextBox, and the message you want to display in it. Any other dialog or loading bar will be closed. The screen will be darkened, and the dialog will appear in the center. All other widget interactions are disabled until the dialog is closed. You can manually close a dialog using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#af5d95dcaa7c74d3345308e4f4e3035e8" title="Hides whatever dialog is currently showing. ">OgreBites::TrayManager::closeDialog</a></code>. To respond to information dialog closing events, see the TrayListenersection below.</p>
<h2>Question Dialog</h2>
<p>Same as the Information Dialog except it asks the user something and displays a Yes button and a No button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a85d47aa11d761742884dc6457ec11cdf" title="Pops up a question dialog with Yes and No buttons. ">OgreBites::TrayManager::showYesNoDialog</a></code> to display a question dialog. Specify the caption of the TextBox, and the question you want to display in it. To respond to question dialog closing events, see the TrayListener section below.</p>
<h1><a class="anchor" id="tray-listener"></a>
TrayListener</h1>
<p>This class contains handlers for all the different events that your widgets can fire. The TrayManager class itself is an TrayListener, because it responds to events from its special widgets. You should extend your sample class from TrayListener as well as Sample if you want to handle widget events. If you're using SdkSample, you're all set because it's already an TrayListener. Some widgets give you an option of not firing an event when you change their state. This is helpful for initialising or resetting a widget, in which case there shouldn't be a response of any sort. For example, if you're initialising your slider bar before the scene is set up, and your slider bar is used to control some part of your scene, firing an event would cause an error. Below is a list of the different handlers. All handlers have return type void.</p><ul>
<li><b>buttonHit</b>: Gives you a pointer to the Button which was hit.</li>
<li><b>itemSelected</b>: Gives you a pointer to the SelectMenu the item was chosen from. You can then use the SelectMenu to see which item was selected.</li>
<li><b>labelHit</b>: Gives you a pointer to the Label that was clicked.</li>
<li><b>sliderMoved</b>: Gives you a pointer to the Slider whose value was changed. You can then use the Slider to see what its new value is. Also, you can convert this value into a more suitable form and display it using Slider::setDisplayedValue.</li>
<li><b>checkBoxToggled</b>: Gives you a pointer to the CheckBox whose state was changed. You can then use the CheckBox to see if it's been checked or unchecked.</li>
<li><b>okDialogClosed</b>: Gives you the message of the OK dialog that was closed.</li>
<li><b>yesNoDialogClosed</b>: Gives you the question of the Yes-No dialog that was closed, and a boolean indicating whether or not the Yes button was pressed.</li>
</ul>
<h1><a class="anchor" id="things-to-try"></a>
Things to Try</h1>
<p>Getting access to widgets: </p><div class="fragment"><div class="line">Button* b;</div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);  <span class="comment">// by tray and position</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by tray and name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#af968c01a627ee654409f558e4ef55537">getWidgetIterator</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>).<a class="code" href="class_ogre_1_1_vector_iterator_wrapper.html#a2460c8adb6819235849de954db6a0f64">getNext</a>();  <span class="comment">// by iterator</span></div></div><!-- fragment --><p> Counting widgets: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>();  <span class="comment">// total</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);  <span class="comment">// by tray</span></div></div><!-- fragment --><p> Moving widgets to other trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div></div><!-- fragment --><p> Removing widgets from trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a04a1085bdee61d7234849663cce08664">TL_NONE</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a77ba6e4d641c146e262b6cdd2c8b04a0">clearTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9787ec5e8989bf6cfa89d03c6ddd27b6">clearAllTrays</a>();</div></div><!-- fragment --><p> Destroying widgets: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4a89cd6f7d87e0e538aa842f1a42a7bc">destroyAllWidgetsInTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aadb1f5a3b7e3b5397b10bdd3449e1603">destroyAllWidgets</a>();</div></div><!-- fragment --><p> Finding the position of a widget in a tray: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa993d2b60cfbcb903aecbff1c4896b67">locateWidgetInTray</a>(b);</div></div><!-- fragment --><p> Finding the tray a widget is in: </p><div class="fragment"><div class="line"><a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530">TrayLocation</a> trayLoc = b-&gt;getTrayLocation();</div></div><!-- fragment --><p> Changing the tray listener object: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a3235fea714a0c61e463dee69ae308be8">setListener</a>(newListener);</div></div><!-- fragment --><p> Toggling system visibility: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a075805136b2241cbb03eeb2c3d27b40d">showAll</a>();</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a188f1d5f5ca16af3b28d11ecd553105a">hideAll</a>();</div></div><!-- fragment --><p> Changing horizontal widget alignment in one tray: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#adfbbc97615fd5f1a939be6e7a1f00c07">setTrayWidgetAlignment</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <a class="code" href="group___overlays.html#gga3396780cdb2d731aa5e4389148bdc5f3a270f18cf07dbe4e75e1b790d02924205">GHA_RIGHT</a>);</div></div><!-- fragment --><p> Changing spacing and padding: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a33a3e3f66a3989dd3de48b4c4577422f">setWidgetSpacing</a>(5);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a52d3fc8638533540232232c37b257de6">setWidgetPadding</a>(3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a866229b6d88dc9d3a609115eaab46e67">setTrayPadding</a>(12);</div></div><!-- fragment --><p> Casting 3D ray from under cursor into the scene: </p><div class="fragment"><div class="line">Ray r = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9dd5d303968329462e9bf4225f59722e">getCursorRay</a>(mCamera);</div></div><!-- fragment --><p> Casting 3D ray from any 2D screen coordinate into the scene: </p><div class="fragment"><div class="line">Ray r = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#a6833f46b0303b559a050f310fa0204fc">OgreBites::TrayManager::screenToScene</a>(mCamera, Vector2(320, 240));</div></div><!-- fragment --><p> Converting a 3D scene coordinate to a 2D screen coordinate: </p><div class="fragment"><div class="line">Vector2 p = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa7a456c2c0c37123e2ab0e497f2c0ccc">OgreBites::TrayManager::sceneToScreen</a>(mCamera, Vector3::ZERO);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Trays GUI System</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('trays.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Trays GUI System </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#trays-1">Trays</a></li>
<li class="level1"><a href="#traymanager">TrayManager</a></li>
<li class="level1"><a href="#widgets">Widgets</a></li>
<li class="level1"><a href="#special-widgets">Special Widgets</a></li>
<li class="level1"><a href="#tray-listener">TrayListener</a></li>
<li class="level1"><a href="#things-to-try">Things to Try</a></li>
</ul>
</div>
<div class="textblock"><p>Ever wanted really simple GUI controls for your sample? Don't want to write one from scratch, but CEGUI's just a little too much? The Trays system was created to address this issue. It's a simple GUI system based on the OGRE Overlay system and designed just for samples. Because it's simple, you're not going to be able to skin it or build very unique interfaces, but you'll also find it much easier to use. The entire system is based on the OGRE Overlay system.</p>
<h1><a class="anchor" id="trays-1"></a>
Trays</h1>
<p>Why trays? The concept of trays is central to the system in that it removes the need for the GUI designer (you) to calculate or specify positional coordinates of any kind. Think about the widget locations in a typical GUI. They are almost always in any of the four corners, along any of the four edges or, on the rare occasion, in the center of the screen. In Trays, there are nine "trays", one in each of the locations previously mentioned. When you create a widget, you specify one of these nine locations, and the widget will be added to the tray at that location. Your widget will be added directly beneath the last widget in that tray. When you add a widget to a tray, the tray grows in size. Trays along the top of the screen grow downward, Trays along the bottom grow upward, and the trays in the middle row grow vertically in both directions. Visually, the trays are semi-transparent panels that fit the widgets they contain. Only non-empty trays are visible. If this is hard to visualise, don't worry, here's a picture to help you out. </p><div class="image">
<img src="Gui2.jpg" alt="Gui2.jpg"/>
</div>
<h1><a class="anchor" id="traymanager"></a>
TrayManager</h1>
<p>To use Trays, you have to create an TrayManager. This is the class through which you will create and manage all your widgets, manipulate the cursor, change the backdrop image, adjust tray properties, pop up dialogs, show/hide the loading bar, etc. You can have multiple tray managers in one application. For example, the OGRE Sample Browser uses its own tray manager and hides it when a sample is running, and the SDK samples also have their own tray managers, which are hidden when the samples are paused by the browser. The TrayManager requires "Trays.zip", so you can only create it after loading that resource. Also, make sure you're using the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> namespace (Trays is part of the <a class="el" href="namespace_ogre_bites.html">OgreBites</a> Samples Framework). Create your tray manager like so: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>* mTrayMgr = <span class="keyword">new</span> <a class="code" href="class_ogre_bites_1_1_tray_manager.html">OgreBites::TrayManager</a>(<span class="stringliteral">&quot;InterfaceName&quot;</span>, mWindow, <span class="keyword">this</span>);</div></div><!-- fragment --><p> You must pass in a name for your interface, an <code><a class="el" href="class_ogre_1_1_render_window.html" title="Manages the target rendering window. ">Ogre::RenderWindow</a></code> and an <code><a class="el" href="class_ogre_bites_1_1_tray_listener.html" title="Listener class for responding to tray events. ">OgreBites::TrayListener</a></code>. You can extend your sample or sample context to be a tray listener. Destroy your tray manager like so: </p><div class="fragment"><div class="line"><span class="keyword">delete</span> mTrayMgr;</div><div class="line">mTrayMgr = 0;</div></div><!-- fragment --><p> Once you have your tray manager, make sure you relay your OIS events to it. </p><div class="fragment"><div class="line"><span class="keywordtype">bool</span> mousePressed(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseDown(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseReleased(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_button_event.html">OgreBites::MouseButtonEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseUp(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">bool</span> mouseMoved(<span class="keyword">const</span> <a class="code" href="struct_ogre_bites_1_1_mouse_motion_event.html">OgreBites::MouseMotionEvent</a>&amp; evt)</div><div class="line">{</div><div class="line">    <span class="keywordflow">if</span> (mTrayMgr-&gt;injectMouseMove(evt)) <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">    <span class="comment">/* normal mouse processing here... */</span></div><div class="line">    <span class="keywordflow">return</span> <span class="keyword">true</span>;</div><div class="line">}</div></div><!-- fragment --><p> The injection methods return true if the event was relevant to the tray manager, and should not be processed again by you. For example, if you click a button that is over an interactive part of your scene, you want the button to be pressed, but you don't want the scene interaction to take place. So the injection methods double as filters for your mouse events.</p>
<p>You're now free to create widgets! Try adding a button to the top-left tray: </p><div class="fragment"><div class="line">Button* b = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">createButton</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530afe04de8736168ab0dd6e7938e679c292">TL_TOPLEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <span class="stringliteral">&quot;Click Me!&quot;</span>);</div></div><!-- fragment --><p> TrayManager is a huge class, and you can do tons of things with it. For some examples, see the Things to Try section below.</p>
<h2>The Cursor</h2>
<p>The cursor has three parts in the Trays system: The layer it moves around in Overlay, the container which positions the cursor (OverlayContainer), and the cursor image, which is a child of the container (OverlayElement). When hiding/showing the cursor, the entire cursor layer is hidden/shown. The top left corner of the cursor container is used as the hotspot of the cursor. By positioning the cursor image relative to the cursor container, you can basically decide which part of the cursor image is the "clicking part". For the default arrow cursor, the image is simply lined up with the container, meaning the top left is the hotspot. However, for something like a crosshair cursor, you could move the cursor image so that its center is over the top left corner of the cursor container. To show the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1cc48ac157278b5845d425abbe9acefd" title="Displays specified material on cursor, or the last material used if none specified. ">OgreBites::TrayManager::showCursor</a></code>, which takes an optional material name for the cursor image. If unspecified, the cursor image is not changed. To hide the cursor, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a979ff2ad2d729223259b3bebb237cafb">OgreBites::TrayManager::hideCursor</a></code>. You can get the cursor's different parts using getCursorLayer, getCursorContainer, and getCursorImage. Note that if the cursor is hidden, all interactions with widgets are disabled.</p>
<h2>The Backdrop</h2>
<p>If you want to show a backdrop, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ad554418c27edb907f0e3bead8659b83c" title="Displays specified material on backdrop, or the last material used if none specified. ">OgreBites::TrayManager::showBackdrop</a></code>, which takes an optional material name for the backdrop. If unspecified, the backdrop image is not changed. To hide it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a6129a1e92ac22789a4602cf36f9c5394">OgreBites::TrayManager::hideBackdrop</a></code>.</p>
<h1><a class="anchor" id="widgets"></a>
Widgets</h1>
<p>There are 10 basic widgets. Each widget is just an instance of an OverlayElement template, and all widgets use {LEX()}pixel{LEX} metrics. You can get access to any widget's underlying OverlayElement through <code><a class="el" href="class_ogre_bites_1_1_widget.html#a379d3f1a2ca6eaf13fc5c52afaafd0d2">OgreBites::Widget::getOverlayElement</a></code>. Do not instantiate and delete widgets manually. Create and destroy them using the TrayManager. The first argument to any one of TrayManager's widget creation methods is the location of the tray you want the widget to be in. This is of the enumerated type TrayLocation. The second argument is the name of your widget (this is not your widget's caption, but a unique string identifier for your widget). The rest of the arguments are specific to the type of widget.</p>
<h2>Button</h2>
<p>This is the most basic widget of all. To create a button, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7486bcec7a51e1d6df53bfdead3281dd">OgreBites::TrayManager::createButton</a></code>. In addition to a tray location and a name, you must specify a caption for your button, and an optional width. If width is not specified, the button will automatically resize to fit its caption. There are no button states. You only get notified when a button is pushed. To see how to respond to button push events, see the TrayListener section below.</p>
<h2>TextBox</h2>
<p>This widget consists of a bold caption bar and a text area that can be scrolled vertically. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a07a8d212939266339e877ff2118250a6">OgreBites::TrayManager::createTextBox</a></code> takes a caption, width, and height. You can set/get the caption, the text area contents, text padding, text alignment, manually change the scroll bar position, among other things.</p>
<h2>SelectMenu</h2>
<p>A basic drop-down menu. To create it, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a60864ca00d65b2bf1b97bb8545fab737">OgreBites::TrayManager::createLongSelectMenu</a></code> or <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a98f478c8daa5084b53146de03adbc216">OgreBites::TrayManager::createThickSelectMenu</a></code>. Both these methods return a SelectMenu object, but they give one of two different visual styles to the widget. One is thicker, but shorter, because it places the caption over the item box. This style of menu is good for putting in the side trays. The other is longer, but thinner, because it places the item box next to the caption. This style of menu is good for putting in the top or bottom trays. createThickSelectMenu takes a tray location, a name, a caption, the width of the whole widget, the maximum number of visible items when expanded, and an optional string vector of items. The medthod <code>createLongSelectMenu</code> takes nearly the same arguments, except that it needs the width of the text box that shows the currently selected item. Also, for long menus, it is optional to specify the total width because it will automatically resize to fit the item box and the caption. You can set/get the caption, and set/get the items in many different ways. You can also manually change the selection, with the option of not firing an event. To see how to respond to menu item selection events, see the TrayListener section below.</p>
<h2>Label</h2>
<p>A big, semi-transparent, tabby-looking label. This widget uses a different font from the rest of the widgets, and is good for section headings and such. In addition to a tray location and a name, <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a15375d59b5c57059c9c6549fc5a1bfcd">OgreBites::TrayManager::createLabel</a></code> takes a caption, and an optional width. If the width is not specified, the label automatically adjusts its width to fill the tray it's currently in, so it matches the other contents of the tray. Labels can also be clicked. To see how to respond to label click events, see the TrayListener section below.</p>
<h2>Separator</h2>
<p>A horizontal line which looks like it was etched into the tray. Good for dividing up other widgets into sections without taking up as much space as a label. <code>TrayManager::createSeparator</code> takes a tray location, name, and an optional width. If the width is not specified, the behaviour is the same as a Label's.</p>
<h2>Slider</h2>
<p>A slider bar consists of a container box, a small text box to display the value, and a track + handle. Sliders are type-agnostic. Using three parameters - a minimum value, a maximum value, and the number of "snapping points", you can give your slider track of any kind of discrete scale - integer, floating point, or even nominal. Snapping points are basically the "steps" on your slider track. By specifying how many of them there are, you are in effect specifying an entire range of values all the way from your minimum value to your maximum value. Let's say you have minimum value 0, maximum value 1, and 6 snapping points. Underneath the surface, each slider stores a floating point value, so in this case you would be able to display 6 floating point values: {0, 0.2, 0.4, 0.6, 0.8, 1}. The slider will display your value in the cleanest way possible (using <code><a class="el" href="class_ogre_1_1_string_converter.html#a45fb498a2f798c82bbf88116a5a34c53" title="Converts a float to a String. ">Ogre::StringConverter::toString</a></code>). This means that if all your values happen to land on integers, then they will be displayed as integers without decimals. You can also exploit this by using your slider's integer values as indices into an array of string values, and manually set your slider's value to the new string value. Basically, you can make your slider display things like Low, Medium, High, 1/4, 3/4, $4.00, N/A, etc. This requires you to respond to slider move events. More on this in the TrayListener section below. Then your Like select menus, sliders also come in two flavours - thick and long. The thick style places the caption and the value box above the track, while the long style places the caption, track, and value box side by side in that order. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a597ec173c1b424980e18fd92e0c56905">OgreBites::TrayManager::createThickSlider</a></code> takes a tray location, name, caption, total width, value box width, minimum value, maximum value, and the number of snapping points. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a321429ade975d3a63dfc1125b4375e78">OgreBites::TrayManager::createLongSlider</a></code> takes a an optional total width, track width, value box width, minimum value, maximum value, and the number of snapping points. If the total width is not specified, the slider will automatically scale to fit the track, the value box, and the caption text. You can get/set the slider's caption, displayed value, actual value, and range of values. When you change the range, the value is reset to be the minimum value. When you change the value, you also have the option of not firing an event. To respond to slider move events, see the TrayListener section below.</p>
<h2>ParamsPanel</h2>
<p>This panel displays an arbitrary number of parameters and their values. This could be anything you want. For example, the stats panel in the SDK samples shows the average framerate, best framerate, batch count, etc. The details panel in the SDK samples shows the texture filtering technique, the polygon mode, and the camera position and orientation. To create a ParamsPanel, use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a5ae6b66603e05193b3077f30900209eb">OgreBites::TrayManager::createParamsPanel</a></code>, which takes a tray location, a name, a width, and then either a string vector of parameter names or the number of parameters (lines) to leave room for. The parameter names will be left justified, and their values will be right justified on the same line. At any time, you can set/get the parameter names and values either one at a time, or all at once using a string vector.</p>
<h2>CheckBox</h2>
<p>Self-explanatory. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a7433f3e89c5b3a1b1b0012dfcb121f1d">OgreBites::TrayManager::createCheckBox</a></code> takes a tray location, name, caption, and an optional width. Unspecified width means auto-fit to caption. You can set/get the state of the check box, with the option of not triggering an event. To respond to check box state change events, see the TrayListener section below. </p><h2>DecorWidget</h2>
<p>This widget takes any OverlayElement template, and creates a widget out of it. If you want to put your own picture, icons, or other static objects into the trays, make an OverlayElement template out of it, and then turn it into a DecorWidget. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a24d1b3a3b95ddcf274bf899b7600deba">OgreBites::TrayManager::createDecorWidget</a></code> takes a tray location, a name, and an OverlayElement template name. These are basically the same things you would normally use to create an OverlayElement from a template. The OGRE logo in the SDK samples is a DecorWidget. </p><h2>ProgressBar</h2>
<p>A progress bar with a caption, a comment/details box, and a meter that fills up. <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a431a347db6465bbf66af82ef363c875f">OgreBites::TrayManager::createProgressBar</a></code> takes a tray location, a name, a caption, a total width, and comment box width. You can use progress bars to show any kind of progress you want, but for the most common kind (loading resources), there's a special instance of ProgressBar already created by TrayManager which you can use. See Loading Bar below.</p>
<h2>The Null Tray</h2>
<p>In addition to the nine trays you can place your widgets in, there is also a "null tray". This is an imaginary tray, whose location is specified by <code>TL_NONE</code>. This tray is virtual, invisible, and does not arrange widgets within it. Basically, if you place a widget in this tray, it becomes "free-floating", and you're allowed to manually position it anywhere on the screen. Widgets must always reside in a tray for as long as they exist, so when a widget is removed from a tray, it is automatically placed in the null tray.</p>
<h1><a class="anchor" id="special-widgets"></a>
Special Widgets</h1>
<p>Some widgets are so common they deserve special treatment.</p>
<h2>Frame Stats</h2>
<p>This is not exactly one widget, but a combination of Label that displays the current FPS, and a ParamsPanel that displays advanced frame statistics (such as average FPS and batch count). Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a49e2f792fee94e75b1b472826bcc8019" title="Shows frame statistics widget set in the specified location. ">OgreBites::TrayManager::showFrameStats</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a1c2e9618a3e6b061a9cfeac4f2cb55e9" title="Hides frame statistics widget set. ">OgreBites::TrayManager::hideFrameStats</a></code> to show/hide this special widget. You can choose where to put it. When the user clicks the FPS label, it toggles the visibility of the advanced frame stats, so they can be out of the way when they're unwanted. You can also manually toggle the visibility of the advanced frame stats using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aed00f8a1009f2ebf6806774cb894d0d7" title="Toggles visibility of advanced statistics. ">OgreBites::TrayManager::toggleAdvancedFrameStats</a></code>.</p>
<h2>Logo</h2>
<p>This is just a decor widget of the OGRE logo. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#affee57f47066e25437649d64daaa7dd9" title="Shows logo in the specified location. ">OgreBites::TrayManager::showLogo</a></code> and <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#ac1ee637b7ef5e887170c8a9aca1c4c7b">OgreBites::TrayManager::hideLogo</a></code> to show/hide the logo. You can choose where to put it.</p>
<h2>Loading Bar</h2>
<p>This is a progress bar that shows you the progress of your current resource loading job. The comment box will show the current resource being loaded. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a0d51005a4b148a4df2c1c6b55e34f085" title="Shows loading bar. ">OgreBites::TrayManager::showLoadingBar</a></code> before you begin your loading job. Specify the number of resource groups you will initialise, the number of groups you will load, and, if you want to, the proportion of time you think will go to initialisation (default estimate is 70%). You cannot decide where to place this loading bar. The screen will be darkened, and the loading bar will appear in the center. Any other dialog or loading bar will be closed. When you finish your loading job, call <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#aab014a2c48c8f91556182e42684d44ad">OgreBites::TrayManager::hideLoadingBar</a></code>.</p>
<h2>Information Dialog</h2>
<p>This is a dialog which tells the user something and displays an OK button. It's a combination of a TextBox and a Button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#abf3bd8e4ef9a6d0d76f27535a6010623" title="Pops up a message dialog with an OK button. ">OgreBites::TrayManager::showOkDialog</a></code> to display an information dialog. Specify the caption of the TextBox, and the message you want to display in it. Any other dialog or loading bar will be closed. The screen will be darkened, and the dialog will appear in the center. All other widget interactions are disabled until the dialog is closed. You can manually close a dialog using <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#af5d95dcaa7c74d3345308e4f4e3035e8" title="Hides whatever dialog is currently showing. ">OgreBites::TrayManager::closeDialog</a></code>. To respond to information dialog closing events, see the TrayListenersection below.</p>
<h2>Question Dialog</h2>
<p>Same as the Information Dialog except it asks the user something and displays a Yes button and a No button. Use <code><a class="el" href="class_ogre_bites_1_1_tray_manager.html#a85d47aa11d761742884dc6457ec11cdf" title="Pops up a question dialog with Yes and No buttons. ">OgreBites::TrayManager::showYesNoDialog</a></code> to display a question dialog. Specify the caption of the TextBox, and the question you want to display in it. To respond to question dialog closing events, see the TrayListener section below.</p>
<h1><a class="anchor" id="tray-listener"></a>
TrayListener</h1>
<p>This class contains handlers for all the different events that your widgets can fire. The TrayManager class itself is an TrayListener, because it responds to events from its special widgets. You should extend your sample class from TrayListener as well as Sample if you want to handle widget events. If you're using SdkSample, you're all set because it's already an TrayListener. Some widgets give you an option of not firing an event when you change their state. This is helpful for initialising or resetting a widget, in which case there shouldn't be a response of any sort. For example, if you're initialising your slider bar before the scene is set up, and your slider bar is used to control some part of your scene, firing an event would cause an error. Below is a list of the different handlers. All handlers have return type void.</p><ul>
<li><b>buttonHit</b>: Gives you a pointer to the Button which was hit.</li>
<li><b>itemSelected</b>: Gives you a pointer to the SelectMenu the item was chosen from. You can then use the SelectMenu to see which item was selected.</li>
<li><b>labelHit</b>: Gives you a pointer to the Label that was clicked.</li>
<li><b>sliderMoved</b>: Gives you a pointer to the Slider whose value was changed. You can then use the Slider to see what its new value is. Also, you can convert this value into a more suitable form and display it using Slider::setDisplayedValue.</li>
<li><b>checkBoxToggled</b>: Gives you a pointer to the CheckBox whose state was changed. You can then use the CheckBox to see if it's been checked or unchecked.</li>
<li><b>okDialogClosed</b>: Gives you the message of the OK dialog that was closed.</li>
<li><b>yesNoDialogClosed</b>: Gives you the question of the Yes-No dialog that was closed, and a boolean indicating whether or not the Yes button was pressed.</li>
</ul>
<h1><a class="anchor" id="things-to-try"></a>
Things to Try</h1>
<p>Getting access to widgets: </p><div class="fragment"><div class="line">Button* b;</div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);  <span class="comment">// by tray and position</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4024ff85dac37aca2ab1a65e4412adc6">getWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <span class="stringliteral">&quot;MyButton&quot;</span>);  <span class="comment">// by tray and name</span></div><div class="line">b = (Button*)mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#af968c01a627ee654409f558e4ef55537">getWidgetIterator</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>).<a class="code" href="class_ogre_1_1_vector_iterator_wrapper.html#a2460c8adb6819235849de954db6a0f64">getNext</a>();  <span class="comment">// by iterator</span></div></div><!-- fragment --><p> Counting widgets: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>();  <span class="comment">// total</span></div><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> n = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a992a25c65079b1882fd29806d5d4467b">getNumWidgets</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);  <span class="comment">// by tray</span></div></div><!-- fragment --><p> Moving widgets to other trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>, 1, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6bc278d85090ab3af3dc01472c1a83f2">TL_RIGHT</a>, 3, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a6a2d593eb6164a5b842e985e8252c3bd">TL_BOTTOM</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530ae4e5c068e88e5c0561a2c30dca2ec5a5">TL_TOP</a>, <span class="stringliteral">&quot;MyButton&quot;</span>, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div></div><!-- fragment --><p> Removing widgets from trays: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#ac2f939d0bd36af335a78589b462506e9">removeWidgetFromTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a35ae90e6dbe0c86e18ee171078fd1266">moveWidgetToTray</a>(b, <a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a04a1085bdee61d7234849663cce08664">TL_NONE</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a77ba6e4d641c146e262b6cdd2c8b04a0">clearTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9787ec5e8989bf6cfa89d03c6ddd27b6">clearAllTrays</a>();</div></div><!-- fragment --><p> Destroying widgets: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(b);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<span class="stringliteral">&quot;MyButton&quot;</span>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4ba9ec359b55a612fc860f69cecd96a7">destroyWidget</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, 0);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a4a89cd6f7d87e0e538aa842f1a42a7bc">destroyAllWidgetsInTray</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aadb1f5a3b7e3b5397b10bdd3449e1603">destroyAllWidgets</a>();</div></div><!-- fragment --><p> Finding the position of a widget in a tray: </p><div class="fragment"><div class="line"><span class="keywordtype">unsigned</span> <span class="keywordtype">int</span> pos = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa993d2b60cfbcb903aecbff1c4896b67">locateWidgetInTray</a>(b);</div></div><!-- fragment --><p> Finding the tray a widget is in: </p><div class="fragment"><div class="line"><a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530">TrayLocation</a> trayLoc = b-&gt;getTrayLocation();</div></div><!-- fragment --><p> Changing the tray listener object: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a3235fea714a0c61e463dee69ae308be8">setListener</a>(newListener);</div></div><!-- fragment --><p> Toggling system visibility: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a075805136b2241cbb03eeb2c3d27b40d">showAll</a>();</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a188f1d5f5ca16af3b28d11ecd553105a">hideAll</a>();</div></div><!-- fragment --><p> Changing horizontal widget alignment in one tray: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#adfbbc97615fd5f1a939be6e7a1f00c07">setTrayWidgetAlignment</a>(<a class="code" href="namespace_ogre_bites.html#a637c114a713225e37b0f0316f5da3530a0ea49133cba5ca84010b7df05947ca13">TL_LEFT</a>, <a class="code" href="group___overlays.html#gga3396780cdb2d731aa5e4389148bdc5f3a270f18cf07dbe4e75e1b790d02924205">GHA_RIGHT</a>);</div></div><!-- fragment --><p> Changing spacing and padding: </p><div class="fragment"><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a33a3e3f66a3989dd3de48b4c4577422f">setWidgetSpacing</a>(5);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a52d3fc8638533540232232c37b257de6">setWidgetPadding</a>(3);</div><div class="line">mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a866229b6d88dc9d3a609115eaab46e67">setTrayPadding</a>(12);</div></div><!-- fragment --><p> Casting 3D ray from under cursor into the scene: </p><div class="fragment"><div class="line">Ray r = mTrayMgr-&gt;<a class="code" href="class_ogre_bites_1_1_tray_manager.html#a9dd5d303968329462e9bf4225f59722e">getCursorRay</a>(mCamera);</div></div><!-- fragment --><p> Casting 3D ray from any 2D screen coordinate into the scene: </p><div class="fragment"><div class="line">Ray r = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#a6833f46b0303b559a050f310fa0204fc">OgreBites::TrayManager::screenToScene</a>(mCamera, Vector2(320, 240));</div></div><!-- fragment --><p> Converting a 3D scene coordinate to a 2D screen coordinate: </p><div class="fragment"><div class="line">Vector2 p = <a class="code" href="class_ogre_bites_1_1_tray_manager.html#aa7a456c2c0c37123e2ab0e497f2c0ccc">OgreBites::TrayManager::sceneToScreen</a>(mCamera, Vector3::ZERO);</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping in Ogre </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non)Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams  <a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[ \begin{aligned} \left[ \begin{array}{c} u_1 w_l \\ u_2 w_l \\ u_3 w_l \\ w_l \end{array} \right] = P_l M_l \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned} \]
</p>
<p class="formulaDsp">
\[\begin{aligned} \left[ \begin{array}{c} y_1 w_c \\ y_2 w_c \\ y_3 w_c \\ w_c \end{array} \right] = P_c M_c \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<div class="image">
<object type="image/svg+xml" data="depthbias.svg">depthbias.svg</object>
<div class="caption">
Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</div></div>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direciton lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxqdu} \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxdu} \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\ \label{eqn:du3du} \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:duwdX3} \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\ \label{eqn:dudX3} \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in  <a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps  <a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community  <a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>the inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>the inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps  <a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<div class="image">
<object type="image/svg+xml" data="optfrust.svg">optfrust.svg</object>
<div class="caption">
Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</div></div>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non)Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps  <a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps  <a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div><div class="line">sceneMgr-&gt;setShadowTexturePixelFormat(<a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2da3ec4fe727d552337e02069cd9efd9">PF_FLOAT32_R</a>);</div><div class="line">sceneMgr-&gt;setShadowTechnique( <a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">SHADOWTYPE_TEXTURE_ADDITIVE</a> );</div><div class="line">sceneMgr-&gt;setShadowTextureCasterMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Caster/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureReceiverMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>); </div><div class="line">sceneMgr-&gt;setShadowTextureSize(1024);</div></div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>The <code>DepthShadowmap.material</code> script is given below:</p>
<div class="fragment"><div class="line"><span class="comment">// Generic Shadow caster material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Caster/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Generic Shadow receiver material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            texture_unit ShadowMap</div><div class="line">            {</div><div class="line">                tex_address_mode clamp</div><div class="line">                filtering none</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Specific receiver material for rockwall</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/RockWall</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// This is the preferred technique which uses both vertex and</span></div><div class="line">    <span class="comment">// fragment programs, supports coloured lights</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// Base ambient pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 1 1 1</div><div class="line">            diffuse 0 0 0 </div><div class="line">            specular 0 0 0 0 </div><div class="line">            </div><div class="line">            depth_bias -1</div><div class="line">        }</div><div class="line">        <span class="comment">// Now do the lighting pass</span></div><div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div><div class="line">        pass lighting</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 0 0 0 </div><div class="line">            </div><div class="line">            <span class="comment">// do this for each light</span></div><div class="line">            iteration once_per_light</div><div class="line"></div><div class="line">        </div><div class="line">            scene_blend add</div><div class="line">            </div><div class="line">            <span class="comment">// Vertex program reference</span></div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Fragment program</span></div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// shadowmap texture will be bound by code</span></div><div class="line"></div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Decal pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            lighting off</div><div class="line"></div><div class="line"></div><div class="line">            scene_blend dest_colour zero</div><div class="line"></div><div class="line">            depth_bias 1</div><div class="line">            </div><div class="line">            texture_unit</div><div class="line">            {</div><div class="line">                texture rockwall.tga</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> The material uses unified programs for HLSL, GLSL and GLSLES. We’ll present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform vec4 texelOffsets;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 outPos = worldViewProj * vertex;</div><div class="line">    outPos.xy += texelOffsets.zw * outPos.w;</div><div class="line">    <span class="comment">// fix pixel / texel alignment</span></div><div class="line">    depth = outPos.zw;</div><div class="line">    gl_Position = outPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> finalDepth = depth.x / depth.y;</div><div class="line"></div><div class="line">    <span class="comment">// just smear across all components </span></div><div class="line">    <span class="comment">// therefore this one needs high individual channel precision</span></div><div class="line">    gl_FragColor = vec4(finalDepth, finalDepth, finalDepth, 1.0);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Just write out the depth values here. We compute the bias and derivatives in the receiver.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 world;</div><div class="line">uniform mat4 worldIT;</div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform mat4 texViewProj;</div><div class="line">uniform vec4 lightPosition;</div><div class="line">uniform vec4 lightColour;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line">attribute vec3 normal;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    gl_Position = worldViewProj * vertex;</div><div class="line">    </div><div class="line">    vec4 worldPos = world * vertex;</div><div class="line"></div><div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div><div class="line"></div><div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div><div class="line">    vec3 lightDir = normalize(</div><div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div><div class="line"></div><div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div><div class="line"></div><div class="line">    <span class="comment">// calculate shadow map coords</span></div><div class="line">    oUv = texViewProj * worldPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div><div class="line">uniform <span class="keywordtype">float</span> fixedDepthBias;</div><div class="line">uniform <span class="keywordtype">float</span> gradientClamp;</div><div class="line">uniform <span class="keywordtype">float</span> gradientScaleBias;</div><div class="line"></div><div class="line">uniform sampler2D shadowMap;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 shadowUV = oUv;</div><div class="line">    <span class="comment">// point on shadowmap</span></div><div class="line">    shadowUV = shadowUV / shadowUV.w;</div><div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div><div class="line">    </div><div class="line">    <span class="comment">// gradient calculation</span></div><div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div><div class="line">    vec4 depths = vec4(</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, -pixeloffset)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, +pixeloffset)).x);</div><div class="line"></div><div class="line">    vec2 differences = abs( depths.yw - depths.xz );</div><div class="line">    <span class="keywordtype">float</span> gradient = min(gradientClamp, max(differences.x, differences.y));</div><div class="line">    <span class="keywordtype">float</span> gradientFactor = gradient * gradientScaleBias;</div><div class="line"></div><div class="line">    <span class="comment">// visibility function</span></div><div class="line">    <span class="keywordtype">float</span> depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);</div><div class="line">    <span class="keywordtype">float</span> finalCenterDepth = centerdepth + depthAdjust;</div><div class="line"></div><div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div><div class="line"><span class="preprocessor">#if PCF</span></div><div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div><div class="line">    depths += depthAdjust;</div><div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (finalCenterDepth &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> *= 0.2;</div><div class="line"></div><div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1);</div><div class="line">    </div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.</p>
<p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.</p>
<p>The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html">Ogre::PlaneOptimalShadowCameraSetup</a> *planeOptShadowCamera = </div><div class="line">                                <span class="keyword">new</span> PlaneOptimalShadowCameraSetup(movablePlane);</div><div class="line"><a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = sceneMgr-&gt;createEntity( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;plane.mesh&quot;</span> );</div><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = </div><div class="line">                sceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div><div class="line">movablePlaneNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div><div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(planeOptShadowCamera));</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Volume Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('volume.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Volume Component </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howto">How to use it</a></li>
<li class="level1"><a href="#creation">Manual creation of a CSG-Tree</a></li>
<li class="level1"><a href="#triangles">Getting the triangles of the chunks</a></li>
<li class="level1"><a href="#intersecting">Intersecting a ray with a volume</a></li>
<li class="level1"><a href="#editing">Editing a Volume made from a GridSource</a></li>
</ul>
</div>
<div class="textblock"><p>Welcome to the Volume Component of OGRE. It is a component to render volumes. It can handle any volume data but featurewise has a tedency towards terrains. The terrain aspect means, that it's all about huge meshes being displayed with high performance via a level of detail mechanism. Thanks to volume rendering, caves, cliffes, holes and similar geometry can be displayed. Also constructive solid geometry gets easy.</p>
<p>A dense list of the features:</p><ul>
<li>Volume Rendering via Dual Marching Cubes</li>
<li>LOD mechanism via a chunk tree and marching squares skirts for crack patching</li>
<li>Data-Sources: 3D Textures with density values and the ability to buildup a CSG-Tree with 3D Textures, Spheres, Cubes, Planes, Intersection, Union, Difference and Negation, SimplexNoise addition</li>
<li>Loading a 3D Texture Scene from config files</li>
<li>An own file format for discrete density values which compresses a lot better</li>
<li>Realtime editing</li>
<li>Serialization and Deserialization from and to an own file format for discrete density values which compresses a lot better than 3D textures</li>
<li>A triplanar texturing example material</li>
<li>A triplanar texturing SubRenderState for the RTSS</li>
</ul>
<p>This documentation is only intended for the usage of the Volume Component, not the algorithms which make it work. If you want to get to know the theory behind it, you can read the articles on this page: <a href="http://volume-gfx.com/">http://volume-gfx.com/</a></p>
<h1><a class="anchor" id="howto"></a>
How to use it</h1>
<p>Here is an example loading the volume scene from a configuration file. The configuration file must be findable by the resource system of course. Only "OgreVolumeChunk.h" has to be included. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> <a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a>();</div><div class="line">SceneNode *volumeRootNode = mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(<span class="stringliteral">&quot;VolumeParent&quot;</span>);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, mSceneMgr, <span class="stringliteral">&quot;volumeTerrain.cfg&quot;</span>);</div></div><!-- fragment --><p> The first line creates the volume chunk which is the MovableObject holding the Volume-Root. Next, a SceneNode is created where the volume(-tree) is attached to. And lastly, the volume is loaded from the configuration file "volumeTerrain.cfg". mSceneMgr is the SceneManager who should show the volume. Later, when you don't need it anymore, you have to free the volumeRoot Chunk via OGRE_DELETE.</p>
<h1><a class="anchor" id="creation"></a>
Manual creation of a CSG-Tree</h1>
<p>This example skips the configuration file and loads a simple CSG-Scene: An union of a 3D Texture and a sphere with 5 LOD levels. It also setups a material LOD system. First, create a sphere with the radius 5 at the coordinates 128, 150, 128: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_sphere_source.html">Ogre::Volume::CSGSphereSource</a> sphere (5, Vector3(128, 150, 128));</div></div><!-- fragment --><p> Now a 3D texture from "volumeTerrainBig.dds" which has the world dimensions 256, 256, 256. The next flag indicates that the trilinear interpolation of the value-selection should be activated. We switch off the trilinear interpolation and the sobel filter of the normal for the sake of faster loading times: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_texture_source.html">Ogre::Volume::TextureSource</a> volumeTexture (<span class="stringliteral">&quot;volumeTerrainBig.dds&quot;</span>, 256, 256, 256, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div></div><!-- fragment --><p> Now combine them: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_union_source.html">Ogre::Volume::CSGUnionSource</a> unionSrc (&amp;sphere, &amp;volumeTexture);</div></div><!-- fragment --><p> Set the general parameters, see the comments for their meaning: </p><div class="fragment"><div class="line"><a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html">Ogre::Volume::ChunkParameters</a> parameters;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a3e154a179b8c824f79b1b426608743ad">sceneManager</a> = mSceneMgr;       <span class="comment">// The SceneManager to use</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a> = &amp;unionSrc;                <span class="comment">// The just created density source.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a4444eac27c71e02886615dcf7fbfed27">baseError</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.8;          <span class="comment">// The error of the highest LOD-level</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aa6186649b7323f937b83828eb86711fa">errorMultiplicator</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.9; <span class="comment">// The factor between each LOD-level (error = baseError * errorMultiplicator  * level)</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a986b4a97b153d50f65603ab507bb4614">skirtFactor</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.7;        <span class="comment">// Controls how long the skirts are. The lower the number, the shorter the skirts are. This saves geometry. But if they are too short, cracks might occure.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#af6ed62b76c67d04eb98424414fb1dc72">scale</a> = 10;                     <span class="comment">// The displayed volume will be scaled by this factor.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#ae125003c00de0d6c0a1a4bd6b99c4ebf">maxScreenSpaceError</a> = 30;       <span class="comment">// The screen space error controlling when the LOD-levels change.</span></div></div><!-- fragment --><p>Create the root-chunk and load now. The two vectors define the area to be scanned in the volume-source. The following integer determines the amount of LOD-levels. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> Chunk();</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(mVolumeRootNode, Vector3::ZERO, Vector3(256), 5, &amp;parameters);</div></div><!-- fragment --><p> Now setup the global volume material: </p><div class="fragment"><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a5129bccc53d17060635ada67443324f7">setMaterial</a>(<span class="stringliteral">&quot;triplanarReference&quot;</span>);</div></div><!-- fragment --> <h1><a class="anchor" id="triangles"></a>
Getting the triangles of the chunks</h1>
<p>When you want to integrate the volume triangles in a physics engine for example, you need to hand over the exact triangles. For this scenario, the ChunkParameters hold a pointer to a ''MeshBuilderCallback'' and a number ''lodCallbackLod''. The first is an interface with a single function ''trianglesReady'' which is called, when the triangles of a chunk are ready. The chunks are chosen via the ''lodCallbackLod''. If you build a volume with 3 LOD levels and you want the triangles of the highest detail level, you set this parameter to 3. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyMeshBuilderCallback : <span class="keyword">public</span> MeshBuilderCallback</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span>  ready(<span class="keyword">const</span> SimpleRenderable *simpleRenderable, <span class="keyword">const</span> <a class="code" href="group___volume.html#gabf42f450c9ea75c61753f6d485cb8357">VecVertex</a> &amp;vertices, <span class="keyword">const</span> <a class="code" href="group___volume.html#ga325b1df965bf0137edd13bb52bc422be">VecIndices</a> &amp;indices, <span class="keywordtype">size_t</span> level, <span class="keywordtype">int</span> inProcess)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">size_t</span> count = indices.size();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count; i += 3)</div><div class="line">        {</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v1 = vertices[indices[i]];</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v2 = vertices[indices[i + 1]];</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v3 = vertices[indices[i + 2]];</div><div class="line">            <span class="comment">// Do something with the Triangle...</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>And using it like this: </p><div class="fragment"><div class="line"><a class="code" href="group___volume.html#ga89fbc5eed010b8802358563eb88e674a">ChunkParameters</a> parameters;</div><div class="line">...</div><div class="line">MyMeshBuilderCallback callback;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a6403e2875cc7b81aefd43ba9f22c2b31">lodCallback</a> = &amp;callback;</div><div class="line">parameters.lodCallbackLod = 3;</div><div class="line">...</div><div class="line">rootChunk-&gt;load(parent, from, to, 3, &amp;parameters);</div></div><!-- fragment --><p> Or in case of loading from a configuration file: </p><div class="fragment"><div class="line">MyMeshBuilderCallback callback;</div><div class="line">rootChunk-&gt;load(parent, sceneManager, <span class="stringliteral">&quot;myVolume.cfg&quot;</span>, 0, &amp;callback, 3);</div></div><!-- fragment --><p>You might have seen, that a pointer to a SimpleRenderable is handed in, too. This is actually the Chunk whose triangles are loaded. It's parent class is used to not create a circular dependency. You might get the triangle data from it, too by getting the Renderoperation.</p>
<h1><a class="anchor" id="intersecting"></a>
Intersecting a ray with a volume</h1>
<p>When you want to do something exactly on the volume surface, you can cast rays and find their first intersection point. Behold that the triangle representation might be slightly different than the actual volume surface. And you have to scale the ray origin just like the volume. Here is an example which uses the negative z-axis of the camera as ray as it might be done like in an ego-shooter: </p><div class="fragment"><div class="line">Ray ray(mCamera-&gt;getPosition() / rootChunk-&gt;getScale(), -mCamera-&gt;getOrientation().zAxis());</div><div class="line">Vector3 intersection;</div><div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> scale = mVolumeRoot-&gt;getChunkParameters()-&gt;scale;</div><div class="line"><span class="keywordtype">bool</span> intersects = mVolumeRoot-&gt;getChunkParameters()-&gt;src-&gt;getFirstRayIntersection(ray, intersection, scale);</div><div class="line"><span class="keywordflow">if</span> (intersects)</div><div class="line">{</div><div class="line">    intersection *= scale; <span class="comment">// As it is in volume space.</span></div><div class="line">    <span class="comment">// Do something with intersection.</span></div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="editing"></a>
Editing a Volume made from a GridSource</h1>
<p>A usecase is realtime editing of volume terrain as seen as in the sample. Let's union the terrain with a sphere of the radius 2.5 and the center 123/123/123. <b>volumeRoot</b> is the Chunk instance with which the terrain was initially loaded. The factor 1.5 is just to have a save border arround the sphere which also gets updated. The rest of the parameters are 5 LOD levels and a volume mesh covering an area of 384^3. </p><div class="fragment"><div class="line">Vector3 center(123);</div><div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> radius = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)2.5;</div><div class="line">CSGSphereSource sphere(radius, center);</div><div class="line">CSGUnionSource operation;</div><div class="line"><span class="keyword">static_cast&lt;</span>GridSource*<span class="keyword">&gt;</span>(volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a>)-&gt;combineWithSource(&amp;operation, &amp;sphere, center, radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aeefacd1d618206fcb432ed947b58e06e">updateFrom</a> = center - radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5;</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#afe30999e8cc71a1f48d87d68bf43059d">updateTo</a> = center + radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5;</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, Vector3::ZERO, Vector3(384), 5, volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>());</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping in Ogre </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non)Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams  <a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[ \begin{aligned} \left[ \begin{array}{c} u_1 w_l \\ u_2 w_l \\ u_3 w_l \\ w_l \end{array} \right] = P_l M_l \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned} \]
</p>
<p class="formulaDsp">
\[\begin{aligned} \left[ \begin{array}{c} y_1 w_c \\ y_2 w_c \\ y_3 w_c \\ w_c \end{array} \right] = P_c M_c \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<div class="image">
<object type="image/svg+xml" data="depthbias.svg">depthbias.svg</object>
<div class="caption">
Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</div></div>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direciton lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxqdu} \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxdu} \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\ \label{eqn:du3du} \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:duwdX3} \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\ \label{eqn:dudX3} \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in  <a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps  <a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community  <a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>the inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>the inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps  <a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<div class="image">
<object type="image/svg+xml" data="optfrust.svg">optfrust.svg</object>
<div class="caption">
Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</div></div>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non)Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps  <a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps  <a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div><div class="line">sceneMgr-&gt;setShadowTexturePixelFormat(<a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2da3ec4fe727d552337e02069cd9efd9">PF_FLOAT32_R</a>);</div><div class="line">sceneMgr-&gt;setShadowTechnique( <a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">SHADOWTYPE_TEXTURE_ADDITIVE</a> );</div><div class="line">sceneMgr-&gt;setShadowTextureCasterMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Caster/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureReceiverMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>); </div><div class="line">sceneMgr-&gt;setShadowTextureSize(1024);</div></div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>The <code>DepthShadowmap.material</code> script is given below:</p>
<div class="fragment"><div class="line"><span class="comment">// Generic Shadow caster material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Caster/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Generic Shadow receiver material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            texture_unit ShadowMap</div><div class="line">            {</div><div class="line">                tex_address_mode clamp</div><div class="line">                filtering none</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Specific receiver material for rockwall</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/RockWall</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// This is the preferred technique which uses both vertex and</span></div><div class="line">    <span class="comment">// fragment programs, supports coloured lights</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// Base ambient pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 1 1 1</div><div class="line">            diffuse 0 0 0 </div><div class="line">            specular 0 0 0 0 </div><div class="line">            </div><div class="line">            depth_bias -1</div><div class="line">        }</div><div class="line">        <span class="comment">// Now do the lighting pass</span></div><div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div><div class="line">        pass lighting</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 0 0 0 </div><div class="line">            </div><div class="line">            <span class="comment">// do this for each light</span></div><div class="line">            iteration once_per_light</div><div class="line"></div><div class="line">        </div><div class="line">            scene_blend add</div><div class="line">            </div><div class="line">            <span class="comment">// Vertex program reference</span></div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Fragment program</span></div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// shadowmap texture will be bound by code</span></div><div class="line"></div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Decal pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            lighting off</div><div class="line"></div><div class="line"></div><div class="line">            scene_blend dest_colour zero</div><div class="line"></div><div class="line">            depth_bias 1</div><div class="line">            </div><div class="line">            texture_unit</div><div class="line">            {</div><div class="line">                texture rockwall.tga</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> The material uses unified programs for HLSL, GLSL and GLSLES. We’ll present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform vec4 texelOffsets;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 outPos = worldViewProj * vertex;</div><div class="line">    outPos.xy += texelOffsets.zw * outPos.w;</div><div class="line">    <span class="comment">// fix pixel / texel alignment</span></div><div class="line">    depth = outPos.zw;</div><div class="line">    gl_Position = outPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> finalDepth = depth.x / depth.y;</div><div class="line"></div><div class="line">    <span class="comment">// just smear across all components </span></div><div class="line">    <span class="comment">// therefore this one needs high individual channel precision</span></div><div class="line">    gl_FragColor = vec4(finalDepth, finalDepth, finalDepth, 1.0);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Just write out the depth values here. We compute the bias and derivatives in the receiver.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 world;</div><div class="line">uniform mat4 worldIT;</div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform mat4 texViewProj;</div><div class="line">uniform vec4 lightPosition;</div><div class="line">uniform vec4 lightColour;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line">attribute vec3 normal;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    gl_Position = worldViewProj * vertex;</div><div class="line">    </div><div class="line">    vec4 worldPos = world * vertex;</div><div class="line"></div><div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div><div class="line"></div><div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div><div class="line">    vec3 lightDir = normalize(</div><div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div><div class="line"></div><div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div><div class="line"></div><div class="line">    <span class="comment">// calculate shadow map coords</span></div><div class="line">    oUv = texViewProj * worldPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div><div class="line">uniform <span class="keywordtype">float</span> fixedDepthBias;</div><div class="line">uniform <span class="keywordtype">float</span> gradientClamp;</div><div class="line">uniform <span class="keywordtype">float</span> gradientScaleBias;</div><div class="line"></div><div class="line">uniform sampler2D shadowMap;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 shadowUV = oUv;</div><div class="line">    <span class="comment">// point on shadowmap</span></div><div class="line">    shadowUV = shadowUV / shadowUV.w;</div><div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div><div class="line">    </div><div class="line">    <span class="comment">// gradient calculation</span></div><div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div><div class="line">    vec4 depths = vec4(</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, -pixeloffset)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, +pixeloffset)).x);</div><div class="line"></div><div class="line">    vec2 differences = abs( depths.yw - depths.xz );</div><div class="line">    <span class="keywordtype">float</span> gradient = min(gradientClamp, max(differences.x, differences.y));</div><div class="line">    <span class="keywordtype">float</span> gradientFactor = gradient * gradientScaleBias;</div><div class="line"></div><div class="line">    <span class="comment">// visibility function</span></div><div class="line">    <span class="keywordtype">float</span> depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);</div><div class="line">    <span class="keywordtype">float</span> finalCenterDepth = centerdepth + depthAdjust;</div><div class="line"></div><div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div><div class="line"><span class="preprocessor">#if PCF</span></div><div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div><div class="line">    depths += depthAdjust;</div><div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (finalCenterDepth &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> *= 0.2;</div><div class="line"></div><div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1);</div><div class="line">    </div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.</p>
<p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.</p>
<p>The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html">Ogre::PlaneOptimalShadowCameraSetup</a> *planeOptShadowCamera = </div><div class="line">                                <span class="keyword">new</span> PlaneOptimalShadowCameraSetup(movablePlane);</div><div class="line"><a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = sceneMgr-&gt;createEntity( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;plane.mesh&quot;</span> );</div><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = </div><div class="line">                sceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div><div class="line">movablePlaneNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div><div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(planeOptShadowCamera));</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Volume Component</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('volume.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Volume Component </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#howto">How to use it</a></li>
<li class="level1"><a href="#creation">Manual creation of a CSG-Tree</a></li>
<li class="level1"><a href="#triangles">Getting the triangles of the chunks</a></li>
<li class="level1"><a href="#intersecting">Intersecting a ray with a volume</a></li>
<li class="level1"><a href="#editing">Editing a Volume made from a GridSource</a></li>
</ul>
</div>
<div class="textblock"><p>Welcome to the Volume Component of OGRE. It is a component to render volumes. It can handle any volume data but featurewise has a tedency towards terrains. The terrain aspect means, that it's all about huge meshes being displayed with high performance via a level of detail mechanism. Thanks to volume rendering, caves, cliffes, holes and similar geometry can be displayed. Also constructive solid geometry gets easy.</p>
<p>A dense list of the features:</p><ul>
<li>Volume Rendering via Dual Marching Cubes</li>
<li>LOD mechanism via a chunk tree and marching squares skirts for crack patching</li>
<li>Data-Sources: 3D Textures with density values and the ability to buildup a CSG-Tree with 3D Textures, Spheres, Cubes, Planes, Intersection, Union, Difference and Negation, SimplexNoise addition</li>
<li>Loading a 3D Texture Scene from config files</li>
<li>An own file format for discrete density values which compresses a lot better</li>
<li>Realtime editing</li>
<li>Serialization and Deserialization from and to an own file format for discrete density values which compresses a lot better than 3D textures</li>
<li>A triplanar texturing example material</li>
<li>A triplanar texturing SubRenderState for the RTSS</li>
</ul>
<p>This documentation is only intended for the usage of the Volume Component, not the algorithms which make it work. If you want to get to know the theory behind it, you can read the articles on this page: <a href="http://volume-gfx.com/">http://volume-gfx.com/</a></p>
<h1><a class="anchor" id="howto"></a>
How to use it</h1>
<p>Here is an example loading the volume scene from a configuration file. The configuration file must be findable by the resource system of course. Only "OgreVolumeChunk.h" has to be included. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> <a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a>();</div><div class="line">SceneNode *volumeRootNode = mSceneMgr-&gt;getRootSceneNode()-&gt;createChildSceneNode(<span class="stringliteral">&quot;VolumeParent&quot;</span>);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, mSceneMgr, <span class="stringliteral">&quot;volumeTerrain.cfg&quot;</span>);</div></div><!-- fragment --><p> The first line creates the volume chunk which is the MovableObject holding the Volume-Root. Next, a SceneNode is created where the volume(-tree) is attached to. And lastly, the volume is loaded from the configuration file "volumeTerrain.cfg". mSceneMgr is the SceneManager who should show the volume. Later, when you don't need it anymore, you have to free the volumeRoot Chunk via OGRE_DELETE.</p>
<h1><a class="anchor" id="creation"></a>
Manual creation of a CSG-Tree</h1>
<p>This example skips the configuration file and loads a simple CSG-Scene: An union of a 3D Texture and a sphere with 5 LOD levels. It also setups a material LOD system. First, create a sphere with the radius 5 at the coordinates 128, 150, 128: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_sphere_source.html">Ogre::Volume::CSGSphereSource</a> sphere (5, Vector3(128, 150, 128));</div></div><!-- fragment --><p> Now a 3D texture from "volumeTerrainBig.dds" which has the world dimensions 256, 256, 256. The next flag indicates that the trilinear interpolation of the value-selection should be activated. We switch off the trilinear interpolation and the sobel filter of the normal for the sake of faster loading times: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_texture_source.html">Ogre::Volume::TextureSource</a> volumeTexture (<span class="stringliteral">&quot;volumeTerrainBig.dds&quot;</span>, 256, 256, 256, <span class="keyword">true</span>, <span class="keyword">false</span>, <span class="keyword">false</span>);</div></div><!-- fragment --><p> Now combine them: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_c_s_g_union_source.html">Ogre::Volume::CSGUnionSource</a> unionSrc (&amp;sphere, &amp;volumeTexture);</div></div><!-- fragment --><p> Set the general parameters, see the comments for their meaning: </p><div class="fragment"><div class="line"><a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html">Ogre::Volume::ChunkParameters</a> parameters;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a3e154a179b8c824f79b1b426608743ad">sceneManager</a> = mSceneMgr;       <span class="comment">// The SceneManager to use</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a> = &amp;unionSrc;                <span class="comment">// The just created density source.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a4444eac27c71e02886615dcf7fbfed27">baseError</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.8;          <span class="comment">// The error of the highest LOD-level</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aa6186649b7323f937b83828eb86711fa">errorMultiplicator</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.9; <span class="comment">// The factor between each LOD-level (error = baseError * errorMultiplicator  * level)</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a986b4a97b153d50f65603ab507bb4614">skirtFactor</a> = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)0.7;        <span class="comment">// Controls how long the skirts are. The lower the number, the shorter the skirts are. This saves geometry. But if they are too short, cracks might occure.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#af6ed62b76c67d04eb98424414fb1dc72">scale</a> = 10;                     <span class="comment">// The displayed volume will be scaled by this factor.</span></div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#ae125003c00de0d6c0a1a4bd6b99c4ebf">maxScreenSpaceError</a> = 30;       <span class="comment">// The screen space error controlling when the LOD-levels change.</span></div></div><!-- fragment --><p>Create the root-chunk and load now. The two vectors define the area to be scanned in the volume-source. The following integer determines the amount of LOD-levels. </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_volume_1_1_chunk.html">Ogre::Volume::Chunk</a> *volumeRoot = <a class="code" href="group___memory.html#gab5fc1358fd5a889de0a06d07e45df1ff">OGRE_NEW</a> Chunk();</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(mVolumeRootNode, Vector3::ZERO, Vector3(256), 5, &amp;parameters);</div></div><!-- fragment --><p> Now setup the global volume material: </p><div class="fragment"><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a5129bccc53d17060635ada67443324f7">setMaterial</a>(<span class="stringliteral">&quot;triplanarReference&quot;</span>);</div></div><!-- fragment --> <h1><a class="anchor" id="triangles"></a>
Getting the triangles of the chunks</h1>
<p>When you want to integrate the volume triangles in a physics engine for example, you need to hand over the exact triangles. For this scenario, the ChunkParameters hold a pointer to a ''MeshBuilderCallback'' and a number ''lodCallbackLod''. The first is an interface with a single function ''trianglesReady'' which is called, when the triangles of a chunk are ready. The chunks are chosen via the ''lodCallbackLod''. If you build a volume with 3 LOD levels and you want the triangles of the highest detail level, you set this parameter to 3. Example:</p>
<div class="fragment"><div class="line"><span class="keyword">class </span>MyMeshBuilderCallback : <span class="keyword">public</span> MeshBuilderCallback</div><div class="line">{</div><div class="line"><span class="keyword">public</span>:</div><div class="line">    <span class="keyword">virtual</span>  ready(<span class="keyword">const</span> SimpleRenderable *simpleRenderable, <span class="keyword">const</span> <a class="code" href="group___volume.html#gabf42f450c9ea75c61753f6d485cb8357">VecVertex</a> &amp;vertices, <span class="keyword">const</span> <a class="code" href="group___volume.html#ga325b1df965bf0137edd13bb52bc422be">VecIndices</a> &amp;indices, <span class="keywordtype">size_t</span> level, <span class="keywordtype">int</span> inProcess)</div><div class="line">    {</div><div class="line">        <span class="keywordtype">size_t</span> count = indices.size();</div><div class="line">        <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count; i += 3)</div><div class="line">        {</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v1 = vertices[indices[i]];</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v2 = vertices[indices[i + 1]];</div><div class="line">            <a class="code" href="group___volume.html#ga90facc4b1e8fd828ae06b8edd0f5b701">Vertex</a> v3 = vertices[indices[i + 2]];</div><div class="line">            <span class="comment">// Do something with the Triangle...</span></div><div class="line">        }</div><div class="line">    }</div><div class="line">};</div></div><!-- fragment --><p>And using it like this: </p><div class="fragment"><div class="line"><a class="code" href="group___volume.html#ga89fbc5eed010b8802358563eb88e674a">ChunkParameters</a> parameters;</div><div class="line">...</div><div class="line">MyMeshBuilderCallback callback;</div><div class="line">parameters.<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a6403e2875cc7b81aefd43ba9f22c2b31">lodCallback</a> = &amp;callback;</div><div class="line">parameters.lodCallbackLod = 3;</div><div class="line">...</div><div class="line">rootChunk-&gt;load(parent, from, to, 3, &amp;parameters);</div></div><!-- fragment --><p> Or in case of loading from a configuration file: </p><div class="fragment"><div class="line">MyMeshBuilderCallback callback;</div><div class="line">rootChunk-&gt;load(parent, sceneManager, <span class="stringliteral">&quot;myVolume.cfg&quot;</span>, 0, &amp;callback, 3);</div></div><!-- fragment --><p>You might have seen, that a pointer to a SimpleRenderable is handed in, too. This is actually the Chunk whose triangles are loaded. It's parent class is used to not create a circular dependency. You might get the triangle data from it, too by getting the Renderoperation.</p>
<h1><a class="anchor" id="intersecting"></a>
Intersecting a ray with a volume</h1>
<p>When you want to do something exactly on the volume surface, you can cast rays and find their first intersection point. Behold that the triangle representation might be slightly different than the actual volume surface. And you have to scale the ray origin just like the volume. Here is an example which uses the negative z-axis of the camera as ray as it might be done like in an ego-shooter: </p><div class="fragment"><div class="line">Ray ray(mCamera-&gt;getPosition() / rootChunk-&gt;getScale(), -mCamera-&gt;getOrientation().zAxis());</div><div class="line">Vector3 intersection;</div><div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> scale = mVolumeRoot-&gt;getChunkParameters()-&gt;scale;</div><div class="line"><span class="keywordtype">bool</span> intersects = mVolumeRoot-&gt;getChunkParameters()-&gt;src-&gt;getFirstRayIntersection(ray, intersection, scale);</div><div class="line"><span class="keywordflow">if</span> (intersects)</div><div class="line">{</div><div class="line">    intersection *= scale; <span class="comment">// As it is in volume space.</span></div><div class="line">    <span class="comment">// Do something with intersection.</span></div><div class="line">}</div></div><!-- fragment --><h1><a class="anchor" id="editing"></a>
Editing a Volume made from a GridSource</h1>
<p>A usecase is realtime editing of volume terrain as seen as in the sample. Let's union the terrain with a sphere of the radius 2.5 and the center 123/123/123. <b>volumeRoot</b> is the Chunk instance with which the terrain was initially loaded. The factor 1.5 is just to have a save border arround the sphere which also gets updated. The rest of the parameters are 5 LOD levels and a volume mesh covering an area of 384^3. </p><div class="fragment"><div class="line">Vector3 center(123);</div><div class="line"><a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a> radius = (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)2.5;</div><div class="line">CSGSphereSource sphere(radius, center);</div><div class="line">CSGUnionSource operation;</div><div class="line"><span class="keyword">static_cast&lt;</span>GridSource*<span class="keyword">&gt;</span>(volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#a111c9e9333e7ae3497fc818190a03fd8">src</a>)-&gt;combineWithSource(&amp;operation, &amp;sphere, center, radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5);</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#aeefacd1d618206fcb432ed947b58e06e">updateFrom</a> = center - radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5;</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>()-&gt;<a class="code" href="struct_ogre_1_1_volume_1_1_chunk_parameters.html#afe30999e8cc71a1f48d87d68bf43059d">updateTo</a> = center + radius * (<a class="code" href="namespace_ogre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d">Real</a>)1.5;</div><div class="line">volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#a9557d5a30cbf29a46d4f8246a1e6d176">load</a>(volumeRootNode, Vector3::ZERO, Vector3(384), 5, volumeRoot-&gt;<a class="code" href="class_ogre_1_1_volume_1_1_chunk.html#acdc6b1e00c67353f3317e1e0ce6d19d9">getChunkParameters</a>());</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping in Ogre </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non)Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams  <a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[ \begin{aligned} \left[ \begin{array}{c} u_1 w_l \\ u_2 w_l \\ u_3 w_l \\ w_l \end{array} \right] = P_l M_l \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned} \]
</p>
<p class="formulaDsp">
\[\begin{aligned} \left[ \begin{array}{c} y_1 w_c \\ y_2 w_c \\ y_3 w_c \\ w_c \end{array} \right] = P_c M_c \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<div class="image">
<object type="image/svg+xml" data="depthbias.svg">depthbias.svg</object>
<div class="caption">
Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</div></div>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direciton lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxqdu} \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxdu} \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\ \label{eqn:du3du} \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:duwdX3} \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\ \label{eqn:dudX3} \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in  <a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps  <a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community  <a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>the inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>the inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps  <a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<div class="image">
<object type="image/svg+xml" data="optfrust.svg">optfrust.svg</object>
<div class="caption">
Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</div></div>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non)Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps  <a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps  <a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div><div class="line">sceneMgr-&gt;setShadowTexturePixelFormat(<a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2da3ec4fe727d552337e02069cd9efd9">PF_FLOAT32_R</a>);</div><div class="line">sceneMgr-&gt;setShadowTechnique( <a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">SHADOWTYPE_TEXTURE_ADDITIVE</a> );</div><div class="line">sceneMgr-&gt;setShadowTextureCasterMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Caster/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureReceiverMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>); </div><div class="line">sceneMgr-&gt;setShadowTextureSize(1024);</div></div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>The <code>DepthShadowmap.material</code> script is given below:</p>
<div class="fragment"><div class="line"><span class="comment">// Generic Shadow caster material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Caster/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Generic Shadow receiver material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            texture_unit ShadowMap</div><div class="line">            {</div><div class="line">                tex_address_mode clamp</div><div class="line">                filtering none</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Specific receiver material for rockwall</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/RockWall</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// This is the preferred technique which uses both vertex and</span></div><div class="line">    <span class="comment">// fragment programs, supports coloured lights</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// Base ambient pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 1 1 1</div><div class="line">            diffuse 0 0 0 </div><div class="line">            specular 0 0 0 0 </div><div class="line">            </div><div class="line">            depth_bias -1</div><div class="line">        }</div><div class="line">        <span class="comment">// Now do the lighting pass</span></div><div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div><div class="line">        pass lighting</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 0 0 0 </div><div class="line">            </div><div class="line">            <span class="comment">// do this for each light</span></div><div class="line">            iteration once_per_light</div><div class="line"></div><div class="line">        </div><div class="line">            scene_blend add</div><div class="line">            </div><div class="line">            <span class="comment">// Vertex program reference</span></div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Fragment program</span></div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// shadowmap texture will be bound by code</span></div><div class="line"></div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Decal pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            lighting off</div><div class="line"></div><div class="line"></div><div class="line">            scene_blend dest_colour zero</div><div class="line"></div><div class="line">            depth_bias 1</div><div class="line">            </div><div class="line">            texture_unit</div><div class="line">            {</div><div class="line">                texture rockwall.tga</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> The material uses unified programs for HLSL, GLSL and GLSLES. We’ll present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform vec4 texelOffsets;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 outPos = worldViewProj * vertex;</div><div class="line">    outPos.xy += texelOffsets.zw * outPos.w;</div><div class="line">    <span class="comment">// fix pixel / texel alignment</span></div><div class="line">    depth = outPos.zw;</div><div class="line">    gl_Position = outPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> finalDepth = depth.x / depth.y;</div><div class="line"></div><div class="line">    <span class="comment">// just smear across all components </span></div><div class="line">    <span class="comment">// therefore this one needs high individual channel precision</span></div><div class="line">    gl_FragColor = vec4(finalDepth, finalDepth, finalDepth, 1.0);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Just write out the depth values here. We compute the bias and derivatives in the receiver.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 world;</div><div class="line">uniform mat4 worldIT;</div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform mat4 texViewProj;</div><div class="line">uniform vec4 lightPosition;</div><div class="line">uniform vec4 lightColour;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line">attribute vec3 normal;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    gl_Position = worldViewProj * vertex;</div><div class="line">    </div><div class="line">    vec4 worldPos = world * vertex;</div><div class="line"></div><div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div><div class="line"></div><div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div><div class="line">    vec3 lightDir = normalize(</div><div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div><div class="line"></div><div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div><div class="line"></div><div class="line">    <span class="comment">// calculate shadow map coords</span></div><div class="line">    oUv = texViewProj * worldPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div><div class="line">uniform <span class="keywordtype">float</span> fixedDepthBias;</div><div class="line">uniform <span class="keywordtype">float</span> gradientClamp;</div><div class="line">uniform <span class="keywordtype">float</span> gradientScaleBias;</div><div class="line"></div><div class="line">uniform sampler2D shadowMap;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 shadowUV = oUv;</div><div class="line">    <span class="comment">// point on shadowmap</span></div><div class="line">    shadowUV = shadowUV / shadowUV.w;</div><div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div><div class="line">    </div><div class="line">    <span class="comment">// gradient calculation</span></div><div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div><div class="line">    vec4 depths = vec4(</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, -pixeloffset)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, +pixeloffset)).x);</div><div class="line"></div><div class="line">    vec2 differences = abs( depths.yw - depths.xz );</div><div class="line">    <span class="keywordtype">float</span> gradient = min(gradientClamp, max(differences.x, differences.y));</div><div class="line">    <span class="keywordtype">float</span> gradientFactor = gradient * gradientScaleBias;</div><div class="line"></div><div class="line">    <span class="comment">// visibility function</span></div><div class="line">    <span class="keywordtype">float</span> depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);</div><div class="line">    <span class="keywordtype">float</span> finalCenterDepth = centerdepth + depthAdjust;</div><div class="line"></div><div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div><div class="line"><span class="preprocessor">#if PCF</span></div><div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div><div class="line">    depths += depthAdjust;</div><div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (finalCenterDepth &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> *= 0.2;</div><div class="line"></div><div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1);</div><div class="line">    </div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.</p>
<p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.</p>
<p>The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html">Ogre::PlaneOptimalShadowCameraSetup</a> *planeOptShadowCamera = </div><div class="line">                                <span class="keyword">new</span> PlaneOptimalShadowCameraSetup(movablePlane);</div><div class="line"><a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = sceneMgr-&gt;createEntity( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;plane.mesh&quot;</span> );</div><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = </div><div class="line">                sceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div><div class="line">movablePlaneNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div><div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(planeOptShadowCamera));</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping in Ogre </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non)Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams  <a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[ \begin{aligned} \left[ \begin{array}{c} u_1 w_l \\ u_2 w_l \\ u_3 w_l \\ w_l \end{array} \right] = P_l M_l \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned} \]
</p>
<p class="formulaDsp">
\[\begin{aligned} \left[ \begin{array}{c} y_1 w_c \\ y_2 w_c \\ y_3 w_c \\ w_c \end{array} \right] = P_c M_c \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<div class="image">
<object type="image/svg+xml" data="depthbias.svg">depthbias.svg</object>
<div class="caption">
Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</div></div>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direciton lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxqdu} \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxdu} \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\ \label{eqn:du3du} \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:duwdX3} \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\ \label{eqn:dudX3} \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in  <a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps  <a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community  <a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>the inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>the inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps  <a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<div class="image">
<object type="image/svg+xml" data="optfrust.svg">optfrust.svg</object>
<div class="caption">
Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</div></div>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non)Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps  <a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps  <a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div><div class="line">sceneMgr-&gt;setShadowTexturePixelFormat(<a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2da3ec4fe727d552337e02069cd9efd9">PF_FLOAT32_R</a>);</div><div class="line">sceneMgr-&gt;setShadowTechnique( <a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">SHADOWTYPE_TEXTURE_ADDITIVE</a> );</div><div class="line">sceneMgr-&gt;setShadowTextureCasterMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Caster/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureReceiverMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>); </div><div class="line">sceneMgr-&gt;setShadowTextureSize(1024);</div></div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>The <code>DepthShadowmap.material</code> script is given below:</p>
<div class="fragment"><div class="line"><span class="comment">// Generic Shadow caster material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Caster/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Generic Shadow receiver material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            texture_unit ShadowMap</div><div class="line">            {</div><div class="line">                tex_address_mode clamp</div><div class="line">                filtering none</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Specific receiver material for rockwall</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/RockWall</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// This is the preferred technique which uses both vertex and</span></div><div class="line">    <span class="comment">// fragment programs, supports coloured lights</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// Base ambient pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 1 1 1</div><div class="line">            diffuse 0 0 0 </div><div class="line">            specular 0 0 0 0 </div><div class="line">            </div><div class="line">            depth_bias -1</div><div class="line">        }</div><div class="line">        <span class="comment">// Now do the lighting pass</span></div><div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div><div class="line">        pass lighting</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 0 0 0 </div><div class="line">            </div><div class="line">            <span class="comment">// do this for each light</span></div><div class="line">            iteration once_per_light</div><div class="line"></div><div class="line">        </div><div class="line">            scene_blend add</div><div class="line">            </div><div class="line">            <span class="comment">// Vertex program reference</span></div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Fragment program</span></div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// shadowmap texture will be bound by code</span></div><div class="line"></div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Decal pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            lighting off</div><div class="line"></div><div class="line"></div><div class="line">            scene_blend dest_colour zero</div><div class="line"></div><div class="line">            depth_bias 1</div><div class="line">            </div><div class="line">            texture_unit</div><div class="line">            {</div><div class="line">                texture rockwall.tga</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> The material uses unified programs for HLSL, GLSL and GLSLES. We’ll present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform vec4 texelOffsets;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 outPos = worldViewProj * vertex;</div><div class="line">    outPos.xy += texelOffsets.zw * outPos.w;</div><div class="line">    <span class="comment">// fix pixel / texel alignment</span></div><div class="line">    depth = outPos.zw;</div><div class="line">    gl_Position = outPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> finalDepth = depth.x / depth.y;</div><div class="line"></div><div class="line">    <span class="comment">// just smear across all components </span></div><div class="line">    <span class="comment">// therefore this one needs high individual channel precision</span></div><div class="line">    gl_FragColor = vec4(finalDepth, finalDepth, finalDepth, 1.0);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Just write out the depth values here. We compute the bias and derivatives in the receiver.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 world;</div><div class="line">uniform mat4 worldIT;</div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform mat4 texViewProj;</div><div class="line">uniform vec4 lightPosition;</div><div class="line">uniform vec4 lightColour;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line">attribute vec3 normal;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    gl_Position = worldViewProj * vertex;</div><div class="line">    </div><div class="line">    vec4 worldPos = world * vertex;</div><div class="line"></div><div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div><div class="line"></div><div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div><div class="line">    vec3 lightDir = normalize(</div><div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div><div class="line"></div><div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div><div class="line"></div><div class="line">    <span class="comment">// calculate shadow map coords</span></div><div class="line">    oUv = texViewProj * worldPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div><div class="line">uniform <span class="keywordtype">float</span> fixedDepthBias;</div><div class="line">uniform <span class="keywordtype">float</span> gradientClamp;</div><div class="line">uniform <span class="keywordtype">float</span> gradientScaleBias;</div><div class="line"></div><div class="line">uniform sampler2D shadowMap;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 shadowUV = oUv;</div><div class="line">    <span class="comment">// point on shadowmap</span></div><div class="line">    shadowUV = shadowUV / shadowUV.w;</div><div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div><div class="line">    </div><div class="line">    <span class="comment">// gradient calculation</span></div><div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div><div class="line">    vec4 depths = vec4(</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, -pixeloffset)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, +pixeloffset)).x);</div><div class="line"></div><div class="line">    vec2 differences = abs( depths.yw - depths.xz );</div><div class="line">    <span class="keywordtype">float</span> gradient = min(gradientClamp, max(differences.x, differences.y));</div><div class="line">    <span class="keywordtype">float</span> gradientFactor = gradient * gradientScaleBias;</div><div class="line"></div><div class="line">    <span class="comment">// visibility function</span></div><div class="line">    <span class="keywordtype">float</span> depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);</div><div class="line">    <span class="keywordtype">float</span> finalCenterDepth = centerdepth + depthAdjust;</div><div class="line"></div><div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div><div class="line"><span class="preprocessor">#if PCF</span></div><div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div><div class="line">    depths += depthAdjust;</div><div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (finalCenterDepth &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> *= 0.2;</div><div class="line"></div><div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1);</div><div class="line">    </div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.</p>
<p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.</p>
<p>The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html">Ogre::PlaneOptimalShadowCameraSetup</a> *planeOptShadowCamera = </div><div class="line">                                <span class="keyword">new</span> PlaneOptimalShadowCameraSetup(movablePlane);</div><div class="line"><a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = sceneMgr-&gt;createEntity( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;plane.mesh&quot;</span> );</div><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = </div><div class="line">                sceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div><div class="line">movablePlaneNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div><div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(planeOptShadowCamera));</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Using the Profiler</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('profiler.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Using the Profiler </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><dl class="section note"><dt>Note</dt><dd>If you are using the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> SDK and you want to use the Profiler, it is advisable to switch to the source code version of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, because the SDK is shipped with <code>OGRE_PROFILING=OFF</code>, so Profiling is disabled by default.</dd></dl>
<p>First you want to initialize the Profiler like this: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">Ogre::Profiler::getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#a91c40e21a3fc96003504ea21fec80d77">setEnabled</a>(<span class="keyword">true</span>);</div></div><!-- fragment --><p> This sets up the media that the profiler uses. The reason this is not in the constructor is because the profiler contains media dependencies that people who aren't using the profiler shouldn't have to worry about. The profiler will need you to specify the main program loop. To do this, you call the following at the very beginning of the frameStarted() function in your FrameListener class: </p><div class="fragment"><div class="line"><a class="code" href="_ogre_profiler_8h.html#af9d7ab83c5a5d7de7579eebe9d27e53d">OgreProfileBegin</a>(<span class="stringliteral">&quot;Ogre Main Loop&quot;</span>);</div></div><!-- fragment --><p> and add this at the very end of the frameEnded() function: </p><div class="fragment"><div class="line"><a class="code" href="_ogre_profiler_8h.html#a292ec22b5d851ef26fa9d7685c18b1f5">OgreProfileEnd</a>(<span class="stringliteral">&quot;Ogre Main Loop&quot;</span>);</div></div><!-- fragment --><p> Make sure the names match exactly, otherwise the profiler will fail an assert. Next you want to profile some of your code. You do this by calling <a class="el" href="_ogre_profiler_8h.html#a1654899e6cfdec9f0972a45f3fa3fee7">OgreProfile()</a> and using braces ({}) to limit the scope. Note that OgreProfile cannot be called in the same scope as another <a class="el" href="_ogre_profiler_8h.html#a1654899e6cfdec9f0972a45f3fa3fee7">OgreProfile()</a>. Doing so will result in a compile-time error. Here is an example of using OgreProfile: </p><div class="fragment"><div class="line">{</div><div class="line">   <a class="code" href="_ogre_profiler_8h.html#a1654899e6cfdec9f0972a45f3fa3fee7">OgreProfile</a>(<span class="stringliteral">&quot;Collision Detection&quot;</span>);</div><div class="line">   mISQR = mISQ-&gt;execute();</div><div class="line">}</div><div class="line">{</div><div class="line">   <a class="code" href="_ogre_profiler_8h.html#a1654899e6cfdec9f0972a45f3fa3fee7">OgreProfile</a>(<span class="stringliteral">&quot;Collision Response&quot;</span>);</div><div class="line">   SceneQueryMovableIntersectionList::iterator iter;</div><div class="line">   <span class="keywordflow">for</span> (iter = mISQR.movables2movables.begin(); iter != mISQR.movables2movables.end(); iter++) {</div><div class="line">      <span class="comment">// do stuff</span></div><div class="line">      <a class="code" href="_ogre_profiler_8h.html#a1654899e6cfdec9f0972a45f3fa3fee7">OgreProfile</a>(<span class="stringliteral">&quot;Explosions&quot;</span>);</div><div class="line">      createExplosion();</div><div class="line">   }</div><div class="line">}</div></div><!-- fragment --><p> If you want a profile to last outside of its scope, use <a class="el" href="_ogre_profiler_8h.html#af9d7ab83c5a5d7de7579eebe9d27e53d">OgreProfileBegin(&lt;name&gt;)</a> and <a class="el" href="_ogre_profiler_8h.html#a292ec22b5d851ef26fa9d7685c18b1f5">OgreProfileEnd(&lt;name&gt;)</a> like you did when creating the main loop profile.</p>
<h1>Reading the Display</h1>
<p>On the left side are the profile names with a number in parentheses next to it. This number is the number of times this profile was called during this frame. If this number is 0, that means that the profile was called before, but is not being called currently. The bars on the left represent the frame time statistics. You can see indicators above which show that a profile can take anywhere from 0% to 100% of the frame time. The big yellow bars show the current frame percentage that the profile is taking. The green line shows the minimum frame time, the red line is the maximum frame time, and the blue line is the average frame time. Big discrepancies between the average and maximum can possibly be the sign of a performance bottleneck (however it could be the profiler acting strangely, see the ''Known Issues'' section). These results will be printed to the log when the application ends or you can manually do it by calling logResults().</p>
<h1>Features</h1>
<h2>Disabling the Profiler</h2>
<p>You can disable the profiler by calling: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">Ogre::Profiler::getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#a91c40e21a3fc96003504ea21fec80d77">setEnabled</a>(<span class="keyword">false</span>);</div></div><!-- fragment --><p> and enable it again by calling: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">Ogre::Profiler::getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#a91c40e21a3fc96003504ea21fec80d77">setEnabled</a>(<span class="keyword">true</span>);</div></div><!-- fragment --><p> Note that this is a temporary solution. If you want to completely disable the profiler for your release version, see the section ''Release Version Considerations''.</p>
<h2>Disabling Individual Profiles</h2>
<p>Disabling profiles can be useful if there are certain core functions that you want to profile on occasion. For example, you could profile certain rendering operations when you are checking general performance and then disable those profiles when you want to profile your AI code. You can disable a profile like this: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#a144fc3944f41b1198a44590beda4ce3f">disableProfile</a>(<span class="stringliteral">&quot;&lt;profile name&gt;&quot;</span>);</div></div><!-- fragment --><p> and you can enable it again with this: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#a52e2f0d3530febbbf7199173d91ad4e2">enableProfile</a>(<span class="stringliteral">&quot;&lt;profile name&gt;&quot;</span>);</div></div><!-- fragment --><p> Please note that trying to enable or disable a profile while that profile is running will have no effect.</p>
<h2>Analyzing Application State</h2>
<p>It is helpful to see the state of your application when a profile reaches a maximum level or some other condition. To check if a specific has reached a new maximum level, use: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#afc737d10ba6b5732df9a538a196ee3e6">watchForMax</a>(<span class="stringliteral">&quot;&lt;profile name&gt;&quot;</span>); <span class="comment">// return true if it reaches a new maximum</span></div></div><!-- fragment --><p> or to see if a profile has reached a new minimum level, use: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#ad37efd3a99cf736a0424fd0c1c92efb4">watchForMin</a>(<span class="stringliteral">&quot;&lt;profile name&gt;&quot;</span>); <span class="comment">// returns true if it reaches a new minimum</span></div></div><!-- fragment --><p> or to set an arbitrary level: </p><div class="fragment"><div class="line"><span class="comment">//returns true when AI code takes over 60% of the frame time</span></div><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#adfd868a7f9213baece5687bd36e23279">watchForLimit</a>(<span class="stringliteral">&quot;AI code&quot;</span>, .6, <span class="keyword">true</span>);</div><div class="line"></div><div class="line"><span class="comment">//returns true when graphics code takes less than 10% of the frame time</span></div><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#adfd868a7f9213baece5687bd36e23279">watchForLimit</a>(<span class="stringliteral">&quot;Graphics code&quot;</span>, .1, <span class="keyword">false</span>);</div></div><!-- fragment --><p>These functions should be used at the end of the main game loop for more accuracy. Otherwise, it will represent the results of the previous frame.</p>
<h2>Logging Results</h2>
<p>You can log the results of the current profiler statistics like this: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#a456a0f133ccea3eb515626edd22963ec">logResults</a>();</div></div><!-- fragment --><p> This is called automatically when you quit your <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> application.</p>
<h2>Changing the Frequency of Updating the Display</h2>
<p>You can change how frequently the display is updated to suit your tastes like this: </p><div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>.<a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#ac29d425e0f0b531f2c7f643907c9402d">setUpdateDisplayFrequency</a>(&lt;numberOfFrames&gt;);</div></div><!-- fragment --><p> Basically the tradeoff is between how accurate the display is and the amount of flicker. The default is that the display is updated every 10 frames.</p>
<h1>Performance and Accuracy</h1>
<p>I've tried to minimize the performance hit from using the profiler. However, like anything else, it still takes some time to perform the necessary calculations. There are some steps you can take to increase the accuracy of the results. Firstly, although the profiler supports multiple calls of a profile during each frame, doing this more than a few times can cause the profiler to take significantly longer than the actual code you are trying to profile. Therefore it is recommended that you move the profile up one level (such as outside of a for loop) so that it is called fewer times.</p>
<p>To maximize the accuracy of a profile, it is best to remove the child profiles of the profile you are analysing. Child profiles increases the frame time of the parent due to the overhead of using the profiler.</p>
<p>Some tests I've conducted show that the profiling code will max out unexpectedly, so take the maximum frame time value with a grain of salt (See the <em>Known Issues</em> section). I think this only happens when a profile is first created, so you can possibly get around this issue by calling the reset() function after the first frame.</p>
<h1>Release Version Considerations</h1>
<p>For the release version of your app, you should set <code>OGRE_PROFILING=OFF</code> in CMake. If the build you are using has been compiled with the <code>OGRE_PROFILING=OFF</code> and you still want to use the profiler without recompiling your SDK, a quick workaround is to instantiate a dummy profiler like this:</p>
<div class="fragment"><div class="line"><span class="comment">// Create dummy profile to set singleton pointer</span></div><div class="line"><span class="keyword">new</span> <a class="code" href="class_ogre_1_1_profiler.html">Ogre::Profiler</a>();</div><div class="line"></div><div class="line"><span class="comment">// Give it a timer and enable it</span></div><div class="line"><a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">Ogre::Profiler::getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#a53a2d2681a3995555df6d789c5596381">setTimer</a>(Root::getSingleton().getTimer());</div><div class="line"><a class="code" href="class_ogre_1_1_profiler.html#aaa925dad8392fe140d017a5766f3cd49">Ogre::Profiler::getSingleton</a>().<a class="code" href="class_ogre_1_1_profiler.html#a91c40e21a3fc96003504ea21fec80d77">setEnabled</a>(<span class="keyword">true</span>);</div></div><!-- fragment --><p>The profiler will now work but the 3 OgreProfile macro will not work. You will have to manually use the beginProfile() and endProfile() method. You can also instantiate scope-limited Profile objects or simply define your own macros somewhere in your code.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#define MyOgreProfile( a ) Ogre::Profile _OgreProfileInstance( (a) )</span></div><div class="line"><span class="preprocessor">#define MyOgreProfileBegin( a ) Ogre::Profiler::getSingleton().beginProfile( (a) )</span></div><div class="line"><span class="preprocessor">#define MyOgreProfileEnd( a ) Ogre::Profiler::getSingleton().endProfile( (a) )</span></div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping in Ogre </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non)Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams  <a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[ \begin{aligned} \left[ \begin{array}{c} u_1 w_l \\ u_2 w_l \\ u_3 w_l \\ w_l \end{array} \right] = P_l M_l \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned} \]
</p>
<p class="formulaDsp">
\[\begin{aligned} \left[ \begin{array}{c} y_1 w_c \\ y_2 w_c \\ y_3 w_c \\ w_c \end{array} \right] = P_c M_c \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<div class="image">
<object type="image/svg+xml" data="depthbias.svg">depthbias.svg</object>
<div class="caption">
Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</div></div>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direciton lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxqdu} \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxdu} \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\ \label{eqn:du3du} \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:duwdX3} \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\ \label{eqn:dudX3} \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in  <a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps  <a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community  <a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>the inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>the inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps  <a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<div class="image">
<object type="image/svg+xml" data="optfrust.svg">optfrust.svg</object>
<div class="caption">
Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</div></div>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non)Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps  <a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps  <a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div><div class="line">sceneMgr-&gt;setShadowTexturePixelFormat(<a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2da3ec4fe727d552337e02069cd9efd9">PF_FLOAT32_R</a>);</div><div class="line">sceneMgr-&gt;setShadowTechnique( <a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">SHADOWTYPE_TEXTURE_ADDITIVE</a> );</div><div class="line">sceneMgr-&gt;setShadowTextureCasterMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Caster/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureReceiverMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>); </div><div class="line">sceneMgr-&gt;setShadowTextureSize(1024);</div></div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>The <code>DepthShadowmap.material</code> script is given below:</p>
<div class="fragment"><div class="line"><span class="comment">// Generic Shadow caster material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Caster/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Generic Shadow receiver material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            texture_unit ShadowMap</div><div class="line">            {</div><div class="line">                tex_address_mode clamp</div><div class="line">                filtering none</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Specific receiver material for rockwall</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/RockWall</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// This is the preferred technique which uses both vertex and</span></div><div class="line">    <span class="comment">// fragment programs, supports coloured lights</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// Base ambient pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 1 1 1</div><div class="line">            diffuse 0 0 0 </div><div class="line">            specular 0 0 0 0 </div><div class="line">            </div><div class="line">            depth_bias -1</div><div class="line">        }</div><div class="line">        <span class="comment">// Now do the lighting pass</span></div><div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div><div class="line">        pass lighting</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 0 0 0 </div><div class="line">            </div><div class="line">            <span class="comment">// do this for each light</span></div><div class="line">            iteration once_per_light</div><div class="line"></div><div class="line">        </div><div class="line">            scene_blend add</div><div class="line">            </div><div class="line">            <span class="comment">// Vertex program reference</span></div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Fragment program</span></div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// shadowmap texture will be bound by code</span></div><div class="line"></div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Decal pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            lighting off</div><div class="line"></div><div class="line"></div><div class="line">            scene_blend dest_colour zero</div><div class="line"></div><div class="line">            depth_bias 1</div><div class="line">            </div><div class="line">            texture_unit</div><div class="line">            {</div><div class="line">                texture rockwall.tga</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> The material uses unified programs for HLSL, GLSL and GLSLES. We’ll present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform vec4 texelOffsets;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 outPos = worldViewProj * vertex;</div><div class="line">    outPos.xy += texelOffsets.zw * outPos.w;</div><div class="line">    <span class="comment">// fix pixel / texel alignment</span></div><div class="line">    depth = outPos.zw;</div><div class="line">    gl_Position = outPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> finalDepth = depth.x / depth.y;</div><div class="line"></div><div class="line">    <span class="comment">// just smear across all components </span></div><div class="line">    <span class="comment">// therefore this one needs high individual channel precision</span></div><div class="line">    gl_FragColor = vec4(finalDepth, finalDepth, finalDepth, 1.0);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Just write out the depth values here. We compute the bias and derivatives in the receiver.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 world;</div><div class="line">uniform mat4 worldIT;</div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform mat4 texViewProj;</div><div class="line">uniform vec4 lightPosition;</div><div class="line">uniform vec4 lightColour;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line">attribute vec3 normal;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    gl_Position = worldViewProj * vertex;</div><div class="line">    </div><div class="line">    vec4 worldPos = world * vertex;</div><div class="line"></div><div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div><div class="line"></div><div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div><div class="line">    vec3 lightDir = normalize(</div><div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div><div class="line"></div><div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div><div class="line"></div><div class="line">    <span class="comment">// calculate shadow map coords</span></div><div class="line">    oUv = texViewProj * worldPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div><div class="line">uniform <span class="keywordtype">float</span> fixedDepthBias;</div><div class="line">uniform <span class="keywordtype">float</span> gradientClamp;</div><div class="line">uniform <span class="keywordtype">float</span> gradientScaleBias;</div><div class="line"></div><div class="line">uniform sampler2D shadowMap;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 shadowUV = oUv;</div><div class="line">    <span class="comment">// point on shadowmap</span></div><div class="line">    shadowUV = shadowUV / shadowUV.w;</div><div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div><div class="line">    </div><div class="line">    <span class="comment">// gradient calculation</span></div><div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div><div class="line">    vec4 depths = vec4(</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, -pixeloffset)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, +pixeloffset)).x);</div><div class="line"></div><div class="line">    vec2 differences = abs( depths.yw - depths.xz );</div><div class="line">    <span class="keywordtype">float</span> gradient = min(gradientClamp, max(differences.x, differences.y));</div><div class="line">    <span class="keywordtype">float</span> gradientFactor = gradient * gradientScaleBias;</div><div class="line"></div><div class="line">    <span class="comment">// visibility function</span></div><div class="line">    <span class="keywordtype">float</span> depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);</div><div class="line">    <span class="keywordtype">float</span> finalCenterDepth = centerdepth + depthAdjust;</div><div class="line"></div><div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div><div class="line"><span class="preprocessor">#if PCF</span></div><div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div><div class="line">    depths += depthAdjust;</div><div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (finalCenterDepth &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> *= 0.2;</div><div class="line"></div><div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1);</div><div class="line">    </div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.</p>
<p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.</p>
<p>The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html">Ogre::PlaneOptimalShadowCameraSetup</a> *planeOptShadowCamera = </div><div class="line">                                <span class="keyword">new</span> PlaneOptimalShadowCameraSetup(movablePlane);</div><div class="line"><a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = sceneMgr-&gt;createEntity( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;plane.mesh&quot;</span> );</div><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = </div><div class="line">                sceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div><div class="line">movablePlaneNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div><div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(planeOptShadowCamera));</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping in Ogre </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non)Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams  <a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[ \begin{aligned} \left[ \begin{array}{c} u_1 w_l \\ u_2 w_l \\ u_3 w_l \\ w_l \end{array} \right] = P_l M_l \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned} \]
</p>
<p class="formulaDsp">
\[\begin{aligned} \left[ \begin{array}{c} y_1 w_c \\ y_2 w_c \\ y_3 w_c \\ w_c \end{array} \right] = P_c M_c \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<div class="image">
<object type="image/svg+xml" data="depthbias.svg">depthbias.svg</object>
<div class="caption">
Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</div></div>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direciton lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxqdu} \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxdu} \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\ \label{eqn:du3du} \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:duwdX3} \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\ \label{eqn:dudX3} \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in  <a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps  <a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community  <a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>the inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>the inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps  <a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<div class="image">
<object type="image/svg+xml" data="optfrust.svg">optfrust.svg</object>
<div class="caption">
Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</div></div>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non)Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps  <a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps  <a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div><div class="line">sceneMgr-&gt;setShadowTexturePixelFormat(<a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2da3ec4fe727d552337e02069cd9efd9">PF_FLOAT32_R</a>);</div><div class="line">sceneMgr-&gt;setShadowTechnique( <a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">SHADOWTYPE_TEXTURE_ADDITIVE</a> );</div><div class="line">sceneMgr-&gt;setShadowTextureCasterMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Caster/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureReceiverMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>); </div><div class="line">sceneMgr-&gt;setShadowTextureSize(1024);</div></div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>The <code>DepthShadowmap.material</code> script is given below:</p>
<div class="fragment"><div class="line"><span class="comment">// Generic Shadow caster material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Caster/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Generic Shadow receiver material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            texture_unit ShadowMap</div><div class="line">            {</div><div class="line">                tex_address_mode clamp</div><div class="line">                filtering none</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Specific receiver material for rockwall</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/RockWall</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// This is the preferred technique which uses both vertex and</span></div><div class="line">    <span class="comment">// fragment programs, supports coloured lights</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// Base ambient pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 1 1 1</div><div class="line">            diffuse 0 0 0 </div><div class="line">            specular 0 0 0 0 </div><div class="line">            </div><div class="line">            depth_bias -1</div><div class="line">        }</div><div class="line">        <span class="comment">// Now do the lighting pass</span></div><div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div><div class="line">        pass lighting</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 0 0 0 </div><div class="line">            </div><div class="line">            <span class="comment">// do this for each light</span></div><div class="line">            iteration once_per_light</div><div class="line"></div><div class="line">        </div><div class="line">            scene_blend add</div><div class="line">            </div><div class="line">            <span class="comment">// Vertex program reference</span></div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Fragment program</span></div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// shadowmap texture will be bound by code</span></div><div class="line"></div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Decal pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            lighting off</div><div class="line"></div><div class="line"></div><div class="line">            scene_blend dest_colour zero</div><div class="line"></div><div class="line">            depth_bias 1</div><div class="line">            </div><div class="line">            texture_unit</div><div class="line">            {</div><div class="line">                texture rockwall.tga</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> The material uses unified programs for HLSL, GLSL and GLSLES. We’ll present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform vec4 texelOffsets;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 outPos = worldViewProj * vertex;</div><div class="line">    outPos.xy += texelOffsets.zw * outPos.w;</div><div class="line">    <span class="comment">// fix pixel / texel alignment</span></div><div class="line">    depth = outPos.zw;</div><div class="line">    gl_Position = outPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> finalDepth = depth.x / depth.y;</div><div class="line"></div><div class="line">    <span class="comment">// just smear across all components </span></div><div class="line">    <span class="comment">// therefore this one needs high individual channel precision</span></div><div class="line">    gl_FragColor = vec4(finalDepth, finalDepth, finalDepth, 1.0);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Just write out the depth values here. We compute the bias and derivatives in the receiver.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 world;</div><div class="line">uniform mat4 worldIT;</div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform mat4 texViewProj;</div><div class="line">uniform vec4 lightPosition;</div><div class="line">uniform vec4 lightColour;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line">attribute vec3 normal;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    gl_Position = worldViewProj * vertex;</div><div class="line">    </div><div class="line">    vec4 worldPos = world * vertex;</div><div class="line"></div><div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div><div class="line"></div><div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div><div class="line">    vec3 lightDir = normalize(</div><div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div><div class="line"></div><div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div><div class="line"></div><div class="line">    <span class="comment">// calculate shadow map coords</span></div><div class="line">    oUv = texViewProj * worldPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div><div class="line">uniform <span class="keywordtype">float</span> fixedDepthBias;</div><div class="line">uniform <span class="keywordtype">float</span> gradientClamp;</div><div class="line">uniform <span class="keywordtype">float</span> gradientScaleBias;</div><div class="line"></div><div class="line">uniform sampler2D shadowMap;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 shadowUV = oUv;</div><div class="line">    <span class="comment">// point on shadowmap</span></div><div class="line">    shadowUV = shadowUV / shadowUV.w;</div><div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div><div class="line">    </div><div class="line">    <span class="comment">// gradient calculation</span></div><div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div><div class="line">    vec4 depths = vec4(</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, -pixeloffset)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, +pixeloffset)).x);</div><div class="line"></div><div class="line">    vec2 differences = abs( depths.yw - depths.xz );</div><div class="line">    <span class="keywordtype">float</span> gradient = min(gradientClamp, max(differences.x, differences.y));</div><div class="line">    <span class="keywordtype">float</span> gradientFactor = gradient * gradientScaleBias;</div><div class="line"></div><div class="line">    <span class="comment">// visibility function</span></div><div class="line">    <span class="keywordtype">float</span> depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);</div><div class="line">    <span class="keywordtype">float</span> finalCenterDepth = centerdepth + depthAdjust;</div><div class="line"></div><div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div><div class="line"><span class="preprocessor">#if PCF</span></div><div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div><div class="line">    depths += depthAdjust;</div><div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (finalCenterDepth &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> *= 0.2;</div><div class="line"></div><div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1);</div><div class="line">    </div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.</p>
<p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.</p>
<p>The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html">Ogre::PlaneOptimalShadowCameraSetup</a> *planeOptShadowCamera = </div><div class="line">                                <span class="keyword">new</span> PlaneOptimalShadowCameraSetup(movablePlane);</div><div class="line"><a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = sceneMgr-&gt;createEntity( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;plane.mesh&quot;</span> );</div><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = </div><div class="line">                sceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div><div class="line">movablePlaneNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div><div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(planeOptShadowCamera));</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping in Ogre </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non)Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams  <a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[ \begin{aligned} \left[ \begin{array}{c} u_1 w_l \\ u_2 w_l \\ u_3 w_l \\ w_l \end{array} \right] = P_l M_l \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned} \]
</p>
<p class="formulaDsp">
\[\begin{aligned} \left[ \begin{array}{c} y_1 w_c \\ y_2 w_c \\ y_3 w_c \\ w_c \end{array} \right] = P_c M_c \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<div class="image">
<object type="image/svg+xml" data="depthbias.svg">depthbias.svg</object>
<div class="caption">
Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</div></div>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direciton lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxqdu} \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxdu} \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\ \label{eqn:du3du} \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:duwdX3} \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\ \label{eqn:dudX3} \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in  <a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps  <a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community  <a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>the inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>the inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps  <a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<div class="image">
<object type="image/svg+xml" data="optfrust.svg">optfrust.svg</object>
<div class="caption">
Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</div></div>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non)Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps  <a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps  <a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div><div class="line">sceneMgr-&gt;setShadowTexturePixelFormat(<a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2da3ec4fe727d552337e02069cd9efd9">PF_FLOAT32_R</a>);</div><div class="line">sceneMgr-&gt;setShadowTechnique( <a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">SHADOWTYPE_TEXTURE_ADDITIVE</a> );</div><div class="line">sceneMgr-&gt;setShadowTextureCasterMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Caster/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureReceiverMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>); </div><div class="line">sceneMgr-&gt;setShadowTextureSize(1024);</div></div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>The <code>DepthShadowmap.material</code> script is given below:</p>
<div class="fragment"><div class="line"><span class="comment">// Generic Shadow caster material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Caster/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Generic Shadow receiver material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            texture_unit ShadowMap</div><div class="line">            {</div><div class="line">                tex_address_mode clamp</div><div class="line">                filtering none</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Specific receiver material for rockwall</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/RockWall</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// This is the preferred technique which uses both vertex and</span></div><div class="line">    <span class="comment">// fragment programs, supports coloured lights</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// Base ambient pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 1 1 1</div><div class="line">            diffuse 0 0 0 </div><div class="line">            specular 0 0 0 0 </div><div class="line">            </div><div class="line">            depth_bias -1</div><div class="line">        }</div><div class="line">        <span class="comment">// Now do the lighting pass</span></div><div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div><div class="line">        pass lighting</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 0 0 0 </div><div class="line">            </div><div class="line">            <span class="comment">// do this for each light</span></div><div class="line">            iteration once_per_light</div><div class="line"></div><div class="line">        </div><div class="line">            scene_blend add</div><div class="line">            </div><div class="line">            <span class="comment">// Vertex program reference</span></div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Fragment program</span></div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// shadowmap texture will be bound by code</span></div><div class="line"></div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Decal pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            lighting off</div><div class="line"></div><div class="line"></div><div class="line">            scene_blend dest_colour zero</div><div class="line"></div><div class="line">            depth_bias 1</div><div class="line">            </div><div class="line">            texture_unit</div><div class="line">            {</div><div class="line">                texture rockwall.tga</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> The material uses unified programs for HLSL, GLSL and GLSLES. We’ll present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform vec4 texelOffsets;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 outPos = worldViewProj * vertex;</div><div class="line">    outPos.xy += texelOffsets.zw * outPos.w;</div><div class="line">    <span class="comment">// fix pixel / texel alignment</span></div><div class="line">    depth = outPos.zw;</div><div class="line">    gl_Position = outPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> finalDepth = depth.x / depth.y;</div><div class="line"></div><div class="line">    <span class="comment">// just smear across all components </span></div><div class="line">    <span class="comment">// therefore this one needs high individual channel precision</span></div><div class="line">    gl_FragColor = vec4(finalDepth, finalDepth, finalDepth, 1.0);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Just write out the depth values here. We compute the bias and derivatives in the receiver.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 world;</div><div class="line">uniform mat4 worldIT;</div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform mat4 texViewProj;</div><div class="line">uniform vec4 lightPosition;</div><div class="line">uniform vec4 lightColour;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line">attribute vec3 normal;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    gl_Position = worldViewProj * vertex;</div><div class="line">    </div><div class="line">    vec4 worldPos = world * vertex;</div><div class="line"></div><div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div><div class="line"></div><div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div><div class="line">    vec3 lightDir = normalize(</div><div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div><div class="line"></div><div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div><div class="line"></div><div class="line">    <span class="comment">// calculate shadow map coords</span></div><div class="line">    oUv = texViewProj * worldPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div><div class="line">uniform <span class="keywordtype">float</span> fixedDepthBias;</div><div class="line">uniform <span class="keywordtype">float</span> gradientClamp;</div><div class="line">uniform <span class="keywordtype">float</span> gradientScaleBias;</div><div class="line"></div><div class="line">uniform sampler2D shadowMap;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 shadowUV = oUv;</div><div class="line">    <span class="comment">// point on shadowmap</span></div><div class="line">    shadowUV = shadowUV / shadowUV.w;</div><div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div><div class="line">    </div><div class="line">    <span class="comment">// gradient calculation</span></div><div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div><div class="line">    vec4 depths = vec4(</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, -pixeloffset)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, +pixeloffset)).x);</div><div class="line"></div><div class="line">    vec2 differences = abs( depths.yw - depths.xz );</div><div class="line">    <span class="keywordtype">float</span> gradient = min(gradientClamp, max(differences.x, differences.y));</div><div class="line">    <span class="keywordtype">float</span> gradientFactor = gradient * gradientScaleBias;</div><div class="line"></div><div class="line">    <span class="comment">// visibility function</span></div><div class="line">    <span class="keywordtype">float</span> depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);</div><div class="line">    <span class="keywordtype">float</span> finalCenterDepth = centerdepth + depthAdjust;</div><div class="line"></div><div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div><div class="line"><span class="preprocessor">#if PCF</span></div><div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div><div class="line">    depths += depthAdjust;</div><div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (finalCenterDepth &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> *= 0.2;</div><div class="line"></div><div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1);</div><div class="line">    </div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.</p>
<p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.</p>
<p>The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html">Ogre::PlaneOptimalShadowCameraSetup</a> *planeOptShadowCamera = </div><div class="line">                                <span class="keyword">new</span> PlaneOptimalShadowCameraSetup(movablePlane);</div><div class="line"><a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = sceneMgr-&gt;createEntity( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;plane.mesh&quot;</span> );</div><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = </div><div class="line">                sceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div><div class="line">movablePlaneNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div><div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(planeOptShadowCamera));</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping in Ogre </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non)Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams  <a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[ \begin{aligned} \left[ \begin{array}{c} u_1 w_l \\ u_2 w_l \\ u_3 w_l \\ w_l \end{array} \right] = P_l M_l \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned} \]
</p>
<p class="formulaDsp">
\[\begin{aligned} \left[ \begin{array}{c} y_1 w_c \\ y_2 w_c \\ y_3 w_c \\ w_c \end{array} \right] = P_c M_c \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<div class="image">
<object type="image/svg+xml" data="depthbias.svg">depthbias.svg</object>
<div class="caption">
Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</div></div>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direciton lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxqdu} \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxdu} \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\ \label{eqn:du3du} \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:duwdX3} \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\ \label{eqn:dudX3} \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in  <a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps  <a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community  <a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>the inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>the inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps  <a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<div class="image">
<object type="image/svg+xml" data="optfrust.svg">optfrust.svg</object>
<div class="caption">
Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</div></div>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non)Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps  <a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps  <a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div><div class="line">sceneMgr-&gt;setShadowTexturePixelFormat(<a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2da3ec4fe727d552337e02069cd9efd9">PF_FLOAT32_R</a>);</div><div class="line">sceneMgr-&gt;setShadowTechnique( <a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">SHADOWTYPE_TEXTURE_ADDITIVE</a> );</div><div class="line">sceneMgr-&gt;setShadowTextureCasterMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Caster/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureReceiverMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>); </div><div class="line">sceneMgr-&gt;setShadowTextureSize(1024);</div></div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>The <code>DepthShadowmap.material</code> script is given below:</p>
<div class="fragment"><div class="line"><span class="comment">// Generic Shadow caster material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Caster/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Generic Shadow receiver material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            texture_unit ShadowMap</div><div class="line">            {</div><div class="line">                tex_address_mode clamp</div><div class="line">                filtering none</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Specific receiver material for rockwall</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/RockWall</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// This is the preferred technique which uses both vertex and</span></div><div class="line">    <span class="comment">// fragment programs, supports coloured lights</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// Base ambient pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 1 1 1</div><div class="line">            diffuse 0 0 0 </div><div class="line">            specular 0 0 0 0 </div><div class="line">            </div><div class="line">            depth_bias -1</div><div class="line">        }</div><div class="line">        <span class="comment">// Now do the lighting pass</span></div><div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div><div class="line">        pass lighting</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 0 0 0 </div><div class="line">            </div><div class="line">            <span class="comment">// do this for each light</span></div><div class="line">            iteration once_per_light</div><div class="line"></div><div class="line">        </div><div class="line">            scene_blend add</div><div class="line">            </div><div class="line">            <span class="comment">// Vertex program reference</span></div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Fragment program</span></div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// shadowmap texture will be bound by code</span></div><div class="line"></div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Decal pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            lighting off</div><div class="line"></div><div class="line"></div><div class="line">            scene_blend dest_colour zero</div><div class="line"></div><div class="line">            depth_bias 1</div><div class="line">            </div><div class="line">            texture_unit</div><div class="line">            {</div><div class="line">                texture rockwall.tga</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> The material uses unified programs for HLSL, GLSL and GLSLES. We’ll present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform vec4 texelOffsets;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 outPos = worldViewProj * vertex;</div><div class="line">    outPos.xy += texelOffsets.zw * outPos.w;</div><div class="line">    <span class="comment">// fix pixel / texel alignment</span></div><div class="line">    depth = outPos.zw;</div><div class="line">    gl_Position = outPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> finalDepth = depth.x / depth.y;</div><div class="line"></div><div class="line">    <span class="comment">// just smear across all components </span></div><div class="line">    <span class="comment">// therefore this one needs high individual channel precision</span></div><div class="line">    gl_FragColor = vec4(finalDepth, finalDepth, finalDepth, 1.0);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Just write out the depth values here. We compute the bias and derivatives in the receiver.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 world;</div><div class="line">uniform mat4 worldIT;</div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform mat4 texViewProj;</div><div class="line">uniform vec4 lightPosition;</div><div class="line">uniform vec4 lightColour;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line">attribute vec3 normal;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    gl_Position = worldViewProj * vertex;</div><div class="line">    </div><div class="line">    vec4 worldPos = world * vertex;</div><div class="line"></div><div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div><div class="line"></div><div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div><div class="line">    vec3 lightDir = normalize(</div><div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div><div class="line"></div><div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div><div class="line"></div><div class="line">    <span class="comment">// calculate shadow map coords</span></div><div class="line">    oUv = texViewProj * worldPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div><div class="line">uniform <span class="keywordtype">float</span> fixedDepthBias;</div><div class="line">uniform <span class="keywordtype">float</span> gradientClamp;</div><div class="line">uniform <span class="keywordtype">float</span> gradientScaleBias;</div><div class="line"></div><div class="line">uniform sampler2D shadowMap;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 shadowUV = oUv;</div><div class="line">    <span class="comment">// point on shadowmap</span></div><div class="line">    shadowUV = shadowUV / shadowUV.w;</div><div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div><div class="line">    </div><div class="line">    <span class="comment">// gradient calculation</span></div><div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div><div class="line">    vec4 depths = vec4(</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, -pixeloffset)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, +pixeloffset)).x);</div><div class="line"></div><div class="line">    vec2 differences = abs( depths.yw - depths.xz );</div><div class="line">    <span class="keywordtype">float</span> gradient = min(gradientClamp, max(differences.x, differences.y));</div><div class="line">    <span class="keywordtype">float</span> gradientFactor = gradient * gradientScaleBias;</div><div class="line"></div><div class="line">    <span class="comment">// visibility function</span></div><div class="line">    <span class="keywordtype">float</span> depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);</div><div class="line">    <span class="keywordtype">float</span> finalCenterDepth = centerdepth + depthAdjust;</div><div class="line"></div><div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div><div class="line"><span class="preprocessor">#if PCF</span></div><div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div><div class="line">    depths += depthAdjust;</div><div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (finalCenterDepth &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> *= 0.2;</div><div class="line"></div><div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1);</div><div class="line">    </div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.</p>
<p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.</p>
<p>The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html">Ogre::PlaneOptimalShadowCameraSetup</a> *planeOptShadowCamera = </div><div class="line">                                <span class="keyword">new</span> PlaneOptimalShadowCameraSetup(movablePlane);</div><div class="line"><a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = sceneMgr-&gt;createEntity( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;plane.mesh&quot;</span> );</div><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = </div><div class="line">                sceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div><div class="line">movablePlaneNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div><div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(planeOptShadowCamera));</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping in Ogre </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non)Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams  <a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[ \begin{aligned} \left[ \begin{array}{c} u_1 w_l \\ u_2 w_l \\ u_3 w_l \\ w_l \end{array} \right] = P_l M_l \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned} \]
</p>
<p class="formulaDsp">
\[\begin{aligned} \left[ \begin{array}{c} y_1 w_c \\ y_2 w_c \\ y_3 w_c \\ w_c \end{array} \right] = P_c M_c \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<div class="image">
<object type="image/svg+xml" data="depthbias.svg">depthbias.svg</object>
<div class="caption">
Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</div></div>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direciton lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxqdu} \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxdu} \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\ \label{eqn:du3du} \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:duwdX3} \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\ \label{eqn:dudX3} \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in  <a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps  <a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community  <a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>the inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>the inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps  <a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<div class="image">
<object type="image/svg+xml" data="optfrust.svg">optfrust.svg</object>
<div class="caption">
Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</div></div>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non)Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps  <a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps  <a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div><div class="line">sceneMgr-&gt;setShadowTexturePixelFormat(<a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2da3ec4fe727d552337e02069cd9efd9">PF_FLOAT32_R</a>);</div><div class="line">sceneMgr-&gt;setShadowTechnique( <a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">SHADOWTYPE_TEXTURE_ADDITIVE</a> );</div><div class="line">sceneMgr-&gt;setShadowTextureCasterMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Caster/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureReceiverMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>); </div><div class="line">sceneMgr-&gt;setShadowTextureSize(1024);</div></div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>The <code>DepthShadowmap.material</code> script is given below:</p>
<div class="fragment"><div class="line"><span class="comment">// Generic Shadow caster material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Caster/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Generic Shadow receiver material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            texture_unit ShadowMap</div><div class="line">            {</div><div class="line">                tex_address_mode clamp</div><div class="line">                filtering none</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Specific receiver material for rockwall</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/RockWall</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// This is the preferred technique which uses both vertex and</span></div><div class="line">    <span class="comment">// fragment programs, supports coloured lights</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// Base ambient pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 1 1 1</div><div class="line">            diffuse 0 0 0 </div><div class="line">            specular 0 0 0 0 </div><div class="line">            </div><div class="line">            depth_bias -1</div><div class="line">        }</div><div class="line">        <span class="comment">// Now do the lighting pass</span></div><div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div><div class="line">        pass lighting</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 0 0 0 </div><div class="line">            </div><div class="line">            <span class="comment">// do this for each light</span></div><div class="line">            iteration once_per_light</div><div class="line"></div><div class="line">        </div><div class="line">            scene_blend add</div><div class="line">            </div><div class="line">            <span class="comment">// Vertex program reference</span></div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Fragment program</span></div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// shadowmap texture will be bound by code</span></div><div class="line"></div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Decal pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            lighting off</div><div class="line"></div><div class="line"></div><div class="line">            scene_blend dest_colour zero</div><div class="line"></div><div class="line">            depth_bias 1</div><div class="line">            </div><div class="line">            texture_unit</div><div class="line">            {</div><div class="line">                texture rockwall.tga</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> The material uses unified programs for HLSL, GLSL and GLSLES. We’ll present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform vec4 texelOffsets;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 outPos = worldViewProj * vertex;</div><div class="line">    outPos.xy += texelOffsets.zw * outPos.w;</div><div class="line">    <span class="comment">// fix pixel / texel alignment</span></div><div class="line">    depth = outPos.zw;</div><div class="line">    gl_Position = outPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> finalDepth = depth.x / depth.y;</div><div class="line"></div><div class="line">    <span class="comment">// just smear across all components </span></div><div class="line">    <span class="comment">// therefore this one needs high individual channel precision</span></div><div class="line">    gl_FragColor = vec4(finalDepth, finalDepth, finalDepth, 1.0);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Just write out the depth values here. We compute the bias and derivatives in the receiver.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 world;</div><div class="line">uniform mat4 worldIT;</div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform mat4 texViewProj;</div><div class="line">uniform vec4 lightPosition;</div><div class="line">uniform vec4 lightColour;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line">attribute vec3 normal;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    gl_Position = worldViewProj * vertex;</div><div class="line">    </div><div class="line">    vec4 worldPos = world * vertex;</div><div class="line"></div><div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div><div class="line"></div><div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div><div class="line">    vec3 lightDir = normalize(</div><div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div><div class="line"></div><div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div><div class="line"></div><div class="line">    <span class="comment">// calculate shadow map coords</span></div><div class="line">    oUv = texViewProj * worldPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div><div class="line">uniform <span class="keywordtype">float</span> fixedDepthBias;</div><div class="line">uniform <span class="keywordtype">float</span> gradientClamp;</div><div class="line">uniform <span class="keywordtype">float</span> gradientScaleBias;</div><div class="line"></div><div class="line">uniform sampler2D shadowMap;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 shadowUV = oUv;</div><div class="line">    <span class="comment">// point on shadowmap</span></div><div class="line">    shadowUV = shadowUV / shadowUV.w;</div><div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div><div class="line">    </div><div class="line">    <span class="comment">// gradient calculation</span></div><div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div><div class="line">    vec4 depths = vec4(</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, -pixeloffset)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, +pixeloffset)).x);</div><div class="line"></div><div class="line">    vec2 differences = abs( depths.yw - depths.xz );</div><div class="line">    <span class="keywordtype">float</span> gradient = min(gradientClamp, max(differences.x, differences.y));</div><div class="line">    <span class="keywordtype">float</span> gradientFactor = gradient * gradientScaleBias;</div><div class="line"></div><div class="line">    <span class="comment">// visibility function</span></div><div class="line">    <span class="keywordtype">float</span> depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);</div><div class="line">    <span class="keywordtype">float</span> finalCenterDepth = centerdepth + depthAdjust;</div><div class="line"></div><div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div><div class="line"><span class="preprocessor">#if PCF</span></div><div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div><div class="line">    depths += depthAdjust;</div><div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (finalCenterDepth &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> *= 0.2;</div><div class="line"></div><div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1);</div><div class="line">    </div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.</p>
<p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.</p>
<p>The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html">Ogre::PlaneOptimalShadowCameraSetup</a> *planeOptShadowCamera = </div><div class="line">                                <span class="keyword">new</span> PlaneOptimalShadowCameraSetup(movablePlane);</div><div class="line"><a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = sceneMgr-&gt;createEntity( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;plane.mesh&quot;</span> );</div><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = </div><div class="line">                sceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div><div class="line">movablePlaneNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div><div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(planeOptShadowCamera));</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping in Ogre </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non)Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams  <a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[ \begin{aligned} \left[ \begin{array}{c} u_1 w_l \\ u_2 w_l \\ u_3 w_l \\ w_l \end{array} \right] = P_l M_l \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned} \]
</p>
<p class="formulaDsp">
\[\begin{aligned} \left[ \begin{array}{c} y_1 w_c \\ y_2 w_c \\ y_3 w_c \\ w_c \end{array} \right] = P_c M_c \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<div class="image">
<object type="image/svg+xml" data="depthbias.svg">depthbias.svg</object>
<div class="caption">
Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</div></div>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direciton lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxqdu} \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxdu} \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\ \label{eqn:du3du} \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:duwdX3} \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\ \label{eqn:dudX3} \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in  <a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps  <a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community  <a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>the inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>the inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps  <a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<div class="image">
<object type="image/svg+xml" data="optfrust.svg">optfrust.svg</object>
<div class="caption">
Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</div></div>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non)Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps  <a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps  <a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div><div class="line">sceneMgr-&gt;setShadowTexturePixelFormat(<a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2da3ec4fe727d552337e02069cd9efd9">PF_FLOAT32_R</a>);</div><div class="line">sceneMgr-&gt;setShadowTechnique( <a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">SHADOWTYPE_TEXTURE_ADDITIVE</a> );</div><div class="line">sceneMgr-&gt;setShadowTextureCasterMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Caster/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureReceiverMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>); </div><div class="line">sceneMgr-&gt;setShadowTextureSize(1024);</div></div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>The <code>DepthShadowmap.material</code> script is given below:</p>
<div class="fragment"><div class="line"><span class="comment">// Generic Shadow caster material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Caster/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Generic Shadow receiver material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            texture_unit ShadowMap</div><div class="line">            {</div><div class="line">                tex_address_mode clamp</div><div class="line">                filtering none</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Specific receiver material for rockwall</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/RockWall</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// This is the preferred technique which uses both vertex and</span></div><div class="line">    <span class="comment">// fragment programs, supports coloured lights</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// Base ambient pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 1 1 1</div><div class="line">            diffuse 0 0 0 </div><div class="line">            specular 0 0 0 0 </div><div class="line">            </div><div class="line">            depth_bias -1</div><div class="line">        }</div><div class="line">        <span class="comment">// Now do the lighting pass</span></div><div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div><div class="line">        pass lighting</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 0 0 0 </div><div class="line">            </div><div class="line">            <span class="comment">// do this for each light</span></div><div class="line">            iteration once_per_light</div><div class="line"></div><div class="line">        </div><div class="line">            scene_blend add</div><div class="line">            </div><div class="line">            <span class="comment">// Vertex program reference</span></div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Fragment program</span></div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// shadowmap texture will be bound by code</span></div><div class="line"></div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Decal pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            lighting off</div><div class="line"></div><div class="line"></div><div class="line">            scene_blend dest_colour zero</div><div class="line"></div><div class="line">            depth_bias 1</div><div class="line">            </div><div class="line">            texture_unit</div><div class="line">            {</div><div class="line">                texture rockwall.tga</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> The material uses unified programs for HLSL, GLSL and GLSLES. We’ll present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform vec4 texelOffsets;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 outPos = worldViewProj * vertex;</div><div class="line">    outPos.xy += texelOffsets.zw * outPos.w;</div><div class="line">    <span class="comment">// fix pixel / texel alignment</span></div><div class="line">    depth = outPos.zw;</div><div class="line">    gl_Position = outPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> finalDepth = depth.x / depth.y;</div><div class="line"></div><div class="line">    <span class="comment">// just smear across all components </span></div><div class="line">    <span class="comment">// therefore this one needs high individual channel precision</span></div><div class="line">    gl_FragColor = vec4(finalDepth, finalDepth, finalDepth, 1.0);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Just write out the depth values here. We compute the bias and derivatives in the receiver.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 world;</div><div class="line">uniform mat4 worldIT;</div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform mat4 texViewProj;</div><div class="line">uniform vec4 lightPosition;</div><div class="line">uniform vec4 lightColour;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line">attribute vec3 normal;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    gl_Position = worldViewProj * vertex;</div><div class="line">    </div><div class="line">    vec4 worldPos = world * vertex;</div><div class="line"></div><div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div><div class="line"></div><div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div><div class="line">    vec3 lightDir = normalize(</div><div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div><div class="line"></div><div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div><div class="line"></div><div class="line">    <span class="comment">// calculate shadow map coords</span></div><div class="line">    oUv = texViewProj * worldPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div><div class="line">uniform <span class="keywordtype">float</span> fixedDepthBias;</div><div class="line">uniform <span class="keywordtype">float</span> gradientClamp;</div><div class="line">uniform <span class="keywordtype">float</span> gradientScaleBias;</div><div class="line"></div><div class="line">uniform sampler2D shadowMap;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 shadowUV = oUv;</div><div class="line">    <span class="comment">// point on shadowmap</span></div><div class="line">    shadowUV = shadowUV / shadowUV.w;</div><div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div><div class="line">    </div><div class="line">    <span class="comment">// gradient calculation</span></div><div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div><div class="line">    vec4 depths = vec4(</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, -pixeloffset)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, +pixeloffset)).x);</div><div class="line"></div><div class="line">    vec2 differences = abs( depths.yw - depths.xz );</div><div class="line">    <span class="keywordtype">float</span> gradient = min(gradientClamp, max(differences.x, differences.y));</div><div class="line">    <span class="keywordtype">float</span> gradientFactor = gradient * gradientScaleBias;</div><div class="line"></div><div class="line">    <span class="comment">// visibility function</span></div><div class="line">    <span class="keywordtype">float</span> depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);</div><div class="line">    <span class="keywordtype">float</span> finalCenterDepth = centerdepth + depthAdjust;</div><div class="line"></div><div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div><div class="line"><span class="preprocessor">#if PCF</span></div><div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div><div class="line">    depths += depthAdjust;</div><div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (finalCenterDepth &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> *= 0.2;</div><div class="line"></div><div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1);</div><div class="line">    </div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.</p>
<p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.</p>
<p>The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html">Ogre::PlaneOptimalShadowCameraSetup</a> *planeOptShadowCamera = </div><div class="line">                                <span class="keyword">new</span> PlaneOptimalShadowCameraSetup(movablePlane);</div><div class="line"><a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = sceneMgr-&gt;createEntity( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;plane.mesh&quot;</span> );</div><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = </div><div class="line">                sceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div><div class="line">movablePlaneNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div><div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(planeOptShadowCamera));</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping in Ogre </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non)Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams  <a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[ \begin{aligned} \left[ \begin{array}{c} u_1 w_l \\ u_2 w_l \\ u_3 w_l \\ w_l \end{array} \right] = P_l M_l \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned} \]
</p>
<p class="formulaDsp">
\[\begin{aligned} \left[ \begin{array}{c} y_1 w_c \\ y_2 w_c \\ y_3 w_c \\ w_c \end{array} \right] = P_c M_c \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<div class="image">
<object type="image/svg+xml" data="depthbias.svg">depthbias.svg</object>
<div class="caption">
Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</div></div>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direciton lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxqdu} \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxdu} \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\ \label{eqn:du3du} \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:duwdX3} \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\ \label{eqn:dudX3} \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in  <a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps  <a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community  <a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>the inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>the inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps  <a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<div class="image">
<object type="image/svg+xml" data="optfrust.svg">optfrust.svg</object>
<div class="caption">
Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</div></div>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non)Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps  <a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps  <a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div><div class="line">sceneMgr-&gt;setShadowTexturePixelFormat(<a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2da3ec4fe727d552337e02069cd9efd9">PF_FLOAT32_R</a>);</div><div class="line">sceneMgr-&gt;setShadowTechnique( <a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">SHADOWTYPE_TEXTURE_ADDITIVE</a> );</div><div class="line">sceneMgr-&gt;setShadowTextureCasterMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Caster/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureReceiverMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>); </div><div class="line">sceneMgr-&gt;setShadowTextureSize(1024);</div></div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>The <code>DepthShadowmap.material</code> script is given below:</p>
<div class="fragment"><div class="line"><span class="comment">// Generic Shadow caster material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Caster/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Generic Shadow receiver material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            texture_unit ShadowMap</div><div class="line">            {</div><div class="line">                tex_address_mode clamp</div><div class="line">                filtering none</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Specific receiver material for rockwall</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/RockWall</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// This is the preferred technique which uses both vertex and</span></div><div class="line">    <span class="comment">// fragment programs, supports coloured lights</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// Base ambient pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 1 1 1</div><div class="line">            diffuse 0 0 0 </div><div class="line">            specular 0 0 0 0 </div><div class="line">            </div><div class="line">            depth_bias -1</div><div class="line">        }</div><div class="line">        <span class="comment">// Now do the lighting pass</span></div><div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div><div class="line">        pass lighting</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 0 0 0 </div><div class="line">            </div><div class="line">            <span class="comment">// do this for each light</span></div><div class="line">            iteration once_per_light</div><div class="line"></div><div class="line">        </div><div class="line">            scene_blend add</div><div class="line">            </div><div class="line">            <span class="comment">// Vertex program reference</span></div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Fragment program</span></div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// shadowmap texture will be bound by code</span></div><div class="line"></div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Decal pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            lighting off</div><div class="line"></div><div class="line"></div><div class="line">            scene_blend dest_colour zero</div><div class="line"></div><div class="line">            depth_bias 1</div><div class="line">            </div><div class="line">            texture_unit</div><div class="line">            {</div><div class="line">                texture rockwall.tga</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> The material uses unified programs for HLSL, GLSL and GLSLES. We’ll present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform vec4 texelOffsets;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 outPos = worldViewProj * vertex;</div><div class="line">    outPos.xy += texelOffsets.zw * outPos.w;</div><div class="line">    <span class="comment">// fix pixel / texel alignment</span></div><div class="line">    depth = outPos.zw;</div><div class="line">    gl_Position = outPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> finalDepth = depth.x / depth.y;</div><div class="line"></div><div class="line">    <span class="comment">// just smear across all components </span></div><div class="line">    <span class="comment">// therefore this one needs high individual channel precision</span></div><div class="line">    gl_FragColor = vec4(finalDepth, finalDepth, finalDepth, 1.0);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Just write out the depth values here. We compute the bias and derivatives in the receiver.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 world;</div><div class="line">uniform mat4 worldIT;</div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform mat4 texViewProj;</div><div class="line">uniform vec4 lightPosition;</div><div class="line">uniform vec4 lightColour;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line">attribute vec3 normal;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    gl_Position = worldViewProj * vertex;</div><div class="line">    </div><div class="line">    vec4 worldPos = world * vertex;</div><div class="line"></div><div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div><div class="line"></div><div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div><div class="line">    vec3 lightDir = normalize(</div><div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div><div class="line"></div><div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div><div class="line"></div><div class="line">    <span class="comment">// calculate shadow map coords</span></div><div class="line">    oUv = texViewProj * worldPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div><div class="line">uniform <span class="keywordtype">float</span> fixedDepthBias;</div><div class="line">uniform <span class="keywordtype">float</span> gradientClamp;</div><div class="line">uniform <span class="keywordtype">float</span> gradientScaleBias;</div><div class="line"></div><div class="line">uniform sampler2D shadowMap;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 shadowUV = oUv;</div><div class="line">    <span class="comment">// point on shadowmap</span></div><div class="line">    shadowUV = shadowUV / shadowUV.w;</div><div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div><div class="line">    </div><div class="line">    <span class="comment">// gradient calculation</span></div><div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div><div class="line">    vec4 depths = vec4(</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, -pixeloffset)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, +pixeloffset)).x);</div><div class="line"></div><div class="line">    vec2 differences = abs( depths.yw - depths.xz );</div><div class="line">    <span class="keywordtype">float</span> gradient = min(gradientClamp, max(differences.x, differences.y));</div><div class="line">    <span class="keywordtype">float</span> gradientFactor = gradient * gradientScaleBias;</div><div class="line"></div><div class="line">    <span class="comment">// visibility function</span></div><div class="line">    <span class="keywordtype">float</span> depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);</div><div class="line">    <span class="keywordtype">float</span> finalCenterDepth = centerdepth + depthAdjust;</div><div class="line"></div><div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div><div class="line"><span class="preprocessor">#if PCF</span></div><div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div><div class="line">    depths += depthAdjust;</div><div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (finalCenterDepth &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> *= 0.2;</div><div class="line"></div><div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1);</div><div class="line">    </div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.</p>
<p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.</p>
<p>The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html">Ogre::PlaneOptimalShadowCameraSetup</a> *planeOptShadowCamera = </div><div class="line">                                <span class="keyword">new</span> PlaneOptimalShadowCameraSetup(movablePlane);</div><div class="line"><a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = sceneMgr-&gt;createEntity( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;plane.mesh&quot;</span> );</div><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = </div><div class="line">                sceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div><div class="line">movablePlaneNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div><div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(planeOptShadowCamera));</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping in Ogre </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non)Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams  <a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[ \begin{aligned} \left[ \begin{array}{c} u_1 w_l \\ u_2 w_l \\ u_3 w_l \\ w_l \end{array} \right] = P_l M_l \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned} \]
</p>
<p class="formulaDsp">
\[\begin{aligned} \left[ \begin{array}{c} y_1 w_c \\ y_2 w_c \\ y_3 w_c \\ w_c \end{array} \right] = P_c M_c \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<div class="image">
<object type="image/svg+xml" data="depthbias.svg">depthbias.svg</object>
<div class="caption">
Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</div></div>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direciton lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxqdu} \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxdu} \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\ \label{eqn:du3du} \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:duwdX3} \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\ \label{eqn:dudX3} \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in  <a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps  <a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community  <a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>the inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>the inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps  <a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<div class="image">
<object type="image/svg+xml" data="optfrust.svg">optfrust.svg</object>
<div class="caption">
Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</div></div>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non)Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps  <a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps  <a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div><div class="line">sceneMgr-&gt;setShadowTexturePixelFormat(<a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2da3ec4fe727d552337e02069cd9efd9">PF_FLOAT32_R</a>);</div><div class="line">sceneMgr-&gt;setShadowTechnique( <a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">SHADOWTYPE_TEXTURE_ADDITIVE</a> );</div><div class="line">sceneMgr-&gt;setShadowTextureCasterMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Caster/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureReceiverMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>); </div><div class="line">sceneMgr-&gt;setShadowTextureSize(1024);</div></div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>The <code>DepthShadowmap.material</code> script is given below:</p>
<div class="fragment"><div class="line"><span class="comment">// Generic Shadow caster material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Caster/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Generic Shadow receiver material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            texture_unit ShadowMap</div><div class="line">            {</div><div class="line">                tex_address_mode clamp</div><div class="line">                filtering none</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Specific receiver material for rockwall</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/RockWall</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// This is the preferred technique which uses both vertex and</span></div><div class="line">    <span class="comment">// fragment programs, supports coloured lights</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// Base ambient pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 1 1 1</div><div class="line">            diffuse 0 0 0 </div><div class="line">            specular 0 0 0 0 </div><div class="line">            </div><div class="line">            depth_bias -1</div><div class="line">        }</div><div class="line">        <span class="comment">// Now do the lighting pass</span></div><div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div><div class="line">        pass lighting</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 0 0 0 </div><div class="line">            </div><div class="line">            <span class="comment">// do this for each light</span></div><div class="line">            iteration once_per_light</div><div class="line"></div><div class="line">        </div><div class="line">            scene_blend add</div><div class="line">            </div><div class="line">            <span class="comment">// Vertex program reference</span></div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Fragment program</span></div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// shadowmap texture will be bound by code</span></div><div class="line"></div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Decal pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            lighting off</div><div class="line"></div><div class="line"></div><div class="line">            scene_blend dest_colour zero</div><div class="line"></div><div class="line">            depth_bias 1</div><div class="line">            </div><div class="line">            texture_unit</div><div class="line">            {</div><div class="line">                texture rockwall.tga</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> The material uses unified programs for HLSL, GLSL and GLSLES. We’ll present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform vec4 texelOffsets;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 outPos = worldViewProj * vertex;</div><div class="line">    outPos.xy += texelOffsets.zw * outPos.w;</div><div class="line">    <span class="comment">// fix pixel / texel alignment</span></div><div class="line">    depth = outPos.zw;</div><div class="line">    gl_Position = outPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> finalDepth = depth.x / depth.y;</div><div class="line"></div><div class="line">    <span class="comment">// just smear across all components </span></div><div class="line">    <span class="comment">// therefore this one needs high individual channel precision</span></div><div class="line">    gl_FragColor = vec4(finalDepth, finalDepth, finalDepth, 1.0);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Just write out the depth values here. We compute the bias and derivatives in the receiver.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 world;</div><div class="line">uniform mat4 worldIT;</div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform mat4 texViewProj;</div><div class="line">uniform vec4 lightPosition;</div><div class="line">uniform vec4 lightColour;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line">attribute vec3 normal;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    gl_Position = worldViewProj * vertex;</div><div class="line">    </div><div class="line">    vec4 worldPos = world * vertex;</div><div class="line"></div><div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div><div class="line"></div><div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div><div class="line">    vec3 lightDir = normalize(</div><div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div><div class="line"></div><div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div><div class="line"></div><div class="line">    <span class="comment">// calculate shadow map coords</span></div><div class="line">    oUv = texViewProj * worldPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div><div class="line">uniform <span class="keywordtype">float</span> fixedDepthBias;</div><div class="line">uniform <span class="keywordtype">float</span> gradientClamp;</div><div class="line">uniform <span class="keywordtype">float</span> gradientScaleBias;</div><div class="line"></div><div class="line">uniform sampler2D shadowMap;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 shadowUV = oUv;</div><div class="line">    <span class="comment">// point on shadowmap</span></div><div class="line">    shadowUV = shadowUV / shadowUV.w;</div><div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div><div class="line">    </div><div class="line">    <span class="comment">// gradient calculation</span></div><div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div><div class="line">    vec4 depths = vec4(</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, -pixeloffset)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, +pixeloffset)).x);</div><div class="line"></div><div class="line">    vec2 differences = abs( depths.yw - depths.xz );</div><div class="line">    <span class="keywordtype">float</span> gradient = min(gradientClamp, max(differences.x, differences.y));</div><div class="line">    <span class="keywordtype">float</span> gradientFactor = gradient * gradientScaleBias;</div><div class="line"></div><div class="line">    <span class="comment">// visibility function</span></div><div class="line">    <span class="keywordtype">float</span> depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);</div><div class="line">    <span class="keywordtype">float</span> finalCenterDepth = centerdepth + depthAdjust;</div><div class="line"></div><div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div><div class="line"><span class="preprocessor">#if PCF</span></div><div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div><div class="line">    depths += depthAdjust;</div><div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (finalCenterDepth &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> *= 0.2;</div><div class="line"></div><div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1);</div><div class="line">    </div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.</p>
<p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.</p>
<p>The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html">Ogre::PlaneOptimalShadowCameraSetup</a> *planeOptShadowCamera = </div><div class="line">                                <span class="keyword">new</span> PlaneOptimalShadowCameraSetup(movablePlane);</div><div class="line"><a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = sceneMgr-&gt;createEntity( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;plane.mesh&quot;</span> );</div><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = </div><div class="line">                sceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div><div class="line">movablePlaneNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div><div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(planeOptShadowCamera));</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Deferred Shading</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('deferred.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Deferred Shading </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#what">What is Deferred Shading?</a></li>
<li class="level1"><a href="#creating">Creating the G-Buffer</a></li>
<li class="level1"><a href="#lighting">Lighting the scene</a><ul><li class="level2"><a href="#lightgeom">Rendering the light geometry</a></li>
</ul>
</li>
<li class="level1"><a href="#post">Post Processing</a></li>
<li class="level1"><a href="#realprojects">Integration in real projects</a></li>
<li class="level1"><a href="#summary">Summary</a><ul><li class="level2"><a href="#further">Further reading</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>This wiki article is complementary to the deferred shading demo that is part of the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> SDK. It will reference the code quite a bit and explain some of the decisions made when implementing the deferred shading framework for the demo.</p>
<h1><a class="anchor" id="what"></a>
What is Deferred Shading?</h1>
<p>Deferred shading is an alternative approach to rendering 3d scenes. The classic rendering approach involves rendering each object and applying lighting passes to it. So, if an ogre head is affected by 6 lights, it will be rendered 6 times, once for each light, in order to accumulate the affection of each light. Deferred shading takes another approach : In the beginning, all of the objects render their "lighting related info" to a texture, often called the G-Buffer. This means their colours, normals, depths and any other info that might be relevant to calculating their final colour. Afterwards, the lights in the scene are rendered as geometry (sphere for point light, cone for spotlight and full screen quad for directional light), and they use the G-buffer to calculate the colour contribution of that light to that pixel.</p>
<p>See the links in <a class="el" href="deferred.html#further">Further reading</a> to read more about it. It is recommended to understand deferred shading before reading this article, as the article focuses on implementing it in ogre, and not explaining how it works.</p>
<h2>Deferred Shading Advantages</h2>
<p>The main reason for using deferred shading is performance related. Classing rendering (also called forward rendering) can, in the worst case, require num_objects * num_lights batches to render a scene. Deferred shading changes that to num_objects + num_lights, which can often be a lot less. Another reason is that some new post-processing effects are easily achievable using the G-Buffer as input. If you wanted to perform these effects without deferred shading, you would've had to render the whole scene again.</p>
<h2>Deferred Shading Disadvantages</h2>
<p>There are several algorithmic drawbacks with deferred shading - transparent objects are hard to handle, anti aliasing can not be used in DX9 class hardware, additional memory consumption because of the G-Buffer. In addition to that, deferred shading is harder to implement - it overrides the entire fixed function pipeline. Pretty much everything is rendered using manual shaders - which probably means a lot of shader code.</p>
<h1><a class="anchor" id="creating"></a>
Creating the G-Buffer</h1>
<p>The first part of the deferred shading pipeline involves rendering all the (non-transparent) objects of the scene to the G-Buffer. This is done using a compositor :</p>
<div class="fragment"><div class="line">compositor DeferredShading/GBuffer</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// temporary textures</span></div><div class="line">        texture mrt_output target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf91793bc9707d6541f4851722267317a">PF_FLOAT16_RGBA</a> <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf91793bc9707d6541f4851722267317a">PF_FLOAT16_RGBA</a> chain_scope</div><div class="line">        </div><div class="line">        target mrt_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line">            </div><div class="line">            shadows off</div><div class="line">            material_scheme GBuffer</div><div class="line">            </div><div class="line">            <span class="comment">// everything but the lights and their meshes</span></div><div class="line">            <span class="comment">// could do this with something like a visibility mask too</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                <span class="comment">//These values are synchronized with the code</span></div><div class="line">                first_render_queue 10</div><div class="line">                last_render_queue  79   </div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Things to note about this compositor :</p><ul>
<li>mrt_output (the GBuffer) is an MRT because there are two pixel formats defined.</li>
<li>mrt_output will be accessible to the next compositors in the chain because it is marked as chain_scope, meaning it is visible to the next compositors in the chain.</li>
<li>The material scheme tells ogre that objects shouldn't be rendered in normal fashion, but in some other way (we'll get to that soon)</li>
<li>Not all the objects are rendered to the GBuffer. Skies and 'late objects' (which can be specified manually using render queues) will be forward rendered.</li>
<li>This compositor does NOT have a target_output pass, because it does not contribute directly to the final image.</li>
</ul>
<h2>Deciding on the GBuffer format</h2>
<p>This in an important decision in deferred shading, as it has performance and visual implications.</p>
<p>Also, the entire pipeline has to be coordinated with this format - all the writing shaders have to write the same data to the same places, and all the reading shaders (for lighting later) have to be synchronized with it.</p>
<p>We chose two PF_FLOAT16_RGBA textures. The first one will contain the colour in RGB, specular intensity in A.</p>
<p>The second one will contain the view-space-normal in RGB (we keep all 3 coordinates) and the (linear) depth in A.</p>
<p>See the references for other possibilities.</p>
<h2>Preparing the objects for G-Buffer rendering</h2>
<p>The only indicator that ogre has when rendering the scene is that the material scheme is different. Material schemes in ogre allow materials to specify different rendering techniques for different scenarios. In this case, we would like to output the lighting related information instead of the lighting calculation result.</p>
<p>Materials that have a technique associated with the GBuffer scheme will render using that, but we don't want to modify the materials of all the objects in our art pipeline to use them in deferred shading.</p>
<p>The solution is to use scheme listeners! The material manager has a method for registering listeners when objects don't have a technique defined for the current scheme: <a class="el" href="class_ogre_1_1_material_manager.html#a8ac18f4bd2e6302f1d92ae8f64195694" title="Add a listener to handle material events. ">Ogre::MaterialManager::addListener()</a>.</p>
<p>The listener has a callback method that gets called whenever an object is about to be rendered without a matching technique: <a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html#a54bc384ab1102063aa00db4c3a5f3fc4" title="Called if a technique for a given scheme is not found within a material, allows the application to sp...">Ogre::MaterialManager::Listener::handleSchemeNotFound()</a>.</p>
<p>We will implement such a listener for the GBuffer scheme. It is GBufferSchemeHandler from the demo. The GBufferSchemeHandlers works like this :</p>
<h3>Inspect the classic technique</h3>
<p>For each pass in the technique that would have been used normally, the GBufferSchemeHandler::inspectPass is called, inspects the pass, and returns the PassProperties - does this pass have a texture? a normal map? is it skinned? tranpsarent? Etc. The PassProperties (should) contain all the information required to build a GBuffer technique for an object.</p>
<h3>Generate the G-Buffer technique</h3>
<p>After a pass has been inspected and understood, the next stage is to generate the G-Buffer-writing technique. This is done using the class GBufferMaterialGenerator. The class receives the flags of the features needed by the material, and dynamically generates the (CG) shaders and material to render an object with those properties to the G-Buffer. This greatly reduces the number of shaders that you need to manage when using deferred shading, as most of them are created on the fly. Here is an example of what they look like :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ToGBufferVP(</div><div class="line">         float4 iPosition : POSITION,</div><div class="line">         float3 iNormal   : NORMAL,</div><div class="line">         float2 iUV0 : TEXCOORD0,</div><div class="line"></div><div class="line">         out float4 oPosition : POSITION,</div><div class="line">         out float3 oViewPos : TEXCOORD0,</div><div class="line">         out float3 oNormal : TEXCOORD1,</div><div class="line">         out float2 oUV0 : TEXCOORD2,</div><div class="line"></div><div class="line">         uniform float4x4 cWorldViewProj,</div><div class="line">         uniform float4x4 cWorldView</div><div class="line">         )</div><div class="line"> {</div><div class="line">         oPosition = mul(cWorldViewProj, iPosition);</div><div class="line">         oNormal = mul(cWorldView, float4(iNormal,0)).xyz;</div><div class="line">         oViewPos = mul(cWorldView, iPosition).xyz;</div><div class="line">         oUV0 = iUV0;</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keywordtype">void</span> ToGBufferFP(</div><div class="line">         float3 iViewPos : TEXCOORD0,</div><div class="line">         float3 iNormal   : TEXCOORD1,</div><div class="line">         float3 iTangent : TEXCOORD2,</div><div class="line">         float3 iBiNormal : TEXCOORD3,</div><div class="line">         float2 iUV0 : TEXCOORD4,</div><div class="line"></div><div class="line">         out float4 oColor0 : COLOR0,</div><div class="line">         out float4 oColor1 : COLOR1,</div><div class="line"></div><div class="line">         uniform sampler sNormalMap : <span class="keyword">register</span>(s0),</div><div class="line">         uniform sampler sTex0 : <span class="keyword">register</span>(s1),</div><div class="line">         uniform float4 cDiffuseColour,</div><div class="line">         uniform <span class="keywordtype">float</span> cFarDistance,</div><div class="line">         uniform <span class="keywordtype">float</span> cSpecularity</div><div class="line">         )</div><div class="line"> {</div><div class="line">         oColor0.rgb = tex2D(sTex0, iUV0);</div><div class="line">         oColor0.rgb *= cDiffuseColour.rgb;</div><div class="line">         oColor0.a = cSpecularity;</div><div class="line">         float3 texNormal = (tex2D(sNormalMap, iUV0)-0.5)*2;</div><div class="line">         float3x3 normalRotation = float3x3(iTangent, iBiNormal, iNormal);</div><div class="line">         oColor1.rgb = normalize(mul(texNormal, normalRotation));</div><div class="line">         oColor1.a = length(iViewPos) / cFarDistance;</div><div class="line"> }</div></div><!-- fragment --><p> (This is for an object with a texture and a normal map)</p>
<h3>Add the G-Buffer technique to the original material</h3>
<p>We don't want to inspect the passes and generate the material each time an object is rendered, so we create a technique in the original material, and fill it with the auto-generated information. After copying the information from the GBuffer technique, texture references have to be updated, to use the correct textures when rendering the object. This happens in <code>GBufferSchemeHandler::fillPass</code>. The next time the object will be rendered, it WILL have a technique for the GBuffer scheme, so the listener won't get called.</p>
<h3>Postponing transparent objects</h3>
<p>We don't want to render transparent objects to the GBuffer, as it doesn't work properly later.</p>
<p>To address this, we also create a technique with a scheme called called 'NoGBuffer'. If the inspectPass decided that the object is transparent, we will not add an auto-generated pass to the 'GBuffer' technique, but instead copy the regular pass to the 'NoGBuffer' technique, to render it regularly later.</p>
<h3>Putting it all together</h3>
<p>This is how <code>GBufferSchemeHandler::handleSchemeNotFound</code> works:</p>
<div class="fragment"><div class="line">Technique* GBufferSchemeHandler::handleSchemeNotFound(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> schemeIndex, </div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; schemeName, Material* originalMaterial, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> lodIndex, </div><div class="line">        <span class="keyword">const</span> Renderable* rend)</div><div class="line">{</div><div class="line">    <a class="code" href="class_ogre_1_1_material_manager.html">Ogre::MaterialManager</a>&amp; matMgr = <a class="code" href="class_ogre_1_1_material_manager.html#a100f413d9d2316028e7ae740e5a43161">Ogre::MaterialManager::getSingleton</a>();</div><div class="line">    <a class="code" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> curSchemeName = matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#ad03ea02e140fc1e7312d14626e59d45d">getActiveScheme</a>();</div><div class="line">    matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0">setActiveScheme</a>(MaterialManager::DEFAULT_SCHEME_NAME);</div><div class="line">    Technique* originalTechnique = originalMaterial-&gt;getBestTechnique(lodIndex, rend);</div><div class="line">    matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0">setActiveScheme</a>(curSchemeName);</div><div class="line"></div><div class="line">    Technique* gBufferTech = originalMaterial-&gt;createTechnique();</div><div class="line">    gBufferTech-&gt;removeAllPasses();</div><div class="line">    gBufferTech-&gt;setSchemeName(schemeName);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef OGRE_BUILD_COMPONENT_RTSHADERSYSTEM</span></div><div class="line">    RTShader::ShaderGenerator&amp; rtShaderGen = RTShader::ShaderGenerator::getSingleton();</div><div class="line">    rtShaderGen.createShaderBasedTechnique(*originalMaterial, originalTechnique-&gt;getSchemeName(), <span class="stringliteral">&quot;NoGBuffer&quot;</span>);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    Technique* noGBufferTech = originalMaterial-&gt;createTechnique();</div><div class="line">    noGBufferTech-&gt;removeAllPasses();</div><div class="line">    noGBufferTech-&gt;setSchemeName(<span class="stringliteral">&quot;NoGBuffer&quot;</span>);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i=0; i&lt;originalTechnique-&gt;getNumPasses(); i++)</div><div class="line">    {</div><div class="line">        Pass* originalPass = originalTechnique-&gt;getPass(i);</div><div class="line">        PassProperties props = inspectPass(originalPass, lodIndex, rend);</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (!props.isDeferred)</div><div class="line">        {</div><div class="line"><span class="preprocessor">#ifdef OGRE_BUILD_COMPONENT_RTSHADERSYSTEM</span></div><div class="line">            rtShaderGen.validateMaterial(<span class="stringliteral">&quot;NoGBuffer&quot;</span>, originalMaterial-&gt;getName(), originalMaterial-&gt;getGroup());</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">            <span class="comment">//Just copy the technique so it gets rendered regularly</span></div><div class="line">            Pass* clonePass = noGBufferTech-&gt;createPass();</div><div class="line">            *clonePass = *originalPass;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        Pass* newPass = gBufferTech-&gt;createPass();</div><div class="line">        MaterialGenerator::Perm perm = getPermutation(props);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::MaterialPtr</a>&amp; templateMat = mMaterialGenerator.getMaterial(perm);</div><div class="line">        </div><div class="line">        <span class="comment">//We assume that the GBuffer technique contains only one pass. But its true.</span></div><div class="line">        *newPass = *(templateMat-&gt;<a class="code" href="class_ogre_1_1_material.html#abc82b3c4963c8d3cd04c93fdc6dbf416">getTechnique</a>(0)-&gt;<a class="code" href="class_ogre_1_1_technique.html#a3ce84da25bb6b5762af714adaf70874a">getPass</a>(0));</div><div class="line">        fillPass(newPass, originalPass, props);    </div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> gBufferTech;</div><div class="line">}</div></div><!-- fragment --> <h2>Overriding the automatic process</h2>
<p>In some cases the automatic material generation will not be good enough. We want to keep the option of manually writing GBuffer materials and shaders.</p>
<p>How do we do this? Easily! Since GBufferSchemeHandler::handleSchemeNotFound only gets called when an object doesn't already have a GBuffer scheme, adding a 'GBuffer' technique to the material will cause it to not get passed to the listener even once.</p>
<h2>Seeing it in action</h2>
<p>Using tools like NVIDIA's PerfHUD, we can see the texture being built during the frame :</p>
<div class="image">
<img src="GBufferPerfHUD.PNG" alt="GBufferPerfHUD.PNG"/>
</div>
<p>Note that nothing has been written to the final output yet (main view is completely black) and that two textures are being written to (see right hand side).</p>
<h1><a class="anchor" id="lighting"></a>
Lighting the scene</h1>
<p>In the GBuffer compositor, we built the G-Buffer for the current frame. It is now the time to use it to calculate the final lighting of the scene. This is what the compositor looks like :</p>
<div class="fragment"><div class="line">compositor DeferredShading/ShowLit</div><div class="line">{</div><div class="line"></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">//Reference the main Gbuffer texture</span></div><div class="line">        texture_ref mrt_output DeferredShading/GBuffer mrt_output</div><div class="line">        </div><div class="line">        target_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line">            <span class="comment">//We will dispatch the shadow texture rendering ourselves</span></div><div class="line">            shadows off</div><div class="line">            </div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">                </div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">// render skies and other pre-gbuffer objects</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                first_render_queue 1</div><div class="line">                last_render_queue  9            </div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the lights and their meshes</span></div><div class="line">            pass render_custom DeferredLight</div><div class="line">            {</div><div class="line">                input 0 mrt_output 0</div><div class="line">                input 1 mrt_output 1</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the objects that skipped rendering into the gbuffer</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                material_scheme NoGBuffer</div><div class="line">                first_render_queue 10</div><div class="line">                last_render_queue 79</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the post-GBuffer render queue objects</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                <span class="comment">//This value is synchronized with the code</span></div><div class="line">                first_render_queue 80</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Yes, it's a long one. Here is a breakdown of the compositor :</p><ul>
<li>The 'texture_ref' definition means that we are referencing a texture from another compositor. In the case of a chain-scoped texture (like the GBuffer), this means that we can only apply this compositor on chains that have the GBuffer creating compositor earlier in the chain than this one. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will check that this is the case.</li>
</ul>
<p>There are four target passes in this compositor.</p><ol type="1">
<li>Render the skies and then the lights using the render_custom directive (more on this later)</li>
<li>Render the objects that are in the GBuffer render queues but didn't get rendered to the GBuffer</li>
<li>Render the post-GBuffer render queue objects</li>
<li>Output the result</li>
</ol>
<h3>Why do we need four target passes ?</h3>
<p>This is mainly a limitation of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Ideally, we could use a single target_output pass and do all the passes there. The problem is that material_scheme is at the target scope and not at the pass scope. This is hard to change, because material schemes are resolved during scene preparing time and not during scene rendering. So even if the scope would change, it would not affect the rendering, as the material scheme will not get tested after we switch to it. Perhaps this will be addressed, and then this compositor will get simplified.</p>
<h2><a class="anchor" id="lightgeom"></a>
Rendering the light geometry</h2>
<p>The geometry that we want to render to calculate lighting information doesn't really fit in any classic category. It is not really a part of the scene, as the light geometry aren't objects in the world. But it is geometry (not always a quad) that needs to be rendered.</p>
<p>For these kind of operations, the render_custom target pass was introduced into <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. It is possible to register custom (named) composition passes that will be performed in the compositor. In this case, it is 'DeferredLight'. The composition pass will receive a call each frame telling it 'it's your turn, do your thing'. The class in the demo is DeferredLightCP.</p>
<p>The registration of the custom composition pass has to be done once, using <a class="el" href="class_ogre_1_1_compositor_manager.html#ae9b8ca4c2a51c0720bb31393d20fe7c9" title="Register a custom composition pass. ">Ogre::CompositorManager::registerCustomCompositionPass()</a>.</p>
<p>CustomCompositionPass is essentially just a factory for RenderSystemOperations, which are the operations that get executed during a compositor chain. This is the single API call: <a class="el" href="class_ogre_1_1_custom_composition_pass.html#a6b8c7a3743f9bb44e27c0348a0035e7b" title="Create a custom composition operation. ">Ogre::CustomCompositionPass::createOperation()</a>.</p>
<p>So, now we get called exactly when we want, after the G-Buffer has been built and the (early) skies have been rendered. What will we do?</p>
<h3>Prepare ambient colour and rebuild original depth buffer</h3>
<p>Since we rendered the original scene to a different RTT, the depth buffer won't necessarily get reused for the output target, so we need to rebuild it so that future objects (lights and non-g-buffer objects) will be able to interact with the depth naturally.</p>
<p>Also, we need to apply the ambient light to the scene. For the purpose of the demo, the ambient light is not a separate colour channel, just the object's original textures applied with the scene's global ambient light factor. In theory, you could set up a different G-Buffer to allow more flexibility, but we didn't do that.</p>
<p>These two actions happen in a single full-screen quad render, that comes from the AmbientLight class.</p>
<h3>Render the light geometries</h3>
<p>The most important stage is the light geometry. The code scans the original scene's lights, builds a matching DLight (deferred light) instance for each light in the scene, and renders away using the G-Buffer.</p>
<p>These lights use pretty sophisticated shaders, since they perform the lighting calculations of the fixed function pipeline themselves, and have to account for many options (specularity, attenuation, different light types and shadows, which will get talked about soon). In contrast to the G-Buffer building stage, the shaders here do not get generated on the fly. There is one big shader (sometimes referred to as an Uber-Shader) with many preprocessor options that account for all the options. (See LightMaterial_ps.cg) Note that the shaders have to be synchronized with the G-Buffer layout. A change in the layout would need a parallel change in the deferred lighting shaders.</p>
<p>The material generator for this section (LightMaterialGenerator class) just scans the flags of input and generates the correct preprocessor defines for the uber-shader. Some people prefer to use this approach for the G-Buffer stage as well, but I wanted to show both options in the demo.</p>
<p>In order to dispatch render operations manually, the following call exists in SceneManager: <a class="el" href="class_ogre_1_1_scene_manager.html#a1593fab748d1b0820e93e49d5732350b" title="Render something as if it came from the current queue. ">Ogre::SceneManager::_injectRenderWithPass()</a>.</p>
<p>When rendering a light, we pass the light we are rendering as the manual light list in order to have the auto params for that light available in the shader.</p>
<h3>Rendering shadow casting lights</h3>
<p>The 'classic' approach to rendering texture shadows is to prepare all of them before the scene rendering starts, and then apply them to the rendered objects using shadow receiver passes or integrated shaders. The downside of this approach is that you need to allocate a texture per-light (5 shadow casting lights -&gt; 5 shadow textures) and that if you don't integrate it in your shaders you also contribute even more passes to the scene.</p>
<p>One of the advantages of deferred shading is that we render the lights completely, and one by one. So, we can generate the shadow texture for a light just before the light's geometry is rendered, allowing us to reuse the same texture for as many lights as we want. (We still have an overhead of rendering the scene from the light's perspective per-light).</p>
<p>The API call that prepares shadow textures on demand is <a class="el" href="class_ogre_1_1_scene_manager.html#a95cd8ff86a7178c2e37b2fcb485f64fa" title="Method for preparing shadow textures ready for use in a regular render Do not call manually unless be...">Ogre::SceneManager::prepareShadowTextures()</a>. The lightList parameter allows specification of which lights to prepare shadow textures for.</p>
<p>Important note - RenderSystemOperations get executed in the middle of scene rendering. This means that there is an active render target being rendered to. In order to render the shadow texture we need to be able to pause rendering mid frame, render the shadow texture, and resume rendering immediately afterwards. For this, SceneManager has two methods that do just that <a class="el" href="class_ogre_1_1_scene_manager.html#a90d0e7484ed4580ec980eef15808bfee" title="Pause rendering of the frame. ">Ogre::SceneManager::_pauseRendering()</a> and <a class="el" href="class_ogre_1_1_scene_manager.html#a794e03ea25dd798346414c1dba31337d" title="Resume rendering of the frame. ">Ogre::SceneManager::_resumeRendering()</a>, so the prepareShadowTextures call has to be inside this.</p>
<p>The demo currently supports just spotlight shadow casting (since it is the cheapest to implement) but the other options can be supported as well.</p>
<h3>Putting it all together</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DeferredLightRenderOperation::execute(SceneManager *sm, RenderSystem *rs)</div><div class="line">{</div><div class="line">    <a class="code" href="class_ogre_1_1_camera.html">Ogre::Camera</a>* cam = mViewport-&gt;getCamera();</div><div class="line"></div><div class="line">    mAmbientLight-&gt;updateFromCamera(cam);</div><div class="line">    Technique* tech = mAmbientLight-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a2a54dff8ade9ab6838c1517062f0eb98">getMaterial</a>()-&gt;<a class="code" href="class_ogre_1_1_material.html#a37ae7259ce89bdc38828ea1b977bdbcf">getBestTechnique</a>();</div><div class="line">    injectTechnique(sm, tech, mAmbientLight, 0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group___general.html#gaab30ef14aae93306a6044cb38d835f0c">LightList</a>&amp; lightList = sm-&gt;_getLightsAffectingFrustum();</div><div class="line">    <span class="keywordflow">for</span> (LightList::const_iterator it = lightList.begin(); it != lightList.end(); it++) </div><div class="line">    {</div><div class="line">        Light* light = *it;</div><div class="line">        <a class="code" href="class_ogre_1_1_hashed_vector.html">Ogre::LightList</a> ll;</div><div class="line">        ll.<a class="code" href="class_ogre_1_1_hashed_vector.html#a87bfcde773502ee964a677580724188f">push_back</a>(light);</div><div class="line"></div><div class="line">        <span class="comment">//if (++i != 2) continue;</span></div><div class="line">        <span class="comment">//if (light-&gt;getType() != Light::LT_DIRECTIONAL) continue;</span></div><div class="line">        <span class="comment">//if (light-&gt;getDiffuseColour() != ColourValue::Red) continue;</span></div><div class="line"></div><div class="line">        LightsMap::iterator dLightIt = mLights.find(light);</div><div class="line">        DLight* dLight = 0;</div><div class="line">        <span class="keywordflow">if</span> (dLightIt == mLights.end()) </div><div class="line">        {</div><div class="line">            dLight = createDLight(light);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> </div><div class="line">        {</div><div class="line">            dLight = dLightIt-&gt;second;</div><div class="line">            dLight-&gt;updateFromParent();</div><div class="line">        }</div><div class="line">        dLight-&gt;updateFromCamera(cam);</div><div class="line">        tech = dLight-&gt;getMaterial()-&gt;getBestTechnique();</div><div class="line"></div><div class="line">        <span class="comment">//Update shadow texture</span></div><div class="line">        <span class="keywordflow">if</span> (dLight-&gt;getCastChadows())</div><div class="line">        {</div><div class="line">            SceneManager::RenderContext* context = sm-&gt;_pauseRendering();</div><div class="line"></div><div class="line">            sm-&gt;prepareShadowTextures(cam, mViewport, &amp;ll);</div><div class="line">            sm-&gt;_resumeRendering(context);</div><div class="line">            </div><div class="line">            Pass* pass = tech-&gt;getPass(0);</div><div class="line">            TextureUnitState* tus = pass-&gt;getTextureUnitState(<span class="stringliteral">&quot;ShadowMap&quot;</span>);</div><div class="line">            assert(tus);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a>&amp; shadowTex = sm-&gt;getShadowTexture(0);</div><div class="line">            <span class="keywordflow">if</span> (tus-&gt;_getTexturePtr() != shadowTex)</div><div class="line">            {</div><div class="line">                tus-&gt;_setTexturePtr(shadowTex);</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">        </div><div class="line">        injectTechnique(sm, tech, dLight, &amp;ll);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h3>Seeing it in action</h3>
<p>Here is a screenshot from PerfHUD of the draw call that renders a spotlight that casts shadows. See the two G-Buffer textures and one shadow texture on the left :</p>
<div class="image">
<img src="DeferredCone1.PNG" alt="DeferredCone1.PNG"/>
</div>
<p>Here is a visualization of the texture being built :</p>
<div class="image">
<img src="DeferredCone2.PNG" alt="DeferredCone2.PNG"/>
</div>
<p>After all the lights are rendered, the scene is fully lit!</p>
<h1><a class="anchor" id="post"></a>
Post Processing</h1>
<p>The compositor framework used to be a post processing framework, but as this article shows - it is now a 'custom render pipeline' framework, allowing different rendering approaches. However, it can still be used to post process the scene, even under deferred rendering.</p>
<h2>Screen Space Ambient Occlusion</h2>
<p>'Screen Space Ambient Occlusion' is a global illumination technique that adds a bit of realism to the scene, where classic lighting often fails. However, it requires the normals and depths of the scene in order to calculate its contribution. Normally, the SSAO compositor would have a render_scene directive that does that.</p>
<p>However, with deferred shading, we already have that information from the G-Buffer stage, so we just need to access it!</p>
<p>This is what the compositor looks like :</p>
<div class="fragment"><div class="line">compositor DeferredShading/SSAO</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        compositor_logic SSAOLogic</div><div class="line">        </div><div class="line">        texture_ref geom DeferredShading/GBuffer mrt_output</div><div class="line">        texture scene target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca74ea3b1c0c5f4ae06b1a7136c5523eca">PF_R8G8B8A8</a></div><div class="line">        texture ssao target_width_scaled 0.5 target_height_scaled 0.5 <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line">        texture ssaoBlurX target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line">        texture ssaoBlurY target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line"></div><div class="line">        <span class="comment">// the scene we want to modulate</span></div><div class="line">        target scene</div><div class="line">        {</div><div class="line">            input previous</div><div class="line">        }</div><div class="line"></div><div class="line">        </div><div class="line"></div><div class="line">        target ssao</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                <span class="comment">// our SSAO listener number</span></div><div class="line">                identifier 42</div><div class="line"></div><div class="line">                material ssao</div><div class="line">                <span class="comment">// pass in the &quot;geometry map&quot;</span></div><div class="line">                input 0 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        target ssaoBlurX</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                identifier 43</div><div class="line"></div><div class="line">                material ssaoBlurX</div><div class="line">                input 0 ssao</div><div class="line">                input 1 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        target ssaoBlurY</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                identifier 43</div><div class="line"></div><div class="line">                material ssaoBlurY</div><div class="line">                input 0 ssaoBlurX</div><div class="line">                input 1 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        target_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                <span class="comment">// just output something, for example, use a modulate</span></div><div class="line">                <span class="comment">// material to just multiply the scene by the ssao</span></div><div class="line">                material modulate</div><div class="line">                input 0 scene</div><div class="line">                input 1 ssaoBlurY</div><div class="line">                <span class="comment">//input 1 ssao</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Some notes :</p><ul>
<li>Again, texture_ref is used to access a chain_scoped texture from the GBuffer compositor</li>
<li>compositor_logic is used to couple between the compositor and some code that it requires to run. A CompositorLogic class is created and registered with the CompositorManager with <a class="el" href="class_ogre_1_1_compositor_manager.html#a9c7d4168d56868599badb2789d54157c" title="Register a compositor logic for listening in to expecting composition techniques. ...">Ogre::CompositorManager::registerCompositorLogic()</a>. Which will cause the binding code to run whenever an instance of this compositor is created.</li>
<li>'Regular' compositors that don't use the GBuffer are also still possible of course, they can be used regularly, as long as they are placed after the DeferredShading/ShowLit compositor.</li>
</ul>
<h1><a class="anchor" id="realprojects"></a>
Integration in real projects</h1>
<p>The framework that this demo uses was designed to be pluggable into other projects. Some of the design considerations that contribute to that are :</p><ol type="1">
<li>The scene setup does not change in any way. You still set the scene up with normal lights and modify their parameters just like you would regularly.</li>
<li>The GBuffer scheme handler and shader generator allow existing materials to work in a deferred shading pipeline unmodified. It might not cover all the cases, but it can.</li>
<li>Easy to integrate - see next section</li>
</ol>
<h2>Integration steps</h2>
<p>The framework created for a demo fits the plugin architecture pretty well. The GBufferSchemeHandler and DeferredLightCompositionPass classes could be instantiated once on plugin setup and registered with ogre's systems. This is not the case currently just to keep the SDK build simpler.</p>
<p>So, the steps are :</p><ol type="1">
<li>Register GBufferSchemeHandler and DeferredLightCompositionPass with their respective managers.</li>
<li>Add the GBuffer and ShowLit compositors to the viewports you want deferred shaded.</li>
</ol>
<p>And thats it! In the demo, the DeferredShading class takes care of that.</p>
<h2>Adapting the framework</h2>
<p>The deferred shading framework in the demo was designed to be usable in real applications. Where would one want to modify it ?</p><ol type="1">
<li>GBufferSchemeHandler / MaterialGenerator - support more options out of the box. Skinning, specular maps, and whatever you have in your project that can be solved in a generic fashion.</li>
<li>LightMaterialGenerator - support more lighting options (fog, etc), more shadow types, different shadow techniques (currently using very basic depth shadow mapping)</li>
<li>Tweak the framework to your pipeline - The material inspection relies on naming (among other things) to decide what its looking at. Just modify it to fit your art pipeline's conventions! (For example, how does a texture get flagged as a normal map?)</li>
</ol>
<p>Indeed, it means that the framework is not 100% plug and play. But, if understood correctly, it can be adapted to real life scenarios with relative ease.</p>
<h2>Adding features to the framework</h2>
<p>Post processing compositors that rely on certain aspects of the scene (like SSAO does) are now much easier to create and integrate with the earlier processes. An example could be edge-based anti aliasing, to address the lack of anti aliasing in DX9-based deferred shading systems.</p>
<p>In addition to that, the deferred shading implementation was focused on simplicity. There are many optimization options and most of them were not done, mainly to keep the demo as simple and understandable as possible.</p>
<h1><a class="anchor" id="summary"></a>
Summary</h1>
<p>Deferred Shading is an advanced rendering technique, that brings a pretty big implementation challenge along with it. This article, along with the demo, shows that it is possible to implement without relying on hacks and bypassing ogre's systems. Yes, it involves more advanced usage of ogre's APIs and requires a bit of knowledge about what happens behind the scenes, but is in no way impossible.</p>
<h2><a class="anchor" id="further"></a>
Further reading</h2>
<ul>
<li><a href="http://www.guerrilla-games.com/publications/dr_kz2_rsx_dev07.pdf">KillZone 2 Deferred Shading overview</a> - Great resource for understanding deferred shading in general before diving into implemeting it in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>.</li>
<li><a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SoC2009+Compositor">Improving Ogre's Compositor Framework GSoC project page</a></li>
<li><a href="http://www.gamedev.net/page/reference/index.html/_//feature/fprogramming/deferred-rendering-demystified-r2746">Deferred Rendering Demystified</a> - An article written around this project that explains the design behind the deferred renderer. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping in Ogre </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non)Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams  <a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[ \begin{aligned} \left[ \begin{array}{c} u_1 w_l \\ u_2 w_l \\ u_3 w_l \\ w_l \end{array} \right] = P_l M_l \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned} \]
</p>
<p class="formulaDsp">
\[\begin{aligned} \left[ \begin{array}{c} y_1 w_c \\ y_2 w_c \\ y_3 w_c \\ w_c \end{array} \right] = P_c M_c \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<div class="image">
<object type="image/svg+xml" data="depthbias.svg">depthbias.svg</object>
<div class="caption">
Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</div></div>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direciton lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxqdu} \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxdu} \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\ \label{eqn:du3du} \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:duwdX3} \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\ \label{eqn:dudX3} \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in  <a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps  <a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community  <a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>the inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>the inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps  <a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<div class="image">
<object type="image/svg+xml" data="optfrust.svg">optfrust.svg</object>
<div class="caption">
Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</div></div>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non)Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps  <a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps  <a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div><div class="line">sceneMgr-&gt;setShadowTexturePixelFormat(<a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2da3ec4fe727d552337e02069cd9efd9">PF_FLOAT32_R</a>);</div><div class="line">sceneMgr-&gt;setShadowTechnique( <a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">SHADOWTYPE_TEXTURE_ADDITIVE</a> );</div><div class="line">sceneMgr-&gt;setShadowTextureCasterMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Caster/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureReceiverMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>); </div><div class="line">sceneMgr-&gt;setShadowTextureSize(1024);</div></div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>The <code>DepthShadowmap.material</code> script is given below:</p>
<div class="fragment"><div class="line"><span class="comment">// Generic Shadow caster material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Caster/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Generic Shadow receiver material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            texture_unit ShadowMap</div><div class="line">            {</div><div class="line">                tex_address_mode clamp</div><div class="line">                filtering none</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Specific receiver material for rockwall</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/RockWall</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// This is the preferred technique which uses both vertex and</span></div><div class="line">    <span class="comment">// fragment programs, supports coloured lights</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// Base ambient pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 1 1 1</div><div class="line">            diffuse 0 0 0 </div><div class="line">            specular 0 0 0 0 </div><div class="line">            </div><div class="line">            depth_bias -1</div><div class="line">        }</div><div class="line">        <span class="comment">// Now do the lighting pass</span></div><div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div><div class="line">        pass lighting</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 0 0 0 </div><div class="line">            </div><div class="line">            <span class="comment">// do this for each light</span></div><div class="line">            iteration once_per_light</div><div class="line"></div><div class="line">        </div><div class="line">            scene_blend add</div><div class="line">            </div><div class="line">            <span class="comment">// Vertex program reference</span></div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Fragment program</span></div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// shadowmap texture will be bound by code</span></div><div class="line"></div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Decal pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            lighting off</div><div class="line"></div><div class="line"></div><div class="line">            scene_blend dest_colour zero</div><div class="line"></div><div class="line">            depth_bias 1</div><div class="line">            </div><div class="line">            texture_unit</div><div class="line">            {</div><div class="line">                texture rockwall.tga</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> The material uses unified programs for HLSL, GLSL and GLSLES. We’ll present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform vec4 texelOffsets;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 outPos = worldViewProj * vertex;</div><div class="line">    outPos.xy += texelOffsets.zw * outPos.w;</div><div class="line">    <span class="comment">// fix pixel / texel alignment</span></div><div class="line">    depth = outPos.zw;</div><div class="line">    gl_Position = outPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> finalDepth = depth.x / depth.y;</div><div class="line"></div><div class="line">    <span class="comment">// just smear across all components </span></div><div class="line">    <span class="comment">// therefore this one needs high individual channel precision</span></div><div class="line">    gl_FragColor = vec4(finalDepth, finalDepth, finalDepth, 1.0);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Just write out the depth values here. We compute the bias and derivatives in the receiver.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 world;</div><div class="line">uniform mat4 worldIT;</div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform mat4 texViewProj;</div><div class="line">uniform vec4 lightPosition;</div><div class="line">uniform vec4 lightColour;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line">attribute vec3 normal;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    gl_Position = worldViewProj * vertex;</div><div class="line">    </div><div class="line">    vec4 worldPos = world * vertex;</div><div class="line"></div><div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div><div class="line"></div><div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div><div class="line">    vec3 lightDir = normalize(</div><div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div><div class="line"></div><div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div><div class="line"></div><div class="line">    <span class="comment">// calculate shadow map coords</span></div><div class="line">    oUv = texViewProj * worldPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div><div class="line">uniform <span class="keywordtype">float</span> fixedDepthBias;</div><div class="line">uniform <span class="keywordtype">float</span> gradientClamp;</div><div class="line">uniform <span class="keywordtype">float</span> gradientScaleBias;</div><div class="line"></div><div class="line">uniform sampler2D shadowMap;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 shadowUV = oUv;</div><div class="line">    <span class="comment">// point on shadowmap</span></div><div class="line">    shadowUV = shadowUV / shadowUV.w;</div><div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div><div class="line">    </div><div class="line">    <span class="comment">// gradient calculation</span></div><div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div><div class="line">    vec4 depths = vec4(</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, -pixeloffset)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, +pixeloffset)).x);</div><div class="line"></div><div class="line">    vec2 differences = abs( depths.yw - depths.xz );</div><div class="line">    <span class="keywordtype">float</span> gradient = min(gradientClamp, max(differences.x, differences.y));</div><div class="line">    <span class="keywordtype">float</span> gradientFactor = gradient * gradientScaleBias;</div><div class="line"></div><div class="line">    <span class="comment">// visibility function</span></div><div class="line">    <span class="keywordtype">float</span> depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);</div><div class="line">    <span class="keywordtype">float</span> finalCenterDepth = centerdepth + depthAdjust;</div><div class="line"></div><div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div><div class="line"><span class="preprocessor">#if PCF</span></div><div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div><div class="line">    depths += depthAdjust;</div><div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (finalCenterDepth &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> *= 0.2;</div><div class="line"></div><div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1);</div><div class="line">    </div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.</p>
<p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.</p>
<p>The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html">Ogre::PlaneOptimalShadowCameraSetup</a> *planeOptShadowCamera = </div><div class="line">                                <span class="keyword">new</span> PlaneOptimalShadowCameraSetup(movablePlane);</div><div class="line"><a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = sceneMgr-&gt;createEntity( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;plane.mesh&quot;</span> );</div><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = </div><div class="line">                sceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div><div class="line">movablePlaneNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div><div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(planeOptShadowCamera));</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Deferred Shading</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('deferred.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Deferred Shading </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#what">What is Deferred Shading?</a></li>
<li class="level1"><a href="#creating">Creating the G-Buffer</a></li>
<li class="level1"><a href="#lighting">Lighting the scene</a><ul><li class="level2"><a href="#lightgeom">Rendering the light geometry</a></li>
</ul>
</li>
<li class="level1"><a href="#post">Post Processing</a></li>
<li class="level1"><a href="#realprojects">Integration in real projects</a></li>
<li class="level1"><a href="#summary">Summary</a><ul><li class="level2"><a href="#further">Further reading</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>This wiki article is complementary to the deferred shading demo that is part of the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> SDK. It will reference the code quite a bit and explain some of the decisions made when implementing the deferred shading framework for the demo.</p>
<h1><a class="anchor" id="what"></a>
What is Deferred Shading?</h1>
<p>Deferred shading is an alternative approach to rendering 3d scenes. The classic rendering approach involves rendering each object and applying lighting passes to it. So, if an ogre head is affected by 6 lights, it will be rendered 6 times, once for each light, in order to accumulate the affection of each light. Deferred shading takes another approach : In the beginning, all of the objects render their "lighting related info" to a texture, often called the G-Buffer. This means their colours, normals, depths and any other info that might be relevant to calculating their final colour. Afterwards, the lights in the scene are rendered as geometry (sphere for point light, cone for spotlight and full screen quad for directional light), and they use the G-buffer to calculate the colour contribution of that light to that pixel.</p>
<p>See the links in <a class="el" href="deferred.html#further">Further reading</a> to read more about it. It is recommended to understand deferred shading before reading this article, as the article focuses on implementing it in ogre, and not explaining how it works.</p>
<h2>Deferred Shading Advantages</h2>
<p>The main reason for using deferred shading is performance related. Classing rendering (also called forward rendering) can, in the worst case, require num_objects * num_lights batches to render a scene. Deferred shading changes that to num_objects + num_lights, which can often be a lot less. Another reason is that some new post-processing effects are easily achievable using the G-Buffer as input. If you wanted to perform these effects without deferred shading, you would've had to render the whole scene again.</p>
<h2>Deferred Shading Disadvantages</h2>
<p>There are several algorithmic drawbacks with deferred shading - transparent objects are hard to handle, anti aliasing can not be used in DX9 class hardware, additional memory consumption because of the G-Buffer. In addition to that, deferred shading is harder to implement - it overrides the entire fixed function pipeline. Pretty much everything is rendered using manual shaders - which probably means a lot of shader code.</p>
<h1><a class="anchor" id="creating"></a>
Creating the G-Buffer</h1>
<p>The first part of the deferred shading pipeline involves rendering all the (non-transparent) objects of the scene to the G-Buffer. This is done using a compositor :</p>
<div class="fragment"><div class="line">compositor DeferredShading/GBuffer</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// temporary textures</span></div><div class="line">        texture mrt_output target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf91793bc9707d6541f4851722267317a">PF_FLOAT16_RGBA</a> <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf91793bc9707d6541f4851722267317a">PF_FLOAT16_RGBA</a> chain_scope</div><div class="line">        </div><div class="line">        target mrt_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line">            </div><div class="line">            shadows off</div><div class="line">            material_scheme GBuffer</div><div class="line">            </div><div class="line">            <span class="comment">// everything but the lights and their meshes</span></div><div class="line">            <span class="comment">// could do this with something like a visibility mask too</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                <span class="comment">//These values are synchronized with the code</span></div><div class="line">                first_render_queue 10</div><div class="line">                last_render_queue  79   </div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Things to note about this compositor :</p><ul>
<li>mrt_output (the GBuffer) is an MRT because there are two pixel formats defined.</li>
<li>mrt_output will be accessible to the next compositors in the chain because it is marked as chain_scope, meaning it is visible to the next compositors in the chain.</li>
<li>The material scheme tells ogre that objects shouldn't be rendered in normal fashion, but in some other way (we'll get to that soon)</li>
<li>Not all the objects are rendered to the GBuffer. Skies and 'late objects' (which can be specified manually using render queues) will be forward rendered.</li>
<li>This compositor does NOT have a target_output pass, because it does not contribute directly to the final image.</li>
</ul>
<h2>Deciding on the GBuffer format</h2>
<p>This in an important decision in deferred shading, as it has performance and visual implications.</p>
<p>Also, the entire pipeline has to be coordinated with this format - all the writing shaders have to write the same data to the same places, and all the reading shaders (for lighting later) have to be synchronized with it.</p>
<p>We chose two PF_FLOAT16_RGBA textures. The first one will contain the colour in RGB, specular intensity in A.</p>
<p>The second one will contain the view-space-normal in RGB (we keep all 3 coordinates) and the (linear) depth in A.</p>
<p>See the references for other possibilities.</p>
<h2>Preparing the objects for G-Buffer rendering</h2>
<p>The only indicator that ogre has when rendering the scene is that the material scheme is different. Material schemes in ogre allow materials to specify different rendering techniques for different scenarios. In this case, we would like to output the lighting related information instead of the lighting calculation result.</p>
<p>Materials that have a technique associated with the GBuffer scheme will render using that, but we don't want to modify the materials of all the objects in our art pipeline to use them in deferred shading.</p>
<p>The solution is to use scheme listeners! The material manager has a method for registering listeners when objects don't have a technique defined for the current scheme: <a class="el" href="class_ogre_1_1_material_manager.html#a8ac18f4bd2e6302f1d92ae8f64195694" title="Add a listener to handle material events. ">Ogre::MaterialManager::addListener()</a>.</p>
<p>The listener has a callback method that gets called whenever an object is about to be rendered without a matching technique: <a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html#a54bc384ab1102063aa00db4c3a5f3fc4" title="Called if a technique for a given scheme is not found within a material, allows the application to sp...">Ogre::MaterialManager::Listener::handleSchemeNotFound()</a>.</p>
<p>We will implement such a listener for the GBuffer scheme. It is GBufferSchemeHandler from the demo. The GBufferSchemeHandlers works like this :</p>
<h3>Inspect the classic technique</h3>
<p>For each pass in the technique that would have been used normally, the GBufferSchemeHandler::inspectPass is called, inspects the pass, and returns the PassProperties - does this pass have a texture? a normal map? is it skinned? tranpsarent? Etc. The PassProperties (should) contain all the information required to build a GBuffer technique for an object.</p>
<h3>Generate the G-Buffer technique</h3>
<p>After a pass has been inspected and understood, the next stage is to generate the G-Buffer-writing technique. This is done using the class GBufferMaterialGenerator. The class receives the flags of the features needed by the material, and dynamically generates the (CG) shaders and material to render an object with those properties to the G-Buffer. This greatly reduces the number of shaders that you need to manage when using deferred shading, as most of them are created on the fly. Here is an example of what they look like :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ToGBufferVP(</div><div class="line">         float4 iPosition : POSITION,</div><div class="line">         float3 iNormal   : NORMAL,</div><div class="line">         float2 iUV0 : TEXCOORD0,</div><div class="line"></div><div class="line">         out float4 oPosition : POSITION,</div><div class="line">         out float3 oViewPos : TEXCOORD0,</div><div class="line">         out float3 oNormal : TEXCOORD1,</div><div class="line">         out float2 oUV0 : TEXCOORD2,</div><div class="line"></div><div class="line">         uniform float4x4 cWorldViewProj,</div><div class="line">         uniform float4x4 cWorldView</div><div class="line">         )</div><div class="line"> {</div><div class="line">         oPosition = mul(cWorldViewProj, iPosition);</div><div class="line">         oNormal = mul(cWorldView, float4(iNormal,0)).xyz;</div><div class="line">         oViewPos = mul(cWorldView, iPosition).xyz;</div><div class="line">         oUV0 = iUV0;</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keywordtype">void</span> ToGBufferFP(</div><div class="line">         float3 iViewPos : TEXCOORD0,</div><div class="line">         float3 iNormal   : TEXCOORD1,</div><div class="line">         float3 iTangent : TEXCOORD2,</div><div class="line">         float3 iBiNormal : TEXCOORD3,</div><div class="line">         float2 iUV0 : TEXCOORD4,</div><div class="line"></div><div class="line">         out float4 oColor0 : COLOR0,</div><div class="line">         out float4 oColor1 : COLOR1,</div><div class="line"></div><div class="line">         uniform sampler sNormalMap : <span class="keyword">register</span>(s0),</div><div class="line">         uniform sampler sTex0 : <span class="keyword">register</span>(s1),</div><div class="line">         uniform float4 cDiffuseColour,</div><div class="line">         uniform <span class="keywordtype">float</span> cFarDistance,</div><div class="line">         uniform <span class="keywordtype">float</span> cSpecularity</div><div class="line">         )</div><div class="line"> {</div><div class="line">         oColor0.rgb = tex2D(sTex0, iUV0);</div><div class="line">         oColor0.rgb *= cDiffuseColour.rgb;</div><div class="line">         oColor0.a = cSpecularity;</div><div class="line">         float3 texNormal = (tex2D(sNormalMap, iUV0)-0.5)*2;</div><div class="line">         float3x3 normalRotation = float3x3(iTangent, iBiNormal, iNormal);</div><div class="line">         oColor1.rgb = normalize(mul(texNormal, normalRotation));</div><div class="line">         oColor1.a = length(iViewPos) / cFarDistance;</div><div class="line"> }</div></div><!-- fragment --><p> (This is for an object with a texture and a normal map)</p>
<h3>Add the G-Buffer technique to the original material</h3>
<p>We don't want to inspect the passes and generate the material each time an object is rendered, so we create a technique in the original material, and fill it with the auto-generated information. After copying the information from the GBuffer technique, texture references have to be updated, to use the correct textures when rendering the object. This happens in <code>GBufferSchemeHandler::fillPass</code>. The next time the object will be rendered, it WILL have a technique for the GBuffer scheme, so the listener won't get called.</p>
<h3>Postponing transparent objects</h3>
<p>We don't want to render transparent objects to the GBuffer, as it doesn't work properly later.</p>
<p>To address this, we also create a technique with a scheme called called 'NoGBuffer'. If the inspectPass decided that the object is transparent, we will not add an auto-generated pass to the 'GBuffer' technique, but instead copy the regular pass to the 'NoGBuffer' technique, to render it regularly later.</p>
<h3>Putting it all together</h3>
<p>This is how <code>GBufferSchemeHandler::handleSchemeNotFound</code> works:</p>
<div class="fragment"><div class="line">Technique* GBufferSchemeHandler::handleSchemeNotFound(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> schemeIndex, </div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; schemeName, Material* originalMaterial, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> lodIndex, </div><div class="line">        <span class="keyword">const</span> Renderable* rend)</div><div class="line">{</div><div class="line">    <a class="code" href="class_ogre_1_1_material_manager.html">Ogre::MaterialManager</a>&amp; matMgr = <a class="code" href="class_ogre_1_1_material_manager.html#a100f413d9d2316028e7ae740e5a43161">Ogre::MaterialManager::getSingleton</a>();</div><div class="line">    <a class="code" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> curSchemeName = matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#ad03ea02e140fc1e7312d14626e59d45d">getActiveScheme</a>();</div><div class="line">    matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0">setActiveScheme</a>(MaterialManager::DEFAULT_SCHEME_NAME);</div><div class="line">    Technique* originalTechnique = originalMaterial-&gt;getBestTechnique(lodIndex, rend);</div><div class="line">    matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0">setActiveScheme</a>(curSchemeName);</div><div class="line"></div><div class="line">    Technique* gBufferTech = originalMaterial-&gt;createTechnique();</div><div class="line">    gBufferTech-&gt;removeAllPasses();</div><div class="line">    gBufferTech-&gt;setSchemeName(schemeName);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef OGRE_BUILD_COMPONENT_RTSHADERSYSTEM</span></div><div class="line">    RTShader::ShaderGenerator&amp; rtShaderGen = RTShader::ShaderGenerator::getSingleton();</div><div class="line">    rtShaderGen.createShaderBasedTechnique(*originalMaterial, originalTechnique-&gt;getSchemeName(), <span class="stringliteral">&quot;NoGBuffer&quot;</span>);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    Technique* noGBufferTech = originalMaterial-&gt;createTechnique();</div><div class="line">    noGBufferTech-&gt;removeAllPasses();</div><div class="line">    noGBufferTech-&gt;setSchemeName(<span class="stringliteral">&quot;NoGBuffer&quot;</span>);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i=0; i&lt;originalTechnique-&gt;getNumPasses(); i++)</div><div class="line">    {</div><div class="line">        Pass* originalPass = originalTechnique-&gt;getPass(i);</div><div class="line">        PassProperties props = inspectPass(originalPass, lodIndex, rend);</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (!props.isDeferred)</div><div class="line">        {</div><div class="line"><span class="preprocessor">#ifdef OGRE_BUILD_COMPONENT_RTSHADERSYSTEM</span></div><div class="line">            rtShaderGen.validateMaterial(<span class="stringliteral">&quot;NoGBuffer&quot;</span>, originalMaterial-&gt;getName(), originalMaterial-&gt;getGroup());</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">            <span class="comment">//Just copy the technique so it gets rendered regularly</span></div><div class="line">            Pass* clonePass = noGBufferTech-&gt;createPass();</div><div class="line">            *clonePass = *originalPass;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        Pass* newPass = gBufferTech-&gt;createPass();</div><div class="line">        MaterialGenerator::Perm perm = getPermutation(props);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::MaterialPtr</a>&amp; templateMat = mMaterialGenerator.getMaterial(perm);</div><div class="line">        </div><div class="line">        <span class="comment">//We assume that the GBuffer technique contains only one pass. But its true.</span></div><div class="line">        *newPass = *(templateMat-&gt;<a class="code" href="class_ogre_1_1_material.html#abc82b3c4963c8d3cd04c93fdc6dbf416">getTechnique</a>(0)-&gt;<a class="code" href="class_ogre_1_1_technique.html#a3ce84da25bb6b5762af714adaf70874a">getPass</a>(0));</div><div class="line">        fillPass(newPass, originalPass, props);    </div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> gBufferTech;</div><div class="line">}</div></div><!-- fragment --> <h2>Overriding the automatic process</h2>
<p>In some cases the automatic material generation will not be good enough. We want to keep the option of manually writing GBuffer materials and shaders.</p>
<p>How do we do this? Easily! Since GBufferSchemeHandler::handleSchemeNotFound only gets called when an object doesn't already have a GBuffer scheme, adding a 'GBuffer' technique to the material will cause it to not get passed to the listener even once.</p>
<h2>Seeing it in action</h2>
<p>Using tools like NVIDIA's PerfHUD, we can see the texture being built during the frame :</p>
<div class="image">
<img src="GBufferPerfHUD.PNG" alt="GBufferPerfHUD.PNG"/>
</div>
<p>Note that nothing has been written to the final output yet (main view is completely black) and that two textures are being written to (see right hand side).</p>
<h1><a class="anchor" id="lighting"></a>
Lighting the scene</h1>
<p>In the GBuffer compositor, we built the G-Buffer for the current frame. It is now the time to use it to calculate the final lighting of the scene. This is what the compositor looks like :</p>
<div class="fragment"><div class="line">compositor DeferredShading/ShowLit</div><div class="line">{</div><div class="line"></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">//Reference the main Gbuffer texture</span></div><div class="line">        texture_ref mrt_output DeferredShading/GBuffer mrt_output</div><div class="line">        </div><div class="line">        target_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line">            <span class="comment">//We will dispatch the shadow texture rendering ourselves</span></div><div class="line">            shadows off</div><div class="line">            </div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">                </div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">// render skies and other pre-gbuffer objects</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                first_render_queue 1</div><div class="line">                last_render_queue  9            </div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the lights and their meshes</span></div><div class="line">            pass render_custom DeferredLight</div><div class="line">            {</div><div class="line">                input 0 mrt_output 0</div><div class="line">                input 1 mrt_output 1</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the objects that skipped rendering into the gbuffer</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                material_scheme NoGBuffer</div><div class="line">                first_render_queue 10</div><div class="line">                last_render_queue 79</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the post-GBuffer render queue objects</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                <span class="comment">//This value is synchronized with the code</span></div><div class="line">                first_render_queue 80</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Yes, it's a long one. Here is a breakdown of the compositor :</p><ul>
<li>The 'texture_ref' definition means that we are referencing a texture from another compositor. In the case of a chain-scoped texture (like the GBuffer), this means that we can only apply this compositor on chains that have the GBuffer creating compositor earlier in the chain than this one. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will check that this is the case.</li>
</ul>
<p>There are four target passes in this compositor.</p><ol type="1">
<li>Render the skies and then the lights using the render_custom directive (more on this later)</li>
<li>Render the objects that are in the GBuffer render queues but didn't get rendered to the GBuffer</li>
<li>Render the post-GBuffer render queue objects</li>
<li>Output the result</li>
</ol>
<h3>Why do we need four target passes ?</h3>
<p>This is mainly a limitation of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Ideally, we could use a single target_output pass and do all the passes there. The problem is that material_scheme is at the target scope and not at the pass scope. This is hard to change, because material schemes are resolved during scene preparing time and not during scene rendering. So even if the scope would change, it would not affect the rendering, as the material scheme will not get tested after we switch to it. Perhaps this will be addressed, and then this compositor will get simplified.</p>
<h2><a class="anchor" id="lightgeom"></a>
Rendering the light geometry</h2>
<p>The geometry that we want to render to calculate lighting information doesn't really fit in any classic category. It is not really a part of the scene, as the light geometry aren't objects in the world. But it is geometry (not always a quad) that needs to be rendered.</p>
<p>For these kind of operations, the render_custom target pass was introduced into <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. It is possible to register custom (named) composition passes that will be performed in the compositor. In this case, it is 'DeferredLight'. The composition pass will receive a call each frame telling it 'it's your turn, do your thing'. The class in the demo is DeferredLightCP.</p>
<p>The registration of the custom composition pass has to be done once, using <a class="el" href="class_ogre_1_1_compositor_manager.html#ae9b8ca4c2a51c0720bb31393d20fe7c9" title="Register a custom composition pass. ">Ogre::CompositorManager::registerCustomCompositionPass()</a>.</p>
<p>CustomCompositionPass is essentially just a factory for RenderSystemOperations, which are the operations that get executed during a compositor chain. This is the single API call: <a class="el" href="class_ogre_1_1_custom_composition_pass.html#a6b8c7a3743f9bb44e27c0348a0035e7b" title="Create a custom composition operation. ">Ogre::CustomCompositionPass::createOperation()</a>.</p>
<p>So, now we get called exactly when we want, after the G-Buffer has been built and the (early) skies have been rendered. What will we do?</p>
<h3>Prepare ambient colour and rebuild original depth buffer</h3>
<p>Since we rendered the original scene to a different RTT, the depth buffer won't necessarily get reused for the output target, so we need to rebuild it so that future objects (lights and non-g-buffer objects) will be able to interact with the depth naturally.</p>
<p>Also, we need to apply the ambient light to the scene. For the purpose of the demo, the ambient light is not a separate colour channel, just the object's original textures applied with the scene's global ambient light factor. In theory, you could set up a different G-Buffer to allow more flexibility, but we didn't do that.</p>
<p>These two actions happen in a single full-screen quad render, that comes from the AmbientLight class.</p>
<h3>Render the light geometries</h3>
<p>The most important stage is the light geometry. The code scans the original scene's lights, builds a matching DLight (deferred light) instance for each light in the scene, and renders away using the G-Buffer.</p>
<p>These lights use pretty sophisticated shaders, since they perform the lighting calculations of the fixed function pipeline themselves, and have to account for many options (specularity, attenuation, different light types and shadows, which will get talked about soon). In contrast to the G-Buffer building stage, the shaders here do not get generated on the fly. There is one big shader (sometimes referred to as an Uber-Shader) with many preprocessor options that account for all the options. (See LightMaterial_ps.cg) Note that the shaders have to be synchronized with the G-Buffer layout. A change in the layout would need a parallel change in the deferred lighting shaders.</p>
<p>The material generator for this section (LightMaterialGenerator class) just scans the flags of input and generates the correct preprocessor defines for the uber-shader. Some people prefer to use this approach for the G-Buffer stage as well, but I wanted to show both options in the demo.</p>
<p>In order to dispatch render operations manually, the following call exists in SceneManager: <a class="el" href="class_ogre_1_1_scene_manager.html#a1593fab748d1b0820e93e49d5732350b" title="Render something as if it came from the current queue. ">Ogre::SceneManager::_injectRenderWithPass()</a>.</p>
<p>When rendering a light, we pass the light we are rendering as the manual light list in order to have the auto params for that light available in the shader.</p>
<h3>Rendering shadow casting lights</h3>
<p>The 'classic' approach to rendering texture shadows is to prepare all of them before the scene rendering starts, and then apply them to the rendered objects using shadow receiver passes or integrated shaders. The downside of this approach is that you need to allocate a texture per-light (5 shadow casting lights -&gt; 5 shadow textures) and that if you don't integrate it in your shaders you also contribute even more passes to the scene.</p>
<p>One of the advantages of deferred shading is that we render the lights completely, and one by one. So, we can generate the shadow texture for a light just before the light's geometry is rendered, allowing us to reuse the same texture for as many lights as we want. (We still have an overhead of rendering the scene from the light's perspective per-light).</p>
<p>The API call that prepares shadow textures on demand is <a class="el" href="class_ogre_1_1_scene_manager.html#a95cd8ff86a7178c2e37b2fcb485f64fa" title="Method for preparing shadow textures ready for use in a regular render Do not call manually unless be...">Ogre::SceneManager::prepareShadowTextures()</a>. The lightList parameter allows specification of which lights to prepare shadow textures for.</p>
<p>Important note - RenderSystemOperations get executed in the middle of scene rendering. This means that there is an active render target being rendered to. In order to render the shadow texture we need to be able to pause rendering mid frame, render the shadow texture, and resume rendering immediately afterwards. For this, SceneManager has two methods that do just that <a class="el" href="class_ogre_1_1_scene_manager.html#a90d0e7484ed4580ec980eef15808bfee" title="Pause rendering of the frame. ">Ogre::SceneManager::_pauseRendering()</a> and <a class="el" href="class_ogre_1_1_scene_manager.html#a794e03ea25dd798346414c1dba31337d" title="Resume rendering of the frame. ">Ogre::SceneManager::_resumeRendering()</a>, so the prepareShadowTextures call has to be inside this.</p>
<p>The demo currently supports just spotlight shadow casting (since it is the cheapest to implement) but the other options can be supported as well.</p>
<h3>Putting it all together</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DeferredLightRenderOperation::execute(SceneManager *sm, RenderSystem *rs)</div><div class="line">{</div><div class="line">    <a class="code" href="class_ogre_1_1_camera.html">Ogre::Camera</a>* cam = mViewport-&gt;getCamera();</div><div class="line"></div><div class="line">    mAmbientLight-&gt;updateFromCamera(cam);</div><div class="line">    Technique* tech = mAmbientLight-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a2a54dff8ade9ab6838c1517062f0eb98">getMaterial</a>()-&gt;<a class="code" href="class_ogre_1_1_material.html#a37ae7259ce89bdc38828ea1b977bdbcf">getBestTechnique</a>();</div><div class="line">    injectTechnique(sm, tech, mAmbientLight, 0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group___general.html#gaab30ef14aae93306a6044cb38d835f0c">LightList</a>&amp; lightList = sm-&gt;_getLightsAffectingFrustum();</div><div class="line">    <span class="keywordflow">for</span> (LightList::const_iterator it = lightList.begin(); it != lightList.end(); it++) </div><div class="line">    {</div><div class="line">        Light* light = *it;</div><div class="line">        <a class="code" href="class_ogre_1_1_hashed_vector.html">Ogre::LightList</a> ll;</div><div class="line">        ll.<a class="code" href="class_ogre_1_1_hashed_vector.html#a87bfcde773502ee964a677580724188f">push_back</a>(light);</div><div class="line"></div><div class="line">        <span class="comment">//if (++i != 2) continue;</span></div><div class="line">        <span class="comment">//if (light-&gt;getType() != Light::LT_DIRECTIONAL) continue;</span></div><div class="line">        <span class="comment">//if (light-&gt;getDiffuseColour() != ColourValue::Red) continue;</span></div><div class="line"></div><div class="line">        LightsMap::iterator dLightIt = mLights.find(light);</div><div class="line">        DLight* dLight = 0;</div><div class="line">        <span class="keywordflow">if</span> (dLightIt == mLights.end()) </div><div class="line">        {</div><div class="line">            dLight = createDLight(light);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> </div><div class="line">        {</div><div class="line">            dLight = dLightIt-&gt;second;</div><div class="line">            dLight-&gt;updateFromParent();</div><div class="line">        }</div><div class="line">        dLight-&gt;updateFromCamera(cam);</div><div class="line">        tech = dLight-&gt;getMaterial()-&gt;getBestTechnique();</div><div class="line"></div><div class="line">        <span class="comment">//Update shadow texture</span></div><div class="line">        <span class="keywordflow">if</span> (dLight-&gt;getCastChadows())</div><div class="line">        {</div><div class="line">            SceneManager::RenderContext* context = sm-&gt;_pauseRendering();</div><div class="line"></div><div class="line">            sm-&gt;prepareShadowTextures(cam, mViewport, &amp;ll);</div><div class="line">            sm-&gt;_resumeRendering(context);</div><div class="line">            </div><div class="line">            Pass* pass = tech-&gt;getPass(0);</div><div class="line">            TextureUnitState* tus = pass-&gt;getTextureUnitState(<span class="stringliteral">&quot;ShadowMap&quot;</span>);</div><div class="line">            assert(tus);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a>&amp; shadowTex = sm-&gt;getShadowTexture(0);</div><div class="line">            <span class="keywordflow">if</span> (tus-&gt;_getTexturePtr() != shadowTex)</div><div class="line">            {</div><div class="line">                tus-&gt;_setTexturePtr(shadowTex);</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">        </div><div class="line">        injectTechnique(sm, tech, dLight, &amp;ll);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h3>Seeing it in action</h3>
<p>Here is a screenshot from PerfHUD of the draw call that renders a spotlight that casts shadows. See the two G-Buffer textures and one shadow texture on the left :</p>
<div class="image">
<img src="DeferredCone1.PNG" alt="DeferredCone1.PNG"/>
</div>
<p>Here is a visualization of the texture being built :</p>
<div class="image">
<img src="DeferredCone2.PNG" alt="DeferredCone2.PNG"/>
</div>
<p>After all the lights are rendered, the scene is fully lit!</p>
<h1><a class="anchor" id="post"></a>
Post Processing</h1>
<p>The compositor framework used to be a post processing framework, but as this article shows - it is now a 'custom render pipeline' framework, allowing different rendering approaches. However, it can still be used to post process the scene, even under deferred rendering.</p>
<h2>Screen Space Ambient Occlusion</h2>
<p>'Screen Space Ambient Occlusion' is a global illumination technique that adds a bit of realism to the scene, where classic lighting often fails. However, it requires the normals and depths of the scene in order to calculate its contribution. Normally, the SSAO compositor would have a render_scene directive that does that.</p>
<p>However, with deferred shading, we already have that information from the G-Buffer stage, so we just need to access it!</p>
<p>This is what the compositor looks like :</p>
<div class="fragment"><div class="line">compositor DeferredShading/SSAO</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        compositor_logic SSAOLogic</div><div class="line">        </div><div class="line">        texture_ref geom DeferredShading/GBuffer mrt_output</div><div class="line">        texture scene target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca74ea3b1c0c5f4ae06b1a7136c5523eca">PF_R8G8B8A8</a></div><div class="line">        texture ssao target_width_scaled 0.5 target_height_scaled 0.5 <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line">        texture ssaoBlurX target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line">        texture ssaoBlurY target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line"></div><div class="line">        <span class="comment">// the scene we want to modulate</span></div><div class="line">        target scene</div><div class="line">        {</div><div class="line">            input previous</div><div class="line">        }</div><div class="line"></div><div class="line">        </div><div class="line"></div><div class="line">        target ssao</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                <span class="comment">// our SSAO listener number</span></div><div class="line">                identifier 42</div><div class="line"></div><div class="line">                material ssao</div><div class="line">                <span class="comment">// pass in the &quot;geometry map&quot;</span></div><div class="line">                input 0 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        target ssaoBlurX</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                identifier 43</div><div class="line"></div><div class="line">                material ssaoBlurX</div><div class="line">                input 0 ssao</div><div class="line">                input 1 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        target ssaoBlurY</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                identifier 43</div><div class="line"></div><div class="line">                material ssaoBlurY</div><div class="line">                input 0 ssaoBlurX</div><div class="line">                input 1 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        target_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                <span class="comment">// just output something, for example, use a modulate</span></div><div class="line">                <span class="comment">// material to just multiply the scene by the ssao</span></div><div class="line">                material modulate</div><div class="line">                input 0 scene</div><div class="line">                input 1 ssaoBlurY</div><div class="line">                <span class="comment">//input 1 ssao</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Some notes :</p><ul>
<li>Again, texture_ref is used to access a chain_scoped texture from the GBuffer compositor</li>
<li>compositor_logic is used to couple between the compositor and some code that it requires to run. A CompositorLogic class is created and registered with the CompositorManager with <a class="el" href="class_ogre_1_1_compositor_manager.html#a9c7d4168d56868599badb2789d54157c" title="Register a compositor logic for listening in to expecting composition techniques. ...">Ogre::CompositorManager::registerCompositorLogic()</a>. Which will cause the binding code to run whenever an instance of this compositor is created.</li>
<li>'Regular' compositors that don't use the GBuffer are also still possible of course, they can be used regularly, as long as they are placed after the DeferredShading/ShowLit compositor.</li>
</ul>
<h1><a class="anchor" id="realprojects"></a>
Integration in real projects</h1>
<p>The framework that this demo uses was designed to be pluggable into other projects. Some of the design considerations that contribute to that are :</p><ol type="1">
<li>The scene setup does not change in any way. You still set the scene up with normal lights and modify their parameters just like you would regularly.</li>
<li>The GBuffer scheme handler and shader generator allow existing materials to work in a deferred shading pipeline unmodified. It might not cover all the cases, but it can.</li>
<li>Easy to integrate - see next section</li>
</ol>
<h2>Integration steps</h2>
<p>The framework created for a demo fits the plugin architecture pretty well. The GBufferSchemeHandler and DeferredLightCompositionPass classes could be instantiated once on plugin setup and registered with ogre's systems. This is not the case currently just to keep the SDK build simpler.</p>
<p>So, the steps are :</p><ol type="1">
<li>Register GBufferSchemeHandler and DeferredLightCompositionPass with their respective managers.</li>
<li>Add the GBuffer and ShowLit compositors to the viewports you want deferred shaded.</li>
</ol>
<p>And thats it! In the demo, the DeferredShading class takes care of that.</p>
<h2>Adapting the framework</h2>
<p>The deferred shading framework in the demo was designed to be usable in real applications. Where would one want to modify it ?</p><ol type="1">
<li>GBufferSchemeHandler / MaterialGenerator - support more options out of the box. Skinning, specular maps, and whatever you have in your project that can be solved in a generic fashion.</li>
<li>LightMaterialGenerator - support more lighting options (fog, etc), more shadow types, different shadow techniques (currently using very basic depth shadow mapping)</li>
<li>Tweak the framework to your pipeline - The material inspection relies on naming (among other things) to decide what its looking at. Just modify it to fit your art pipeline's conventions! (For example, how does a texture get flagged as a normal map?)</li>
</ol>
<p>Indeed, it means that the framework is not 100% plug and play. But, if understood correctly, it can be adapted to real life scenarios with relative ease.</p>
<h2>Adding features to the framework</h2>
<p>Post processing compositors that rely on certain aspects of the scene (like SSAO does) are now much easier to create and integrate with the earlier processes. An example could be edge-based anti aliasing, to address the lack of anti aliasing in DX9-based deferred shading systems.</p>
<p>In addition to that, the deferred shading implementation was focused on simplicity. There are many optimization options and most of them were not done, mainly to keep the demo as simple and understandable as possible.</p>
<h1><a class="anchor" id="summary"></a>
Summary</h1>
<p>Deferred Shading is an advanced rendering technique, that brings a pretty big implementation challenge along with it. This article, along with the demo, shows that it is possible to implement without relying on hacks and bypassing ogre's systems. Yes, it involves more advanced usage of ogre's APIs and requires a bit of knowledge about what happens behind the scenes, but is in no way impossible.</p>
<h2><a class="anchor" id="further"></a>
Further reading</h2>
<ul>
<li><a href="http://www.guerrilla-games.com/publications/dr_kz2_rsx_dev07.pdf">KillZone 2 Deferred Shading overview</a> - Great resource for understanding deferred shading in general before diving into implemeting it in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>.</li>
<li><a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SoC2009+Compositor">Improving Ogre's Compositor Framework GSoC project page</a></li>
<li><a href="http://www.gamedev.net/page/reference/index.html/_//feature/fprogramming/deferred-rendering-demystified-r2746">Deferred Rendering Demystified</a> - An article written around this project that explains the design behind the deferred renderer. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Deferred Shading</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('deferred.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Deferred Shading </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#what">What is Deferred Shading?</a></li>
<li class="level1"><a href="#creating">Creating the G-Buffer</a></li>
<li class="level1"><a href="#lighting">Lighting the scene</a><ul><li class="level2"><a href="#lightgeom">Rendering the light geometry</a></li>
</ul>
</li>
<li class="level1"><a href="#post">Post Processing</a></li>
<li class="level1"><a href="#realprojects">Integration in real projects</a></li>
<li class="level1"><a href="#summary">Summary</a><ul><li class="level2"><a href="#further">Further reading</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>This wiki article is complementary to the deferred shading demo that is part of the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> SDK. It will reference the code quite a bit and explain some of the decisions made when implementing the deferred shading framework for the demo.</p>
<h1><a class="anchor" id="what"></a>
What is Deferred Shading?</h1>
<p>Deferred shading is an alternative approach to rendering 3d scenes. The classic rendering approach involves rendering each object and applying lighting passes to it. So, if an ogre head is affected by 6 lights, it will be rendered 6 times, once for each light, in order to accumulate the affection of each light. Deferred shading takes another approach : In the beginning, all of the objects render their "lighting related info" to a texture, often called the G-Buffer. This means their colours, normals, depths and any other info that might be relevant to calculating their final colour. Afterwards, the lights in the scene are rendered as geometry (sphere for point light, cone for spotlight and full screen quad for directional light), and they use the G-buffer to calculate the colour contribution of that light to that pixel.</p>
<p>See the links in <a class="el" href="deferred.html#further">Further reading</a> to read more about it. It is recommended to understand deferred shading before reading this article, as the article focuses on implementing it in ogre, and not explaining how it works.</p>
<h2>Deferred Shading Advantages</h2>
<p>The main reason for using deferred shading is performance related. Classing rendering (also called forward rendering) can, in the worst case, require num_objects * num_lights batches to render a scene. Deferred shading changes that to num_objects + num_lights, which can often be a lot less. Another reason is that some new post-processing effects are easily achievable using the G-Buffer as input. If you wanted to perform these effects without deferred shading, you would've had to render the whole scene again.</p>
<h2>Deferred Shading Disadvantages</h2>
<p>There are several algorithmic drawbacks with deferred shading - transparent objects are hard to handle, anti aliasing can not be used in DX9 class hardware, additional memory consumption because of the G-Buffer. In addition to that, deferred shading is harder to implement - it overrides the entire fixed function pipeline. Pretty much everything is rendered using manual shaders - which probably means a lot of shader code.</p>
<h1><a class="anchor" id="creating"></a>
Creating the G-Buffer</h1>
<p>The first part of the deferred shading pipeline involves rendering all the (non-transparent) objects of the scene to the G-Buffer. This is done using a compositor :</p>
<div class="fragment"><div class="line">compositor DeferredShading/GBuffer</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// temporary textures</span></div><div class="line">        texture mrt_output target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf91793bc9707d6541f4851722267317a">PF_FLOAT16_RGBA</a> <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf91793bc9707d6541f4851722267317a">PF_FLOAT16_RGBA</a> chain_scope</div><div class="line">        </div><div class="line">        target mrt_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line">            </div><div class="line">            shadows off</div><div class="line">            material_scheme GBuffer</div><div class="line">            </div><div class="line">            <span class="comment">// everything but the lights and their meshes</span></div><div class="line">            <span class="comment">// could do this with something like a visibility mask too</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                <span class="comment">//These values are synchronized with the code</span></div><div class="line">                first_render_queue 10</div><div class="line">                last_render_queue  79   </div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Things to note about this compositor :</p><ul>
<li>mrt_output (the GBuffer) is an MRT because there are two pixel formats defined.</li>
<li>mrt_output will be accessible to the next compositors in the chain because it is marked as chain_scope, meaning it is visible to the next compositors in the chain.</li>
<li>The material scheme tells ogre that objects shouldn't be rendered in normal fashion, but in some other way (we'll get to that soon)</li>
<li>Not all the objects are rendered to the GBuffer. Skies and 'late objects' (which can be specified manually using render queues) will be forward rendered.</li>
<li>This compositor does NOT have a target_output pass, because it does not contribute directly to the final image.</li>
</ul>
<h2>Deciding on the GBuffer format</h2>
<p>This in an important decision in deferred shading, as it has performance and visual implications.</p>
<p>Also, the entire pipeline has to be coordinated with this format - all the writing shaders have to write the same data to the same places, and all the reading shaders (for lighting later) have to be synchronized with it.</p>
<p>We chose two PF_FLOAT16_RGBA textures. The first one will contain the colour in RGB, specular intensity in A.</p>
<p>The second one will contain the view-space-normal in RGB (we keep all 3 coordinates) and the (linear) depth in A.</p>
<p>See the references for other possibilities.</p>
<h2>Preparing the objects for G-Buffer rendering</h2>
<p>The only indicator that ogre has when rendering the scene is that the material scheme is different. Material schemes in ogre allow materials to specify different rendering techniques for different scenarios. In this case, we would like to output the lighting related information instead of the lighting calculation result.</p>
<p>Materials that have a technique associated with the GBuffer scheme will render using that, but we don't want to modify the materials of all the objects in our art pipeline to use them in deferred shading.</p>
<p>The solution is to use scheme listeners! The material manager has a method for registering listeners when objects don't have a technique defined for the current scheme: <a class="el" href="class_ogre_1_1_material_manager.html#a8ac18f4bd2e6302f1d92ae8f64195694" title="Add a listener to handle material events. ">Ogre::MaterialManager::addListener()</a>.</p>
<p>The listener has a callback method that gets called whenever an object is about to be rendered without a matching technique: <a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html#a54bc384ab1102063aa00db4c3a5f3fc4" title="Called if a technique for a given scheme is not found within a material, allows the application to sp...">Ogre::MaterialManager::Listener::handleSchemeNotFound()</a>.</p>
<p>We will implement such a listener for the GBuffer scheme. It is GBufferSchemeHandler from the demo. The GBufferSchemeHandlers works like this :</p>
<h3>Inspect the classic technique</h3>
<p>For each pass in the technique that would have been used normally, the GBufferSchemeHandler::inspectPass is called, inspects the pass, and returns the PassProperties - does this pass have a texture? a normal map? is it skinned? tranpsarent? Etc. The PassProperties (should) contain all the information required to build a GBuffer technique for an object.</p>
<h3>Generate the G-Buffer technique</h3>
<p>After a pass has been inspected and understood, the next stage is to generate the G-Buffer-writing technique. This is done using the class GBufferMaterialGenerator. The class receives the flags of the features needed by the material, and dynamically generates the (CG) shaders and material to render an object with those properties to the G-Buffer. This greatly reduces the number of shaders that you need to manage when using deferred shading, as most of them are created on the fly. Here is an example of what they look like :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ToGBufferVP(</div><div class="line">         float4 iPosition : POSITION,</div><div class="line">         float3 iNormal   : NORMAL,</div><div class="line">         float2 iUV0 : TEXCOORD0,</div><div class="line"></div><div class="line">         out float4 oPosition : POSITION,</div><div class="line">         out float3 oViewPos : TEXCOORD0,</div><div class="line">         out float3 oNormal : TEXCOORD1,</div><div class="line">         out float2 oUV0 : TEXCOORD2,</div><div class="line"></div><div class="line">         uniform float4x4 cWorldViewProj,</div><div class="line">         uniform float4x4 cWorldView</div><div class="line">         )</div><div class="line"> {</div><div class="line">         oPosition = mul(cWorldViewProj, iPosition);</div><div class="line">         oNormal = mul(cWorldView, float4(iNormal,0)).xyz;</div><div class="line">         oViewPos = mul(cWorldView, iPosition).xyz;</div><div class="line">         oUV0 = iUV0;</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keywordtype">void</span> ToGBufferFP(</div><div class="line">         float3 iViewPos : TEXCOORD0,</div><div class="line">         float3 iNormal   : TEXCOORD1,</div><div class="line">         float3 iTangent : TEXCOORD2,</div><div class="line">         float3 iBiNormal : TEXCOORD3,</div><div class="line">         float2 iUV0 : TEXCOORD4,</div><div class="line"></div><div class="line">         out float4 oColor0 : COLOR0,</div><div class="line">         out float4 oColor1 : COLOR1,</div><div class="line"></div><div class="line">         uniform sampler sNormalMap : <span class="keyword">register</span>(s0),</div><div class="line">         uniform sampler sTex0 : <span class="keyword">register</span>(s1),</div><div class="line">         uniform float4 cDiffuseColour,</div><div class="line">         uniform <span class="keywordtype">float</span> cFarDistance,</div><div class="line">         uniform <span class="keywordtype">float</span> cSpecularity</div><div class="line">         )</div><div class="line"> {</div><div class="line">         oColor0.rgb = tex2D(sTex0, iUV0);</div><div class="line">         oColor0.rgb *= cDiffuseColour.rgb;</div><div class="line">         oColor0.a = cSpecularity;</div><div class="line">         float3 texNormal = (tex2D(sNormalMap, iUV0)-0.5)*2;</div><div class="line">         float3x3 normalRotation = float3x3(iTangent, iBiNormal, iNormal);</div><div class="line">         oColor1.rgb = normalize(mul(texNormal, normalRotation));</div><div class="line">         oColor1.a = length(iViewPos) / cFarDistance;</div><div class="line"> }</div></div><!-- fragment --><p> (This is for an object with a texture and a normal map)</p>
<h3>Add the G-Buffer technique to the original material</h3>
<p>We don't want to inspect the passes and generate the material each time an object is rendered, so we create a technique in the original material, and fill it with the auto-generated information. After copying the information from the GBuffer technique, texture references have to be updated, to use the correct textures when rendering the object. This happens in <code>GBufferSchemeHandler::fillPass</code>. The next time the object will be rendered, it WILL have a technique for the GBuffer scheme, so the listener won't get called.</p>
<h3>Postponing transparent objects</h3>
<p>We don't want to render transparent objects to the GBuffer, as it doesn't work properly later.</p>
<p>To address this, we also create a technique with a scheme called called 'NoGBuffer'. If the inspectPass decided that the object is transparent, we will not add an auto-generated pass to the 'GBuffer' technique, but instead copy the regular pass to the 'NoGBuffer' technique, to render it regularly later.</p>
<h3>Putting it all together</h3>
<p>This is how <code>GBufferSchemeHandler::handleSchemeNotFound</code> works:</p>
<div class="fragment"><div class="line">Technique* GBufferSchemeHandler::handleSchemeNotFound(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> schemeIndex, </div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; schemeName, Material* originalMaterial, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> lodIndex, </div><div class="line">        <span class="keyword">const</span> Renderable* rend)</div><div class="line">{</div><div class="line">    <a class="code" href="class_ogre_1_1_material_manager.html">Ogre::MaterialManager</a>&amp; matMgr = <a class="code" href="class_ogre_1_1_material_manager.html#a100f413d9d2316028e7ae740e5a43161">Ogre::MaterialManager::getSingleton</a>();</div><div class="line">    <a class="code" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> curSchemeName = matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#ad03ea02e140fc1e7312d14626e59d45d">getActiveScheme</a>();</div><div class="line">    matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0">setActiveScheme</a>(MaterialManager::DEFAULT_SCHEME_NAME);</div><div class="line">    Technique* originalTechnique = originalMaterial-&gt;getBestTechnique(lodIndex, rend);</div><div class="line">    matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0">setActiveScheme</a>(curSchemeName);</div><div class="line"></div><div class="line">    Technique* gBufferTech = originalMaterial-&gt;createTechnique();</div><div class="line">    gBufferTech-&gt;removeAllPasses();</div><div class="line">    gBufferTech-&gt;setSchemeName(schemeName);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef OGRE_BUILD_COMPONENT_RTSHADERSYSTEM</span></div><div class="line">    RTShader::ShaderGenerator&amp; rtShaderGen = RTShader::ShaderGenerator::getSingleton();</div><div class="line">    rtShaderGen.createShaderBasedTechnique(*originalMaterial, originalTechnique-&gt;getSchemeName(), <span class="stringliteral">&quot;NoGBuffer&quot;</span>);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    Technique* noGBufferTech = originalMaterial-&gt;createTechnique();</div><div class="line">    noGBufferTech-&gt;removeAllPasses();</div><div class="line">    noGBufferTech-&gt;setSchemeName(<span class="stringliteral">&quot;NoGBuffer&quot;</span>);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i=0; i&lt;originalTechnique-&gt;getNumPasses(); i++)</div><div class="line">    {</div><div class="line">        Pass* originalPass = originalTechnique-&gt;getPass(i);</div><div class="line">        PassProperties props = inspectPass(originalPass, lodIndex, rend);</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (!props.isDeferred)</div><div class="line">        {</div><div class="line"><span class="preprocessor">#ifdef OGRE_BUILD_COMPONENT_RTSHADERSYSTEM</span></div><div class="line">            rtShaderGen.validateMaterial(<span class="stringliteral">&quot;NoGBuffer&quot;</span>, originalMaterial-&gt;getName(), originalMaterial-&gt;getGroup());</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">            <span class="comment">//Just copy the technique so it gets rendered regularly</span></div><div class="line">            Pass* clonePass = noGBufferTech-&gt;createPass();</div><div class="line">            *clonePass = *originalPass;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        Pass* newPass = gBufferTech-&gt;createPass();</div><div class="line">        MaterialGenerator::Perm perm = getPermutation(props);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::MaterialPtr</a>&amp; templateMat = mMaterialGenerator.getMaterial(perm);</div><div class="line">        </div><div class="line">        <span class="comment">//We assume that the GBuffer technique contains only one pass. But its true.</span></div><div class="line">        *newPass = *(templateMat-&gt;<a class="code" href="class_ogre_1_1_material.html#abc82b3c4963c8d3cd04c93fdc6dbf416">getTechnique</a>(0)-&gt;<a class="code" href="class_ogre_1_1_technique.html#a3ce84da25bb6b5762af714adaf70874a">getPass</a>(0));</div><div class="line">        fillPass(newPass, originalPass, props);    </div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> gBufferTech;</div><div class="line">}</div></div><!-- fragment --> <h2>Overriding the automatic process</h2>
<p>In some cases the automatic material generation will not be good enough. We want to keep the option of manually writing GBuffer materials and shaders.</p>
<p>How do we do this? Easily! Since GBufferSchemeHandler::handleSchemeNotFound only gets called when an object doesn't already have a GBuffer scheme, adding a 'GBuffer' technique to the material will cause it to not get passed to the listener even once.</p>
<h2>Seeing it in action</h2>
<p>Using tools like NVIDIA's PerfHUD, we can see the texture being built during the frame :</p>
<div class="image">
<img src="GBufferPerfHUD.PNG" alt="GBufferPerfHUD.PNG"/>
</div>
<p>Note that nothing has been written to the final output yet (main view is completely black) and that two textures are being written to (see right hand side).</p>
<h1><a class="anchor" id="lighting"></a>
Lighting the scene</h1>
<p>In the GBuffer compositor, we built the G-Buffer for the current frame. It is now the time to use it to calculate the final lighting of the scene. This is what the compositor looks like :</p>
<div class="fragment"><div class="line">compositor DeferredShading/ShowLit</div><div class="line">{</div><div class="line"></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">//Reference the main Gbuffer texture</span></div><div class="line">        texture_ref mrt_output DeferredShading/GBuffer mrt_output</div><div class="line">        </div><div class="line">        target_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line">            <span class="comment">//We will dispatch the shadow texture rendering ourselves</span></div><div class="line">            shadows off</div><div class="line">            </div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">                </div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">// render skies and other pre-gbuffer objects</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                first_render_queue 1</div><div class="line">                last_render_queue  9            </div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the lights and their meshes</span></div><div class="line">            pass render_custom DeferredLight</div><div class="line">            {</div><div class="line">                input 0 mrt_output 0</div><div class="line">                input 1 mrt_output 1</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the objects that skipped rendering into the gbuffer</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                material_scheme NoGBuffer</div><div class="line">                first_render_queue 10</div><div class="line">                last_render_queue 79</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the post-GBuffer render queue objects</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                <span class="comment">//This value is synchronized with the code</span></div><div class="line">                first_render_queue 80</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Yes, it's a long one. Here is a breakdown of the compositor :</p><ul>
<li>The 'texture_ref' definition means that we are referencing a texture from another compositor. In the case of a chain-scoped texture (like the GBuffer), this means that we can only apply this compositor on chains that have the GBuffer creating compositor earlier in the chain than this one. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will check that this is the case.</li>
</ul>
<p>There are four target passes in this compositor.</p><ol type="1">
<li>Render the skies and then the lights using the render_custom directive (more on this later)</li>
<li>Render the objects that are in the GBuffer render queues but didn't get rendered to the GBuffer</li>
<li>Render the post-GBuffer render queue objects</li>
<li>Output the result</li>
</ol>
<h3>Why do we need four target passes ?</h3>
<p>This is mainly a limitation of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Ideally, we could use a single target_output pass and do all the passes there. The problem is that material_scheme is at the target scope and not at the pass scope. This is hard to change, because material schemes are resolved during scene preparing time and not during scene rendering. So even if the scope would change, it would not affect the rendering, as the material scheme will not get tested after we switch to it. Perhaps this will be addressed, and then this compositor will get simplified.</p>
<h2><a class="anchor" id="lightgeom"></a>
Rendering the light geometry</h2>
<p>The geometry that we want to render to calculate lighting information doesn't really fit in any classic category. It is not really a part of the scene, as the light geometry aren't objects in the world. But it is geometry (not always a quad) that needs to be rendered.</p>
<p>For these kind of operations, the render_custom target pass was introduced into <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. It is possible to register custom (named) composition passes that will be performed in the compositor. In this case, it is 'DeferredLight'. The composition pass will receive a call each frame telling it 'it's your turn, do your thing'. The class in the demo is DeferredLightCP.</p>
<p>The registration of the custom composition pass has to be done once, using <a class="el" href="class_ogre_1_1_compositor_manager.html#ae9b8ca4c2a51c0720bb31393d20fe7c9" title="Register a custom composition pass. ">Ogre::CompositorManager::registerCustomCompositionPass()</a>.</p>
<p>CustomCompositionPass is essentially just a factory for RenderSystemOperations, which are the operations that get executed during a compositor chain. This is the single API call: <a class="el" href="class_ogre_1_1_custom_composition_pass.html#a6b8c7a3743f9bb44e27c0348a0035e7b" title="Create a custom composition operation. ">Ogre::CustomCompositionPass::createOperation()</a>.</p>
<p>So, now we get called exactly when we want, after the G-Buffer has been built and the (early) skies have been rendered. What will we do?</p>
<h3>Prepare ambient colour and rebuild original depth buffer</h3>
<p>Since we rendered the original scene to a different RTT, the depth buffer won't necessarily get reused for the output target, so we need to rebuild it so that future objects (lights and non-g-buffer objects) will be able to interact with the depth naturally.</p>
<p>Also, we need to apply the ambient light to the scene. For the purpose of the demo, the ambient light is not a separate colour channel, just the object's original textures applied with the scene's global ambient light factor. In theory, you could set up a different G-Buffer to allow more flexibility, but we didn't do that.</p>
<p>These two actions happen in a single full-screen quad render, that comes from the AmbientLight class.</p>
<h3>Render the light geometries</h3>
<p>The most important stage is the light geometry. The code scans the original scene's lights, builds a matching DLight (deferred light) instance for each light in the scene, and renders away using the G-Buffer.</p>
<p>These lights use pretty sophisticated shaders, since they perform the lighting calculations of the fixed function pipeline themselves, and have to account for many options (specularity, attenuation, different light types and shadows, which will get talked about soon). In contrast to the G-Buffer building stage, the shaders here do not get generated on the fly. There is one big shader (sometimes referred to as an Uber-Shader) with many preprocessor options that account for all the options. (See LightMaterial_ps.cg) Note that the shaders have to be synchronized with the G-Buffer layout. A change in the layout would need a parallel change in the deferred lighting shaders.</p>
<p>The material generator for this section (LightMaterialGenerator class) just scans the flags of input and generates the correct preprocessor defines for the uber-shader. Some people prefer to use this approach for the G-Buffer stage as well, but I wanted to show both options in the demo.</p>
<p>In order to dispatch render operations manually, the following call exists in SceneManager: <a class="el" href="class_ogre_1_1_scene_manager.html#a1593fab748d1b0820e93e49d5732350b" title="Render something as if it came from the current queue. ">Ogre::SceneManager::_injectRenderWithPass()</a>.</p>
<p>When rendering a light, we pass the light we are rendering as the manual light list in order to have the auto params for that light available in the shader.</p>
<h3>Rendering shadow casting lights</h3>
<p>The 'classic' approach to rendering texture shadows is to prepare all of them before the scene rendering starts, and then apply them to the rendered objects using shadow receiver passes or integrated shaders. The downside of this approach is that you need to allocate a texture per-light (5 shadow casting lights -&gt; 5 shadow textures) and that if you don't integrate it in your shaders you also contribute even more passes to the scene.</p>
<p>One of the advantages of deferred shading is that we render the lights completely, and one by one. So, we can generate the shadow texture for a light just before the light's geometry is rendered, allowing us to reuse the same texture for as many lights as we want. (We still have an overhead of rendering the scene from the light's perspective per-light).</p>
<p>The API call that prepares shadow textures on demand is <a class="el" href="class_ogre_1_1_scene_manager.html#a95cd8ff86a7178c2e37b2fcb485f64fa" title="Method for preparing shadow textures ready for use in a regular render Do not call manually unless be...">Ogre::SceneManager::prepareShadowTextures()</a>. The lightList parameter allows specification of which lights to prepare shadow textures for.</p>
<p>Important note - RenderSystemOperations get executed in the middle of scene rendering. This means that there is an active render target being rendered to. In order to render the shadow texture we need to be able to pause rendering mid frame, render the shadow texture, and resume rendering immediately afterwards. For this, SceneManager has two methods that do just that <a class="el" href="class_ogre_1_1_scene_manager.html#a90d0e7484ed4580ec980eef15808bfee" title="Pause rendering of the frame. ">Ogre::SceneManager::_pauseRendering()</a> and <a class="el" href="class_ogre_1_1_scene_manager.html#a794e03ea25dd798346414c1dba31337d" title="Resume rendering of the frame. ">Ogre::SceneManager::_resumeRendering()</a>, so the prepareShadowTextures call has to be inside this.</p>
<p>The demo currently supports just spotlight shadow casting (since it is the cheapest to implement) but the other options can be supported as well.</p>
<h3>Putting it all together</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DeferredLightRenderOperation::execute(SceneManager *sm, RenderSystem *rs)</div><div class="line">{</div><div class="line">    <a class="code" href="class_ogre_1_1_camera.html">Ogre::Camera</a>* cam = mViewport-&gt;getCamera();</div><div class="line"></div><div class="line">    mAmbientLight-&gt;updateFromCamera(cam);</div><div class="line">    Technique* tech = mAmbientLight-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a2a54dff8ade9ab6838c1517062f0eb98">getMaterial</a>()-&gt;<a class="code" href="class_ogre_1_1_material.html#a37ae7259ce89bdc38828ea1b977bdbcf">getBestTechnique</a>();</div><div class="line">    injectTechnique(sm, tech, mAmbientLight, 0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group___general.html#gaab30ef14aae93306a6044cb38d835f0c">LightList</a>&amp; lightList = sm-&gt;_getLightsAffectingFrustum();</div><div class="line">    <span class="keywordflow">for</span> (LightList::const_iterator it = lightList.begin(); it != lightList.end(); it++) </div><div class="line">    {</div><div class="line">        Light* light = *it;</div><div class="line">        <a class="code" href="class_ogre_1_1_hashed_vector.html">Ogre::LightList</a> ll;</div><div class="line">        ll.<a class="code" href="class_ogre_1_1_hashed_vector.html#a87bfcde773502ee964a677580724188f">push_back</a>(light);</div><div class="line"></div><div class="line">        <span class="comment">//if (++i != 2) continue;</span></div><div class="line">        <span class="comment">//if (light-&gt;getType() != Light::LT_DIRECTIONAL) continue;</span></div><div class="line">        <span class="comment">//if (light-&gt;getDiffuseColour() != ColourValue::Red) continue;</span></div><div class="line"></div><div class="line">        LightsMap::iterator dLightIt = mLights.find(light);</div><div class="line">        DLight* dLight = 0;</div><div class="line">        <span class="keywordflow">if</span> (dLightIt == mLights.end()) </div><div class="line">        {</div><div class="line">            dLight = createDLight(light);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> </div><div class="line">        {</div><div class="line">            dLight = dLightIt-&gt;second;</div><div class="line">            dLight-&gt;updateFromParent();</div><div class="line">        }</div><div class="line">        dLight-&gt;updateFromCamera(cam);</div><div class="line">        tech = dLight-&gt;getMaterial()-&gt;getBestTechnique();</div><div class="line"></div><div class="line">        <span class="comment">//Update shadow texture</span></div><div class="line">        <span class="keywordflow">if</span> (dLight-&gt;getCastChadows())</div><div class="line">        {</div><div class="line">            SceneManager::RenderContext* context = sm-&gt;_pauseRendering();</div><div class="line"></div><div class="line">            sm-&gt;prepareShadowTextures(cam, mViewport, &amp;ll);</div><div class="line">            sm-&gt;_resumeRendering(context);</div><div class="line">            </div><div class="line">            Pass* pass = tech-&gt;getPass(0);</div><div class="line">            TextureUnitState* tus = pass-&gt;getTextureUnitState(<span class="stringliteral">&quot;ShadowMap&quot;</span>);</div><div class="line">            assert(tus);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a>&amp; shadowTex = sm-&gt;getShadowTexture(0);</div><div class="line">            <span class="keywordflow">if</span> (tus-&gt;_getTexturePtr() != shadowTex)</div><div class="line">            {</div><div class="line">                tus-&gt;_setTexturePtr(shadowTex);</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">        </div><div class="line">        injectTechnique(sm, tech, dLight, &amp;ll);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h3>Seeing it in action</h3>
<p>Here is a screenshot from PerfHUD of the draw call that renders a spotlight that casts shadows. See the two G-Buffer textures and one shadow texture on the left :</p>
<div class="image">
<img src="DeferredCone1.PNG" alt="DeferredCone1.PNG"/>
</div>
<p>Here is a visualization of the texture being built :</p>
<div class="image">
<img src="DeferredCone2.PNG" alt="DeferredCone2.PNG"/>
</div>
<p>After all the lights are rendered, the scene is fully lit!</p>
<h1><a class="anchor" id="post"></a>
Post Processing</h1>
<p>The compositor framework used to be a post processing framework, but as this article shows - it is now a 'custom render pipeline' framework, allowing different rendering approaches. However, it can still be used to post process the scene, even under deferred rendering.</p>
<h2>Screen Space Ambient Occlusion</h2>
<p>'Screen Space Ambient Occlusion' is a global illumination technique that adds a bit of realism to the scene, where classic lighting often fails. However, it requires the normals and depths of the scene in order to calculate its contribution. Normally, the SSAO compositor would have a render_scene directive that does that.</p>
<p>However, with deferred shading, we already have that information from the G-Buffer stage, so we just need to access it!</p>
<p>This is what the compositor looks like :</p>
<div class="fragment"><div class="line">compositor DeferredShading/SSAO</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        compositor_logic SSAOLogic</div><div class="line">        </div><div class="line">        texture_ref geom DeferredShading/GBuffer mrt_output</div><div class="line">        texture scene target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca74ea3b1c0c5f4ae06b1a7136c5523eca">PF_R8G8B8A8</a></div><div class="line">        texture ssao target_width_scaled 0.5 target_height_scaled 0.5 <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line">        texture ssaoBlurX target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line">        texture ssaoBlurY target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line"></div><div class="line">        <span class="comment">// the scene we want to modulate</span></div><div class="line">        target scene</div><div class="line">        {</div><div class="line">            input previous</div><div class="line">        }</div><div class="line"></div><div class="line">        </div><div class="line"></div><div class="line">        target ssao</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                <span class="comment">// our SSAO listener number</span></div><div class="line">                identifier 42</div><div class="line"></div><div class="line">                material ssao</div><div class="line">                <span class="comment">// pass in the &quot;geometry map&quot;</span></div><div class="line">                input 0 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        target ssaoBlurX</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                identifier 43</div><div class="line"></div><div class="line">                material ssaoBlurX</div><div class="line">                input 0 ssao</div><div class="line">                input 1 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        target ssaoBlurY</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                identifier 43</div><div class="line"></div><div class="line">                material ssaoBlurY</div><div class="line">                input 0 ssaoBlurX</div><div class="line">                input 1 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        target_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                <span class="comment">// just output something, for example, use a modulate</span></div><div class="line">                <span class="comment">// material to just multiply the scene by the ssao</span></div><div class="line">                material modulate</div><div class="line">                input 0 scene</div><div class="line">                input 1 ssaoBlurY</div><div class="line">                <span class="comment">//input 1 ssao</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Some notes :</p><ul>
<li>Again, texture_ref is used to access a chain_scoped texture from the GBuffer compositor</li>
<li>compositor_logic is used to couple between the compositor and some code that it requires to run. A CompositorLogic class is created and registered with the CompositorManager with <a class="el" href="class_ogre_1_1_compositor_manager.html#a9c7d4168d56868599badb2789d54157c" title="Register a compositor logic for listening in to expecting composition techniques. ...">Ogre::CompositorManager::registerCompositorLogic()</a>. Which will cause the binding code to run whenever an instance of this compositor is created.</li>
<li>'Regular' compositors that don't use the GBuffer are also still possible of course, they can be used regularly, as long as they are placed after the DeferredShading/ShowLit compositor.</li>
</ul>
<h1><a class="anchor" id="realprojects"></a>
Integration in real projects</h1>
<p>The framework that this demo uses was designed to be pluggable into other projects. Some of the design considerations that contribute to that are :</p><ol type="1">
<li>The scene setup does not change in any way. You still set the scene up with normal lights and modify their parameters just like you would regularly.</li>
<li>The GBuffer scheme handler and shader generator allow existing materials to work in a deferred shading pipeline unmodified. It might not cover all the cases, but it can.</li>
<li>Easy to integrate - see next section</li>
</ol>
<h2>Integration steps</h2>
<p>The framework created for a demo fits the plugin architecture pretty well. The GBufferSchemeHandler and DeferredLightCompositionPass classes could be instantiated once on plugin setup and registered with ogre's systems. This is not the case currently just to keep the SDK build simpler.</p>
<p>So, the steps are :</p><ol type="1">
<li>Register GBufferSchemeHandler and DeferredLightCompositionPass with their respective managers.</li>
<li>Add the GBuffer and ShowLit compositors to the viewports you want deferred shaded.</li>
</ol>
<p>And thats it! In the demo, the DeferredShading class takes care of that.</p>
<h2>Adapting the framework</h2>
<p>The deferred shading framework in the demo was designed to be usable in real applications. Where would one want to modify it ?</p><ol type="1">
<li>GBufferSchemeHandler / MaterialGenerator - support more options out of the box. Skinning, specular maps, and whatever you have in your project that can be solved in a generic fashion.</li>
<li>LightMaterialGenerator - support more lighting options (fog, etc), more shadow types, different shadow techniques (currently using very basic depth shadow mapping)</li>
<li>Tweak the framework to your pipeline - The material inspection relies on naming (among other things) to decide what its looking at. Just modify it to fit your art pipeline's conventions! (For example, how does a texture get flagged as a normal map?)</li>
</ol>
<p>Indeed, it means that the framework is not 100% plug and play. But, if understood correctly, it can be adapted to real life scenarios with relative ease.</p>
<h2>Adding features to the framework</h2>
<p>Post processing compositors that rely on certain aspects of the scene (like SSAO does) are now much easier to create and integrate with the earlier processes. An example could be edge-based anti aliasing, to address the lack of anti aliasing in DX9-based deferred shading systems.</p>
<p>In addition to that, the deferred shading implementation was focused on simplicity. There are many optimization options and most of them were not done, mainly to keep the demo as simple and understandable as possible.</p>
<h1><a class="anchor" id="summary"></a>
Summary</h1>
<p>Deferred Shading is an advanced rendering technique, that brings a pretty big implementation challenge along with it. This article, along with the demo, shows that it is possible to implement without relying on hacks and bypassing ogre's systems. Yes, it involves more advanced usage of ogre's APIs and requires a bit of knowledge about what happens behind the scenes, but is in no way impossible.</p>
<h2><a class="anchor" id="further"></a>
Further reading</h2>
<ul>
<li><a href="http://www.guerrilla-games.com/publications/dr_kz2_rsx_dev07.pdf">KillZone 2 Deferred Shading overview</a> - Great resource for understanding deferred shading in general before diving into implemeting it in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>.</li>
<li><a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SoC2009+Compositor">Improving Ogre's Compositor Framework GSoC project page</a></li>
<li><a href="http://www.gamedev.net/page/reference/index.html/_//feature/fprogramming/deferred-rendering-demystified-r2746">Deferred Rendering Demystified</a> - An article written around this project that explains the design behind the deferred renderer. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Shadow Mapping in Ogre</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_shadow_mapping_ogre.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Shadow Mapping in Ogre </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#ShadowMappingIntro">Introduction to the Shadow Mapping Algorithm</a><ul><li class="level2"><a href="#sm_formalism">Formalism</a></li>
<li class="level2"><a href="#DepthBias">Depth Biasing</a></li>
<li class="level2"><a href="#sm_pcm">Percentage Closest Filtering</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_variants">Variants</a><ul><li class="level2"><a href="#sm_additional_info">Storing Additional Info</a></li>
<li class="level2"><a href="#sm_breaking_frusta">Breaking up Shadow Frusta</a></li>
<li class="level2"><a href="#sect_planeopt">Playing with Projection Matrices</a></li>
</ul>
</li>
<li class="level1"><a href="#sm_theory">Theory and Analysis</a><ul><li class="level2"><a href="#sm_nonopt">(Non)Optimality of Logarithmic Shadow Maps</a></li>
<li class="level2"><a href="#sm_aliasing">Sampling Aliasing versus Depth Precision Aliasing</a></li>
<li class="level2"><a href="#sm_proj_aliasing">Projective versus Perspective Aliasing</a></li>
</ul>
</li>
<li class="level1"><a href="#Implementation">Implementation</a></li>
</ul>
</div>
<div class="textblock"><h1><a class="anchor" id="ShadowMappingIntro"></a>
Introduction to the Shadow Mapping Algorithm</h1>
<p>Shadow mapping, an algorithm introduced by Lance Williams  <a class="el" href="citelist.html#CITEREF_WIL78">[9]</a> and now prevalent in real-time and off-line rendering, is based on a simple idea: First, a snapshot of the scene is taken from the viewpoint of the light. Then, when creating an image from the perspective of the camera, the light’s snapshot is used to determine visibility. Parts of the scene seen by both the light and the camera must be lit (by the light in question). Parts of the scene visible only to the camera must be shadowed. We do not care about parts of the scene seen only by the light.</p>
<p>In practice, the snapshot from the viewpoint of the light is stored as a floating point depth buffer. It is important to use a format that supports enough precision to avoid shadow acne (z-fighting) on lit surfaces. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we can specify the depth format to use; in the example code, we will choose the 32-bit format.</p>
<p>Once shadow determination has occurred (whether a fragment is in shadow or not), <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides two different ways to render the shadows into the final image. The modulative technique will uniformly darken regions of the image determined to be in shadow. This is a cheaper and less accurate lighting model. For instance, specular highlights in shadow will appear as darkened specular highlights. The other technique is additive light masking. This technique builds up contributions from each light in non-shadowed areas and adds them together to create the final image. The code in section <a class="el" href="_shadow_mapping_ogre.html#Implementation">Implementation</a> will use additive light masking, but could just as easily be adapted for modulative shadows.</p>
<h2><a class="anchor" id="sm_formalism"></a>
Formalism</h2>
<p>Mathematically, the process can be represented as follows: Let \(P_l\) and \(P_c\) be the projection matrices for the light and camera respectively. Let \(M_l\) and \(M_c\) be the modelview matrices for the light and camera coordinate systems. Let \(\vec{x} = [x_1,x_2,x_3,1]^t\) be a point in object space, \(\vec{y} = [y_1,y_2,y_3,1]^t\) the screen space coordinates, and \(\vec{u} = [u_1,u_2,u_3,1]^t\) the shadow map coordinates.</p>
<p class="formulaDsp">
\[ \begin{aligned} \left[ \begin{array}{c} u_1 w_l \\ u_2 w_l \\ u_3 w_l \\ w_l \end{array} \right] = P_l M_l \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned} \]
</p>
<p class="formulaDsp">
\[\begin{aligned} \left[ \begin{array}{c} y_1 w_c \\ y_2 w_c \\ y_3 w_c \\ w_c \end{array} \right] = P_c M_c \left[ \begin{array}{c} x_1 \\ x_2 \\ x_3 \\ 1 \end{array} \right]\end{aligned}\]
</p>
<p>These equations can be written more concisely as: \(\vec{u}w_l = P_l M_l \vec{x}\) and \(\vec{y} w_c = P_c M_c \vec{x}\). Division of \(\vec{u}w_l\) and \(\vec{y}w_c\) by their respective homogeneous coordinates yields the Euclidean representations \(\vec{u}\) and \(\vec{y}\).</p>
<p>Note that while \(P_c\) and \(M_c\) are completely determined by the camera image we want to produce, we have some ambiguity in the \(P_l\) and \(M_l\) chosen for shadow mapping. The degrees of freedom here are later exploited to combat the aliasing issue.</p>
<h2><a class="anchor" id="DepthBias"></a>
Depth Biasing</h2>
<div class="image">
<object type="image/svg+xml" data="depthbias.svg">depthbias.svg</object>
<div class="caption">
Shadow map sample must use one float to represent a range of possible depth values. A depth sample is chosen in the middle. Any camera image point in between the two camera rays will see the geometry, and depending on distance from light will report differently on shadowed versus lit. However, every such point should be lit.</div></div>
<p>Due to the finite precision of floating point representations and inherent inability of one number to represent a range of values, it is often necessary to add a little bias to the depth values stored in a shadow map. One does not simply store the \(u_3\) value. Figure [fig:bias] illustrates the issue. Here we have used blue dots on the light’s image plane to represent boundaries between shadow “texels.” The interval in between the dots then represents a shadow map sample for which a single depth value (float) is stored. For the sample whose boundary rays are shown, the red dot’s depth is saved. However, note that from the camera’s perspective, any (camera) image point in between the two drawn camera rays will hit the scene geometry within the shadow map sample’s interval. Hence, the same shadow map sample depth will be used to determine visibility for all such camera pixels. Camera pixels whose rays fall to the right of the red dot will be marked as shadowed, while pixels whose rays fall to the left of the red dot will be marked as lit. This is not the right behavior because clearly all the pixels should be marked as lit. As we can see, a depth bias is needed. By pushing the shadow map sample’s depth farther (to the 2nd red dot), we can achieve correct shadow determination.</p>
<p>One could approach the depth bias issue in a completely <span>*ad hoc*</span> manner, but it is possible to do better. One would ideally compute a bias that depends on how depth ( \(u_3\)) changes between shadow map samples. The change in depth as one moves a unit step (to the next shadow map sample) represents the ambiguity of the depth value. Such a value may seem intractable to compute, but calculus and linear algebra save the day. From calculus, we learn that the derivative provides the best linear approximation to any function ( \(u_3 = u_3(u_1, u_2)\) in particular). In multiple dimensions, this role is played by the Jacobian (matrix of partial derivatives). In other words, we want to compute \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\), where we have treated \(u_3\) as a function of \(u_1\) and \(u_2\). Once these values are computed, it makes sense to then add some weighted combination of these to the stored depth value (e.g., some scale of the Jacobian’s Frobenius norm).</p>
<p>But even if the light is staring at a plane straight on (view direciton lines up with plane’s normal), making \(\frac{du_3}{du_1}\) and \(\frac{du_3}{du_2}\) both zero, we would still need a slight offset because rounding due to the float’s finite representation may still cause shadow acne. In this case, we’d like to offset the depth by a small value that pushes it beyond rounding ambiguity. While one could use an arbitrary constant offset, this is unsatisfactory since the constant in light image space corresponds to varying amounts of offset in light space (pre-projection Euclidean space with light’s position at origin). Let us instead choose a constant offset in the z direction of <span>*light space*</span> and compute what the offset for a particular sample should be in <span>*light image space*</span>. In Ogre’s example code, the small constant offset in light space is chosen to be 1 unit. If 1 is not a small amount in your engine’s chosen scale, you can easily change this choice. At any rate, the relevant quantity is \(\frac{\partial u_3}{\partial X_3}\) where \(\vec{X} = M_l \vec{x}\).</p>
<p>The choices here closely mirror what OpenGL implements through glPolygonOffset. The second adjustment is slightly different since OpenGL chooses a vendor specific fudge factor.</p>
<p>Equations for computing the stated quantities are provided below. One need not wade through these to use the depth biasing code. Understanding what the relevant parameters explained above are (in case adjustment is needed) is sufficient.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxqdu} \frac{\partial (\vec{x} q_l)}{\partial u_i} = \mbox{i-th column of } M_l^{-1} P_l^{-1} V_l^{-1} \end{aligned}\]
</p>
<p>where \(V_l\) is the viewport matrix for the light and \(i=1,2,3\). \(q_l\) turns out to be \(1/w_l\).</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:dxdu} \frac{\partial \vec{x}}{\partial u_i} = \frac{1}{q_l} \left( \frac{\partial (\vec{x} q_l)}{\partial u_i} - \vec{x}\frac{\partial q_l}{\partial u_i} \right) \\ \label{eqn:du3du} \frac{du_3}{du_j} = \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_3} \right)^{-1} \left( \vec{n} \cdot \frac{\partial \vec{x}}{\partial u_j} \right)\end{aligned}\]
</p>
<p>where \(\vec{n}\) is the normal at point \(\vec{x}\) and \(j=1,2\). Note that ([eqn:du3du]) is exactly the set of values needed for the first part.</p>
<p class="formulaDsp">
\[\begin{aligned} \label{eqn:duwdX3} \frac{\partial (\vec{u} w_l)}{\partial X_3} = \mbox{3rd column of } P_l \\ \label{eqn:dudX3} \frac{\partial \vec{u}}{\partial X_3} = \frac{1}{w_l} \left( \frac{\partial (\vec{u} w_l)}{\partial X_3} - \vec{u}\frac{\partial w_l}{\partial X_3} \right)\end{aligned}\]
</p>
<p>Note that ([eqn:dudX3]) is the quantity needed for the second bias term. This is also the term to scale for different choices of small offset in light space. If 0.01 units is the small offset, scale this value by 0.01.</p>
<h2><a class="anchor" id="sm_pcm"></a>
Percentage Closest Filtering</h2>
<p>As widely known, shadow mapping can exhibit significant aliasing. When this happens during texture mapping we apply filtering. We’d like to apply a similar principle with shadow maps, but filtering depth values is categorically the wrong thing to do. As described in  <a class="el" href="citelist.html#CITEREF_RSC87">[7]</a>, one should instead filter depth test results. This is termed percentage closest filtering. Ideally this would be a filtering technique much like anisotropic texture filtering, but for simplicity and efficiency, Ogre’s example code implements the bilinear analogue.</p>
<h1><a class="anchor" id="sm_variants"></a>
Variants</h1>
<p>There are many shadow mapping variants. Enumerating (much less describing) all of them would take us too far afield in this article. We instead defer to the provided references and google for such coverage. The many variants can, however, be broken up into three broad categories:</p><ol type="1">
<li>Those that store additional information beyond a single float,</li>
<li>those that divide up shadow frusta into multiple frusta to be handled separately, and</li>
<li>those that propose less naive \(P_l\) and \(M_l\) to use and thereby affect the sampling distribution.</li>
</ol>
<p>Algorithms in each category usually work quite independently and so many hybrid approaches are easily conceivable.</p>
<h2><a class="anchor" id="sm_additional_info"></a>
Storing Additional Info</h2>
<p>One example of this is Deep Shadow Maps  <a class="el" href="citelist.html#CITEREF_LV00">[5]</a>. In this work, instead of storing a single depth value and treating visibility as a binary value, a transfer function is stored and visibility is continuous. This algorithm is important in offline movie rendering, but also relevant to the Variance Shadow Mapping algorithm elucidated by the game developer community  <a class="el" href="citelist.html#CITEREF_DL06">[3]</a>.</p>
<p>While variance shadow maps are motivated by statistical considerations, it is perhaps more properly understood in the Deep Shadow Maps framework. Analyzing it in terms of distributions is flawed for two reasons:</p><ol type="1">
<li>the inequality considered is valid only for unimodal distributions whereas depth values are often discontinuous in regions that matter;</li>
<li>the inequality is treated as equality. The equations are justified with a very specific example in which two planes are viewed straight on. In practice there are very noticeable halo effects around objects, which makes more heuristic tweaks necessary.</li>
</ol>
<p>Recasting this into the framework of deep shadow maps, we see that the proposed equality is simply a particular functional approximation to the transfer function. Variance shadow maps proposes a two-parameter family of approximation functions whose parameters are linearly interpolated in the usual way. This viewpoint allows for analysis and also suggests the possibility of getting improvements via other approximating functional forms.</p>
<h2><a class="anchor" id="sm_breaking_frusta"></a>
Breaking up Shadow Frusta</h2>
<p>Adaptive Shadow Maps  <a class="el" href="citelist.html#CITEREF_FFB01">[4]</a> are an example of this. It is still largely considered too expensive for real-time rendering, but continued research and growing GPU power may make some variant worthwhile.</p>
<h2><a class="anchor" id="sect_planeopt"></a>
Playing with Projection Matrices</h2>
<p>There are various heuristic approaches for choosing \(P_l\) and \(M_l\), but here we will focus on one method, the Plane Optimal algorithm  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a>, that provides a particular guarantee. For this algorithm, we specify a plane of interest (e.g., ground plane, wall, table top) for which we want perfect shadowing no matter the configuration of light and camera in the scene (even dueling frusta). The algorithm will then compute \(P_l\) and \(M_l\) so that the mapping between camera image and light image is the identity when restricted to the plane. If the shadow map matches the resolution of the screen, then each pixel gets exactly one shadow sample. Shadows off the plane of interest have no guarantees. One limitation of the method is shown in Figure [fig:planeopt]. Only region I will be shadowed and self-shadowed properly, with points on the plane being shadowed perfectly (alias-free). This makes the method perhaps most useful for games where the view is top-down or isometric (like RTS games). It is also useful for cases like dueling frusta (where just about all other methods fail).</p>
<div class="image">
<object type="image/svg+xml" data="optfrust.svg">optfrust.svg</object>
<div class="caption">
Region I is defined as the set of all points along rays between the light and a point on the plane of interest in the camera’s view. Everything in region I is shadowed and self-shadowed properly. Objects in region II are not self-shadowed properly.</div></div>
<h1><a class="anchor" id="sm_theory"></a>
Theory and Analysis</h1>
<p>A full discussion of shadow map analysis is beyond the scope of this article. For those interested, the references  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> and  <a class="el" href="citelist.html#CITEREF_Chong04">[1]</a> are good (in my extremely biased opinion). Note that as research papers, they are quite concise. Unfortunately there don’t seem to more step-by-step expositions available at this moment.</p>
<p>There has been a lot of academic and industry research on improving shadow maps. However, analyses presented on shadow maps often do not say what people claim they say. These faulty conclusions usually come from considering very special cases and assuming the general case is very similar. For clarification, we explore some of these misconceptions here.</p>
<h2><a class="anchor" id="sm_nonopt"></a>
(Non)Optimality of Logarithmic Shadow Maps</h2>
<p>We start with one <em>heuristic</em> that has gained quite a bit of traction: the idea of using some logarithmic mapping between light space and light image space instead of a projective transform. A number of algorithms based on this idea have been proposed, and even some hardware changes. Much of this work seems to be motivated by the incorrect assumption that logarithmic mappings are optimal.</p>
<p>The very special motivating case is this: The camera looks down the z axis. Directional light illuminates the scene perpendicular to the z axis. An angled piece of a plane is viewed by the camera. As the angled piece of plane is pulled along the camera ray direction, using a logarithmic shadow map gives us constant shadow quality on this geometric piece. But unless we’re rendering translucent dust particles along a camera ray, this analysis is irrelevant. If the dust particles are not translucent, we only care about shadow determination on the first one, not a whole line of them. If we are rendering continuous surfaces (resp. curves), we care about the quality as one moves in the tangent plane (resp. tangent) direction because this is the best linear approximation to the surface (resp. curve), not the camera ray direction.</p>
<p>In fact, in the case of a chosen plane of interest for example, we know we can get completely alias free shadow mapping using a projective transform (section <a class="el" href="_shadow_mapping_ogre.html#sect_planeopt">Playing with Projection Matrices</a>). Logarithmic shadow maps may be an interesting heuristic to try out, but certainly not worth changing hardware over in my opinion. If you’re going to change hardware, might as well aim for true optimality.</p>
<h2><a class="anchor" id="sm_aliasing"></a>
Sampling Aliasing versus Depth Precision Aliasing</h2>
<p>Sometimes people tend to conflate these two sources of aliasing. They note that after applying some sort of custom projective transform, the depth values are warped as well. This problem can be completely overcome via the depth replacement method prescribed in Trapezoidal Shadow Maps  <a class="el" href="citelist.html#CITEREF_MT04">[6]</a>. So this is a completely orthogonal issue. Depth precision can be just as good as “normal” shadow maps, no matter the perspective warp used to affect sampling.</p>
<h2><a class="anchor" id="sm_proj_aliasing"></a>
Projective versus Perspective Aliasing</h2>
<p>The terms perspective and projective aliasing appeared in the Perspective Shadow Maps  <a class="el" href="citelist.html#CITEREF_SD02">[8]</a> paper and has since been used extensively by those who work on improving shadow heuristics. Often it is claimed that methods ameliorate perspective aliasing while projective aliasing is either unavoidable or must be addressed via completely separate means. However, the distinction between the two is somewhat artificial. Both result from not allocating enough shadow map samples to regions that matter to the viewer. As the Plane Optimal algorithm demonstrates, it is possible to completely remove projective aliasing (as well as perspective aliasing) in certain scenes. In general, there should be one combined measure of aliasing and algorithms must minimize this quantity. See  <a class="el" href="citelist.html#CITEREF_Chong06">[2]</a> for a unified notion of aliasing.</p>
<h1><a class="anchor" id="Implementation"></a>
Implementation</h1>
<p><a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> provides a powerful framework that allows us to do a lot of shadow map customization. In <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>, we turn on custom shadow mapping through the scene manager (here, sceneMgr). It is recommended that this happen early as it may affect how certain resources are loaded.</p>
<div class="fragment"><div class="line"><span class="comment">// Use Ogre&#39;s custom shadow mapping ability</span></div><div class="line">sceneMgr-&gt;setShadowTexturePixelFormat(<a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca2da3ec4fe727d552337e02069cd9efd9">PF_FLOAT32_R</a>);</div><div class="line">sceneMgr-&gt;setShadowTechnique( <a class="code" href="group___general.html#gga79dcd426d291c31072c1ad6f183715d6a8a2b43e30e6d8d590e6853e4f46b8103">SHADOWTYPE_TEXTURE_ADDITIVE</a> );</div><div class="line">sceneMgr-&gt;setShadowTextureCasterMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Caster/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureReceiverMaterial(<span class="stringliteral">&quot;Ogre/DepthShadowmap/Receiver/Float&quot;</span>);</div><div class="line">sceneMgr-&gt;setShadowTextureSelfShadow(<span class="keyword">true</span>); </div><div class="line">sceneMgr-&gt;setShadowTextureSize(1024);</div></div><!-- fragment --><p>The setShadowTechnique call is all that is required for Ogre’s default shadow mapping. In the code above, we have told <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> to use the R channel of a floating point texture to store depth values. This tends to be a very portable method (over graphics cards and APIs). The sample uses 1024x1024 shadow maps. Self-shadowing is turned on, but be warned that this will only work properly if appropriate depth biasing is also used. The example code will manually account for depth biasing via the method described above in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. The shadow caster and shadow receiver materials are defined in a materials script. They tell <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> which shaders to use when rendering shadow casters into the shadow map and rendering shadow receivers during shadow determination.</p>
<p>The <code>DepthShadowmap.material</code> script is given below:</p>
<div class="fragment"><div class="line"><span class="comment">// Generic Shadow caster material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Caster/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/CasterFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"><span class="comment">// Generic Shadow receiver material (floating point shadowmap)</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/Float</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass </div><div class="line">        {</div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            texture_unit ShadowMap</div><div class="line">            {</div><div class="line">                tex_address_mode clamp</div><div class="line">                filtering none</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// Specific receiver material for rockwall</span></div><div class="line">material <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/Receiver/RockWall</div><div class="line">{</div><div class="line"></div><div class="line">    <span class="comment">// This is the preferred technique which uses both vertex and</span></div><div class="line">    <span class="comment">// fragment programs, supports coloured lights</span></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// Base ambient pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 1 1 1</div><div class="line">            diffuse 0 0 0 </div><div class="line">            specular 0 0 0 0 </div><div class="line">            </div><div class="line">            depth_bias -1</div><div class="line">        }</div><div class="line">        <span class="comment">// Now do the lighting pass</span></div><div class="line">        <span class="comment">// NB we don&#39;t do decal texture here because this is repeated per light</span></div><div class="line">        pass lighting</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            ambient 0 0 0 </div><div class="line">            </div><div class="line">            <span class="comment">// do this for each light</span></div><div class="line">            iteration once_per_light</div><div class="line"></div><div class="line">        </div><div class="line">            scene_blend add</div><div class="line">            </div><div class="line">            <span class="comment">// Vertex program reference</span></div><div class="line">            vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_vertex_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverVP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// Fragment program</span></div><div class="line">            fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line">            shadow_receiver_fragment_program_ref <a class="code" href="namespace_ogre.html">Ogre</a>/DepthShadowmap/ReceiverFP</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            <span class="comment">// shadowmap texture will be bound by code</span></div><div class="line"></div><div class="line">        }</div><div class="line">        </div><div class="line">        <span class="comment">// Decal pass</span></div><div class="line">        pass</div><div class="line">        {</div><div class="line">            <span class="comment">// base colours, not needed for rendering, but as information</span></div><div class="line">            <span class="comment">// to lighting pass categorisation routine</span></div><div class="line">            lighting off</div><div class="line"></div><div class="line"></div><div class="line">            scene_blend dest_colour zero</div><div class="line"></div><div class="line">            depth_bias 1</div><div class="line">            </div><div class="line">            texture_unit</div><div class="line">            {</div><div class="line">                texture rockwall.tga</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">    }</div><div class="line"></div><div class="line"></div><div class="line">}</div></div><!-- fragment --><p> The material uses unified programs for HLSL, GLSL and GLSLES. We’ll present the GLSL code below. Note that while most of the shader files are direct translations of each other, DirectX HLSL shaders must handle percentage closest filtering slightly differently from OpenGL. OpenGL chooses the convention of having integers index sample centers whereas DirectX chooses integers to index sample corners. Also note the variable names in the shaders presented below are slightly different from those presented earlier in this document. This is due in part to the awkwardness of expressing subscripts in variable names and also in part because \(u_3\) is less evocative of depth than \(z\), etc. With minimal effort one can match the shader equations with those presented earlier. The code is presented here mostly to demonstrate how things fit together.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform vec4 texelOffsets;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 outPos = worldViewProj * vertex;</div><div class="line">    outPos.xy += texelOffsets.zw * outPos.w;</div><div class="line">    <span class="comment">// fix pixel / texel alignment</span></div><div class="line">    depth = outPos.zw;</div><div class="line">    gl_Position = outPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">varying vec2 depth;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    <span class="keywordtype">float</span> finalDepth = depth.x / depth.y;</div><div class="line"></div><div class="line">    <span class="comment">// just smear across all components </span></div><div class="line">    <span class="comment">// therefore this one needs high individual channel precision</span></div><div class="line">    gl_FragColor = vec4(finalDepth, finalDepth, finalDepth, 1.0);</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>Just write out the depth values here. We compute the bias and derivatives in the receiver.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform mat4 world;</div><div class="line">uniform mat4 worldIT;</div><div class="line">uniform mat4 worldViewProj;</div><div class="line">uniform mat4 texViewProj;</div><div class="line">uniform vec4 lightPosition;</div><div class="line">uniform vec4 lightColour;</div><div class="line"></div><div class="line">attribute vec4 vertex;</div><div class="line">attribute vec3 normal;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    gl_Position = worldViewProj * vertex;</div><div class="line">    </div><div class="line">    vec4 worldPos = world * vertex;</div><div class="line"></div><div class="line">    vec3 worldNorm = (worldIT * vec4(normal, 1.0)).xyz;</div><div class="line"></div><div class="line">    <span class="comment">// calculate lighting (simple vertex lighting)</span></div><div class="line">    vec3 lightDir = normalize(</div><div class="line">        lightPosition.xyz - (worldPos.xyz * lightPosition.w));</div><div class="line"></div><div class="line">    outColor = lightColour * max(dot(lightDir, worldNorm), 0.0);</div><div class="line"></div><div class="line">    <span class="comment">// calculate shadow map coords</span></div><div class="line">    oUv = texViewProj * worldPos;</div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This is a pretty standard vertex shader as well.</p>
<div class="fragment"><div class="line"><span class="preprocessor">#version 120</span></div><div class="line"></div><div class="line">uniform <span class="keywordtype">float</span> inverseShadowmapSize;</div><div class="line">uniform <span class="keywordtype">float</span> fixedDepthBias;</div><div class="line">uniform <span class="keywordtype">float</span> gradientClamp;</div><div class="line">uniform <span class="keywordtype">float</span> gradientScaleBias;</div><div class="line"></div><div class="line">uniform sampler2D shadowMap;</div><div class="line"></div><div class="line">varying vec4 oUv;</div><div class="line">varying vec4 outColor;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> main()</div><div class="line">{</div><div class="line">    vec4 shadowUV = oUv;</div><div class="line">    <span class="comment">// point on shadowmap</span></div><div class="line">    shadowUV = shadowUV / shadowUV.w;</div><div class="line">    <span class="keywordtype">float</span> centerdepth = texture2D(shadowMap, shadowUV.xy).x;</div><div class="line">    </div><div class="line">    <span class="comment">// gradient calculation</span></div><div class="line">    <span class="keywordtype">float</span> pixeloffset = inverseShadowmapSize;</div><div class="line">    vec4 depths = vec4(</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(-pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(+pixeloffset, 0)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, -pixeloffset)).x,</div><div class="line">        texture2D(shadowMap, shadowUV.xy + vec2(0, +pixeloffset)).x);</div><div class="line"></div><div class="line">    vec2 differences = abs( depths.yw - depths.xz );</div><div class="line">    <span class="keywordtype">float</span> gradient = min(gradientClamp, max(differences.x, differences.y));</div><div class="line">    <span class="keywordtype">float</span> gradientFactor = gradient * gradientScaleBias;</div><div class="line"></div><div class="line">    <span class="comment">// visibility function</span></div><div class="line">    <span class="keywordtype">float</span> depthAdjust = gradientFactor + (fixedDepthBias * centerdepth);</div><div class="line">    <span class="keywordtype">float</span> finalCenterDepth = centerdepth + depthAdjust;</div><div class="line"></div><div class="line">    <span class="comment">// shadowUV.z contains lightspace position of current object</span></div><div class="line"><span class="preprocessor">#if PCF</span></div><div class="line">    <span class="comment">// use depths from prev, calculate diff</span></div><div class="line">    depths += depthAdjust;</div><div class="line">    <span class="keywordtype">float</span> <span class="keyword">final</span> = (finalCenterDepth &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.x &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.y &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.z &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    <span class="keyword">final</span> += (depths.w &gt; shadowUV.z) ? 1.0 : 0.0;</div><div class="line">    </div><div class="line">    <span class="keyword">final</span> *= 0.2;</div><div class="line"></div><div class="line">    gl_FragColor = vec4(outColor.xyz * <span class="keyword">final</span>, 1);</div><div class="line">    </div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    gl_FragColor = (centerdepth &gt; shadowUV.z) ? vec4(outColor.xyz,1) : vec4(0,0,0,1);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">}</div><div class="line"></div></div><!-- fragment --><p>This shader computes the two depth bias pieces described in section <a class="el" href="_shadow_mapping_ogre.html#DepthBias">Depth Biasing</a>. These are used to offset the stored depth value. This is where the notation differs from above, but the translation is quite straightforward.</p>
<p>Additionally this file implements percentage closest filtering. To use unfiltered shadow mapping, comment out the PCF block as noted and uncomment the Non-PCF block. Note that after doing this, the uSTexWidth and uSTexHeight variables are likely to be optimized away and so you should uncomment these variables in the materials script as well.</p>
<p>The following shows how to activate plane optimal shadow mapping given some pointer to a MovablePlane and a pointer to a light.</p>
<div class="fragment"><div class="line"><a class="code" href="class_ogre_1_1_plane_optimal_shadow_camera_setup.html">Ogre::PlaneOptimalShadowCameraSetup</a> *planeOptShadowCamera = </div><div class="line">                                <span class="keyword">new</span> PlaneOptimalShadowCameraSetup(movablePlane);</div><div class="line"><a class="code" href="class_ogre_1_1_entity.html">Ogre::Entity</a> *movablePlaneEntity = sceneMgr-&gt;createEntity( <span class="stringliteral">&quot;movablePlane&quot;</span>, <span class="stringliteral">&quot;plane.mesh&quot;</span> );</div><div class="line"><a class="code" href="class_ogre_1_1_scene_node.html">Ogre::SceneNode</a> *movablePlaneNode = </div><div class="line">                sceneMgr-&gt;getRootSceneNode()-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#aeaee9cb1cb0c23fab2cc9bab08f51181">createChildSceneNode</a>(<span class="stringliteral">&quot;MovablePlaneNode&quot;</span>);</div><div class="line">movablePlaneNode-&gt;<a class="code" href="class_ogre_1_1_scene_node.html#a51052c58747a77a6cf7451b700e7eb87">attachObject</a>(movablePlaneEntity);</div><div class="line">light-&gt;setCustomShadowCameraSetup(<a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::ShadowCameraSetupPtr</a>(planeOptShadowCamera));</div></div><!-- fragment --> </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Deferred Shading</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('deferred.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Deferred Shading </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#what">What is Deferred Shading?</a></li>
<li class="level1"><a href="#creating">Creating the G-Buffer</a></li>
<li class="level1"><a href="#lighting">Lighting the scene</a><ul><li class="level2"><a href="#lightgeom">Rendering the light geometry</a></li>
</ul>
</li>
<li class="level1"><a href="#post">Post Processing</a></li>
<li class="level1"><a href="#realprojects">Integration in real projects</a></li>
<li class="level1"><a href="#summary">Summary</a><ul><li class="level2"><a href="#further">Further reading</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>This wiki article is complementary to the deferred shading demo that is part of the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> SDK. It will reference the code quite a bit and explain some of the decisions made when implementing the deferred shading framework for the demo.</p>
<h1><a class="anchor" id="what"></a>
What is Deferred Shading?</h1>
<p>Deferred shading is an alternative approach to rendering 3d scenes. The classic rendering approach involves rendering each object and applying lighting passes to it. So, if an ogre head is affected by 6 lights, it will be rendered 6 times, once for each light, in order to accumulate the affection of each light. Deferred shading takes another approach : In the beginning, all of the objects render their "lighting related info" to a texture, often called the G-Buffer. This means their colours, normals, depths and any other info that might be relevant to calculating their final colour. Afterwards, the lights in the scene are rendered as geometry (sphere for point light, cone for spotlight and full screen quad for directional light), and they use the G-buffer to calculate the colour contribution of that light to that pixel.</p>
<p>See the links in <a class="el" href="deferred.html#further">Further reading</a> to read more about it. It is recommended to understand deferred shading before reading this article, as the article focuses on implementing it in ogre, and not explaining how it works.</p>
<h2>Deferred Shading Advantages</h2>
<p>The main reason for using deferred shading is performance related. Classing rendering (also called forward rendering) can, in the worst case, require num_objects * num_lights batches to render a scene. Deferred shading changes that to num_objects + num_lights, which can often be a lot less. Another reason is that some new post-processing effects are easily achievable using the G-Buffer as input. If you wanted to perform these effects without deferred shading, you would've had to render the whole scene again.</p>
<h2>Deferred Shading Disadvantages</h2>
<p>There are several algorithmic drawbacks with deferred shading - transparent objects are hard to handle, anti aliasing can not be used in DX9 class hardware, additional memory consumption because of the G-Buffer. In addition to that, deferred shading is harder to implement - it overrides the entire fixed function pipeline. Pretty much everything is rendered using manual shaders - which probably means a lot of shader code.</p>
<h1><a class="anchor" id="creating"></a>
Creating the G-Buffer</h1>
<p>The first part of the deferred shading pipeline involves rendering all the (non-transparent) objects of the scene to the G-Buffer. This is done using a compositor :</p>
<div class="fragment"><div class="line">compositor DeferredShading/GBuffer</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// temporary textures</span></div><div class="line">        texture mrt_output target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf91793bc9707d6541f4851722267317a">PF_FLOAT16_RGBA</a> <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf91793bc9707d6541f4851722267317a">PF_FLOAT16_RGBA</a> chain_scope</div><div class="line">        </div><div class="line">        target mrt_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line">            </div><div class="line">            shadows off</div><div class="line">            material_scheme GBuffer</div><div class="line">            </div><div class="line">            <span class="comment">// everything but the lights and their meshes</span></div><div class="line">            <span class="comment">// could do this with something like a visibility mask too</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                <span class="comment">//These values are synchronized with the code</span></div><div class="line">                first_render_queue 10</div><div class="line">                last_render_queue  79   </div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Things to note about this compositor :</p><ul>
<li>mrt_output (the GBuffer) is an MRT because there are two pixel formats defined.</li>
<li>mrt_output will be accessible to the next compositors in the chain because it is marked as chain_scope, meaning it is visible to the next compositors in the chain.</li>
<li>The material scheme tells ogre that objects shouldn't be rendered in normal fashion, but in some other way (we'll get to that soon)</li>
<li>Not all the objects are rendered to the GBuffer. Skies and 'late objects' (which can be specified manually using render queues) will be forward rendered.</li>
<li>This compositor does NOT have a target_output pass, because it does not contribute directly to the final image.</li>
</ul>
<h2>Deciding on the GBuffer format</h2>
<p>This in an important decision in deferred shading, as it has performance and visual implications.</p>
<p>Also, the entire pipeline has to be coordinated with this format - all the writing shaders have to write the same data to the same places, and all the reading shaders (for lighting later) have to be synchronized with it.</p>
<p>We chose two PF_FLOAT16_RGBA textures. The first one will contain the colour in RGB, specular intensity in A.</p>
<p>The second one will contain the view-space-normal in RGB (we keep all 3 coordinates) and the (linear) depth in A.</p>
<p>See the references for other possibilities.</p>
<h2>Preparing the objects for G-Buffer rendering</h2>
<p>The only indicator that ogre has when rendering the scene is that the material scheme is different. Material schemes in ogre allow materials to specify different rendering techniques for different scenarios. In this case, we would like to output the lighting related information instead of the lighting calculation result.</p>
<p>Materials that have a technique associated with the GBuffer scheme will render using that, but we don't want to modify the materials of all the objects in our art pipeline to use them in deferred shading.</p>
<p>The solution is to use scheme listeners! The material manager has a method for registering listeners when objects don't have a technique defined for the current scheme: <a class="el" href="class_ogre_1_1_material_manager.html#a8ac18f4bd2e6302f1d92ae8f64195694" title="Add a listener to handle material events. ">Ogre::MaterialManager::addListener()</a>.</p>
<p>The listener has a callback method that gets called whenever an object is about to be rendered without a matching technique: <a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html#a54bc384ab1102063aa00db4c3a5f3fc4" title="Called if a technique for a given scheme is not found within a material, allows the application to sp...">Ogre::MaterialManager::Listener::handleSchemeNotFound()</a>.</p>
<p>We will implement such a listener for the GBuffer scheme. It is GBufferSchemeHandler from the demo. The GBufferSchemeHandlers works like this :</p>
<h3>Inspect the classic technique</h3>
<p>For each pass in the technique that would have been used normally, the GBufferSchemeHandler::inspectPass is called, inspects the pass, and returns the PassProperties - does this pass have a texture? a normal map? is it skinned? tranpsarent? Etc. The PassProperties (should) contain all the information required to build a GBuffer technique for an object.</p>
<h3>Generate the G-Buffer technique</h3>
<p>After a pass has been inspected and understood, the next stage is to generate the G-Buffer-writing technique. This is done using the class GBufferMaterialGenerator. The class receives the flags of the features needed by the material, and dynamically generates the (CG) shaders and material to render an object with those properties to the G-Buffer. This greatly reduces the number of shaders that you need to manage when using deferred shading, as most of them are created on the fly. Here is an example of what they look like :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ToGBufferVP(</div><div class="line">         float4 iPosition : POSITION,</div><div class="line">         float3 iNormal   : NORMAL,</div><div class="line">         float2 iUV0 : TEXCOORD0,</div><div class="line"></div><div class="line">         out float4 oPosition : POSITION,</div><div class="line">         out float3 oViewPos : TEXCOORD0,</div><div class="line">         out float3 oNormal : TEXCOORD1,</div><div class="line">         out float2 oUV0 : TEXCOORD2,</div><div class="line"></div><div class="line">         uniform float4x4 cWorldViewProj,</div><div class="line">         uniform float4x4 cWorldView</div><div class="line">         )</div><div class="line"> {</div><div class="line">         oPosition = mul(cWorldViewProj, iPosition);</div><div class="line">         oNormal = mul(cWorldView, float4(iNormal,0)).xyz;</div><div class="line">         oViewPos = mul(cWorldView, iPosition).xyz;</div><div class="line">         oUV0 = iUV0;</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keywordtype">void</span> ToGBufferFP(</div><div class="line">         float3 iViewPos : TEXCOORD0,</div><div class="line">         float3 iNormal   : TEXCOORD1,</div><div class="line">         float3 iTangent : TEXCOORD2,</div><div class="line">         float3 iBiNormal : TEXCOORD3,</div><div class="line">         float2 iUV0 : TEXCOORD4,</div><div class="line"></div><div class="line">         out float4 oColor0 : COLOR0,</div><div class="line">         out float4 oColor1 : COLOR1,</div><div class="line"></div><div class="line">         uniform sampler sNormalMap : <span class="keyword">register</span>(s0),</div><div class="line">         uniform sampler sTex0 : <span class="keyword">register</span>(s1),</div><div class="line">         uniform float4 cDiffuseColour,</div><div class="line">         uniform <span class="keywordtype">float</span> cFarDistance,</div><div class="line">         uniform <span class="keywordtype">float</span> cSpecularity</div><div class="line">         )</div><div class="line"> {</div><div class="line">         oColor0.rgb = tex2D(sTex0, iUV0);</div><div class="line">         oColor0.rgb *= cDiffuseColour.rgb;</div><div class="line">         oColor0.a = cSpecularity;</div><div class="line">         float3 texNormal = (tex2D(sNormalMap, iUV0)-0.5)*2;</div><div class="line">         float3x3 normalRotation = float3x3(iTangent, iBiNormal, iNormal);</div><div class="line">         oColor1.rgb = normalize(mul(texNormal, normalRotation));</div><div class="line">         oColor1.a = length(iViewPos) / cFarDistance;</div><div class="line"> }</div></div><!-- fragment --><p> (This is for an object with a texture and a normal map)</p>
<h3>Add the G-Buffer technique to the original material</h3>
<p>We don't want to inspect the passes and generate the material each time an object is rendered, so we create a technique in the original material, and fill it with the auto-generated information. After copying the information from the GBuffer technique, texture references have to be updated, to use the correct textures when rendering the object. This happens in <code>GBufferSchemeHandler::fillPass</code>. The next time the object will be rendered, it WILL have a technique for the GBuffer scheme, so the listener won't get called.</p>
<h3>Postponing transparent objects</h3>
<p>We don't want to render transparent objects to the GBuffer, as it doesn't work properly later.</p>
<p>To address this, we also create a technique with a scheme called called 'NoGBuffer'. If the inspectPass decided that the object is transparent, we will not add an auto-generated pass to the 'GBuffer' technique, but instead copy the regular pass to the 'NoGBuffer' technique, to render it regularly later.</p>
<h3>Putting it all together</h3>
<p>This is how <code>GBufferSchemeHandler::handleSchemeNotFound</code> works:</p>
<div class="fragment"><div class="line">Technique* GBufferSchemeHandler::handleSchemeNotFound(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> schemeIndex, </div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; schemeName, Material* originalMaterial, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> lodIndex, </div><div class="line">        <span class="keyword">const</span> Renderable* rend)</div><div class="line">{</div><div class="line">    <a class="code" href="class_ogre_1_1_material_manager.html">Ogre::MaterialManager</a>&amp; matMgr = <a class="code" href="class_ogre_1_1_material_manager.html#a100f413d9d2316028e7ae740e5a43161">Ogre::MaterialManager::getSingleton</a>();</div><div class="line">    <a class="code" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> curSchemeName = matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#ad03ea02e140fc1e7312d14626e59d45d">getActiveScheme</a>();</div><div class="line">    matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0">setActiveScheme</a>(MaterialManager::DEFAULT_SCHEME_NAME);</div><div class="line">    Technique* originalTechnique = originalMaterial-&gt;getBestTechnique(lodIndex, rend);</div><div class="line">    matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0">setActiveScheme</a>(curSchemeName);</div><div class="line"></div><div class="line">    Technique* gBufferTech = originalMaterial-&gt;createTechnique();</div><div class="line">    gBufferTech-&gt;removeAllPasses();</div><div class="line">    gBufferTech-&gt;setSchemeName(schemeName);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef OGRE_BUILD_COMPONENT_RTSHADERSYSTEM</span></div><div class="line">    RTShader::ShaderGenerator&amp; rtShaderGen = RTShader::ShaderGenerator::getSingleton();</div><div class="line">    rtShaderGen.createShaderBasedTechnique(*originalMaterial, originalTechnique-&gt;getSchemeName(), <span class="stringliteral">&quot;NoGBuffer&quot;</span>);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    Technique* noGBufferTech = originalMaterial-&gt;createTechnique();</div><div class="line">    noGBufferTech-&gt;removeAllPasses();</div><div class="line">    noGBufferTech-&gt;setSchemeName(<span class="stringliteral">&quot;NoGBuffer&quot;</span>);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i=0; i&lt;originalTechnique-&gt;getNumPasses(); i++)</div><div class="line">    {</div><div class="line">        Pass* originalPass = originalTechnique-&gt;getPass(i);</div><div class="line">        PassProperties props = inspectPass(originalPass, lodIndex, rend);</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (!props.isDeferred)</div><div class="line">        {</div><div class="line"><span class="preprocessor">#ifdef OGRE_BUILD_COMPONENT_RTSHADERSYSTEM</span></div><div class="line">            rtShaderGen.validateMaterial(<span class="stringliteral">&quot;NoGBuffer&quot;</span>, originalMaterial-&gt;getName(), originalMaterial-&gt;getGroup());</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">            <span class="comment">//Just copy the technique so it gets rendered regularly</span></div><div class="line">            Pass* clonePass = noGBufferTech-&gt;createPass();</div><div class="line">            *clonePass = *originalPass;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        Pass* newPass = gBufferTech-&gt;createPass();</div><div class="line">        MaterialGenerator::Perm perm = getPermutation(props);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::MaterialPtr</a>&amp; templateMat = mMaterialGenerator.getMaterial(perm);</div><div class="line">        </div><div class="line">        <span class="comment">//We assume that the GBuffer technique contains only one pass. But its true.</span></div><div class="line">        *newPass = *(templateMat-&gt;<a class="code" href="class_ogre_1_1_material.html#abc82b3c4963c8d3cd04c93fdc6dbf416">getTechnique</a>(0)-&gt;<a class="code" href="class_ogre_1_1_technique.html#a3ce84da25bb6b5762af714adaf70874a">getPass</a>(0));</div><div class="line">        fillPass(newPass, originalPass, props);    </div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> gBufferTech;</div><div class="line">}</div></div><!-- fragment --> <h2>Overriding the automatic process</h2>
<p>In some cases the automatic material generation will not be good enough. We want to keep the option of manually writing GBuffer materials and shaders.</p>
<p>How do we do this? Easily! Since GBufferSchemeHandler::handleSchemeNotFound only gets called when an object doesn't already have a GBuffer scheme, adding a 'GBuffer' technique to the material will cause it to not get passed to the listener even once.</p>
<h2>Seeing it in action</h2>
<p>Using tools like NVIDIA's PerfHUD, we can see the texture being built during the frame :</p>
<div class="image">
<img src="GBufferPerfHUD.PNG" alt="GBufferPerfHUD.PNG"/>
</div>
<p>Note that nothing has been written to the final output yet (main view is completely black) and that two textures are being written to (see right hand side).</p>
<h1><a class="anchor" id="lighting"></a>
Lighting the scene</h1>
<p>In the GBuffer compositor, we built the G-Buffer for the current frame. It is now the time to use it to calculate the final lighting of the scene. This is what the compositor looks like :</p>
<div class="fragment"><div class="line">compositor DeferredShading/ShowLit</div><div class="line">{</div><div class="line"></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">//Reference the main Gbuffer texture</span></div><div class="line">        texture_ref mrt_output DeferredShading/GBuffer mrt_output</div><div class="line">        </div><div class="line">        target_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line">            <span class="comment">//We will dispatch the shadow texture rendering ourselves</span></div><div class="line">            shadows off</div><div class="line">            </div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">                </div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">// render skies and other pre-gbuffer objects</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                first_render_queue 1</div><div class="line">                last_render_queue  9            </div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the lights and their meshes</span></div><div class="line">            pass render_custom DeferredLight</div><div class="line">            {</div><div class="line">                input 0 mrt_output 0</div><div class="line">                input 1 mrt_output 1</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the objects that skipped rendering into the gbuffer</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                material_scheme NoGBuffer</div><div class="line">                first_render_queue 10</div><div class="line">                last_render_queue 79</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the post-GBuffer render queue objects</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                <span class="comment">//This value is synchronized with the code</span></div><div class="line">                first_render_queue 80</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Yes, it's a long one. Here is a breakdown of the compositor :</p><ul>
<li>The 'texture_ref' definition means that we are referencing a texture from another compositor. In the case of a chain-scoped texture (like the GBuffer), this means that we can only apply this compositor on chains that have the GBuffer creating compositor earlier in the chain than this one. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will check that this is the case.</li>
</ul>
<p>There are four target passes in this compositor.</p><ol type="1">
<li>Render the skies and then the lights using the render_custom directive (more on this later)</li>
<li>Render the objects that are in the GBuffer render queues but didn't get rendered to the GBuffer</li>
<li>Render the post-GBuffer render queue objects</li>
<li>Output the result</li>
</ol>
<h3>Why do we need four target passes ?</h3>
<p>This is mainly a limitation of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Ideally, we could use a single target_output pass and do all the passes there. The problem is that material_scheme is at the target scope and not at the pass scope. This is hard to change, because material schemes are resolved during scene preparing time and not during scene rendering. So even if the scope would change, it would not affect the rendering, as the material scheme will not get tested after we switch to it. Perhaps this will be addressed, and then this compositor will get simplified.</p>
<h2><a class="anchor" id="lightgeom"></a>
Rendering the light geometry</h2>
<p>The geometry that we want to render to calculate lighting information doesn't really fit in any classic category. It is not really a part of the scene, as the light geometry aren't objects in the world. But it is geometry (not always a quad) that needs to be rendered.</p>
<p>For these kind of operations, the render_custom target pass was introduced into <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. It is possible to register custom (named) composition passes that will be performed in the compositor. In this case, it is 'DeferredLight'. The composition pass will receive a call each frame telling it 'it's your turn, do your thing'. The class in the demo is DeferredLightCP.</p>
<p>The registration of the custom composition pass has to be done once, using <a class="el" href="class_ogre_1_1_compositor_manager.html#ae9b8ca4c2a51c0720bb31393d20fe7c9" title="Register a custom composition pass. ">Ogre::CompositorManager::registerCustomCompositionPass()</a>.</p>
<p>CustomCompositionPass is essentially just a factory for RenderSystemOperations, which are the operations that get executed during a compositor chain. This is the single API call: <a class="el" href="class_ogre_1_1_custom_composition_pass.html#a6b8c7a3743f9bb44e27c0348a0035e7b" title="Create a custom composition operation. ">Ogre::CustomCompositionPass::createOperation()</a>.</p>
<p>So, now we get called exactly when we want, after the G-Buffer has been built and the (early) skies have been rendered. What will we do?</p>
<h3>Prepare ambient colour and rebuild original depth buffer</h3>
<p>Since we rendered the original scene to a different RTT, the depth buffer won't necessarily get reused for the output target, so we need to rebuild it so that future objects (lights and non-g-buffer objects) will be able to interact with the depth naturally.</p>
<p>Also, we need to apply the ambient light to the scene. For the purpose of the demo, the ambient light is not a separate colour channel, just the object's original textures applied with the scene's global ambient light factor. In theory, you could set up a different G-Buffer to allow more flexibility, but we didn't do that.</p>
<p>These two actions happen in a single full-screen quad render, that comes from the AmbientLight class.</p>
<h3>Render the light geometries</h3>
<p>The most important stage is the light geometry. The code scans the original scene's lights, builds a matching DLight (deferred light) instance for each light in the scene, and renders away using the G-Buffer.</p>
<p>These lights use pretty sophisticated shaders, since they perform the lighting calculations of the fixed function pipeline themselves, and have to account for many options (specularity, attenuation, different light types and shadows, which will get talked about soon). In contrast to the G-Buffer building stage, the shaders here do not get generated on the fly. There is one big shader (sometimes referred to as an Uber-Shader) with many preprocessor options that account for all the options. (See LightMaterial_ps.cg) Note that the shaders have to be synchronized with the G-Buffer layout. A change in the layout would need a parallel change in the deferred lighting shaders.</p>
<p>The material generator for this section (LightMaterialGenerator class) just scans the flags of input and generates the correct preprocessor defines for the uber-shader. Some people prefer to use this approach for the G-Buffer stage as well, but I wanted to show both options in the demo.</p>
<p>In order to dispatch render operations manually, the following call exists in SceneManager: <a class="el" href="class_ogre_1_1_scene_manager.html#a1593fab748d1b0820e93e49d5732350b" title="Render something as if it came from the current queue. ">Ogre::SceneManager::_injectRenderWithPass()</a>.</p>
<p>When rendering a light, we pass the light we are rendering as the manual light list in order to have the auto params for that light available in the shader.</p>
<h3>Rendering shadow casting lights</h3>
<p>The 'classic' approach to rendering texture shadows is to prepare all of them before the scene rendering starts, and then apply them to the rendered objects using shadow receiver passes or integrated shaders. The downside of this approach is that you need to allocate a texture per-light (5 shadow casting lights -&gt; 5 shadow textures) and that if you don't integrate it in your shaders you also contribute even more passes to the scene.</p>
<p>One of the advantages of deferred shading is that we render the lights completely, and one by one. So, we can generate the shadow texture for a light just before the light's geometry is rendered, allowing us to reuse the same texture for as many lights as we want. (We still have an overhead of rendering the scene from the light's perspective per-light).</p>
<p>The API call that prepares shadow textures on demand is <a class="el" href="class_ogre_1_1_scene_manager.html#a95cd8ff86a7178c2e37b2fcb485f64fa" title="Method for preparing shadow textures ready for use in a regular render Do not call manually unless be...">Ogre::SceneManager::prepareShadowTextures()</a>. The lightList parameter allows specification of which lights to prepare shadow textures for.</p>
<p>Important note - RenderSystemOperations get executed in the middle of scene rendering. This means that there is an active render target being rendered to. In order to render the shadow texture we need to be able to pause rendering mid frame, render the shadow texture, and resume rendering immediately afterwards. For this, SceneManager has two methods that do just that <a class="el" href="class_ogre_1_1_scene_manager.html#a90d0e7484ed4580ec980eef15808bfee" title="Pause rendering of the frame. ">Ogre::SceneManager::_pauseRendering()</a> and <a class="el" href="class_ogre_1_1_scene_manager.html#a794e03ea25dd798346414c1dba31337d" title="Resume rendering of the frame. ">Ogre::SceneManager::_resumeRendering()</a>, so the prepareShadowTextures call has to be inside this.</p>
<p>The demo currently supports just spotlight shadow casting (since it is the cheapest to implement) but the other options can be supported as well.</p>
<h3>Putting it all together</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DeferredLightRenderOperation::execute(SceneManager *sm, RenderSystem *rs)</div><div class="line">{</div><div class="line">    <a class="code" href="class_ogre_1_1_camera.html">Ogre::Camera</a>* cam = mViewport-&gt;getCamera();</div><div class="line"></div><div class="line">    mAmbientLight-&gt;updateFromCamera(cam);</div><div class="line">    Technique* tech = mAmbientLight-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a2a54dff8ade9ab6838c1517062f0eb98">getMaterial</a>()-&gt;<a class="code" href="class_ogre_1_1_material.html#a37ae7259ce89bdc38828ea1b977bdbcf">getBestTechnique</a>();</div><div class="line">    injectTechnique(sm, tech, mAmbientLight, 0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group___general.html#gaab30ef14aae93306a6044cb38d835f0c">LightList</a>&amp; lightList = sm-&gt;_getLightsAffectingFrustum();</div><div class="line">    <span class="keywordflow">for</span> (LightList::const_iterator it = lightList.begin(); it != lightList.end(); it++) </div><div class="line">    {</div><div class="line">        Light* light = *it;</div><div class="line">        <a class="code" href="class_ogre_1_1_hashed_vector.html">Ogre::LightList</a> ll;</div><div class="line">        ll.<a class="code" href="class_ogre_1_1_hashed_vector.html#a87bfcde773502ee964a677580724188f">push_back</a>(light);</div><div class="line"></div><div class="line">        <span class="comment">//if (++i != 2) continue;</span></div><div class="line">        <span class="comment">//if (light-&gt;getType() != Light::LT_DIRECTIONAL) continue;</span></div><div class="line">        <span class="comment">//if (light-&gt;getDiffuseColour() != ColourValue::Red) continue;</span></div><div class="line"></div><div class="line">        LightsMap::iterator dLightIt = mLights.find(light);</div><div class="line">        DLight* dLight = 0;</div><div class="line">        <span class="keywordflow">if</span> (dLightIt == mLights.end()) </div><div class="line">        {</div><div class="line">            dLight = createDLight(light);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> </div><div class="line">        {</div><div class="line">            dLight = dLightIt-&gt;second;</div><div class="line">            dLight-&gt;updateFromParent();</div><div class="line">        }</div><div class="line">        dLight-&gt;updateFromCamera(cam);</div><div class="line">        tech = dLight-&gt;getMaterial()-&gt;getBestTechnique();</div><div class="line"></div><div class="line">        <span class="comment">//Update shadow texture</span></div><div class="line">        <span class="keywordflow">if</span> (dLight-&gt;getCastChadows())</div><div class="line">        {</div><div class="line">            SceneManager::RenderContext* context = sm-&gt;_pauseRendering();</div><div class="line"></div><div class="line">            sm-&gt;prepareShadowTextures(cam, mViewport, &amp;ll);</div><div class="line">            sm-&gt;_resumeRendering(context);</div><div class="line">            </div><div class="line">            Pass* pass = tech-&gt;getPass(0);</div><div class="line">            TextureUnitState* tus = pass-&gt;getTextureUnitState(<span class="stringliteral">&quot;ShadowMap&quot;</span>);</div><div class="line">            assert(tus);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a>&amp; shadowTex = sm-&gt;getShadowTexture(0);</div><div class="line">            <span class="keywordflow">if</span> (tus-&gt;_getTexturePtr() != shadowTex)</div><div class="line">            {</div><div class="line">                tus-&gt;_setTexturePtr(shadowTex);</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">        </div><div class="line">        injectTechnique(sm, tech, dLight, &amp;ll);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h3>Seeing it in action</h3>
<p>Here is a screenshot from PerfHUD of the draw call that renders a spotlight that casts shadows. See the two G-Buffer textures and one shadow texture on the left :</p>
<div class="image">
<img src="DeferredCone1.PNG" alt="DeferredCone1.PNG"/>
</div>
<p>Here is a visualization of the texture being built :</p>
<div class="image">
<img src="DeferredCone2.PNG" alt="DeferredCone2.PNG"/>
</div>
<p>After all the lights are rendered, the scene is fully lit!</p>
<h1><a class="anchor" id="post"></a>
Post Processing</h1>
<p>The compositor framework used to be a post processing framework, but as this article shows - it is now a 'custom render pipeline' framework, allowing different rendering approaches. However, it can still be used to post process the scene, even under deferred rendering.</p>
<h2>Screen Space Ambient Occlusion</h2>
<p>'Screen Space Ambient Occlusion' is a global illumination technique that adds a bit of realism to the scene, where classic lighting often fails. However, it requires the normals and depths of the scene in order to calculate its contribution. Normally, the SSAO compositor would have a render_scene directive that does that.</p>
<p>However, with deferred shading, we already have that information from the G-Buffer stage, so we just need to access it!</p>
<p>This is what the compositor looks like :</p>
<div class="fragment"><div class="line">compositor DeferredShading/SSAO</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        compositor_logic SSAOLogic</div><div class="line">        </div><div class="line">        texture_ref geom DeferredShading/GBuffer mrt_output</div><div class="line">        texture scene target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca74ea3b1c0c5f4ae06b1a7136c5523eca">PF_R8G8B8A8</a></div><div class="line">        texture ssao target_width_scaled 0.5 target_height_scaled 0.5 <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line">        texture ssaoBlurX target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line">        texture ssaoBlurY target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line"></div><div class="line">        <span class="comment">// the scene we want to modulate</span></div><div class="line">        target scene</div><div class="line">        {</div><div class="line">            input previous</div><div class="line">        }</div><div class="line"></div><div class="line">        </div><div class="line"></div><div class="line">        target ssao</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                <span class="comment">// our SSAO listener number</span></div><div class="line">                identifier 42</div><div class="line"></div><div class="line">                material ssao</div><div class="line">                <span class="comment">// pass in the &quot;geometry map&quot;</span></div><div class="line">                input 0 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        target ssaoBlurX</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                identifier 43</div><div class="line"></div><div class="line">                material ssaoBlurX</div><div class="line">                input 0 ssao</div><div class="line">                input 1 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        target ssaoBlurY</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                identifier 43</div><div class="line"></div><div class="line">                material ssaoBlurY</div><div class="line">                input 0 ssaoBlurX</div><div class="line">                input 1 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        target_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                <span class="comment">// just output something, for example, use a modulate</span></div><div class="line">                <span class="comment">// material to just multiply the scene by the ssao</span></div><div class="line">                material modulate</div><div class="line">                input 0 scene</div><div class="line">                input 1 ssaoBlurY</div><div class="line">                <span class="comment">//input 1 ssao</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Some notes :</p><ul>
<li>Again, texture_ref is used to access a chain_scoped texture from the GBuffer compositor</li>
<li>compositor_logic is used to couple between the compositor and some code that it requires to run. A CompositorLogic class is created and registered with the CompositorManager with <a class="el" href="class_ogre_1_1_compositor_manager.html#a9c7d4168d56868599badb2789d54157c" title="Register a compositor logic for listening in to expecting composition techniques. ...">Ogre::CompositorManager::registerCompositorLogic()</a>. Which will cause the binding code to run whenever an instance of this compositor is created.</li>
<li>'Regular' compositors that don't use the GBuffer are also still possible of course, they can be used regularly, as long as they are placed after the DeferredShading/ShowLit compositor.</li>
</ul>
<h1><a class="anchor" id="realprojects"></a>
Integration in real projects</h1>
<p>The framework that this demo uses was designed to be pluggable into other projects. Some of the design considerations that contribute to that are :</p><ol type="1">
<li>The scene setup does not change in any way. You still set the scene up with normal lights and modify their parameters just like you would regularly.</li>
<li>The GBuffer scheme handler and shader generator allow existing materials to work in a deferred shading pipeline unmodified. It might not cover all the cases, but it can.</li>
<li>Easy to integrate - see next section</li>
</ol>
<h2>Integration steps</h2>
<p>The framework created for a demo fits the plugin architecture pretty well. The GBufferSchemeHandler and DeferredLightCompositionPass classes could be instantiated once on plugin setup and registered with ogre's systems. This is not the case currently just to keep the SDK build simpler.</p>
<p>So, the steps are :</p><ol type="1">
<li>Register GBufferSchemeHandler and DeferredLightCompositionPass with their respective managers.</li>
<li>Add the GBuffer and ShowLit compositors to the viewports you want deferred shaded.</li>
</ol>
<p>And thats it! In the demo, the DeferredShading class takes care of that.</p>
<h2>Adapting the framework</h2>
<p>The deferred shading framework in the demo was designed to be usable in real applications. Where would one want to modify it ?</p><ol type="1">
<li>GBufferSchemeHandler / MaterialGenerator - support more options out of the box. Skinning, specular maps, and whatever you have in your project that can be solved in a generic fashion.</li>
<li>LightMaterialGenerator - support more lighting options (fog, etc), more shadow types, different shadow techniques (currently using very basic depth shadow mapping)</li>
<li>Tweak the framework to your pipeline - The material inspection relies on naming (among other things) to decide what its looking at. Just modify it to fit your art pipeline's conventions! (For example, how does a texture get flagged as a normal map?)</li>
</ol>
<p>Indeed, it means that the framework is not 100% plug and play. But, if understood correctly, it can be adapted to real life scenarios with relative ease.</p>
<h2>Adding features to the framework</h2>
<p>Post processing compositors that rely on certain aspects of the scene (like SSAO does) are now much easier to create and integrate with the earlier processes. An example could be edge-based anti aliasing, to address the lack of anti aliasing in DX9-based deferred shading systems.</p>
<p>In addition to that, the deferred shading implementation was focused on simplicity. There are many optimization options and most of them were not done, mainly to keep the demo as simple and understandable as possible.</p>
<h1><a class="anchor" id="summary"></a>
Summary</h1>
<p>Deferred Shading is an advanced rendering technique, that brings a pretty big implementation challenge along with it. This article, along with the demo, shows that it is possible to implement without relying on hacks and bypassing ogre's systems. Yes, it involves more advanced usage of ogre's APIs and requires a bit of knowledge about what happens behind the scenes, but is in no way impossible.</p>
<h2><a class="anchor" id="further"></a>
Further reading</h2>
<ul>
<li><a href="http://www.guerrilla-games.com/publications/dr_kz2_rsx_dev07.pdf">KillZone 2 Deferred Shading overview</a> - Great resource for understanding deferred shading in general before diving into implemeting it in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>.</li>
<li><a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SoC2009+Compositor">Improving Ogre's Compositor Framework GSoC project page</a></li>
<li><a href="http://www.gamedev.net/page/reference/index.html/_//feature/fprogramming/deferred-rendering-demystified-r2746">Deferred Rendering Demystified</a> - An article written around this project that explains the design behind the deferred renderer. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: External Texture Sources</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('_external-_texture-_sources.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">External Texture Sources </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>This tutorial will provide a brief introduction of ExternalTextureSource and ExternalTextureSourceManager classes, their relationship, and how the PlugIns work. For those interested in developing a Texture Source Plugin or maybe just wanting to know more about this system, take a look the ffmpegVideoSystem plugin, which you can find more about on the OGRE forums.</p>
<p><a class="anchor" id="What-Is-An-External-Texture-Source_003f"></a></p>
<h1>What Is An External Texture Source?</h1>
<p>What is a texture source? Well, a texture source could be anything - png, bmp, jpeg, etc. However, loading textures from traditional bitmap files is already handled by another part OGRE. There are, however, other types of sources to get texture data from - i.e. mpeg/avi/etc movie files, flash, run-time generated source, user defined, etc.</p>
<p>How do external texture source plugins benefit OGRE? Well, the main answer is: adding support for any type of texture source does not require changing OGRE to support it... all that is involved is writing a new plugin. Additionally, because the manager uses the StringInterface class to issue commands/params, no change to the material script reader is needs to be made. As a result, if a plugin needs a special parameter set, it just creates a new command in it’s Parameter Dictionary. - see ffmpegVideoSystem plugin for an example. To make this work, two classes have been added to OGRE: ExternalTextureSource &amp; ExternalTextureSourceManager.</p>
<p><a class="anchor" id="ExternalTextureSource-Class"></a></p>
<h1>ExternalTextureSource Class</h1>
<p>The ExternalTextureSource class is the base class that Texture Source PlugIns must be derived from. It provides a generic framework (via StringInterface class) with a very limited amount of functionality. The most common of parameters can be set through the TexturePlugInSource class interface or via the StringInterface commands contained within this class. While this may seem like duplication of code, it is not. By using the string command interface, it becomes extremely easy for derived plugins to add any new types of parameters that it may need.</p>
<p>Default Command Parameters defined in ExternalTextureSource base class are:</p>
<ul>
<li>Parameter Name: "filename" Argument Type: <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">Ogre::String</a> Sets a filename plugin will read from</li>
<li>Parameter Name: "play\_mode" Argument Type: <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">Ogre::String</a> Sets initial play mode to be used by the plugin - "play", "loop", "pause"</li>
<li>Parameter Name: "set\_T\_P\_S" Argument Type: <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">Ogre::String</a> Used to set the technique, pass, and texture unit level to apply this texture to. As an example: To set a technique level of 1, a pass level of 2, and a texture unit level of 3, send this string "1 2 3".</li>
<li>Parameter Name: "frames\_per\_second" Argument Type: <a class="el" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">Ogre::String</a> Set a Frames per second update speed. (Integer Values only)</li>
</ul>
<p><a class="anchor" id="ExternalTextureSourceManager-Class"></a></p>
<h1>ExternalTextureSourceManager Class</h1>
<p>ExternalTextureSourceManager is responsible for keeping track of loaded Texture Source PlugIns. It also aids in the creation of texture source textures from scripts. It also is the interface you should use when dealing with texture source plugins.</p>
<p>Note: The function prototypes shown below are mockups - param names are simplified to better illustrate purpose here... Steps needed to create a new texture via ExternalTextureSourceManager:</p>
<ul>
<li>Obviously, the first step is to have the desired plugin included in plugin.cfg for it to be loaded.</li>
<li>Set the desired PlugIn as Active via AdvancedTextureManager::getSingleton().SetCurrentPlugIn( String Type ); – type is whatever the plugin registers as handling (e.g. "video", "flash", "whatever", etc).</li>
<li>Note: Consult Desired PlugIn to see what params it needs/expects. Set params/value pairs via AdvancedTextureManager::getSingleton().getCurrentPlugIn()-&gt;setParameter( String Param, String Value );</li>
<li>After required params are set, a simple call to AdvancedTextureManager::getSingleton().getCurrentPlugIn()-&gt;createDefinedTexture( sMaterialName ); will create a texture to the material name given.</li>
</ul>
<p>The manager also provides a method for deleting a texture source material: AdvancedTextureManager::DestroyAdvancedTexture( String sTextureName ); The destroy method works by broadcasting the material name to all loaded TextureSourcePlugIns, and the PlugIn who actually created the material is responsible for the deletion, while other PlugIns will just ignore the request. What this means is that you do not need to worry about which PlugIn created the material, or activating the PlugIn yourself. Just call the manager method to remove the material. Also, all texture plugins should handle cleanup when they are shutdown.</p>
<p><a class="anchor" id="Texture-Source-Material-Script"></a></p>
<h1>Texture Source Material Script</h1>
<p>As mentioned earlier, the process of defining/creating texture sources can be done within material script file. Here is an example of a material script definition - Note: This example is based off the ffmpegVideoSystem plugin parameters.</p>
<div class="fragment"><div class="line">material Example/MyVideoExample</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        pass</div><div class="line">        {</div><div class="line">            texture_unit</div><div class="line">            {</div><div class="line">                texture_source video</div><div class="line">                {</div><div class="line">                    filename mymovie.mpeg</div><div class="line">                    play_mode play</div><div class="line">                    sound_mode on</div><div class="line">                }</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Notice that the first two param/value pairs are defined in the ExternalTextureSource base class and that the third parameter/value pair is not defined in the base class... That parameter is added to the param dictionary by the ffmpegVideoPlugin... This shows that extending the functionality with the plugins is extremely easy. Also, pay particular attention to the line: texture_source video. This line identifies that this texture unit will come from a texture source plugin. It requires one parameter that determines which texture plugin will be used. In the example shown, the plugin requested is one that registered with "video" name.</p>
<p><a class="anchor" id="Simplified-Diagram-of-Process"></a></p>
<h1>Simplified Diagram of Process</h1>
<p>This diagram uses ffmpegVideoPlugin as example, but all plug ins will work the same in how they are registered/used here. Also note that TextureSource Plugins are loaded/registered before scripts are parsed. This does not mean that they are initialized... Plugins are not initialized until they are set active! This is to ensure that a rendersystem is set up before the plugins might make a call the rendersystem.</p>
<div class="image">
<object type="image/svg+xml" data="TextureSource.svg">TextureSource.svg</object>
</div>
 </div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>OGRE: Deferred Shading</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/x-mathjax-config">
  MathJax.Hub.Config({
    extensions: ["tex2jax.js"],
    jax: ["input/TeX","output/HTML-CSS"],
});
</script><script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.0/MathJax.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="ogre_style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ogre-logo-wetfloor.gif"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">OGRE
   &#160;<span id="projectnumber">1.10.12</span>
   </div>
   <div id="projectbrief">Object-Oriented Graphics Rendering Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('deferred.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Deferred Shading </div>  </div>
</div><!--header-->
<div class="contents">
<div class="toc"><h3>Table of Contents</h3>
<ul><li class="level1"><a href="#what">What is Deferred Shading?</a></li>
<li class="level1"><a href="#creating">Creating the G-Buffer</a></li>
<li class="level1"><a href="#lighting">Lighting the scene</a><ul><li class="level2"><a href="#lightgeom">Rendering the light geometry</a></li>
</ul>
</li>
<li class="level1"><a href="#post">Post Processing</a></li>
<li class="level1"><a href="#realprojects">Integration in real projects</a></li>
<li class="level1"><a href="#summary">Summary</a><ul><li class="level2"><a href="#further">Further reading</a></li>
</ul>
</li>
</ul>
</div>
<div class="textblock"><p>This wiki article is complementary to the deferred shading demo that is part of the <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> SDK. It will reference the code quite a bit and explain some of the decisions made when implementing the deferred shading framework for the demo.</p>
<h1><a class="anchor" id="what"></a>
What is Deferred Shading?</h1>
<p>Deferred shading is an alternative approach to rendering 3d scenes. The classic rendering approach involves rendering each object and applying lighting passes to it. So, if an ogre head is affected by 6 lights, it will be rendered 6 times, once for each light, in order to accumulate the affection of each light. Deferred shading takes another approach : In the beginning, all of the objects render their "lighting related info" to a texture, often called the G-Buffer. This means their colours, normals, depths and any other info that might be relevant to calculating their final colour. Afterwards, the lights in the scene are rendered as geometry (sphere for point light, cone for spotlight and full screen quad for directional light), and they use the G-buffer to calculate the colour contribution of that light to that pixel.</p>
<p>See the links in <a class="el" href="deferred.html#further">Further reading</a> to read more about it. It is recommended to understand deferred shading before reading this article, as the article focuses on implementing it in ogre, and not explaining how it works.</p>
<h2>Deferred Shading Advantages</h2>
<p>The main reason for using deferred shading is performance related. Classing rendering (also called forward rendering) can, in the worst case, require num_objects * num_lights batches to render a scene. Deferred shading changes that to num_objects + num_lights, which can often be a lot less. Another reason is that some new post-processing effects are easily achievable using the G-Buffer as input. If you wanted to perform these effects without deferred shading, you would've had to render the whole scene again.</p>
<h2>Deferred Shading Disadvantages</h2>
<p>There are several algorithmic drawbacks with deferred shading - transparent objects are hard to handle, anti aliasing can not be used in DX9 class hardware, additional memory consumption because of the G-Buffer. In addition to that, deferred shading is harder to implement - it overrides the entire fixed function pipeline. Pretty much everything is rendered using manual shaders - which probably means a lot of shader code.</p>
<h1><a class="anchor" id="creating"></a>
Creating the G-Buffer</h1>
<p>The first part of the deferred shading pipeline involves rendering all the (non-transparent) objects of the scene to the G-Buffer. This is done using a compositor :</p>
<div class="fragment"><div class="line">compositor DeferredShading/GBuffer</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">// temporary textures</span></div><div class="line">        texture mrt_output target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf91793bc9707d6541f4851722267317a">PF_FLOAT16_RGBA</a> <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39caf91793bc9707d6541f4851722267317a">PF_FLOAT16_RGBA</a> chain_scope</div><div class="line">        </div><div class="line">        target mrt_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line">            </div><div class="line">            shadows off</div><div class="line">            material_scheme GBuffer</div><div class="line">            </div><div class="line">            <span class="comment">// everything but the lights and their meshes</span></div><div class="line">            <span class="comment">// could do this with something like a visibility mask too</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                <span class="comment">//These values are synchronized with the code</span></div><div class="line">                first_render_queue 10</div><div class="line">                last_render_queue  79   </div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Things to note about this compositor :</p><ul>
<li>mrt_output (the GBuffer) is an MRT because there are two pixel formats defined.</li>
<li>mrt_output will be accessible to the next compositors in the chain because it is marked as chain_scope, meaning it is visible to the next compositors in the chain.</li>
<li>The material scheme tells ogre that objects shouldn't be rendered in normal fashion, but in some other way (we'll get to that soon)</li>
<li>Not all the objects are rendered to the GBuffer. Skies and 'late objects' (which can be specified manually using render queues) will be forward rendered.</li>
<li>This compositor does NOT have a target_output pass, because it does not contribute directly to the final image.</li>
</ul>
<h2>Deciding on the GBuffer format</h2>
<p>This in an important decision in deferred shading, as it has performance and visual implications.</p>
<p>Also, the entire pipeline has to be coordinated with this format - all the writing shaders have to write the same data to the same places, and all the reading shaders (for lighting later) have to be synchronized with it.</p>
<p>We chose two PF_FLOAT16_RGBA textures. The first one will contain the colour in RGB, specular intensity in A.</p>
<p>The second one will contain the view-space-normal in RGB (we keep all 3 coordinates) and the (linear) depth in A.</p>
<p>See the references for other possibilities.</p>
<h2>Preparing the objects for G-Buffer rendering</h2>
<p>The only indicator that ogre has when rendering the scene is that the material scheme is different. Material schemes in ogre allow materials to specify different rendering techniques for different scenarios. In this case, we would like to output the lighting related information instead of the lighting calculation result.</p>
<p>Materials that have a technique associated with the GBuffer scheme will render using that, but we don't want to modify the materials of all the objects in our art pipeline to use them in deferred shading.</p>
<p>The solution is to use scheme listeners! The material manager has a method for registering listeners when objects don't have a technique defined for the current scheme: <a class="el" href="class_ogre_1_1_material_manager.html#a8ac18f4bd2e6302f1d92ae8f64195694" title="Add a listener to handle material events. ">Ogre::MaterialManager::addListener()</a>.</p>
<p>The listener has a callback method that gets called whenever an object is about to be rendered without a matching technique: <a class="el" href="class_ogre_1_1_material_manager_1_1_listener.html#a54bc384ab1102063aa00db4c3a5f3fc4" title="Called if a technique for a given scheme is not found within a material, allows the application to sp...">Ogre::MaterialManager::Listener::handleSchemeNotFound()</a>.</p>
<p>We will implement such a listener for the GBuffer scheme. It is GBufferSchemeHandler from the demo. The GBufferSchemeHandlers works like this :</p>
<h3>Inspect the classic technique</h3>
<p>For each pass in the technique that would have been used normally, the GBufferSchemeHandler::inspectPass is called, inspects the pass, and returns the PassProperties - does this pass have a texture? a normal map? is it skinned? tranpsarent? Etc. The PassProperties (should) contain all the information required to build a GBuffer technique for an object.</p>
<h3>Generate the G-Buffer technique</h3>
<p>After a pass has been inspected and understood, the next stage is to generate the G-Buffer-writing technique. This is done using the class GBufferMaterialGenerator. The class receives the flags of the features needed by the material, and dynamically generates the (CG) shaders and material to render an object with those properties to the G-Buffer. This greatly reduces the number of shaders that you need to manage when using deferred shading, as most of them are created on the fly. Here is an example of what they look like :</p>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> ToGBufferVP(</div><div class="line">         float4 iPosition : POSITION,</div><div class="line">         float3 iNormal   : NORMAL,</div><div class="line">         float2 iUV0 : TEXCOORD0,</div><div class="line"></div><div class="line">         out float4 oPosition : POSITION,</div><div class="line">         out float3 oViewPos : TEXCOORD0,</div><div class="line">         out float3 oNormal : TEXCOORD1,</div><div class="line">         out float2 oUV0 : TEXCOORD2,</div><div class="line"></div><div class="line">         uniform float4x4 cWorldViewProj,</div><div class="line">         uniform float4x4 cWorldView</div><div class="line">         )</div><div class="line"> {</div><div class="line">         oPosition = mul(cWorldViewProj, iPosition);</div><div class="line">         oNormal = mul(cWorldView, float4(iNormal,0)).xyz;</div><div class="line">         oViewPos = mul(cWorldView, iPosition).xyz;</div><div class="line">         oUV0 = iUV0;</div><div class="line"> }</div><div class="line"></div><div class="line"> <span class="keywordtype">void</span> ToGBufferFP(</div><div class="line">         float3 iViewPos : TEXCOORD0,</div><div class="line">         float3 iNormal   : TEXCOORD1,</div><div class="line">         float3 iTangent : TEXCOORD2,</div><div class="line">         float3 iBiNormal : TEXCOORD3,</div><div class="line">         float2 iUV0 : TEXCOORD4,</div><div class="line"></div><div class="line">         out float4 oColor0 : COLOR0,</div><div class="line">         out float4 oColor1 : COLOR1,</div><div class="line"></div><div class="line">         uniform sampler sNormalMap : <span class="keyword">register</span>(s0),</div><div class="line">         uniform sampler sTex0 : <span class="keyword">register</span>(s1),</div><div class="line">         uniform float4 cDiffuseColour,</div><div class="line">         uniform <span class="keywordtype">float</span> cFarDistance,</div><div class="line">         uniform <span class="keywordtype">float</span> cSpecularity</div><div class="line">         )</div><div class="line"> {</div><div class="line">         oColor0.rgb = tex2D(sTex0, iUV0);</div><div class="line">         oColor0.rgb *= cDiffuseColour.rgb;</div><div class="line">         oColor0.a = cSpecularity;</div><div class="line">         float3 texNormal = (tex2D(sNormalMap, iUV0)-0.5)*2;</div><div class="line">         float3x3 normalRotation = float3x3(iTangent, iBiNormal, iNormal);</div><div class="line">         oColor1.rgb = normalize(mul(texNormal, normalRotation));</div><div class="line">         oColor1.a = length(iViewPos) / cFarDistance;</div><div class="line"> }</div></div><!-- fragment --><p> (This is for an object with a texture and a normal map)</p>
<h3>Add the G-Buffer technique to the original material</h3>
<p>We don't want to inspect the passes and generate the material each time an object is rendered, so we create a technique in the original material, and fill it with the auto-generated information. After copying the information from the GBuffer technique, texture references have to be updated, to use the correct textures when rendering the object. This happens in <code>GBufferSchemeHandler::fillPass</code>. The next time the object will be rendered, it WILL have a technique for the GBuffer scheme, so the listener won't get called.</p>
<h3>Postponing transparent objects</h3>
<p>We don't want to render transparent objects to the GBuffer, as it doesn't work properly later.</p>
<p>To address this, we also create a technique with a scheme called called 'NoGBuffer'. If the inspectPass decided that the object is transparent, we will not add an auto-generated pass to the 'GBuffer' technique, but instead copy the regular pass to the 'NoGBuffer' technique, to render it regularly later.</p>
<h3>Putting it all together</h3>
<p>This is how <code>GBufferSchemeHandler::handleSchemeNotFound</code> works:</p>
<div class="fragment"><div class="line">Technique* GBufferSchemeHandler::handleSchemeNotFound(<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> schemeIndex, </div><div class="line">        <span class="keyword">const</span> <a class="code" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; schemeName, Material* originalMaterial, <span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> lodIndex, </div><div class="line">        <span class="keyword">const</span> Renderable* rend)</div><div class="line">{</div><div class="line">    <a class="code" href="class_ogre_1_1_material_manager.html">Ogre::MaterialManager</a>&amp; matMgr = <a class="code" href="class_ogre_1_1_material_manager.html#a100f413d9d2316028e7ae740e5a43161">Ogre::MaterialManager::getSingleton</a>();</div><div class="line">    <a class="code" href="namespace_ogre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a> curSchemeName = matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#ad03ea02e140fc1e7312d14626e59d45d">getActiveScheme</a>();</div><div class="line">    matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0">setActiveScheme</a>(MaterialManager::DEFAULT_SCHEME_NAME);</div><div class="line">    Technique* originalTechnique = originalMaterial-&gt;getBestTechnique(lodIndex, rend);</div><div class="line">    matMgr.<a class="code" href="class_ogre_1_1_material_manager.html#a95decc3900f547bb68b74ba28d3013e0">setActiveScheme</a>(curSchemeName);</div><div class="line"></div><div class="line">    Technique* gBufferTech = originalMaterial-&gt;createTechnique();</div><div class="line">    gBufferTech-&gt;removeAllPasses();</div><div class="line">    gBufferTech-&gt;setSchemeName(schemeName);</div><div class="line"></div><div class="line"><span class="preprocessor">#ifdef OGRE_BUILD_COMPONENT_RTSHADERSYSTEM</span></div><div class="line">    RTShader::ShaderGenerator&amp; rtShaderGen = RTShader::ShaderGenerator::getSingleton();</div><div class="line">    rtShaderGen.createShaderBasedTechnique(*originalMaterial, originalTechnique-&gt;getSchemeName(), <span class="stringliteral">&quot;NoGBuffer&quot;</span>);</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">    Technique* noGBufferTech = originalMaterial-&gt;createTechnique();</div><div class="line">    noGBufferTech-&gt;removeAllPasses();</div><div class="line">    noGBufferTech-&gt;setSchemeName(<span class="stringliteral">&quot;NoGBuffer&quot;</span>);</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line"></div><div class="line">    <span class="keywordflow">for</span> (<span class="keywordtype">unsigned</span> <span class="keywordtype">short</span> i=0; i&lt;originalTechnique-&gt;getNumPasses(); i++)</div><div class="line">    {</div><div class="line">        Pass* originalPass = originalTechnique-&gt;getPass(i);</div><div class="line">        PassProperties props = inspectPass(originalPass, lodIndex, rend);</div><div class="line">        </div><div class="line">        <span class="keywordflow">if</span> (!props.isDeferred)</div><div class="line">        {</div><div class="line"><span class="preprocessor">#ifdef OGRE_BUILD_COMPONENT_RTSHADERSYSTEM</span></div><div class="line">            rtShaderGen.validateMaterial(<span class="stringliteral">&quot;NoGBuffer&quot;</span>, originalMaterial-&gt;getName(), originalMaterial-&gt;getGroup());</div><div class="line"><span class="preprocessor">#else</span></div><div class="line">            <span class="comment">//Just copy the technique so it gets rendered regularly</span></div><div class="line">            Pass* clonePass = noGBufferTech-&gt;createPass();</div><div class="line">            *clonePass = *originalPass;</div><div class="line"><span class="preprocessor">#endif</span></div><div class="line">            <span class="keywordflow">continue</span>;</div><div class="line">        }</div><div class="line"></div><div class="line">        Pass* newPass = gBufferTech-&gt;createPass();</div><div class="line">        MaterialGenerator::Perm perm = getPermutation(props);</div><div class="line"></div><div class="line">        <span class="keyword">const</span> <a class="code" href="class_ogre_1_1_shared_ptr.html">Ogre::MaterialPtr</a>&amp; templateMat = mMaterialGenerator.getMaterial(perm);</div><div class="line">        </div><div class="line">        <span class="comment">//We assume that the GBuffer technique contains only one pass. But its true.</span></div><div class="line">        *newPass = *(templateMat-&gt;<a class="code" href="class_ogre_1_1_material.html#abc82b3c4963c8d3cd04c93fdc6dbf416">getTechnique</a>(0)-&gt;<a class="code" href="class_ogre_1_1_technique.html#a3ce84da25bb6b5762af714adaf70874a">getPass</a>(0));</div><div class="line">        fillPass(newPass, originalPass, props);    </div><div class="line">    }</div><div class="line">    </div><div class="line">    <span class="keywordflow">return</span> gBufferTech;</div><div class="line">}</div></div><!-- fragment --> <h2>Overriding the automatic process</h2>
<p>In some cases the automatic material generation will not be good enough. We want to keep the option of manually writing GBuffer materials and shaders.</p>
<p>How do we do this? Easily! Since GBufferSchemeHandler::handleSchemeNotFound only gets called when an object doesn't already have a GBuffer scheme, adding a 'GBuffer' technique to the material will cause it to not get passed to the listener even once.</p>
<h2>Seeing it in action</h2>
<p>Using tools like NVIDIA's PerfHUD, we can see the texture being built during the frame :</p>
<div class="image">
<img src="GBufferPerfHUD.PNG" alt="GBufferPerfHUD.PNG"/>
</div>
<p>Note that nothing has been written to the final output yet (main view is completely black) and that two textures are being written to (see right hand side).</p>
<h1><a class="anchor" id="lighting"></a>
Lighting the scene</h1>
<p>In the GBuffer compositor, we built the G-Buffer for the current frame. It is now the time to use it to calculate the final lighting of the scene. This is what the compositor looks like :</p>
<div class="fragment"><div class="line">compositor DeferredShading/ShowLit</div><div class="line">{</div><div class="line"></div><div class="line">    technique</div><div class="line">    {</div><div class="line">        <span class="comment">//Reference the main Gbuffer texture</span></div><div class="line">        texture_ref mrt_output DeferredShading/GBuffer mrt_output</div><div class="line">        </div><div class="line">        target_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line">            <span class="comment">//We will dispatch the shadow texture rendering ourselves</span></div><div class="line">            shadows off</div><div class="line">            </div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">                </div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">// render skies and other pre-gbuffer objects</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                first_render_queue 1</div><div class="line">                last_render_queue  9            </div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the lights and their meshes</span></div><div class="line">            pass render_custom DeferredLight</div><div class="line">            {</div><div class="line">                input 0 mrt_output 0</div><div class="line">                input 1 mrt_output 1</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the objects that skipped rendering into the gbuffer</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                material_scheme NoGBuffer</div><div class="line">                first_render_queue 10</div><div class="line">                last_render_queue 79</div><div class="line">            }</div><div class="line">            </div><div class="line">            <span class="comment">//Render the post-GBuffer render queue objects</span></div><div class="line">            pass render_scene</div><div class="line">            {</div><div class="line">                <span class="comment">//This value is synchronized with the code</span></div><div class="line">                first_render_queue 80</div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p> Yes, it's a long one. Here is a breakdown of the compositor :</p><ul>
<li>The 'texture_ref' definition means that we are referencing a texture from another compositor. In the case of a chain-scoped texture (like the GBuffer), this means that we can only apply this compositor on chains that have the GBuffer creating compositor earlier in the chain than this one. <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a> will check that this is the case.</li>
</ul>
<p>There are four target passes in this compositor.</p><ol type="1">
<li>Render the skies and then the lights using the render_custom directive (more on this later)</li>
<li>Render the objects that are in the GBuffer render queues but didn't get rendered to the GBuffer</li>
<li>Render the post-GBuffer render queue objects</li>
<li>Output the result</li>
</ol>
<h3>Why do we need four target passes ?</h3>
<p>This is mainly a limitation of <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. Ideally, we could use a single target_output pass and do all the passes there. The problem is that material_scheme is at the target scope and not at the pass scope. This is hard to change, because material schemes are resolved during scene preparing time and not during scene rendering. So even if the scope would change, it would not affect the rendering, as the material scheme will not get tested after we switch to it. Perhaps this will be addressed, and then this compositor will get simplified.</p>
<h2><a class="anchor" id="lightgeom"></a>
Rendering the light geometry</h2>
<p>The geometry that we want to render to calculate lighting information doesn't really fit in any classic category. It is not really a part of the scene, as the light geometry aren't objects in the world. But it is geometry (not always a quad) that needs to be rendered.</p>
<p>For these kind of operations, the render_custom target pass was introduced into <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>. It is possible to register custom (named) composition passes that will be performed in the compositor. In this case, it is 'DeferredLight'. The composition pass will receive a call each frame telling it 'it's your turn, do your thing'. The class in the demo is DeferredLightCP.</p>
<p>The registration of the custom composition pass has to be done once, using <a class="el" href="class_ogre_1_1_compositor_manager.html#ae9b8ca4c2a51c0720bb31393d20fe7c9" title="Register a custom composition pass. ">Ogre::CompositorManager::registerCustomCompositionPass()</a>.</p>
<p>CustomCompositionPass is essentially just a factory for RenderSystemOperations, which are the operations that get executed during a compositor chain. This is the single API call: <a class="el" href="class_ogre_1_1_custom_composition_pass.html#a6b8c7a3743f9bb44e27c0348a0035e7b" title="Create a custom composition operation. ">Ogre::CustomCompositionPass::createOperation()</a>.</p>
<p>So, now we get called exactly when we want, after the G-Buffer has been built and the (early) skies have been rendered. What will we do?</p>
<h3>Prepare ambient colour and rebuild original depth buffer</h3>
<p>Since we rendered the original scene to a different RTT, the depth buffer won't necessarily get reused for the output target, so we need to rebuild it so that future objects (lights and non-g-buffer objects) will be able to interact with the depth naturally.</p>
<p>Also, we need to apply the ambient light to the scene. For the purpose of the demo, the ambient light is not a separate colour channel, just the object's original textures applied with the scene's global ambient light factor. In theory, you could set up a different G-Buffer to allow more flexibility, but we didn't do that.</p>
<p>These two actions happen in a single full-screen quad render, that comes from the AmbientLight class.</p>
<h3>Render the light geometries</h3>
<p>The most important stage is the light geometry. The code scans the original scene's lights, builds a matching DLight (deferred light) instance for each light in the scene, and renders away using the G-Buffer.</p>
<p>These lights use pretty sophisticated shaders, since they perform the lighting calculations of the fixed function pipeline themselves, and have to account for many options (specularity, attenuation, different light types and shadows, which will get talked about soon). In contrast to the G-Buffer building stage, the shaders here do not get generated on the fly. There is one big shader (sometimes referred to as an Uber-Shader) with many preprocessor options that account for all the options. (See LightMaterial_ps.cg) Note that the shaders have to be synchronized with the G-Buffer layout. A change in the layout would need a parallel change in the deferred lighting shaders.</p>
<p>The material generator for this section (LightMaterialGenerator class) just scans the flags of input and generates the correct preprocessor defines for the uber-shader. Some people prefer to use this approach for the G-Buffer stage as well, but I wanted to show both options in the demo.</p>
<p>In order to dispatch render operations manually, the following call exists in SceneManager: <a class="el" href="class_ogre_1_1_scene_manager.html#a1593fab748d1b0820e93e49d5732350b" title="Render something as if it came from the current queue. ">Ogre::SceneManager::_injectRenderWithPass()</a>.</p>
<p>When rendering a light, we pass the light we are rendering as the manual light list in order to have the auto params for that light available in the shader.</p>
<h3>Rendering shadow casting lights</h3>
<p>The 'classic' approach to rendering texture shadows is to prepare all of them before the scene rendering starts, and then apply them to the rendered objects using shadow receiver passes or integrated shaders. The downside of this approach is that you need to allocate a texture per-light (5 shadow casting lights -&gt; 5 shadow textures) and that if you don't integrate it in your shaders you also contribute even more passes to the scene.</p>
<p>One of the advantages of deferred shading is that we render the lights completely, and one by one. So, we can generate the shadow texture for a light just before the light's geometry is rendered, allowing us to reuse the same texture for as many lights as we want. (We still have an overhead of rendering the scene from the light's perspective per-light).</p>
<p>The API call that prepares shadow textures on demand is <a class="el" href="class_ogre_1_1_scene_manager.html#a95cd8ff86a7178c2e37b2fcb485f64fa" title="Method for preparing shadow textures ready for use in a regular render Do not call manually unless be...">Ogre::SceneManager::prepareShadowTextures()</a>. The lightList parameter allows specification of which lights to prepare shadow textures for.</p>
<p>Important note - RenderSystemOperations get executed in the middle of scene rendering. This means that there is an active render target being rendered to. In order to render the shadow texture we need to be able to pause rendering mid frame, render the shadow texture, and resume rendering immediately afterwards. For this, SceneManager has two methods that do just that <a class="el" href="class_ogre_1_1_scene_manager.html#a90d0e7484ed4580ec980eef15808bfee" title="Pause rendering of the frame. ">Ogre::SceneManager::_pauseRendering()</a> and <a class="el" href="class_ogre_1_1_scene_manager.html#a794e03ea25dd798346414c1dba31337d" title="Resume rendering of the frame. ">Ogre::SceneManager::_resumeRendering()</a>, so the prepareShadowTextures call has to be inside this.</p>
<p>The demo currently supports just spotlight shadow casting (since it is the cheapest to implement) but the other options can be supported as well.</p>
<h3>Putting it all together</h3>
<div class="fragment"><div class="line"><span class="keywordtype">void</span> DeferredLightRenderOperation::execute(SceneManager *sm, RenderSystem *rs)</div><div class="line">{</div><div class="line">    <a class="code" href="class_ogre_1_1_camera.html">Ogre::Camera</a>* cam = mViewport-&gt;getCamera();</div><div class="line"></div><div class="line">    mAmbientLight-&gt;updateFromCamera(cam);</div><div class="line">    Technique* tech = mAmbientLight-&gt;<a class="code" href="class_ogre_1_1_frustum.html#a2a54dff8ade9ab6838c1517062f0eb98">getMaterial</a>()-&gt;<a class="code" href="class_ogre_1_1_material.html#a37ae7259ce89bdc38828ea1b977bdbcf">getBestTechnique</a>();</div><div class="line">    injectTechnique(sm, tech, mAmbientLight, 0);</div><div class="line"></div><div class="line">    <span class="keyword">const</span> <a class="code" href="group___general.html#gaab30ef14aae93306a6044cb38d835f0c">LightList</a>&amp; lightList = sm-&gt;_getLightsAffectingFrustum();</div><div class="line">    <span class="keywordflow">for</span> (LightList::const_iterator it = lightList.begin(); it != lightList.end(); it++) </div><div class="line">    {</div><div class="line">        Light* light = *it;</div><div class="line">        <a class="code" href="class_ogre_1_1_hashed_vector.html">Ogre::LightList</a> ll;</div><div class="line">        ll.<a class="code" href="class_ogre_1_1_hashed_vector.html#a87bfcde773502ee964a677580724188f">push_back</a>(light);</div><div class="line"></div><div class="line">        <span class="comment">//if (++i != 2) continue;</span></div><div class="line">        <span class="comment">//if (light-&gt;getType() != Light::LT_DIRECTIONAL) continue;</span></div><div class="line">        <span class="comment">//if (light-&gt;getDiffuseColour() != ColourValue::Red) continue;</span></div><div class="line"></div><div class="line">        LightsMap::iterator dLightIt = mLights.find(light);</div><div class="line">        DLight* dLight = 0;</div><div class="line">        <span class="keywordflow">if</span> (dLightIt == mLights.end()) </div><div class="line">        {</div><div class="line">            dLight = createDLight(light);</div><div class="line">        }</div><div class="line">        <span class="keywordflow">else</span> </div><div class="line">        {</div><div class="line">            dLight = dLightIt-&gt;second;</div><div class="line">            dLight-&gt;updateFromParent();</div><div class="line">        }</div><div class="line">        dLight-&gt;updateFromCamera(cam);</div><div class="line">        tech = dLight-&gt;getMaterial()-&gt;getBestTechnique();</div><div class="line"></div><div class="line">        <span class="comment">//Update shadow texture</span></div><div class="line">        <span class="keywordflow">if</span> (dLight-&gt;getCastChadows())</div><div class="line">        {</div><div class="line">            SceneManager::RenderContext* context = sm-&gt;_pauseRendering();</div><div class="line"></div><div class="line">            sm-&gt;prepareShadowTextures(cam, mViewport, &amp;ll);</div><div class="line">            sm-&gt;_resumeRendering(context);</div><div class="line">            </div><div class="line">            Pass* pass = tech-&gt;getPass(0);</div><div class="line">            TextureUnitState* tus = pass-&gt;getTextureUnitState(<span class="stringliteral">&quot;ShadowMap&quot;</span>);</div><div class="line">            assert(tus);</div><div class="line">            <span class="keyword">const</span> <a class="code" href="namespace_ogre.html#aa381890787803da43b614dee8d9c8994">TexturePtr</a>&amp; shadowTex = sm-&gt;getShadowTexture(0);</div><div class="line">            <span class="keywordflow">if</span> (tus-&gt;_getTexturePtr() != shadowTex)</div><div class="line">            {</div><div class="line">                tus-&gt;_setTexturePtr(shadowTex);</div><div class="line">            }</div><div class="line">            </div><div class="line">        }</div><div class="line">        </div><div class="line">        injectTechnique(sm, tech, dLight, &amp;ll);</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --> <h3>Seeing it in action</h3>
<p>Here is a screenshot from PerfHUD of the draw call that renders a spotlight that casts shadows. See the two G-Buffer textures and one shadow texture on the left :</p>
<div class="image">
<img src="DeferredCone1.PNG" alt="DeferredCone1.PNG"/>
</div>
<p>Here is a visualization of the texture being built :</p>
<div class="image">
<img src="DeferredCone2.PNG" alt="DeferredCone2.PNG"/>
</div>
<p>After all the lights are rendered, the scene is fully lit!</p>
<h1><a class="anchor" id="post"></a>
Post Processing</h1>
<p>The compositor framework used to be a post processing framework, but as this article shows - it is now a 'custom render pipeline' framework, allowing different rendering approaches. However, it can still be used to post process the scene, even under deferred rendering.</p>
<h2>Screen Space Ambient Occlusion</h2>
<p>'Screen Space Ambient Occlusion' is a global illumination technique that adds a bit of realism to the scene, where classic lighting often fails. However, it requires the normals and depths of the scene in order to calculate its contribution. Normally, the SSAO compositor would have a render_scene directive that does that.</p>
<p>However, with deferred shading, we already have that information from the G-Buffer stage, so we just need to access it!</p>
<p>This is what the compositor looks like :</p>
<div class="fragment"><div class="line">compositor DeferredShading/SSAO</div><div class="line">{</div><div class="line">    technique</div><div class="line">    {</div><div class="line">        compositor_logic SSAOLogic</div><div class="line">        </div><div class="line">        texture_ref geom DeferredShading/GBuffer mrt_output</div><div class="line">        texture scene target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca74ea3b1c0c5f4ae06b1a7136c5523eca">PF_R8G8B8A8</a></div><div class="line">        texture ssao target_width_scaled 0.5 target_height_scaled 0.5 <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line">        texture ssaoBlurX target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line">        texture ssaoBlurY target_width target_height <a class="code" href="group___image.html#gga7e0353e7d36d4c2e8468641b7303d39ca32d32d3a5a8b68c1495d5c494575a6d8">PF_R8G8B8</a></div><div class="line"></div><div class="line">        <span class="comment">// the scene we want to modulate</span></div><div class="line">        target scene</div><div class="line">        {</div><div class="line">            input previous</div><div class="line">        }</div><div class="line"></div><div class="line">        </div><div class="line"></div><div class="line">        target ssao</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                <span class="comment">// our SSAO listener number</span></div><div class="line">                identifier 42</div><div class="line"></div><div class="line">                material ssao</div><div class="line">                <span class="comment">// pass in the &quot;geometry map&quot;</span></div><div class="line">                input 0 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        target ssaoBlurX</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                identifier 43</div><div class="line"></div><div class="line">                material ssaoBlurX</div><div class="line">                input 0 ssao</div><div class="line">                input 1 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line">        target ssaoBlurY</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass clear</div><div class="line">            {</div><div class="line">            }</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                identifier 43</div><div class="line"></div><div class="line">                material ssaoBlurY</div><div class="line">                input 0 ssaoBlurX</div><div class="line">                input 1 geom 1</div><div class="line">            }</div><div class="line">        }</div><div class="line"></div><div class="line"></div><div class="line"></div><div class="line">        target_output</div><div class="line">        {</div><div class="line">            input none</div><div class="line"></div><div class="line">            pass render_quad</div><div class="line">            {</div><div class="line">                <span class="comment">// just output something, for example, use a modulate</span></div><div class="line">                <span class="comment">// material to just multiply the scene by the ssao</span></div><div class="line">                material modulate</div><div class="line">                input 0 scene</div><div class="line">                input 1 ssaoBlurY</div><div class="line">                <span class="comment">//input 1 ssao</span></div><div class="line">            }</div><div class="line">        }</div><div class="line">    }</div><div class="line">}</div></div><!-- fragment --><p>Some notes :</p><ul>
<li>Again, texture_ref is used to access a chain_scoped texture from the GBuffer compositor</li>
<li>compositor_logic is used to couple between the compositor and some code that it requires to run. A CompositorLogic class is created and registered with the CompositorManager with <a class="el" href="class_ogre_1_1_compositor_manager.html#a9c7d4168d56868599badb2789d54157c" title="Register a compositor logic for listening in to expecting composition techniques. ...">Ogre::CompositorManager::registerCompositorLogic()</a>. Which will cause the binding code to run whenever an instance of this compositor is created.</li>
<li>'Regular' compositors that don't use the GBuffer are also still possible of course, they can be used regularly, as long as they are placed after the DeferredShading/ShowLit compositor.</li>
</ul>
<h1><a class="anchor" id="realprojects"></a>
Integration in real projects</h1>
<p>The framework that this demo uses was designed to be pluggable into other projects. Some of the design considerations that contribute to that are :</p><ol type="1">
<li>The scene setup does not change in any way. You still set the scene up with normal lights and modify their parameters just like you would regularly.</li>
<li>The GBuffer scheme handler and shader generator allow existing materials to work in a deferred shading pipeline unmodified. It might not cover all the cases, but it can.</li>
<li>Easy to integrate - see next section</li>
</ol>
<h2>Integration steps</h2>
<p>The framework created for a demo fits the plugin architecture pretty well. The GBufferSchemeHandler and DeferredLightCompositionPass classes could be instantiated once on plugin setup and registered with ogre's systems. This is not the case currently just to keep the SDK build simpler.</p>
<p>So, the steps are :</p><ol type="1">
<li>Register GBufferSchemeHandler and DeferredLightCompositionPass with their respective managers.</li>
<li>Add the GBuffer and ShowLit compositors to the viewports you want deferred shaded.</li>
</ol>
<p>And thats it! In the demo, the DeferredShading class takes care of that.</p>
<h2>Adapting the framework</h2>
<p>The deferred shading framework in the demo was designed to be usable in real applications. Where would one want to modify it ?</p><ol type="1">
<li>GBufferSchemeHandler / MaterialGenerator - support more options out of the box. Skinning, specular maps, and whatever you have in your project that can be solved in a generic fashion.</li>
<li>LightMaterialGenerator - support more lighting options (fog, etc), more shadow types, different shadow techniques (currently using very basic depth shadow mapping)</li>
<li>Tweak the framework to your pipeline - The material inspection relies on naming (among other things) to decide what its looking at. Just modify it to fit your art pipeline's conventions! (For example, how does a texture get flagged as a normal map?)</li>
</ol>
<p>Indeed, it means that the framework is not 100% plug and play. But, if understood correctly, it can be adapted to real life scenarios with relative ease.</p>
<h2>Adding features to the framework</h2>
<p>Post processing compositors that rely on certain aspects of the scene (like SSAO does) are now much easier to create and integrate with the earlier processes. An example could be edge-based anti aliasing, to address the lack of anti aliasing in DX9-based deferred shading systems.</p>
<p>In addition to that, the deferred shading implementation was focused on simplicity. There are many optimization options and most of them were not done, mainly to keep the demo as simple and understandable as possible.</p>
<h1><a class="anchor" id="summary"></a>
Summary</h1>
<p>Deferred Shading is an advanced rendering technique, that brings a pretty big implementation challenge along with it. This article, along with the demo, shows that it is possible to implement without relying on hacks and bypassing ogre's systems. Yes, it involves more advanced usage of ogre's APIs and requires a bit of knowledge about what happens behind the scenes, but is in no way impossible.</p>
<h2><a class="anchor" id="further"></a>
Further reading</h2>
<ul>
<li><a href="http://www.guerrilla-games.com/publications/dr_kz2_rsx_dev07.pdf">KillZone 2 Deferred Shading overview</a> - Great resource for understanding deferred shading in general before diving into implemeting it in <a class="el" href="namespace_ogre.html" title=" This source file is part of OGRE (Object-oriented Graphics Rendering Engine) For the latest info...">Ogre</a>.</li>
<li><a href="http://www.ogre3d.org/tikiwiki/tiki-index.php?page=SoC2009+Compositor">Improving Ogre's Compositor Framework GSoC project page</a></li>
<li><a href="http://www.gamedev.net/page/reference/index.html/_//feature/fprogramming/deferred-rendering-demystified-r2746">Deferred Rendering Demystified</a> - An article written around this project that explains the design behind the deferred renderer. </li>
</ul>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="tutorials.html">Tutorials</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
